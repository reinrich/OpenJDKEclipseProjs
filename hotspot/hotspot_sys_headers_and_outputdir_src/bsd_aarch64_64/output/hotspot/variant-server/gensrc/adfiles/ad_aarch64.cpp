#line 1 "ad_aarch64.cpp"
//
// Copyright (c) 2003, 2024, Oracle and/or its affiliates. All rights reserved.
// Copyright (c) 2014, 2021, Red Hat, Inc. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 only, as
// published by the Free Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// You should have received a copy of the GNU General Public License version
// 2 along with this work; if not, write to the Free Software Foundation,
// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
//
// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
// or visit www.oracle.com if you need additional information or have any
// questions.
//
//

// Machine Generated File.  Do Not Edit!

#include "precompiled.hpp"
#include "adfiles/adGlobals_aarch64.hpp"
#include "adfiles/ad_aarch64.hpp"
#include "memory/allocation.inline.hpp"
#include "code/codeCache.hpp"
#include "code/compiledIC.hpp"
#include "code/nativeInst.hpp"
#include "code/vmreg.inline.hpp"
#include "gc/shared/collectedHeap.inline.hpp"
#include "oops/compressedOops.hpp"
#include "oops/markWord.hpp"
#include "oops/method.hpp"
#include "oops/oop.inline.hpp"
#include "opto/c2_MacroAssembler.hpp"
#include "opto/cfgnode.hpp"
#include "opto/intrinsicnode.hpp"
#include "opto/locknode.hpp"
#include "opto/opcodes.hpp"
#include "opto/regalloc.hpp"
#include "opto/regmask.hpp"
#include "opto/runtime.hpp"
#include "runtime/safepointMechanism.hpp"
#include "runtime/sharedRuntime.hpp"
#include "runtime/stubRoutines.hpp"
#include "utilities/growableArray.hpp"
#include "utilities/powerOfTwo.hpp"

//SourceForm

#line 1195 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"


  // Derived RegMask with conditionally allocatable registers

  void PhaseOutput::pd_perform_mach_node_analysis() {
  }

  int MachNode::pd_alignment_required() const {
    return 1;
  }

  int MachNode::compute_padding(int current_offset) const {
    return 0;
  }

  RegMask _ANY_REG32_mask;
  RegMask _ANY_REG_mask;
  RegMask _PTR_REG_mask;
  RegMask _NO_SPECIAL_REG32_mask;
  RegMask _NO_SPECIAL_REG_mask;
  RegMask _NO_SPECIAL_PTR_REG_mask;

  void reg_mask_init() {
    // We derive below RegMask(s) from the ones which are auto-generated from
    // adlc register classes to make AArch64 rheapbase (r27) and rfp (r29)
    // registers conditionally reserved.

    _ANY_REG32_mask = _ALL_REG32_mask;
    _ANY_REG32_mask.Remove(OptoReg::as_OptoReg(r31_sp->as_VMReg()));

    _ANY_REG_mask = _ALL_REG_mask;

    _PTR_REG_mask = _ALL_REG_mask;

    _NO_SPECIAL_REG32_mask = _ALL_REG32_mask;
    _NO_SPECIAL_REG32_mask.SUBTRACT(_NON_ALLOCATABLE_REG32_mask);

    _NO_SPECIAL_REG_mask = _ALL_REG_mask;
    _NO_SPECIAL_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);

    _NO_SPECIAL_PTR_REG_mask = _ALL_REG_mask;
    _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);

    // r27 is not allocatable when compressed oops is on and heapbase is not
    // zero, compressed klass pointers doesn't use r27 after JDK-8234794
    if (UseCompressedOops && (CompressedOops::ptrs_base() != nullptr)) {
      _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r27->as_VMReg()));
      _NO_SPECIAL_REG_mask.Remove(OptoReg::as_OptoReg(r27->as_VMReg()));
      _NO_SPECIAL_PTR_REG_mask.Remove(OptoReg::as_OptoReg(r27->as_VMReg()));
    }

    // r29 is not allocatable when PreserveFramePointer is on
    if (PreserveFramePointer) {
      _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));
      _NO_SPECIAL_REG_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));
      _NO_SPECIAL_PTR_REG_mask.Remove(OptoReg::as_OptoReg(r29->as_VMReg()));
    }
  }

  // Optimizaton of volatile gets and puts
  // -------------------------------------
  //
  // AArch64 has ldar<x> and stlr<x> instructions which we can safely
  // use to implement volatile reads and writes. For a volatile read
  // we simply need
  //
  //   ldar<x>
  //
  // and for a volatile write we need
  //
  //   stlr<x>
  //
  // Alternatively, we can implement them by pairing a normal
  // load/store with a memory barrier. For a volatile read we need
  //
  //   ldr<x>
  //   dmb ishld
  //
  // for a volatile write
  //
  //   dmb ish
  //   str<x>
  //   dmb ish
  //
  // We can also use ldaxr and stlxr to implement compare and swap CAS
  // sequences. These are normally translated to an instruction
  // sequence like the following
  //
  //   dmb      ish
  // retry:
  //   ldxr<x>   rval raddr
  //   cmp       rval rold
  //   b.ne done
  //   stlxr<x>  rval, rnew, rold
  //   cbnz      rval retry
  // done:
  //   cset      r0, eq
  //   dmb ishld
  //
  // Note that the exclusive store is already using an stlxr
  // instruction. That is required to ensure visibility to other
  // threads of the exclusive write (assuming it succeeds) before that
  // of any subsequent writes.
  //
  // The following instruction sequence is an improvement on the above
  //
  // retry:
  //   ldaxr<x>  rval raddr
  //   cmp       rval rold
  //   b.ne done
  //   stlxr<x>  rval, rnew, rold
  //   cbnz      rval retry
  // done:
  //   cset      r0, eq
  //
  // We don't need the leading dmb ish since the stlxr guarantees
  // visibility of prior writes in the case that the swap is
  // successful. Crucially we don't have to worry about the case where
  // the swap is not successful since no valid program should be
  // relying on visibility of prior changes by the attempting thread
  // in the case where the CAS fails.
  //
  // Similarly, we don't need the trailing dmb ishld if we substitute
  // an ldaxr instruction since that will provide all the guarantees we
  // require regarding observation of changes made by other threads
  // before any change to the CAS address observed by the load.
  //
  // In order to generate the desired instruction sequence we need to
  // be able to identify specific 'signature' ideal graph node
  // sequences which i) occur as a translation of a volatile reads or
  // writes or CAS operations and ii) do not occur through any other
  // translation or graph transformation. We can then provide
  // alternative aldc matching rules which translate these node
  // sequences to the desired machine code sequences. Selection of the
  // alternative rules can be implemented by predicates which identify
  // the relevant node sequences.
  //
  // The ideal graph generator translates a volatile read to the node
  // sequence
  //
  //   LoadX[mo_acquire]
  //   MemBarAcquire
  //
  // As a special case when using the compressed oops optimization we
  // may also see this variant
  //
  //   LoadN[mo_acquire]
  //   DecodeN
  //   MemBarAcquire
  //
  // A volatile write is translated to the node sequence
  //
  //   MemBarRelease
  //   StoreX[mo_release] {CardMark}-optional
  //   MemBarVolatile
  //
  // n.b. the above node patterns are generated with a strict
  // 'signature' configuration of input and output dependencies (see
  // the predicates below for exact details). The card mark may be as
  // simple as a few extra nodes or, in a few GC configurations, may
  // include more complex control flow between the leading and
  // trailing memory barriers. However, whatever the card mark
  // configuration these signatures are unique to translated volatile
  // reads/stores -- they will not appear as a result of any other
  // bytecode translation or inlining nor as a consequence of
  // optimizing transforms.
  //
  // We also want to catch inlined unsafe volatile gets and puts and
  // be able to implement them using either ldar<x>/stlr<x> or some
  // combination of ldr<x>/stlr<x> and dmb instructions.
  //
  // Inlined unsafe volatiles puts manifest as a minor variant of the
  // normal volatile put node sequence containing an extra cpuorder
  // membar
  //
  //   MemBarRelease
  //   MemBarCPUOrder
  //   StoreX[mo_release] {CardMark}-optional
  //   MemBarCPUOrder
  //   MemBarVolatile
  //
  // n.b. as an aside, a cpuorder membar is not itself subject to
  // matching and translation by adlc rules.  However, the rule
  // predicates need to detect its presence in order to correctly
  // select the desired adlc rules.
  //
  // Inlined unsafe volatile gets manifest as a slightly different
  // node sequence to a normal volatile get because of the
  // introduction of some CPUOrder memory barriers to bracket the
  // Load. However, but the same basic skeleton of a LoadX feeding a
  // MemBarAcquire, possibly through an optional DecodeN, is still
  // present
  //
  //   MemBarCPUOrder
  //        ||       \\
  //   MemBarCPUOrder LoadX[mo_acquire]
  //        ||            |
  //        ||       {DecodeN} optional
  //        ||       /
  //     MemBarAcquire
  //
  // In this case the acquire membar does not directly depend on the
  // load. However, we can be sure that the load is generated from an
  // inlined unsafe volatile get if we see it dependent on this unique
  // sequence of membar nodes. Similarly, given an acquire membar we
  // can know that it was added because of an inlined unsafe volatile
  // get if it is fed and feeds a cpuorder membar and if its feed
  // membar also feeds an acquiring load.
  //
  // Finally an inlined (Unsafe) CAS operation is translated to the
  // following ideal graph
  //
  //   MemBarRelease
  //   MemBarCPUOrder
  //   CompareAndSwapX {CardMark}-optional
  //   MemBarCPUOrder
  //   MemBarAcquire
  //
  // So, where we can identify these volatile read and write
  // signatures we can choose to plant either of the above two code
  // sequences. For a volatile read we can simply plant a normal
  // ldr<x> and translate the MemBarAcquire to a dmb. However, we can
  // also choose to inhibit translation of the MemBarAcquire and
  // inhibit planting of the ldr<x>, instead planting an ldar<x>.
  //
  // When we recognise a volatile store signature we can choose to
  // plant at a dmb ish as a translation for the MemBarRelease, a
  // normal str<x> and then a dmb ish for the MemBarVolatile.
  // Alternatively, we can inhibit translation of the MemBarRelease
  // and MemBarVolatile and instead plant a simple stlr<x>
  // instruction.
  //
  // when we recognise a CAS signature we can choose to plant a dmb
  // ish as a translation for the MemBarRelease, the conventional
  // macro-instruction sequence for the CompareAndSwap node (which
  // uses ldxr<x>) and then a dmb ishld for the MemBarAcquire.
  // Alternatively, we can elide generation of the dmb instructions
  // and plant the alternative CompareAndSwap macro-instruction
  // sequence (which uses ldaxr<x>).
  //
  // Of course, the above only applies when we see these signature
  // configurations. We still want to plant dmb instructions in any
  // other cases where we may see a MemBarAcquire, MemBarRelease or
  // MemBarVolatile. For example, at the end of a constructor which
  // writes final/volatile fields we will see a MemBarRelease
  // instruction and this needs a 'dmb ish' lest we risk the
  // constructed object being visible without making the
  // final/volatile field writes visible.
  //
  // n.b. the translation rules below which rely on detection of the
  // volatile signatures and insert ldar<x> or stlr<x> are failsafe.
  // If we see anything other than the signature configurations we
  // always just translate the loads and stores to ldr<x> and str<x>
  // and translate acquire, release and volatile membars to the
  // relevant dmb instructions.
  //

  // is_CAS(int opcode, bool maybe_volatile)
  //
  // return true if opcode is one of the possible CompareAndSwapX
  // values otherwise false.

  bool is_CAS(int opcode, bool maybe_volatile)
  {
    switch(opcode) {
      // We handle these
    case Op_CompareAndSwapI:
    case Op_CompareAndSwapL:
    case Op_CompareAndSwapP:
    case Op_CompareAndSwapN:
    case Op_ShenandoahCompareAndSwapP:
    case Op_ShenandoahCompareAndSwapN:
    case Op_CompareAndSwapB:
    case Op_CompareAndSwapS:
    case Op_GetAndSetI:
    case Op_GetAndSetL:
    case Op_GetAndSetP:
    case Op_GetAndSetN:
    case Op_GetAndAddI:
    case Op_GetAndAddL:
      return true;
    case Op_CompareAndExchangeI:
    case Op_CompareAndExchangeN:
    case Op_CompareAndExchangeB:
    case Op_CompareAndExchangeS:
    case Op_CompareAndExchangeL:
    case Op_CompareAndExchangeP:
    case Op_WeakCompareAndSwapB:
    case Op_WeakCompareAndSwapS:
    case Op_WeakCompareAndSwapI:
    case Op_WeakCompareAndSwapL:
    case Op_WeakCompareAndSwapP:
    case Op_WeakCompareAndSwapN:
    case Op_ShenandoahWeakCompareAndSwapP:
    case Op_ShenandoahWeakCompareAndSwapN:
    case Op_ShenandoahCompareAndExchangeP:
    case Op_ShenandoahCompareAndExchangeN:
      return maybe_volatile;
    default:
      return false;
    }
  }

  // helper to determine the maximum number of Phi nodes we may need to
  // traverse when searching from a card mark membar for the merge mem
  // feeding a trailing membar or vice versa

// predicates controlling emit of ldr<x>/ldar<x>

bool unnecessary_acquire(const Node *barrier)
{
  assert(barrier->is_MemBar(), "expecting a membar");

  MemBarNode* mb = barrier->as_MemBar();

  if (mb->trailing_load()) {
    return true;
  }

  if (mb->trailing_load_store()) {
    Node* load_store = mb->in(MemBarNode::Precedent);
    assert(load_store->is_LoadStore(), "unexpected graph shape");
    return is_CAS(load_store->Opcode(), true);
  }

  return false;
}

bool needs_acquiring_load(const Node *n)
{
  assert(n->is_Load(), "expecting a load");
  LoadNode *ld = n->as_Load();
  return ld->is_acquire();
}

bool unnecessary_release(const Node *n)
{
  assert((n->is_MemBar() &&
          n->Opcode() == Op_MemBarRelease),
         "expecting a release membar");

  MemBarNode *barrier = n->as_MemBar();
  if (!barrier->leading()) {
    return false;
  } else {
    Node* trailing = barrier->trailing_membar();
    MemBarNode* trailing_mb = trailing->as_MemBar();
    assert(trailing_mb->trailing(), "Not a trailing membar?");
    assert(trailing_mb->leading_membar() == n, "inconsistent leading/trailing membars");

    Node* mem = trailing_mb->in(MemBarNode::Precedent);
    if (mem->is_Store()) {
      assert(mem->as_Store()->is_release(), "");
      assert(trailing_mb->Opcode() == Op_MemBarVolatile, "");
      return true;
    } else {
      assert(mem->is_LoadStore(), "");
      assert(trailing_mb->Opcode() == Op_MemBarAcquire, "");
      return is_CAS(mem->Opcode(), true);
    }
  }
  return false;
}

bool unnecessary_volatile(const Node *n)
{
  // assert n->is_MemBar();
  MemBarNode *mbvol = n->as_MemBar();

  bool release = mbvol->trailing_store();
  assert(!release || (mbvol->in(MemBarNode::Precedent)->is_Store() && mbvol->in(MemBarNode::Precedent)->as_Store()->is_release()), "");
#ifdef ASSERT
  if (release) {
    Node* leading = mbvol->leading_membar();
    assert(leading->Opcode() == Op_MemBarRelease, "");
    assert(leading->as_MemBar()->leading_store(), "");
    assert(leading->as_MemBar()->trailing_membar() == mbvol, "");
  }
#endif

  return release;
}

// predicates controlling emit of str<x>/stlr<x>

bool needs_releasing_store(const Node *n)
{
  // assert n->is_Store();
  StoreNode *st = n->as_Store();
  return st->trailing_membar() != nullptr;
}

// predicate controlling translation of CAS
//
// returns true if CAS needs to use an acquiring load otherwise false

bool needs_acquiring_load_exclusive(const Node *n)
{
  assert(is_CAS(n->Opcode(), true), "expecting a compare and swap");
  LoadStoreNode* ldst = n->as_LoadStore();
  if (is_CAS(n->Opcode(), false)) {
    assert(ldst->trailing_membar() != nullptr, "expected trailing membar");
  } else {
    return ldst->trailing_membar() != nullptr;
  }

  // so we can just return true here
  return true;
}

#define __ _masm.

// advance declarations for helper functions to convert register
// indices to register objects

// the ad file has to provide implementations of certain methods
// expected by the generic code
//
// REQUIRED FUNCTIONALITY

//=============================================================================

// !!!!! Special hack to get all types of calls to specify the byte offset
//       from the start of the call to the point where the return address
//       will point.

int MachCallStaticJavaNode::ret_addr_offset()
{
  // call should be a simple bl
  int off = 4;
  return off;
}

int MachCallDynamicJavaNode::ret_addr_offset()
{
  return 16; // movz, movk, movk, bl
}

int MachCallRuntimeNode::ret_addr_offset() {
  // for generated stubs the call will be
  //   bl(addr)
  // or with far branches
  //   bl(trampoline_stub)
  // for real runtime callouts it will be six instructions
  // see aarch64_enc_java_to_runtime
  //   adr(rscratch2, retaddr)
  //   lea(rscratch1, RuntimeAddress(addr)
  //   stp(zr, rscratch2, Address(__ pre(sp, -2 * wordSize)))
  //   blr(rscratch1)
  CodeBlob *cb = CodeCache::find_blob(_entry_point);
  if (cb) {
    return 1 * NativeInstruction::instruction_size;
  } else {
    return 6 * NativeInstruction::instruction_size;
  }
}

//=============================================================================

#ifndef PRODUCT
void MachBreakpointNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
  st->print("BREAKPOINT");
}
#endif

void MachBreakpointNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
  C2_MacroAssembler _masm(&cbuf);
  __ brk(0);
}

uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  return MachNode::size(ra_);
}

//=============================================================================

#ifndef PRODUCT
  void MachNopNode::format(PhaseRegAlloc*, outputStream* st) const {
    st->print("nop \t# %d bytes pad for loops and calls", _count);
  }
#endif

  void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc*) const {
    C2_MacroAssembler _masm(&cbuf);
    for (int i = 0; i < _count; i++) {
      __ nop();
    }
  }

  uint MachNopNode::size(PhaseRegAlloc*) const {
    return _count * NativeInstruction::instruction_size;
  }

//=============================================================================
const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::Empty;

int ConstantTable::calculate_table_base_offset() const {
  return 0;  // absolute addressing, no offset
}

bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
void MachConstantBaseNode::postalloc_expand(GrowableArray <Node *> *nodes, PhaseRegAlloc *ra_) {
  ShouldNotReachHere();
}

void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  // Empty encoding
}

uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  return 0;
}

#ifndef PRODUCT
void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  st->print("-- \t// MachConstantBaseNode (empty encoding)");
}
#endif

#ifndef PRODUCT
void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
  Compile* C = ra_->C;

  int framesize = C->output()->frame_slots() << LogBytesPerInt;

  if (C->output()->need_stack_bang(framesize))
    st->print("# stack bang size=%d\n\t", framesize);

  if (VM_Version::use_rop_protection()) {
    st->print("ldr  zr, [lr]\n\t");
    st->print("paciaz\n\t");
  }
  if (framesize < ((1 << 9) + 2 * wordSize)) {
    st->print("sub  sp, sp, #%d\n\t", framesize);
    st->print("stp  rfp, lr, [sp, #%d]", framesize - 2 * wordSize);
    if (PreserveFramePointer) st->print("\n\tadd  rfp, sp, #%d", framesize - 2 * wordSize);
  } else {
    st->print("stp  lr, rfp, [sp, #%d]!\n\t", -(2 * wordSize));
    if (PreserveFramePointer) st->print("mov  rfp, sp\n\t");
    st->print("mov  rscratch1, #%d\n\t", framesize - 2 * wordSize);
    st->print("sub  sp, sp, rscratch1");
  }
  if (C->stub_function() == nullptr && BarrierSet::barrier_set()->barrier_set_nmethod() != nullptr) {
    st->print("\n\t");
    st->print("ldr  rscratch1, [guard]\n\t");
    st->print("dmb ishld\n\t");
    st->print("ldr  rscratch2, [rthread, #thread_disarmed_guard_value_offset]\n\t");
    st->print("cmp  rscratch1, rscratch2\n\t");
    st->print("b.eq skip");
    st->print("\n\t");
    st->print("blr #nmethod_entry_barrier_stub\n\t");
    st->print("b skip\n\t");
    st->print("guard: int\n\t");
    st->print("\n\t");
    st->print("skip:\n\t");
  }
}
#endif

void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
  Compile* C = ra_->C;
  C2_MacroAssembler _masm(&cbuf);

  // n.b. frame size includes space for return pc and rfp
  const int framesize = C->output()->frame_size_in_bytes();

  // insert a nop at the start of the prolog so we can patch in a
  // branch if we need to invalidate the method later
  __ nop();

  if (C->clinit_barrier_on_entry()) {
    assert(!C->method()->holder()->is_not_initialized(), "initialization should have been started");

    Label L_skip_barrier;

    __ mov_metadata(rscratch2, C->method()->holder()->constant_encoding());
    __ clinit_barrier(rscratch2, rscratch1, &L_skip_barrier);
    __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
    __ bind(L_skip_barrier);
  }

  if (C->max_vector_size() > 0) {
    __ reinitialize_ptrue();
  }

  int bangsize = C->output()->bang_size_in_bytes();
  if (C->output()->need_stack_bang(bangsize))
    __ generate_stack_overflow_check(bangsize);

  __ build_frame(framesize);

  if (C->stub_function() == nullptr) {
    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();
    if (BarrierSet::barrier_set()->barrier_set_nmethod() != nullptr) {
      // Dummy labels for just measuring the code size
      Label dummy_slow_path;
      Label dummy_continuation;
      Label dummy_guard;
      Label* slow_path = &dummy_slow_path;
      Label* continuation = &dummy_continuation;
      Label* guard = &dummy_guard;
      if (!Compile::current()->output()->in_scratch_emit_size()) {
        // Use real labels from actual stub when not emitting code for the purpose of measuring its size
        C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();
        Compile::current()->output()->add_stub(stub);
        slow_path = &stub->entry();
        continuation = &stub->continuation();
        guard = &stub->guard();
      }
      // In the C2 code, we move the non-hot part of nmethod entry barriers out-of-line to a stub.
      bs->nmethod_entry_barrier(&_masm, slow_path, continuation, guard);
    }
  }

  if (VerifyStackAtCalls) {
    Unimplemented();
  }

  C->output()->set_frame_complete(cbuf.insts_size());

  if (C->has_mach_constant_base_node()) {
    // NOTE: We set the table base offset here because users might be
    // emitted before MachConstantBaseNode.
    ConstantTable& constant_table = C->output()->constant_table();
    constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  }
}

uint MachPrologNode::size(PhaseRegAlloc* ra_) const
{
  return MachNode::size(ra_); // too many variables; just compute it
                              // the hard way
}

int MachPrologNode::reloc() const
{
  return 0;
}

//=============================================================================

#ifndef PRODUCT
void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
  Compile* C = ra_->C;
  int framesize = C->output()->frame_slots() << LogBytesPerInt;

  st->print("# pop frame %d\n\t",framesize);

  if (framesize == 0) {
    st->print("ldp  lr, rfp, [sp],#%d\n\t", (2 * wordSize));
  } else if (framesize < ((1 << 9) + 2 * wordSize)) {
    st->print("ldp  lr, rfp, [sp,#%d]\n\t", framesize - 2 * wordSize);
    st->print("add  sp, sp, #%d\n\t", framesize);
  } else {
    st->print("mov  rscratch1, #%d\n\t", framesize - 2 * wordSize);
    st->print("add  sp, sp, rscratch1\n\t");
    st->print("ldp  lr, rfp, [sp],#%d\n\t", (2 * wordSize));
  }
  if (VM_Version::use_rop_protection()) {
    st->print("autiaz\n\t");
    st->print("ldr  zr, [lr]\n\t");
  }

  if (do_polling() && C->is_method_compilation()) {
    st->print("# test polling word\n\t");
    st->print("ldr  rscratch1, [rthread],#%d\n\t", in_bytes(JavaThread::polling_word_offset()));
    st->print("cmp  sp, rscratch1\n\t");
    st->print("bhi #slow_path");
  }
}
#endif

void MachEpilogNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
  Compile* C = ra_->C;
  C2_MacroAssembler _masm(&cbuf);
  int framesize = C->output()->frame_slots() << LogBytesPerInt;

  __ remove_frame(framesize);

  if (StackReservedPages > 0 && C->has_reserved_stack_access()) {
    __ reserved_stack_check();
  }

  if (do_polling() && C->is_method_compilation()) {
    Label dummy_label;
    Label* code_stub = &dummy_label;
    if (!C->output()->in_scratch_emit_size()) {
      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());
      C->output()->add_stub(stub);
      code_stub = &stub->entry();
    }
    __ relocate(relocInfo::poll_return_type);
    __ safepoint_poll(*code_stub, true /* at_return */, false /* acquire */, true /* in_nmethod */);
  }
}

uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  // Variable size. Determine dynamically.
  return MachNode::size(ra_);
}

int MachEpilogNode::reloc() const {
  // Return number of relocatable values contained in this instruction.
  return 1; // 1 for polling page.
}

const Pipeline * MachEpilogNode::pipeline() const {
  return MachNode::pipeline_class();
}

//=============================================================================

// Figure out which register class each belongs in: rc_int, rc_float or
// rc_stack.
enum RC { rc_bad, rc_int, rc_float, rc_predicate, rc_stack };

static enum RC rc_class(OptoReg::Name reg) {

  if (reg == OptoReg::Bad) {
    return rc_bad;
  }

  // we have 32 int registers * 2 halves
  int slots_of_int_registers = Register::number_of_registers * Register::max_slots_per_register;

  if (reg < slots_of_int_registers) {
    return rc_int;
  }

  // we have 32 float register * 8 halves
  int slots_of_float_registers = FloatRegister::number_of_registers * FloatRegister::max_slots_per_register;
  if (reg < slots_of_int_registers + slots_of_float_registers) {
    return rc_float;
  }

  int slots_of_predicate_registers = PRegister::number_of_registers * PRegister::max_slots_per_register;
  if (reg < slots_of_int_registers + slots_of_float_registers + slots_of_predicate_registers) {
    return rc_predicate;
  }

  // Between predicate regs & stack is the flags.
  assert(OptoReg::is_stack(reg), "blow up if spilling flags");

  return rc_stack;
}

uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {
  Compile* C = ra_->C;

  // Get registers to move.
  OptoReg::Name src_hi = ra_->get_reg_second(in(1));
  OptoReg::Name src_lo = ra_->get_reg_first(in(1));
  OptoReg::Name dst_hi = ra_->get_reg_second(this);
  OptoReg::Name dst_lo = ra_->get_reg_first(this);

  enum RC src_hi_rc = rc_class(src_hi);
  enum RC src_lo_rc = rc_class(src_lo);
  enum RC dst_hi_rc = rc_class(dst_hi);
  enum RC dst_lo_rc = rc_class(dst_lo);

  assert(src_lo != OptoReg::Bad && dst_lo != OptoReg::Bad, "must move at least 1 register");

  if (src_hi != OptoReg::Bad && !bottom_type()->isa_vectmask()) {
    assert((src_lo&1)==0 && src_lo+1==src_hi &&
           (dst_lo&1)==0 && dst_lo+1==dst_hi,
           "expected aligned-adjacent pairs");
  }

  if (src_lo == dst_lo && src_hi == dst_hi) {
    return 0;            // Self copy, no move.
  }

  bool is64 = (src_lo & 1) == 0 && src_lo + 1 == src_hi &&
              (dst_lo & 1) == 0 && dst_lo + 1 == dst_hi;
  int src_offset = ra_->reg2offset(src_lo);
  int dst_offset = ra_->reg2offset(dst_lo);

  if (bottom_type()->isa_vect() && !bottom_type()->isa_vectmask()) {
    uint ireg = ideal_reg();
    if (ireg == Op_VecA && cbuf) {
      C2_MacroAssembler _masm(cbuf);
      int sve_vector_reg_size_in_bytes = Matcher::scalable_vector_reg_size(T_BYTE);
      if (src_lo_rc == rc_stack && dst_lo_rc == rc_stack) {
        // stack->stack
        __ spill_copy_sve_vector_stack_to_stack(src_offset, dst_offset,
                                                sve_vector_reg_size_in_bytes);
      } else if (src_lo_rc == rc_float && dst_lo_rc == rc_stack) {
        __ spill_sve_vector(as_FloatRegister(Matcher::_regEncode[src_lo]), ra_->reg2offset(dst_lo),
                            sve_vector_reg_size_in_bytes);
      } else if (src_lo_rc == rc_stack && dst_lo_rc == rc_float) {
        __ unspill_sve_vector(as_FloatRegister(Matcher::_regEncode[dst_lo]), ra_->reg2offset(src_lo),
                              sve_vector_reg_size_in_bytes);
      } else if (src_lo_rc == rc_float && dst_lo_rc == rc_float) {
        __ sve_orr(as_FloatRegister(Matcher::_regEncode[dst_lo]),
                   as_FloatRegister(Matcher::_regEncode[src_lo]),
                   as_FloatRegister(Matcher::_regEncode[src_lo]));
      } else {
        ShouldNotReachHere();
      }
    } else if (cbuf) {
      assert(ireg == Op_VecD || ireg == Op_VecX, "must be 64 bit or 128 bit vector");
      C2_MacroAssembler _masm(cbuf);
      assert((src_lo_rc != rc_int && dst_lo_rc != rc_int), "sanity");
      if (src_lo_rc == rc_stack && dst_lo_rc == rc_stack) {
        // stack->stack
        assert((src_offset & 7) == 0 && (dst_offset & 7) == 0, "unaligned stack offset");
        if (ireg == Op_VecD) {
          __ unspill(rscratch1, true, src_offset);
          __ spill(rscratch1, true, dst_offset);
        } else {
          __ spill_copy128(src_offset, dst_offset);
        }
      } else if (src_lo_rc == rc_float && dst_lo_rc == rc_float) {
        __ mov(as_FloatRegister(Matcher::_regEncode[dst_lo]),
               ireg == Op_VecD ? __ T8B : __ T16B,
               as_FloatRegister(Matcher::_regEncode[src_lo]));
      } else if (src_lo_rc == rc_float && dst_lo_rc == rc_stack) {
        __ spill(as_FloatRegister(Matcher::_regEncode[src_lo]),
                 ireg == Op_VecD ? __ D : __ Q,
                 ra_->reg2offset(dst_lo));
      } else if (src_lo_rc == rc_stack && dst_lo_rc == rc_float) {
        __ unspill(as_FloatRegister(Matcher::_regEncode[dst_lo]),
                   ireg == Op_VecD ? __ D : __ Q,
                   ra_->reg2offset(src_lo));
      } else {
        ShouldNotReachHere();
      }
    }
  } else if (cbuf) {
    C2_MacroAssembler _masm(cbuf);
    switch (src_lo_rc) {
    case rc_int:
      if (dst_lo_rc == rc_int) {  // gpr --> gpr copy
        if (is64) {
            __ mov(as_Register(Matcher::_regEncode[dst_lo]),
                   as_Register(Matcher::_regEncode[src_lo]));
        } else {
            C2_MacroAssembler _masm(cbuf);
            __ movw(as_Register(Matcher::_regEncode[dst_lo]),
                    as_Register(Matcher::_regEncode[src_lo]));
        }
      } else if (dst_lo_rc == rc_float) { // gpr --> fpr copy
        if (is64) {
            __ fmovd(as_FloatRegister(Matcher::_regEncode[dst_lo]),
                     as_Register(Matcher::_regEncode[src_lo]));
        } else {
            __ fmovs(as_FloatRegister(Matcher::_regEncode[dst_lo]),
                     as_Register(Matcher::_regEncode[src_lo]));
        }
      } else {                    // gpr --> stack spill
        assert(dst_lo_rc == rc_stack, "spill to bad register class");
        __ spill(as_Register(Matcher::_regEncode[src_lo]), is64, dst_offset);
      }
      break;
    case rc_float:
      if (dst_lo_rc == rc_int) {  // fpr --> gpr copy
        if (is64) {
            __ fmovd(as_Register(Matcher::_regEncode[dst_lo]),
                     as_FloatRegister(Matcher::_regEncode[src_lo]));
        } else {
            __ fmovs(as_Register(Matcher::_regEncode[dst_lo]),
                     as_FloatRegister(Matcher::_regEncode[src_lo]));
        }
      } else if (dst_lo_rc == rc_float) { // fpr --> fpr copy
        if (is64) {
            __ fmovd(as_FloatRegister(Matcher::_regEncode[dst_lo]),
                     as_FloatRegister(Matcher::_regEncode[src_lo]));
        } else {
            __ fmovs(as_FloatRegister(Matcher::_regEncode[dst_lo]),
                     as_FloatRegister(Matcher::_regEncode[src_lo]));
        }
      } else {                    // fpr --> stack spill
        assert(dst_lo_rc == rc_stack, "spill to bad register class");
        __ spill(as_FloatRegister(Matcher::_regEncode[src_lo]),
                 is64 ? __ D : __ S, dst_offset);
      }
      break;
    case rc_stack:
      if (dst_lo_rc == rc_int) {  // stack --> gpr load
        __ unspill(as_Register(Matcher::_regEncode[dst_lo]), is64, src_offset);
      } else if (dst_lo_rc == rc_float) { // stack --> fpr load
        __ unspill(as_FloatRegister(Matcher::_regEncode[dst_lo]),
                   is64 ? __ D : __ S, src_offset);
      } else if (dst_lo_rc == rc_predicate) {
        __ unspill_sve_predicate(as_PRegister(Matcher::_regEncode[dst_lo]), ra_->reg2offset(src_lo),
                                 Matcher::scalable_vector_reg_size(T_BYTE) >> 3);
      } else {                    // stack --> stack copy
        assert(dst_lo_rc == rc_stack, "spill to bad register class");
        if (ideal_reg() == Op_RegVectMask) {
          __ spill_copy_sve_predicate_stack_to_stack(src_offset, dst_offset,
                                                     Matcher::scalable_vector_reg_size(T_BYTE) >> 3);
        } else {
          __ unspill(rscratch1, is64, src_offset);
          __ spill(rscratch1, is64, dst_offset);
        }
      }
      break;
    case rc_predicate:
      if (dst_lo_rc == rc_predicate) {
        __ sve_mov(as_PRegister(Matcher::_regEncode[dst_lo]), as_PRegister(Matcher::_regEncode[src_lo]));
      } else if (dst_lo_rc == rc_stack) {
        __ spill_sve_predicate(as_PRegister(Matcher::_regEncode[src_lo]), ra_->reg2offset(dst_lo),
                               Matcher::scalable_vector_reg_size(T_BYTE) >> 3);
      } else {
        assert(false, "bad src and dst rc_class combination.");
        ShouldNotReachHere();
      }
      break;
    default:
      assert(false, "bad rc_class for spill");
      ShouldNotReachHere();
    }
  }

  if (st) {
    st->print("spill ");
    if (src_lo_rc == rc_stack) {
      st->print("[sp, #%d] -> ", ra_->reg2offset(src_lo));
    } else {
      st->print("%s -> ", Matcher::regName[src_lo]);
    }
    if (dst_lo_rc == rc_stack) {
      st->print("[sp, #%d]", ra_->reg2offset(dst_lo));
    } else {
      st->print("%s", Matcher::regName[dst_lo]);
    }
    if (bottom_type()->isa_vect() && !bottom_type()->isa_vectmask()) {
      int vsize = 0;
      switch (ideal_reg()) {
      case Op_VecD:
        vsize = 64;
        break;
      case Op_VecX:
        vsize = 128;
        break;
      case Op_VecA:
        vsize = Matcher::scalable_vector_reg_size(T_BYTE) * 8;
        break;
      default:
        assert(false, "bad register type for spill");
        ShouldNotReachHere();
      }
      st->print("\t# vector spill size = %d", vsize);
    } else if (ideal_reg() == Op_RegVectMask) {
      assert(Matcher::supports_scalable_vector(), "bad register type for spill");
      int vsize = Matcher::scalable_predicate_reg_slots() * 32;
      st->print("\t# predicate spill size = %d", vsize);
    } else {
      st->print("\t# spill size = %d", is64 ? 64 : 32);
    }
  }

  return 0;

}

#ifndef PRODUCT
void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
  if (!ra_)
    st->print("N%d = SpillCopy(N%d)", _idx, in(1)->_idx);
  else
    implementation(nullptr, ra_, false, st);
}
#endif

void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
  implementation(&cbuf, ra_, false, nullptr);
}

uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
  return MachNode::size(ra_);
}

//=============================================================================

#ifndef PRODUCT
void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());
  int reg = ra_->get_reg_first(this);
  st->print("add %s, rsp, #%d]\t# box lock",
            Matcher::regName[reg], offset);
}
#endif

void BoxLockNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
  C2_MacroAssembler _masm(&cbuf);

  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());
  int reg    = ra_->get_encode(this);

  // This add will handle any 24-bit signed offset. 24 bits allows an
  // 8 megabyte stack frame.
  __ add(as_Register(reg), sp, offset);
}

uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
  // BoxLockNode is not a MachNode, so we can't just call MachNode::size(ra_).
  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());

  if (Assembler::operand_valid_for_add_sub_immediate(offset)) {
    return NativeInstruction::instruction_size;
  } else {
    return 2 * NativeInstruction::instruction_size;
  }
}

//=============================================================================

#ifndef PRODUCT
void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
{
  st->print_cr("# MachUEPNode");
  if (UseCompressedClassPointers) {
    st->print_cr("\tldrw rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass");
    st->print_cr("\tldrw r10, [rscratch2 + CompiledICData::speculated_klass_offset()]\t# compressed klass");
    st->print_cr("\tcmpw rscratch1, r10");
  } else {
    st->print_cr("\tldr rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass");
    st->print_cr("\tldr r10, [rscratch2 + CompiledICData::speculated_klass_offset()]\t# compressed klass");
    st->print_cr("\tcmp rscratch1, r10");
  }
  st->print_cr("\tbne, SharedRuntime::_ic_miss_stub");
}
#endif

void MachUEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const
{
  // This is the unverified entry point.
  C2_MacroAssembler _masm(&cbuf);
  __ ic_check(InteriorEntryAlignment);
}

uint MachUEPNode::size(PhaseRegAlloc* ra_) const
{
  return MachNode::size(ra_);
}

// REQUIRED EMIT CODE

//=============================================================================

// Emit exception handler code.
int HandlerImpl::emit_exception_handler(CodeBuffer& cbuf)
{
  // mov rscratch1 #exception_blob_entry_point
  // br rscratch1
  // Note that the code buffer's insts_mark is always relative to insts.
  // That's why we must use the macroassembler to generate a handler.
  C2_MacroAssembler _masm(&cbuf);
  address base = __ start_a_stub(size_exception_handler());
  if (base == nullptr) {
    ciEnv::current()->record_failure("CodeCache is full");
    return 0;  // CodeBuffer::expand failed
  }
  int offset = __ offset();
  __ far_jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));
  assert(__ offset() - offset <= (int) size_exception_handler(), "overflow");
  __ end_a_stub();
  return offset;
}

// Emit deopt handler code.
int HandlerImpl::emit_deopt_handler(CodeBuffer& cbuf)
{
  // Note that the code buffer's insts_mark is always relative to insts.
  // That's why we must use the macroassembler to generate a handler.
  C2_MacroAssembler _masm(&cbuf);
  address base = __ start_a_stub(size_deopt_handler());
  if (base == nullptr) {
    ciEnv::current()->record_failure("CodeCache is full");
    return 0;  // CodeBuffer::expand failed
  }
  int offset = __ offset();

  __ adr(lr, __ pc());
  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));

  assert(__ offset() - offset == (int) size_deopt_handler(), "overflow");
  __ end_a_stub();
  return offset;
}

// REQUIRED MATCHER CODE

//=============================================================================

bool Matcher::match_rule_supported(int opcode) {
  if (!has_match_rule(opcode))
    return false;

  switch (opcode) {
    case Op_OnSpinWait:
      return VM_Version::supports_on_spin_wait();
    case Op_CacheWB:
    case Op_CacheWBPreSync:
    case Op_CacheWBPostSync:
      if (!VM_Version::supports_data_cache_line_flush()) {
        return false;
      }
      break;
    case Op_ExpandBits:
    case Op_CompressBits:
      if (!VM_Version::supports_svebitperm()) {
        return false;
      }
      break;
    case Op_FmaF:
    case Op_FmaD:
    case Op_FmaVF:
    case Op_FmaVD:
      if (!UseFMA) {
        return false;
      }
      break;
  }

  return true; // Per default match rules are supported.
}

const RegMask* Matcher::predicate_reg_mask(void) {
  return &_PR_REG_mask;
}

const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {
  return new TypeVectMask(elemTy, length);
}

// Vector calling convention not yet implemented.
bool Matcher::supports_vector_calling_convention(void) {
  return false;
}

OptoRegPair Matcher::vector_return_value(uint ideal_reg) {
  Unimplemented();
  return OptoRegPair(0, 0);
}

// Is this branch offset short enough that a short branch can be used?
//
// NOTE: If the platform does not provide any short branch variants, then
//       this method should return false for offset 0.
bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
  // The passed offset is relative to address of the branch.

  return (-32768 <= offset && offset < 32768);
}

// Vector width in bytes.
int Matcher::vector_width_in_bytes(BasicType bt) {
  // The MaxVectorSize should have been set by detecting SVE max vector register size.
  int size = MIN2((UseSVE > 0) ? 256 : 16, (int)MaxVectorSize);
  // Minimum 2 values in vector
  if (size < 2*type2aelembytes(bt)) size = 0;
  // But never < 4
  if (size < 4) size = 0;
  return size;
}

// Limits on vector size (number of elements) loaded into vector.
int Matcher::max_vector_size(const BasicType bt) {
  return vector_width_in_bytes(bt)/type2aelembytes(bt);
}

int Matcher::min_vector_size(const BasicType bt) {
  int max_size = max_vector_size(bt);
  // Limit the min vector size to 8 bytes.
  int size = 8 / type2aelembytes(bt);
  if (bt == T_BYTE) {
    // To support vector api shuffle/rearrange.
    size = 4;
  } else if (bt == T_BOOLEAN) {
    // To support vector api load/store mask.
    size = 2;
  }
  if (size < 2) size = 2;
  return MIN2(size, max_size);
}

int Matcher::max_vector_size_auto_vectorization(const BasicType bt) {
  return Matcher::max_vector_size(bt);
}

// Actual max scalable vector register length.
int Matcher::scalable_vector_reg_size(const BasicType bt) {
  return Matcher::max_vector_size(bt);
}

// Vector ideal reg.
uint Matcher::vector_ideal_reg(int len) {
  if (UseSVE > 0 && 16 < len && len <= 256) {
    return Op_VecA;
  }
  switch(len) {
    // For 16-bit/32-bit mask vector, reuse VecD.
    case  2:
    case  4:
    case  8: return Op_VecD;
    case 16: return Op_VecX;
  }
  ShouldNotReachHere();
  return 0;
}

MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* generic_opnd, uint ideal_reg, bool is_temp) {
  assert(Matcher::is_generic_vector(generic_opnd), "not generic");
  switch (ideal_reg) {
    case Op_VecA: return new vecAOper();
    case Op_VecD: return new vecDOper();
    case Op_VecX: return new vecXOper();
  }
  ShouldNotReachHere();
  return nullptr;
}

bool Matcher::is_reg2reg_move(MachNode* m) {
  return false;
}

bool Matcher::is_generic_vector(MachOper* opnd)  {
  return opnd->opcode() == VREG;
}

// Return whether or not this register is ever used as an argument.
// This function is used on startup to build the trampoline stubs in
// generateOptoStub.  Registers not mentioned will be killed by the VM
// call in the trampoline, and arguments in those registers not be
// available to the callee.
bool Matcher::can_be_java_arg(int reg)
{
  return
    reg ==  R0_num || reg == R0_H_num ||
    reg ==  R1_num || reg == R1_H_num ||
    reg ==  R2_num || reg == R2_H_num ||
    reg ==  R3_num || reg == R3_H_num ||
    reg ==  R4_num || reg == R4_H_num ||
    reg ==  R5_num || reg == R5_H_num ||
    reg ==  R6_num || reg == R6_H_num ||
    reg ==  R7_num || reg == R7_H_num ||
    reg ==  V0_num || reg == V0_H_num ||
    reg ==  V1_num || reg == V1_H_num ||
    reg ==  V2_num || reg == V2_H_num ||
    reg ==  V3_num || reg == V3_H_num ||
    reg ==  V4_num || reg == V4_H_num ||
    reg ==  V5_num || reg == V5_H_num ||
    reg ==  V6_num || reg == V6_H_num ||
    reg ==  V7_num || reg == V7_H_num;
}

bool Matcher::is_spillable_arg(int reg)
{
  return can_be_java_arg(reg);
}

uint Matcher::int_pressure_limit()
{
  // JDK-8183543: When taking the number of available registers as int
  // register pressure threshold, the jtreg test:
  // test/hotspot/jtreg/compiler/regalloc/TestC2IntPressure.java
  // failed due to C2 compilation failure with
  // "COMPILE SKIPPED: failed spill-split-recycle sanity check".
  //
  // A derived pointer is live at CallNode and then is flagged by RA
  // as a spilled LRG. Spilling heuristics(Spill-USE) explicitly skip
  // derived pointers and lastly fail to spill after reaching maximum
  // number of iterations. Lowering the default pressure threshold to
  // (_NO_SPECIAL_REG32_mask.Size() minus 1) forces CallNode to become
  // a high register pressure area of the code so that split_DEF can
  // generate DefinitionSpillCopy for the derived pointer.
  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.Size() - 1;
  if (!PreserveFramePointer) {
    // When PreserveFramePointer is off, frame pointer is allocatable,
    // but different from other SOC registers, it is excluded from
    // fatproj's mask because its save type is No-Save. Decrease 1 to
    // ensure high pressure at fatproj when PreserveFramePointer is off.
    // See check_pressure_at_fatproj().
    default_int_pressure_threshold--;
  }
  return (INTPRESSURE == -1) ? default_int_pressure_threshold : INTPRESSURE;
}

uint Matcher::float_pressure_limit()
{
  // _FLOAT_REG_mask is generated by adlc from the float_reg register class.
  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.Size() : FLOATPRESSURE;
}

bool Matcher::use_asm_for_ldiv_by_con(jlong divisor) {
  return false;
}

RegMask Matcher::divI_proj_mask() {
  ShouldNotReachHere();
  return RegMask();
}

// Register for MODI projection of divmodI.
RegMask Matcher::modI_proj_mask() {
  ShouldNotReachHere();
  return RegMask();
}

// Register for DIVL projection of divmodL.
RegMask Matcher::divL_proj_mask() {
  ShouldNotReachHere();
  return RegMask();
}

// Register for MODL projection of divmodL.
RegMask Matcher::modL_proj_mask() {
  ShouldNotReachHere();
  return RegMask();
}

const RegMask Matcher::method_handle_invoke_SP_save_mask() {
  return FP_REG_mask();
}

bool size_fits_all_mem_uses(AddPNode* addp, int shift) {
  for (DUIterator_Fast imax, i = addp->fast_outs(imax); i < imax; i++) {
    Node* u = addp->fast_out(i);
    if (u->is_LoadStore()) {
      // On AArch64, LoadStoreNodes (i.e. compare and swap
      // instructions) only take register indirect as an operand, so
      // any attempt to use an AddPNode as an input to a LoadStoreNode
      // must fail.
      return false;
    }
    if (u->is_Mem()) {
      int opsize = u->as_Mem()->memory_size();
      assert(opsize > 0, "unexpected memory operand size");
      if (u->as_Mem()->memory_size() != (1<<shift)) {
        return false;
      }
    }
  }
  return true;
}

// Convert BootTest condition to Assembler condition.
// Replicate the logic of cmpOpOper::ccode() and cmpOpUOper::ccode().
Assembler::Condition to_assembler_cond(BoolTest::mask cond) {
  Assembler::Condition result;
  switch(cond) {
    case BoolTest::eq:
      result = Assembler::EQ; break;
    case BoolTest::ne:
      result = Assembler::NE; break;
    case BoolTest::le:
      result = Assembler::LE; break;
    case BoolTest::ge:
      result = Assembler::GE; break;
    case BoolTest::lt:
      result = Assembler::LT; break;
    case BoolTest::gt:
      result = Assembler::GT; break;
    case BoolTest::ule:
      result = Assembler::LS; break;
    case BoolTest::uge:
      result = Assembler::HS; break;
    case BoolTest::ult:
      result = Assembler::LO; break;
    case BoolTest::ugt:
      result = Assembler::HI; break;
    case BoolTest::overflow:
      result = Assembler::VS; break;
    case BoolTest::no_overflow:
      result = Assembler::VC; break;
    default:
      ShouldNotReachHere();
      return Assembler::Condition(-1);
  }

  // Check conversion
  if (cond & BoolTest::unsigned_compare) {
    assert(cmpOpUOper((BoolTest::mask)((int)cond & ~(BoolTest::unsigned_compare))).ccode() == result, "Invalid conversion");
  } else {
    assert(cmpOpOper(cond).ccode() == result, "Invalid conversion");
  }

  return result;
}

// Binary src (Replicate con)
static bool is_valid_sve_arith_imm_pattern(Node* n, Node* m) {
  if (n == nullptr || m == nullptr) {
    return false;
  }

  if (UseSVE == 0 || m->Opcode() != Op_Replicate) {
    return false;
  }

  Node* imm_node = m->in(1);
  if (!imm_node->is_Con()) {
    return false;
  }

  const Type* t = imm_node->bottom_type();
  if (!(t->isa_int() || t->isa_long())) {
    return false;
  }

  switch (n->Opcode()) {
  case Op_AndV:
  case Op_OrV:
  case Op_XorV: {
    Assembler::SIMD_RegVariant T = Assembler::elemType_to_regVariant(Matcher::vector_element_basic_type(n));
    uint64_t value = t->isa_long() ? (uint64_t)imm_node->get_long() : (uint64_t)imm_node->get_int();
    return Assembler::operand_valid_for_sve_logical_immediate(Assembler::regVariant_to_elemBits(T), value);
  }
  case Op_AddVB:
    return (imm_node->get_int() <= 255 && imm_node->get_int() >= -255);
  case Op_AddVS:
  case Op_AddVI:
    return Assembler::operand_valid_for_sve_add_sub_immediate((int64_t)imm_node->get_int());
  case Op_AddVL:
    return Assembler::operand_valid_for_sve_add_sub_immediate(imm_node->get_long());
  default:
    return false;
  }
}

// (XorV src (Replicate m1))
// (XorVMask src (MaskAll m1))
static bool is_vector_bitwise_not_pattern(Node* n, Node* m) {
  if (n != nullptr && m != nullptr) {
    return (n->Opcode() == Op_XorV || n->Opcode() == Op_XorVMask) &&
           VectorNode::is_all_ones_vector(m);
  }
  return false;
}

// Should the matcher clone input 'm' of node 'n'?
bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack& mstack) {
  if (is_vshift_con_pattern(n, m) ||
      is_vector_bitwise_not_pattern(n, m) ||
      is_valid_sve_arith_imm_pattern(n, m)) {
    mstack.push(m, Visit);
    return true;
  }
  return false;
}

// Should the Matcher clone shifts on addressing modes, expecting them
// to be subsumed into complex addressing expressions or compute them
// into registers?
bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack& mstack, VectorSet& address_visited) {
  if (clone_base_plus_offset_address(m, mstack, address_visited)) {
    return true;
  }

  Node *off = m->in(AddPNode::Offset);
  if (off->Opcode() == Op_LShiftL && off->in(2)->is_Con() &&
      size_fits_all_mem_uses(m, off->in(2)->get_int()) &&
      // Are there other uses besides address expressions?
      !is_visited(off)) {
    address_visited.set(off->_idx); // Flag as address_visited
    mstack.push(off->in(2), Visit);
    Node *conv = off->in(1);
    if (conv->Opcode() == Op_ConvI2L &&
        // Are there other uses besides address expressions?
        !is_visited(conv)) {
      address_visited.set(conv->_idx); // Flag as address_visited
      mstack.push(conv->in(1), Pre_Visit);
    } else {
      mstack.push(conv, Pre_Visit);
    }
    address_visited.test_set(m->_idx); // Flag as address_visited
    mstack.push(m->in(AddPNode::Address), Pre_Visit);
    mstack.push(m->in(AddPNode::Base), Pre_Visit);
    return true;
  } else if (off->Opcode() == Op_ConvI2L &&
             // Are there other uses besides address expressions?
             !is_visited(off)) {
    address_visited.test_set(m->_idx); // Flag as address_visited
    address_visited.set(off->_idx); // Flag as address_visited
    mstack.push(off->in(1), Pre_Visit);
    mstack.push(m->in(AddPNode::Address), Pre_Visit);
    mstack.push(m->in(AddPNode::Base), Pre_Visit);
    return true;
  }
  return false;
}

#define MOV_VOLATILE(REG, BASE, INDEX, SCALE, DISP, SCRATCH, INSN)      \
  C2_MacroAssembler _masm(&cbuf);                                       \
  {                                                                     \
    guarantee(INDEX == -1, "mode not permitted for volatile");          \
    guarantee(DISP == 0, "mode not permitted for volatile");            \
    guarantee(SCALE == 0, "mode not permitted for volatile");           \
    __ INSN(REG, as_Register(BASE));                                    \
  }


static Address mem2address(int opcode, Register base, int index, int size, int disp)
  {
    Address::extend scale;

    // Hooboy, this is fugly.  We need a way to communicate to the
    // encoder that the index needs to be sign extended, so we have to
    // enumerate all the cases.
    switch (opcode) {
    case INDINDEXSCALEDI2L:
    case INDINDEXSCALEDI2LN:
    case INDINDEXI2L:
    case INDINDEXI2LN:
      scale = Address::sxtw(size);
      break;
    default:
      scale = Address::lsl(size);
    }

    if (index == -1) {
      return Address(base, disp);
    } else {
      assert(disp == 0, "unsupported address mode: disp = %d", disp);
      return Address(base, as_Register(index), scale);
    }
  }


typedef void (MacroAssembler::* mem_insn)(Register Rt, const Address &adr);
typedef void (MacroAssembler::* mem_insn2)(Register Rt, Register adr);
typedef void (MacroAssembler::* mem_float_insn)(FloatRegister Rt, const Address &adr);
typedef void (MacroAssembler::* mem_vector_insn)(FloatRegister Rt,
                                  MacroAssembler::SIMD_RegVariant T, const Address &adr);

  // Used for all non-volatile memory accesses.  The use of
  // $mem->opcode() to discover whether this pattern uses sign-extended
  // offsets is something of a kludge.
  static void loadStore(C2_MacroAssembler masm, mem_insn insn,
                        Register reg, int opcode,
                        Register base, int index, int scale, int disp,
                        int size_in_memory)
  {
    Address addr = mem2address(opcode, base, index, scale, disp);
    if (addr.getMode() == Address::base_plus_offset) {
      /* Fix up any out-of-range offsets. */
      assert_different_registers(rscratch1, base);
      assert_different_registers(rscratch1, reg);
      addr = masm.legitimize_address(addr, size_in_memory, rscratch1);
    }
    (masm.*insn)(reg, addr);
  }

  static void loadStore(C2_MacroAssembler masm, mem_float_insn insn,
                        FloatRegister reg, int opcode,
                        Register base, int index, int size, int disp,
                        int size_in_memory)
  {
    Address::extend scale;

    switch (opcode) {
    case INDINDEXSCALEDI2L:
    case INDINDEXSCALEDI2LN:
      scale = Address::sxtw(size);
      break;
    default:
      scale = Address::lsl(size);
    }

    if (index == -1) {
      /* If we get an out-of-range offset it is a bug in the compiler,
         so we assert here. */
      assert(Address::offset_ok_for_immed(disp, exact_log2(size_in_memory)), "c2 compiler bug");
      /* Fix up any out-of-range offsets. */
      assert_different_registers(rscratch1, base);
      Address addr = Address(base, disp);
      addr = masm.legitimize_address(addr, size_in_memory, rscratch1);
      (masm.*insn)(reg, addr);
    } else {
      assert(disp == 0, "unsupported address mode: disp = %d", disp);
      (masm.*insn)(reg, Address(base, as_Register(index), scale));
    }
  }

  static void loadStore(C2_MacroAssembler masm, mem_vector_insn insn,
                        FloatRegister reg, MacroAssembler::SIMD_RegVariant T,
                        int opcode, Register base, int index, int size, int disp)
  {
    if (index == -1) {
      (masm.*insn)(reg, T, Address(base, disp));
    } else {
      assert(disp == 0, "unsupported address mode");
      (masm.*insn)(reg, T, Address(base, as_Register(index), Address::lsl(size)));
    }
  }


#line 1648 "ad_aarch64.cpp"


//SourceForm

#line 91 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"


  typedef void (C2_MacroAssembler::* sve_mem_insn_predicate)(FloatRegister Rt, Assembler::SIMD_RegVariant T,
                                                             PRegister Pg, const Address &adr);

  // Predicated load/store, with optional ptrue to all elements of given predicate register.
  static void loadStoreA_predicated(C2_MacroAssembler masm, bool is_store, FloatRegister reg,
                                    PRegister pg, BasicType mem_elem_bt, BasicType vector_elem_bt,
                                    int opcode, Register base, int index, int size, int disp) {
    sve_mem_insn_predicate insn;
    int mesize = type2aelembytes(mem_elem_bt);
    if (index == -1) {
      assert(size == 0, "unsupported address mode: scale size = %d", size);
      switch(mesize) {
      case 1:
        insn = is_store ? &C2_MacroAssembler::sve_st1b : &C2_MacroAssembler::sve_ld1b;
        break;
      case 2:
        insn = is_store ? &C2_MacroAssembler::sve_st1h : &C2_MacroAssembler::sve_ld1h;
        break;
      case 4:
        insn = is_store ? &C2_MacroAssembler::sve_st1w : &C2_MacroAssembler::sve_ld1w;
        break;
      case 8:
        insn = is_store ? &C2_MacroAssembler::sve_st1d : &C2_MacroAssembler::sve_ld1d;
        break;
      default:
        assert(false, "unsupported");
        ShouldNotReachHere();
      }
      int imm4 = disp / mesize / Matcher::scalable_vector_reg_size(vector_elem_bt);
      (masm.*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));
    } else {
      assert(false, "unimplemented");
      ShouldNotReachHere();
    }
  }

  bool Matcher::match_rule_supported_auto_vectorization(int opcode, int vlen, BasicType bt) {
    if (UseSVE == 0) {
      // These operations are not profitable to be vectorized on NEON, because no direct
      // NEON instructions support them. But the match rule support for them is profitable for
      // Vector API intrinsics.
      if ((opcode == Op_VectorCastD2X && bt == T_INT) ||
          (opcode == Op_VectorCastL2X && bt == T_FLOAT) ||
          (opcode == Op_CountLeadingZerosV && bt == T_LONG) ||
          (opcode == Op_CountTrailingZerosV && bt == T_LONG) ||
          // The vector implementation of Op_AddReductionVD/F is for the Vector API only.
          // It is not suitable for auto-vectorization because it does not add the elements
          // in the same order as sequential code, and FP addition is non-associative.
          opcode == Op_AddReductionVD || opcode == Op_AddReductionVF ||
          opcode == Op_MulReductionVD || opcode == Op_MulReductionVF ||
          opcode == Op_MulVL) {
        return false;
      }
    }
    return match_rule_supported_vector(opcode, vlen, bt);
  }

  // Identify extra cases that we might want to provide match rules for vector nodes and
  // other intrinsics guarded with vector length (vlen) and element type (bt).
  bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
    if (!match_rule_supported(opcode)) {
      return false;
    }

    int length_in_bytes = vlen * type2aelembytes(bt);
    if (UseSVE == 0 && length_in_bytes > 16) {
      return false;
    }

    // Check whether specific Op is supported.
    // Fail fast, otherwise fall through to common vector_size_supported() check.
    switch (opcode) {
      case Op_AndVMask:
      case Op_OrVMask:
      case Op_XorVMask:
      case Op_MaskAll:
      case Op_VectorMaskGen:
      case Op_LoadVectorMasked:
      case Op_StoreVectorMasked:
      case Op_LoadVectorGather:
      case Op_StoreVectorScatter:
      case Op_LoadVectorGatherMasked:
      case Op_StoreVectorScatterMasked:
      case Op_PopulateIndex:
      case Op_CompressM:
      case Op_CompressV:
        if (UseSVE == 0) {
          return false;
        }
        break;
      case Op_MulAddVS2VI:
        if (length_in_bytes != 16) {
          return false;
        }
        break;
      case Op_MulReductionVD:
      case Op_MulReductionVF:
      case Op_MulReductionVI:
      case Op_MulReductionVL:
        // No vector multiply reduction instructions, but we do
        // emit scalar instructions for 64/128-bit vectors.
        if (length_in_bytes != 8 && length_in_bytes != 16) {
          return false;
        }
        break;
      case Op_VectorMaskCmp:
        if (length_in_bytes < 8) {
          return false;
        }
        break;
      case Op_VectorLoadShuffle:
      case Op_VectorRearrange:
        if (vlen < 4) {
          return false;
        }
        break;
      case Op_ExpandV:
        if (UseSVE < 2 || is_subword_type(bt)) {
          return false;
        }
        break;
      case Op_VectorMaskToLong:
        if (UseSVE > 0 && vlen > 64) {
          return false;
        }
        break;
      case Op_VectorLongToMask:
        if (vlen > 64 || !VM_Version::supports_svebitperm()) {
          return false;
        }
        break;
      case Op_CompressBitsV:
      case Op_ExpandBitsV:
        if (!VM_Version::supports_svebitperm()) {
          return false;
        }
        break;
      default:
        break;
    }
    return vector_size_supported(bt, vlen);
  }

  bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {
    // Only SVE supports masked operations.
    if (UseSVE == 0) {
      return false;
    }

    // If an opcode does not support the masked version,
    // unpredicated node with VectorBlend node will be used instead.
    switch(opcode) {
      case Op_VectorRearrange:
      case Op_MulReductionVD:
      case Op_MulReductionVF:
      case Op_MulReductionVI:
      case Op_MulReductionVL:
      case Op_CompressBitsV:
      case Op_ExpandBitsV:
        return false;
      // We use Op_LoadVectorMasked to implement the predicated Op_LoadVector.
      // Hence we turn to check whether Op_LoadVectorMasked is supported. The
      // same as vector store/gather/scatter.
      case Op_LoadVector:
        opcode = Op_LoadVectorMasked;
        break;
      case Op_StoreVector:
        opcode = Op_StoreVectorMasked;
        break;
      case Op_LoadVectorGather:
        opcode = Op_LoadVectorGatherMasked;
        break;
      case Op_StoreVectorScatter:
        opcode = Op_StoreVectorScatterMasked;
        break;
      default:
        break;
    }

    return match_rule_supported_vector(opcode, vlen, bt);
  }

  bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {
    // Only SVE has partial vector operations
    if (UseSVE == 0) {
      return false;
    }

    switch(node->Opcode()) {
      case Op_VectorLoadMask:
      case Op_VectorMaskCmp:
      case Op_LoadVectorGather:
      case Op_StoreVectorScatter:
      case Op_AddReductionVF:
      case Op_AddReductionVD:
      case Op_AndReductionV:
      case Op_OrReductionV:
      case Op_XorReductionV:
      // Mask is needed for partial Op_VectorMaskFirstTrue, because when the
      // input predicate is all-false, the result should be the vector length
      // instead of the vector register size.
      case Op_VectorMaskFirstTrue:
        return true;
      case Op_MaskAll:
        return !node->in(1)->is_Con();
      case Op_LoadVector:
      case Op_StoreVector:
        // We use NEON load/store instructions if the vector length is <= 128 bits.
        return vt->length_in_bytes() > 16;
      case Op_AddReductionVI:
      case Op_AddReductionVL:
        // We may prefer using NEON instructions rather than SVE partial operations.
        return !VM_Version::use_neon_for_vector(vt->length_in_bytes());
      case Op_MinReductionV:
      case Op_MaxReductionV:
        // For BYTE/SHORT/INT/FLOAT/DOUBLE types, we may prefer using NEON
        // instructions rather than SVE partial operations.
        return vt->element_basic_type() == T_LONG ||
               !VM_Version::use_neon_for_vector(vt->length_in_bytes());
      default:
        // For other ops whose vector size is smaller than the max vector size, a
        // full-sized unpredicated operation does not impact the final vector result.
        return false;
    }
  }

  // Assert that the given node is not a variable shift.
  bool assert_not_var_shift(const Node* n) {
    assert(!n->as_ShiftV()->is_var_shift(), "illegal variable shift");
    return true;
  }

  Assembler::SIMD_Arrangement get_arrangement(const Node* n) {
    BasicType bt = Matcher::vector_element_basic_type(n);
    uint length_in_bytes = Matcher::vector_length_in_bytes(n);
    return Assembler::esize2arrangement((uint)type2aelembytes(bt),
                                        /* isQ */ length_in_bytes == 16);
  }

  Assembler::SIMD_RegVariant get_reg_variant(const Node* n) {
    BasicType bt = Matcher::vector_element_basic_type(n);
    return Assembler::elemType_to_regVariant(bt);
  }

#line 1900 "ad_aarch64.cpp"


//SourceForm

#line 32 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/x/x_aarch64.ad"


static void x_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, uint8_t barrier_data) {
  if (barrier_data == XLoadBarrierElided) {
    return;
  }
  XLoadBarrierStubC2* const stub = XLoadBarrierStubC2::create(node, ref_addr, ref, tmp, barrier_data);
  __ ldr(tmp, Address(rthread, XThreadLocalData::address_bad_mask_offset()));
  __ andr(tmp, tmp, ref);
  __ cbnz(tmp, *stub->entry());
  __ bind(*stub->continuation());
}

static void x_load_barrier_slow_path(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp) {
  XLoadBarrierStubC2* const stub = XLoadBarrierStubC2::create(node, ref_addr, ref, tmp, XLoadBarrierStrong);
  __ b(*stub->entry());
  __ bind(*stub->continuation());
}


#line 1926 "ad_aarch64.cpp"


//SourceForm

#line 32 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/z/z_aarch64.ad"


#include "gc/z/zBarrierSetAssembler.hpp"

static void z_color(MacroAssembler& _masm, const MachNode* node, Register dst, Register src) {
  assert_different_registers(src, dst);
  __ relocate(barrier_Relocation::spec(), ZBarrierRelocationFormatStoreGoodBeforeMov);
  __ movzw(dst, barrier_Relocation::unpatched);
  __ orr(dst, dst, src, Assembler::LSL, ZPointerLoadShift);
}

static void z_uncolor(MacroAssembler& _masm, const MachNode* node, Register ref) {
  __ lsr(ref, ref, ZPointerLoadShift);
}

static void z_keep_alive_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp) {
  __ relocate(barrier_Relocation::spec(), ZBarrierRelocationFormatMarkBadBeforeMov);
  __ movzw(tmp, barrier_Relocation::unpatched);
  __ tst(ref, tmp);
  ZLoadBarrierStubC2Aarch64* const stub = ZLoadBarrierStubC2Aarch64::create(node, ref_addr, ref);
  __ br(Assembler::NE, *stub->entry());
  z_uncolor(_masm, node, ref);
  __ bind(*stub->continuation());
}

static void z_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp) {
  Assembler::InlineSkippedInstructionsCounter skipped_counter(&_masm);
  const bool on_non_strong =
      ((node->barrier_data() & ZBarrierWeak) != 0) ||
      ((node->barrier_data() & ZBarrierPhantom) != 0);

  if (on_non_strong) {
    z_keep_alive_load_barrier(_masm, node, ref_addr, ref, tmp);
    return;
  }

  if (node->barrier_data() == ZBarrierElided) {
    z_uncolor(_masm, node, ref);
    return;
  }

  ZLoadBarrierStubC2Aarch64* const stub = ZLoadBarrierStubC2Aarch64::create(node, ref_addr, ref, __ offset());
  if (stub->is_test_and_branch_reachable()) {
    __ relocate(barrier_Relocation::spec(), ZBarrierRelocationFormatLoadGoodBeforeTbX);
    __ tbnz(ref, barrier_Relocation::unpatched, *stub->entry());
  } else {
    Label good;
    __ relocate(barrier_Relocation::spec(), ZBarrierRelocationFormatLoadGoodBeforeTbX);
    __ tbz(ref, barrier_Relocation::unpatched, good);
    __ b(*stub->entry());
    __ bind(good);
  }
  z_uncolor(_masm, node, ref);
  __ bind(*stub->continuation());
}

static void z_store_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register rnew_zaddress, Register rnew_zpointer, Register tmp, bool is_atomic) {
  Assembler::InlineSkippedInstructionsCounter skipped_counter(&_masm);
  if (node->barrier_data() == ZBarrierElided) {
    z_color(_masm, node, rnew_zpointer, rnew_zaddress);
  } else {
    bool is_native = (node->barrier_data() & ZBarrierNative) != 0;
    ZStoreBarrierStubC2Aarch64* const stub = ZStoreBarrierStubC2Aarch64::create(node, ref_addr, rnew_zaddress, rnew_zpointer, is_native, is_atomic);
    ZBarrierSetAssembler* bs_asm = ZBarrierSet::assembler();
    bs_asm->store_barrier_fast(&_masm, ref_addr, rnew_zaddress, rnew_zpointer, tmp, true /* in_nmethod */, is_atomic, *stub->entry(), *stub->continuation());
  }
}


#line 2001 "ad_aarch64.cpp"


#ifndef PRODUCT
void Compile::adlc_verification() {

  // Following assertions generated from definition section
  assert( INSN_COST == 100, "Expect (100) to equal 100");
  assert( BRANCH_COST == 200, "Expect (2 * INSN_COST) to equal 200");
  assert( CALL_COST == 200, "Expect (2 * INSN_COST) to equal 200");
  assert( VOLATILE_REF_COST == 1000, "Expect (10 * INSN_COST) to equal 1000");
}
#endif

// Map from machine-independent register number to register_save_policy
const        char register_save_policy[] = {
  'C', // R10
  'C', // R10_H
  'C', // R11
  'C', // R11_H
  'C', // R12
  'C', // R12_H
  'C', // R13
  'C', // R13_H
  'C', // R14
  'C', // R14_H
  'C', // R15
  'C', // R15_H
  'C', // R16
  'C', // R16_H
  'C', // R17
  'C', // R17_H
  'C', // R18
  'C', // R18_H
  'C', // R0
  'C', // R0_H
  'C', // R1
  'C', // R1_H
  'C', // R2
  'C', // R2_H
  'C', // R3
  'C', // R3_H
  'C', // R4
  'C', // R4_H
  'C', // R5
  'C', // R5_H
  'C', // R6
  'C', // R6_H
  'C', // R7
  'C', // R7_H
  'C', // R19
  'C', // R19_H
  'C', // R20
  'C', // R20_H
  'C', // R21
  'C', // R21_H
  'C', // R22
  'C', // R22_H
  'C', // R23
  'C', // R23_H
  'C', // R24
  'C', // R24_H
  'C', // R25
  'C', // R25_H
  'C', // R26
  'C', // R26_H
  'C', // R27
  'C', // R27_H
  'N', // R28
  'N', // R28_H
  'N', // R29
  'N', // R29_H
  'N', // R30
  'N', // R30_H
  'N', // R31
  'N', // R31_H
  'N', // R8
  'N', // R8_H
  'N', // R9
  'N', // R9_H
  'C', // V16
  'C', // V16_H
  'C', // V16_J
  'C', // V16_K
  'C', // V17
  'C', // V17_H
  'C', // V17_J
  'C', // V17_K
  'C', // V18
  'C', // V18_H
  'C', // V18_J
  'C', // V18_K
  'C', // V19
  'C', // V19_H
  'C', // V19_J
  'C', // V19_K
  'C', // V20
  'C', // V20_H
  'C', // V20_J
  'C', // V20_K
  'C', // V21
  'C', // V21_H
  'C', // V21_J
  'C', // V21_K
  'C', // V22
  'C', // V22_H
  'C', // V22_J
  'C', // V22_K
  'C', // V23
  'C', // V23_H
  'C', // V23_J
  'C', // V23_K
  'C', // V24
  'C', // V24_H
  'C', // V24_J
  'C', // V24_K
  'C', // V25
  'C', // V25_H
  'C', // V25_J
  'C', // V25_K
  'C', // V26
  'C', // V26_H
  'C', // V26_J
  'C', // V26_K
  'C', // V27
  'C', // V27_H
  'C', // V27_J
  'C', // V27_K
  'C', // V28
  'C', // V28_H
  'C', // V28_J
  'C', // V28_K
  'C', // V29
  'C', // V29_H
  'C', // V29_J
  'C', // V29_K
  'C', // V30
  'C', // V30_H
  'C', // V30_J
  'C', // V30_K
  'C', // V31
  'C', // V31_H
  'C', // V31_J
  'C', // V31_K
  'C', // V0
  'C', // V0_H
  'C', // V0_J
  'C', // V0_K
  'C', // V1
  'C', // V1_H
  'C', // V1_J
  'C', // V1_K
  'C', // V2
  'C', // V2_H
  'C', // V2_J
  'C', // V2_K
  'C', // V3
  'C', // V3_H
  'C', // V3_J
  'C', // V3_K
  'C', // V4
  'C', // V4_H
  'C', // V4_J
  'C', // V4_K
  'C', // V5
  'C', // V5_H
  'C', // V5_J
  'C', // V5_K
  'C', // V6
  'C', // V6_H
  'C', // V6_J
  'C', // V6_K
  'C', // V7
  'C', // V7_H
  'C', // V7_J
  'C', // V7_K
  'C', // V8
  'C', // V8_H
  'C', // V8_J
  'C', // V8_K
  'C', // V9
  'C', // V9_H
  'C', // V9_J
  'C', // V9_K
  'C', // V10
  'C', // V10_H
  'C', // V10_J
  'C', // V10_K
  'C', // V11
  'C', // V11_H
  'C', // V11_J
  'C', // V11_K
  'C', // V12
  'C', // V12_H
  'C', // V12_J
  'C', // V12_K
  'C', // V13
  'C', // V13_H
  'C', // V13_J
  'C', // V13_K
  'C', // V14
  'C', // V14_H
  'C', // V14_J
  'C', // V14_K
  'C', // V15
  'C', // V15_H
  'C', // V15_J
  'C', // V15_K
  'C', // P0
  'C', // P1
  'C', // P2
  'C', // P3
  'C', // P4
  'C', // P5
  'C', // P6
  'C', // P8
  'C', // P9
  'C', // P10
  'C', // P11
  'C', // P12
  'C', // P13
  'C', // P14
  'C', // P15
  'C', // P7
  'C' // no trailing comma // RFLAGS
};

// Map from machine-independent register number to c_reg_save_policy
const        char c_reg_save_policy[] = {
  'C', // R10
  'C', // R10_H
  'C', // R11
  'C', // R11_H
  'C', // R12
  'C', // R12_H
  'C', // R13
  'C', // R13_H
  'C', // R14
  'C', // R14_H
  'C', // R15
  'C', // R15_H
  'C', // R16
  'C', // R16_H
  'C', // R17
  'C', // R17_H
  'C', // R18
  'C', // R18_H
  'C', // R0
  'C', // R0_H
  'C', // R1
  'C', // R1_H
  'C', // R2
  'C', // R2_H
  'C', // R3
  'C', // R3_H
  'C', // R4
  'C', // R4_H
  'C', // R5
  'C', // R5_H
  'C', // R6
  'C', // R6_H
  'C', // R7
  'C', // R7_H
  'E', // R19
  'E', // R19_H
  'E', // R20
  'E', // R20_H
  'E', // R21
  'E', // R21_H
  'E', // R22
  'E', // R22_H
  'E', // R23
  'E', // R23_H
  'E', // R24
  'E', // R24_H
  'E', // R25
  'E', // R25_H
  'E', // R26
  'E', // R26_H
  'E', // R27
  'E', // R27_H
  'E', // R28
  'E', // R28_H
  'N', // R29
  'N', // R29_H
  'N', // R30
  'N', // R30_H
  'N', // R31
  'N', // R31_H
  'C', // R8
  'C', // R8_H
  'C', // R9
  'C', // R9_H
  'C', // V16
  'C', // V16_H
  'C', // V16_J
  'C', // V16_K
  'C', // V17
  'C', // V17_H
  'C', // V17_J
  'C', // V17_K
  'C', // V18
  'C', // V18_H
  'C', // V18_J
  'C', // V18_K
  'C', // V19
  'C', // V19_H
  'C', // V19_J
  'C', // V19_K
  'C', // V20
  'C', // V20_H
  'C', // V20_J
  'C', // V20_K
  'C', // V21
  'C', // V21_H
  'C', // V21_J
  'C', // V21_K
  'C', // V22
  'C', // V22_H
  'C', // V22_J
  'C', // V22_K
  'C', // V23
  'C', // V23_H
  'C', // V23_J
  'C', // V23_K
  'C', // V24
  'C', // V24_H
  'C', // V24_J
  'C', // V24_K
  'C', // V25
  'C', // V25_H
  'C', // V25_J
  'C', // V25_K
  'C', // V26
  'C', // V26_H
  'C', // V26_J
  'C', // V26_K
  'C', // V27
  'C', // V27_H
  'C', // V27_J
  'C', // V27_K
  'C', // V28
  'C', // V28_H
  'C', // V28_J
  'C', // V28_K
  'C', // V29
  'C', // V29_H
  'C', // V29_J
  'C', // V29_K
  'C', // V30
  'C', // V30_H
  'C', // V30_J
  'C', // V30_K
  'C', // V31
  'C', // V31_H
  'C', // V31_J
  'C', // V31_K
  'C', // V0
  'C', // V0_H
  'C', // V0_J
  'C', // V0_K
  'C', // V1
  'C', // V1_H
  'C', // V1_J
  'C', // V1_K
  'C', // V2
  'C', // V2_H
  'C', // V2_J
  'C', // V2_K
  'C', // V3
  'C', // V3_H
  'C', // V3_J
  'C', // V3_K
  'C', // V4
  'C', // V4_H
  'C', // V4_J
  'C', // V4_K
  'C', // V5
  'C', // V5_H
  'C', // V5_J
  'C', // V5_K
  'C', // V6
  'C', // V6_H
  'C', // V6_J
  'C', // V6_K
  'C', // V7
  'C', // V7_H
  'C', // V7_J
  'C', // V7_K
  'E', // V8
  'E', // V8_H
  'C', // V8_J
  'C', // V8_K
  'E', // V9
  'E', // V9_H
  'C', // V9_J
  'C', // V9_K
  'E', // V10
  'E', // V10_H
  'C', // V10_J
  'C', // V10_K
  'E', // V11
  'E', // V11_H
  'C', // V11_J
  'C', // V11_K
  'E', // V12
  'E', // V12_H
  'C', // V12_J
  'C', // V12_K
  'E', // V13
  'E', // V13_H
  'C', // V13_J
  'C', // V13_K
  'E', // V14
  'E', // V14_H
  'C', // V14_J
  'C', // V14_K
  'E', // V15
  'E', // V15_H
  'C', // V15_J
  'C', // V15_K
  'C', // P0
  'C', // P1
  'C', // P2
  'C', // P3
  'C', // P4
  'C', // P5
  'C', // P6
  'C', // P8
  'C', // P9
  'C', // P10
  'C', // P11
  'C', // P12
  'C', // P13
  'C', // P14
  'C', // P15
  'C', // P7
  'C' // no trailing comma // RFLAGS
};

// Map from machine-independent register number to register_save_type
const        int register_save_type[] = {
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegVectMask,
  Op_RegVectMask,
  Op_RegVectMask,
  Op_RegVectMask,
  Op_RegVectMask,
  Op_RegVectMask,
  Op_RegVectMask,
  Op_RegVectMask,
  Op_RegVectMask,
  Op_RegVectMask,
  Op_RegVectMask,
  Op_RegVectMask,
  Op_RegVectMask,
  Op_RegVectMask,
  Op_RegVectMask,
  Op_RegVectMask,
  0 // no trailing comma
};


const        int   reduceOp[] = {
  /*    0 */  0,
  /*    1 */  0,
  /*    2 */  0,
  /*    3 */  0,
  /*    4 */  0,
  /*    5 */  0,
  /*    6 */  0,
  /*    7 */  0,
  /*    8 */  immI_rule,
  /*    9 */  immI0_rule,
  /*   10 */  immI_1_rule,
  /*   11 */  immI_M1_rule,
  /*   12 */  immIExt_rule,
  /*   13 */  immI_gt_1_rule,
  /*   14 */  immI_le_4_rule,
  /*   15 */  immI_16_rule,
  /*   16 */  immI_24_rule,
  /*   17 */  immI_32_rule,
  /*   18 */  immI_48_rule,
  /*   19 */  immI_56_rule,
  /*   20 */  immI_255_rule,
  /*   21 */  immI_65535_rule,
  /*   22 */  immI_positive_rule,
  /*   23 */  immI_cmp_cond_rule,
  /*   24 */  immI_cmpU_cond_rule,
  /*   25 */  immL_255_rule,
  /*   26 */  immL_65535_rule,
  /*   27 */  immL_4294967295_rule,
  /*   28 */  immL_bitmask_rule,
  /*   29 */  immI_bitmask_rule,
  /*   30 */  immL_positive_bitmaskI_rule,
  /*   31 */  immIScale_rule,
  /*   32 */  immI5_rule,
  /*   33 */  immIU7_rule,
  /*   34 */  immIOffset_rule,
  /*   35 */  immIOffset1_rule,
  /*   36 */  immIOffset2_rule,
  /*   37 */  immIOffset4_rule,
  /*   38 */  immIOffset8_rule,
  /*   39 */  immIOffset16_rule,
  /*   40 */  immLoffset_rule,
  /*   41 */  immLoffset1_rule,
  /*   42 */  immLoffset2_rule,
  /*   43 */  immLoffset4_rule,
  /*   44 */  immLoffset8_rule,
  /*   45 */  immLoffset16_rule,
  /*   46 */  immL5_rule,
  /*   47 */  immLU7_rule,
  /*   48 */  immI8_rule,
  /*   49 */  immI8_shift8_rule,
  /*   50 */  immL8_shift8_rule,
  /*   51 */  immBAddSubV_rule,
  /*   52 */  immIAddSub_rule,
  /*   53 */  immIAddSubV_rule,
  /*   54 */  immBLog_rule,
  /*   55 */  immSLog_rule,
  /*   56 */  immILog_rule,
  /*   57 */  immL_rule,
  /*   58 */  immL0_rule,
  /*   59 */  immL_M1_rule,
  /*   60 */  immLAddSub_rule,
  /*   61 */  immLAddSubV_rule,
  /*   62 */  immLLog_rule,
  /*   63 */  immL_32bits_rule,
  /*   64 */  immP_rule,
  /*   65 */  immP0_rule,
  /*   66 */  immP_1_rule,
  /*   67 */  immByteMapBase_rule,
  /*   68 */  immD_rule,
  /*   69 */  immD0_rule,
  /*   70 */  immDPacked_rule,
  /*   71 */  immF_rule,
  /*   72 */  immF0_rule,
  /*   73 */  immFPacked_rule,
  /*   74 */  immN_rule,
  /*   75 */  immN0_rule,
  /*   76 */  immNKlass_rule,
  /*   77 */  iRegI_rule,
  /*   78 */  iRegINoSp_rule,
  /*   79 */  iRegL_rule,
  /*   80 */  iRegLNoSp_rule,
  /*   81 */  iRegP_rule,
  /*   82 */  iRegPNoSp_rule,
  /*   83 */  iRegP_R0_rule,
  /*   84 */  iRegP_R1_rule,
  /*   85 */  iRegP_R2_rule,
  /*   86 */  iRegP_R3_rule,
  /*   87 */  iRegP_R4_rule,
  /*   88 */  iRegP_R5_rule,
  /*   89 */  iRegP_R10_rule,
  /*   90 */  iRegL_R0_rule,
  /*   91 */  iRegL_R11_rule,
  /*   92 */  iRegI_R0_rule,
  /*   93 */  iRegI_R2_rule,
  /*   94 */  iRegI_R3_rule,
  /*   95 */  iRegI_R4_rule,
  /*   96 */  iRegN_rule,
  /*   97 */  iRegNNoSp_rule,
  /*   98 */  vRegF_rule,
  /*   99 */  vRegD_rule,
  /*  100 */  vReg_rule,
  /*  101 */  vecA_rule,
  /*  102 */  vecD_rule,
  /*  103 */  vecX_rule,
  /*  104 */  vRegD_V0_rule,
  /*  105 */  vRegD_V1_rule,
  /*  106 */  vRegD_V2_rule,
  /*  107 */  vRegD_V3_rule,
  /*  108 */  vRegD_V4_rule,
  /*  109 */  vRegD_V5_rule,
  /*  110 */  vRegD_V6_rule,
  /*  111 */  vRegD_V7_rule,
  /*  112 */  pReg_rule,
  /*  113 */  pRegGov_rule,
  /*  114 */  pRegGov_P0_rule,
  /*  115 */  pRegGov_P1_rule,
  /*  116 */  rFlagsReg_rule,
  /*  117 */  rFlagsRegU_rule,
  /*  118 */  inline_cache_RegP_rule,
  /*  119 */  thread_RegP_rule,
  /*  120 */  indirect_rule,
  /*  121 */  indIndexScaledI2L_rule,
  /*  122 */  indIndexScaled_rule,
  /*  123 */  indIndexI2L_rule,
  /*  124 */  indIndex_rule,
  /*  125 */  indOffI1_rule,
  /*  126 */  indOffI2_rule,
  /*  127 */  indOffI4_rule,
  /*  128 */  indOffI8_rule,
  /*  129 */  indOffI16_rule,
  /*  130 */  indOffL1_rule,
  /*  131 */  indOffL2_rule,
  /*  132 */  indOffL4_rule,
  /*  133 */  indOffL8_rule,
  /*  134 */  indOffL16_rule,
  /*  135 */  indirectN_rule,
  /*  136 */  indIndexScaledI2LN_rule,
  /*  137 */  indIndexScaledN_rule,
  /*  138 */  indIndexI2LN_rule,
  /*  139 */  indIndexN_rule,
  /*  140 */  indOffIN_rule,
  /*  141 */  indOffLN_rule,
  /*  142 */  stackSlotP_rule,
  /*  143 */  stackSlotI_rule,
  /*  144 */  stackSlotF_rule,
  /*  145 */  stackSlotD_rule,
  /*  146 */  stackSlotL_rule,
  /*  147 */  cmpOp_rule,
  /*  148 */  cmpOpU_rule,
  /*  149 */  cmpOpEqNe_rule,
  /*  150 */  cmpOpLtGe_rule,
  /*  151 */  cmpOpUEqNeLtGe_rule,
  /*  152 */  iRegL2I_rule,
  /*  153 */  vmemA_immIOffset4_rule,
  /*  154 */  vmemA_immLOffset4_rule,
  /*  155 */  vmemA_indOffI4_rule,
  /*  156 */  vmemA_indOffL4_rule,
  // last operand
  /*  157 */  vmem2_rule,
  /*  158 */  vmem4_rule,
  /*  159 */  vmem8_rule,
  /*  160 */  vmem16_rule,
  /*  161 */  memory1_rule,
  /*  162 */  memory2_rule,
  /*  163 */  memory4_rule,
  /*  164 */  memory8_rule,
  /*  165 */  memory_rule,
  /*  166 */  iRegIorL2I_rule,
  /*  167 */  vmemA_rule,
  // last operand class
  /*  168 */  _ConvI2L_iRegI__rule,
  /*  169 */  _LShiftL__ConvI2L_iRegI__immIScale_rule,
  /*  170 */  _LShiftL_iRegL_immIScale_rule,
  /*  171 */  _DecodeN_iRegN__rule,
  /*  172 */  _LoadB_memory1__rule,
  /*  173 */  _LoadUB_memory1__rule,
  /*  174 */  _LoadS_memory2__rule,
  /*  175 */  _LoadUS_memory2__rule,
  /*  176 */  _LoadI_memory4__rule,
  /*  177 */  _ConvI2L__LoadI_memory4___rule,
  /*  178 */  _LoadB_indirect__rule,
  /*  179 */  _LoadUB_indirect__rule,
  /*  180 */  _LoadUS_indirect__rule,
  /*  181 */  _LoadS_indirect__rule,
  /*  182 */  _LoadI_indirect__rule,
  /*  183 */  _ConvI2L__LoadI_indirect___rule,
  /*  184 */  _LoadL_memory8__rule,
  /*  185 */  _CastP2X_iRegP__rule,
  /*  186 */  _CastP2X__DecodeN_iRegN___rule,
  /*  187 */  _Binary_iRegINoSp_iRegINoSp_rule,
  /*  188 */  _Binary_iRegLNoSp_iRegLNoSp_rule,
  /*  189 */  _Binary_iRegP_iRegP_rule,
  /*  190 */  _Binary_iRegNNoSp_iRegNNoSp_rule,
  /*  191 */  _Binary_iRegI_iRegI_rule,
  /*  192 */  _Binary_iRegL_iRegL_rule,
  /*  193 */  _Binary_iRegN_iRegN_rule,
  /*  194 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  195 */  _Binary_iRegIorL2I_iRegIorL2I_rule,
  /*  196 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  197 */  _Binary_immI0_iRegIorL2I_rule,
  /*  198 */  _Binary_iRegIorL2I_immI0_rule,
  /*  199 */  _Binary_immI_1_immI0_rule,
  /*  200 */  _Binary_iRegL_immL0_rule,
  /*  201 */  _Binary_immL0_iRegL_rule,
  /*  202 */  _Binary_iRegP_immP0_rule,
  /*  203 */  _Binary_immP0_iRegP_rule,
  /*  204 */  _Binary_iRegN_immN0_rule,
  /*  205 */  _Binary_immN0_iRegN_rule,
  /*  206 */  _Binary_vRegF_vRegF_rule,
  /*  207 */  _Binary_vRegD_vRegD_rule,
  /*  208 */  _ConvL2I_iRegL__rule,
  /*  209 */  _ConvI2L_iRegIorL2I__rule,
  /*  210 */  _LShiftL__ConvI2L_iRegIorL2I__immIScale_rule,
  /*  211 */  _MulI_iRegIorL2I_iRegIorL2I_rule,
  /*  212 */  _SubI_immI0_iRegIorL2I_rule,
  /*  213 */  _MulL_iRegL_iRegL_rule,
  /*  214 */  _SubL_immL0_iRegL_rule,
  /*  215 */  _MulL__ConvI2L_iRegIorL2I___ConvI2L_iRegIorL2I__rule,
  /*  216 */  _SubL_immL0__ConvI2L_iRegIorL2I__rule,
  /*  217 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  218 */  _RShiftI_iRegIorL2I_immI_rule,
  /*  219 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  220 */  _URShiftL_iRegL_immI_rule,
  /*  221 */  _RShiftL_iRegL_immI_rule,
  /*  222 */  _LShiftL_iRegL_immI_rule,
  /*  223 */  _XorI_iRegIorL2I_immI_M1_rule,
  /*  224 */  _XorL_iRegL_immL_M1_rule,
  /*  225 */  _XorI_iRegIorL2I_iRegIorL2I_rule,
  /*  226 */  _XorL_iRegL_iRegL_rule,
  /*  227 */  _XorI__URShiftI_iRegIorL2I_immI_immI_M1_rule,
  /*  228 */  _XorL__URShiftL_iRegL_immI_immL_M1_rule,
  /*  229 */  _XorI__RShiftI_iRegIorL2I_immI_immI_M1_rule,
  /*  230 */  _XorL__RShiftL_iRegL_immI_immL_M1_rule,
  /*  231 */  _RotateRight_iRegIorL2I_immI_rule,
  /*  232 */  _XorI__RotateRight_iRegIorL2I_immI_immI_M1_rule,
  /*  233 */  _RotateRight_iRegL_immI_rule,
  /*  234 */  _XorL__RotateRight_iRegL_immI_immL_M1_rule,
  /*  235 */  _XorI__LShiftI_iRegIorL2I_immI_immI_M1_rule,
  /*  236 */  _XorL__LShiftL_iRegL_immI_immL_M1_rule,
  /*  237 */  _XorI__URShiftI_iRegIorL2I_immI_iRegIorL2I_rule,
  /*  238 */  _XorI_iRegIorL2I__URShiftI_iRegIorL2I_immI_rule,
  /*  239 */  _XorL__URShiftL_iRegL_immI_iRegL_rule,
  /*  240 */  _XorL_iRegL__URShiftL_iRegL_immI_rule,
  /*  241 */  _XorI__RShiftI_iRegIorL2I_immI_iRegIorL2I_rule,
  /*  242 */  _XorI_iRegIorL2I__RShiftI_iRegIorL2I_immI_rule,
  /*  243 */  _XorL__RShiftL_iRegL_immI_iRegL_rule,
  /*  244 */  _XorL_iRegL__RShiftL_iRegL_immI_rule,
  /*  245 */  _XorI__RotateRight_iRegIorL2I_immI_iRegIorL2I_rule,
  /*  246 */  _XorI_iRegIorL2I__RotateRight_iRegIorL2I_immI_rule,
  /*  247 */  _XorL__RotateRight_iRegL_immI_iRegL_rule,
  /*  248 */  _XorL_iRegL__RotateRight_iRegL_immI_rule,
  /*  249 */  _XorI__LShiftI_iRegIorL2I_immI_iRegIorL2I_rule,
  /*  250 */  _XorI_iRegIorL2I__LShiftI_iRegIorL2I_immI_rule,
  /*  251 */  _XorL__LShiftL_iRegL_immI_iRegL_rule,
  /*  252 */  _XorL_iRegL__LShiftL_iRegL_immI_rule,
  /*  253 */  _AndI__URShiftI_iRegIorL2I_immI_immI_bitmask_rule,
  /*  254 */  _AndI_iRegIorL2I_immI_bitmask_rule,
  /*  255 */  _AndL_iRegL_immL_bitmask_rule,
  /*  256 */  _LShiftI__AndI_iRegIorL2I_immI_bitmask_immI_rule,
  /*  257 */  _AndL_iRegL_immL_positive_bitmaskI_rule,
  /*  258 */  _LShiftL__AndL_iRegL_immL_positive_bitmaskI_immI_rule,
  /*  259 */  _ConvI2L__AndI_iRegIorL2I_immI_bitmask__rule,
  /*  260 */  _ConvL2I__AndL_iRegL_immL_positive_bitmaskI__rule,
  /*  261 */  _AndI_iRegI_immI_bitmask_rule,
  /*  262 */  _LShiftI_iRegIorL2I_immI_16_rule,
  /*  263 */  _RShiftI__LShiftI_iRegIorL2I_immI_16_immI_16_rule,
  /*  264 */  _LShiftI_iRegIorL2I_immI_24_rule,
  /*  265 */  _RShiftI__LShiftI_iRegIorL2I_immI_24_immI_24_rule,
  /*  266 */  _URShiftI__LShiftI_iRegIorL2I_immI_24_immI_24_rule,
  /*  267 */  _LShiftL_iRegL_immI_48_rule,
  /*  268 */  _RShiftL__LShiftL_iRegL_immI_48_immI_48_rule,
  /*  269 */  _LShiftL_iRegL_immI_32_rule,
  /*  270 */  _RShiftL__LShiftL_iRegL_immI_32_immI_32_rule,
  /*  271 */  _LShiftL_iRegL_immI_56_rule,
  /*  272 */  _RShiftL__LShiftL_iRegL_immI_56_immI_56_rule,
  /*  273 */  _URShiftL__LShiftL_iRegL_immI_56_immI_56_rule,
  /*  274 */  _AndI_iRegIorL2I_immI_255_rule,
  /*  275 */  _AndI_iRegIorL2I_immI_65535_rule,
  /*  276 */  _AndL_iRegL_immL_255_rule,
  /*  277 */  _AndL_iRegL_immL_65535_rule,
  /*  278 */  _AndL_iRegL_immL_4294967295_rule,
  /*  279 */  _LShiftL__RShiftL__LShiftL_iRegL_immI_56_immI_56_immIExt_rule,
  /*  280 */  _LShiftL__RShiftL__LShiftL_iRegL_immI_48_immI_48_immIExt_rule,
  /*  281 */  _LShiftL__RShiftL__LShiftL_iRegL_immI_32_immI_32_immIExt_rule,
  /*  282 */  _LShiftI__RShiftI__LShiftI_iRegIorL2I_immI_24_immI_24_immIExt_rule,
  /*  283 */  _LShiftI__RShiftI__LShiftI_iRegIorL2I_immI_16_immI_16_immIExt_rule,
  /*  284 */  _LShiftL__ConvI2L_iRegIorL2I__immIExt_rule,
  /*  285 */  _LShiftL__AndL_iRegL_immL_255_immIExt_rule,
  /*  286 */  _LShiftL__AndL_iRegL_immL_65535_immIExt_rule,
  /*  287 */  _LShiftL__AndL_iRegL_immL_4294967295_immIExt_rule,
  /*  288 */  _LShiftI__AndI_iRegIorL2I_immI_255_immIExt_rule,
  /*  289 */  _LShiftI__AndI_iRegIorL2I_immI_65535_immIExt_rule,
  /*  290 */  _NegF_vRegF__rule,
  /*  291 */  _Binary_vRegF__NegF_vRegF__rule,
  /*  292 */  _NegD_vRegD__rule,
  /*  293 */  _Binary_vRegD__NegD_vRegD__rule,
  /*  294 */  _SubF_vRegF_vRegF_rule,
  /*  295 */  _SubD_vRegD_vRegD_rule,
  /*  296 */  _OverflowMulI_iRegIorL2I_iRegIorL2I_rule,
  /*  297 */  _OverflowMulL_iRegL_iRegL_rule,
  /*  298 */  _CmpI_iRegIorL2I_immI0_rule,
  /*  299 */  _CmpL_iRegL_immL0_rule,
  /*  300 */  _CmpP_iRegP_immP0_rule,
  /*  301 */  _CmpN_iRegN_immN0_rule,
  /*  302 */  _CmpP__DecodeN_iRegN__immP0_rule,
  /*  303 */  _CmpU_iRegIorL2I_immI0_rule,
  /*  304 */  _CmpUL_iRegL_immL0_rule,
  /*  305 */  _AndL_iRegL_immL_rule,
  /*  306 */  _CmpL__AndL_iRegL_immL_immL0_rule,
  /*  307 */  _AndI_iRegIorL2I_immI_rule,
  /*  308 */  _CmpI__AndI_iRegIorL2I_immI_immI0_rule,
  /*  309 */  _AndL_iRegL_iRegL_rule,
  /*  310 */  _AndI_iRegIorL2I_iRegIorL2I_rule,
  /*  311 */  _PartialSubtypeCheck_iRegP_R4_iRegP_R0_rule,
  /*  312 */  _Binary_iRegP_R1_iRegI_R2_rule,
  /*  313 */  _Binary_iRegP_R3_iRegI_R4_rule,
  /*  314 */  _Binary_iRegP_R1_iRegI_R4_rule,
  /*  315 */  _Binary_iRegP_R3_iRegI_R2_rule,
  /*  316 */  _Binary_iRegP_R3_immI_le_4_rule,
  /*  317 */  _Binary_iRegP_R3_immI_1_rule,
  /*  318 */  _Binary_iRegP_R1_iRegP_R3_rule,
  /*  319 */  _Binary_iRegP_R1_iRegI_R3_rule,
  /*  320 */  _Binary_vReg_pRegGov_rule,
  /*  321 */  _Binary_vReg_vReg_rule,
  /*  322 */  _Replicate_immBAddSubV__rule,
  /*  323 */  _Replicate_immIAddSubV__rule,
  /*  324 */  _Replicate_immLAddSubV__rule,
  /*  325 */  _Replicate_immBLog__rule,
  /*  326 */  _Replicate_immSLog__rule,
  /*  327 */  _Replicate_immILog__rule,
  /*  328 */  _Replicate_immLLog__rule,
  /*  329 */  _XorV_vReg_vReg_rule,
  /*  330 */  _Replicate_immI_M1__rule,
  /*  331 */  _Replicate_immL_M1__rule,
  /*  332 */  _Binary_vReg__Replicate_immI_M1__rule,
  /*  333 */  _Binary_vReg__Replicate_immL_M1__rule,
  /*  334 */  _XorV_vReg__Replicate_immI_M1__rule,
  /*  335 */  _XorV__Replicate_immI_M1__vReg_rule,
  /*  336 */  _XorV_vReg__Replicate_immL_M1__rule,
  /*  337 */  _XorV__Replicate_immL_M1__vReg_rule,
  /*  338 */  _Binary_vReg__XorV_vReg__Replicate_immI_M1__rule,
  /*  339 */  _Binary_vReg__XorV__Replicate_immI_M1__vReg_rule,
  /*  340 */  _Binary_vReg__XorV_vReg__Replicate_immL_M1__rule,
  /*  341 */  _Binary_vReg__XorV__Replicate_immL_M1__vReg_rule,
  /*  342 */  _SubVF_vReg_vReg_rule,
  /*  343 */  _SubVD_vReg_vReg_rule,
  /*  344 */  _SubVF__Binary_vReg_vReg_pRegGov_rule,
  /*  345 */  _SubVD__Binary_vReg_vReg_pRegGov_rule,
  /*  346 */  _MulVB_vReg_vReg_rule,
  /*  347 */  _MulVS_vReg_vReg_rule,
  /*  348 */  _MulVI_vReg_vReg_rule,
  /*  349 */  _MulVL_vReg_vReg_rule,
  /*  350 */  _Binary_vReg__MulVB_vReg_vReg_rule,
  /*  351 */  _Binary_vReg__MulVS_vReg_vReg_rule,
  /*  352 */  _Binary_vReg__MulVI_vReg_vReg_rule,
  /*  353 */  _Binary_vReg__MulVL_vReg_vReg_rule,
  /*  354 */  _NegVF_vReg__rule,
  /*  355 */  _Binary_vReg__NegVF_vReg__rule,
  /*  356 */  _NegVD_vReg__rule,
  /*  357 */  _Binary_vReg__NegVD_vReg__rule,
  /*  358 */  _Binary__NegVF_vReg__pRegGov_rule,
  /*  359 */  _Binary__NegVD_vReg__pRegGov_rule,
  /*  360 */  _LShiftCntV_immI__rule,
  /*  361 */  _RShiftCntV_immI_positive__rule,
  /*  362 */  _RShiftVB_vReg__RShiftCntV_immI_positive__rule,
  /*  363 */  _RShiftVS_vReg__RShiftCntV_immI_positive__rule,
  /*  364 */  _RShiftVI_vReg__RShiftCntV_immI_positive__rule,
  /*  365 */  _RShiftVL_vReg__RShiftCntV_immI_positive__rule,
  /*  366 */  _URShiftVB_vReg__RShiftCntV_immI_positive__rule,
  /*  367 */  _URShiftVS_vReg__RShiftCntV_immI_positive__rule,
  /*  368 */  _URShiftVI_vReg__RShiftCntV_immI_positive__rule,
  /*  369 */  _URShiftVL_vReg__RShiftCntV_immI_positive__rule,
  /*  370 */  _Binary_vReg__LShiftCntV_immI__rule,
  /*  371 */  _Binary_vReg__RShiftCntV_immI_positive__rule,
  /*  372 */  _Binary_iRegIorL2I_vReg_rule,
  /*  373 */  _Binary_iRegL_vReg_rule,
  /*  374 */  _Binary_vRegF_vReg_rule,
  /*  375 */  _Binary_vRegD_vReg_rule,
  /*  376 */  _Binary_vReg_iRegIorL2I_rule,
  /*  377 */  _Binary_vReg_iRegL_rule,
  /*  378 */  _Binary_vReg_vRegF_rule,
  /*  379 */  _Binary_vReg_vRegD_rule,
  /*  380 */  _LoadVector_indirect__rule,
  /*  381 */  _LoadVectorMasked_vmemA_pRegGov_rule,
  /*  382 */  _VectorStoreMask_pReg_immI_gt_1_rule,
  /*  383 */  _Binary__VectorStoreMask_pReg_immI_gt_1_pRegGov_rule,
  /*  384 */  _MaskAll_immI_M1__rule,
  /*  385 */  _XorVMask_pReg__MaskAll_immI_M1__rule,
  /*  386 */  _MaskAll_immL_M1__rule,
  /*  387 */  _XorVMask_pReg__MaskAll_immL_M1__rule,
  /*  388 */  _Replicate_immI0__rule,
  /*  389 */  _Binary_vReg__Replicate_immI0__rule,
  /*  390 */  _Replicate_immL0__rule,
  /*  391 */  _Binary_vReg__Replicate_immL0__rule,
  /*  392 */  _Replicate_immF0__rule,
  /*  393 */  _Binary_vReg__Replicate_immF0__rule,
  /*  394 */  _Replicate_immD0__rule,
  /*  395 */  _Binary_vReg__Replicate_immD0__rule,
  /*  396 */  _Replicate_immI5__rule,
  /*  397 */  _Binary_vReg__Replicate_immI5__rule,
  /*  398 */  _Replicate_immIU7__rule,
  /*  399 */  _Binary_vReg__Replicate_immIU7__rule,
  /*  400 */  _Replicate_immL5__rule,
  /*  401 */  _Binary_vReg__Replicate_immL5__rule,
  /*  402 */  _Replicate_immLU7__rule,
  /*  403 */  _Binary_vReg__Replicate_immLU7__rule,
  /*  404 */  _Binary_immI_pRegGov_rule,
  /*  405 */  _VectorStoreMask_vReg_immI_gt_1_rule,
  /*  406 */  _SubL_iRegL_iRegL_rule,
  /*  407 */  _Binary_vReg__Binary_vReg_pRegGov_rule,
  // last internally defined operand
  /*  408 */  iRegINoSp_rule,
  /*  409 */  iRegLNoSp_rule,
  /*  410 */  iRegPNoSp_rule,
  /*  411 */  iRegPNoSp_rule,
  /*  412 */  iRegPNoSp_rule,
  /*  413 */  iRegPNoSp_rule,
  /*  414 */  iRegNNoSp_rule,
  /*  415 */  iRegNNoSp_rule,
  /*  416 */  iRegNNoSp_rule,
  /*  417 */  vRegF_rule,
  /*  418 */  vRegF_rule,
  /*  419 */  vRegD_rule,
  /*  420 */  vRegD_rule,
  /*  421 */  iRegINoSp_rule,
  /*  422 */  iRegINoSp_rule,
  /*  423 */  iRegINoSp_rule,
  /*  424 */  iRegINoSp_rule,
  /*  425 */  iRegPNoSp_rule,
  /*  426 */  iRegLNoSp_rule,
  /*  427 */  iRegPNoSp_rule,
  /*  428 */  iRegPNoSp_rule,
  /*  429 */  iRegI_rule,
  /*  430 */  iRegL_rule,
  /*  431 */  vRegF_rule,
  /*  432 */  vRegD_rule,
  /*  433 */  vReg_rule,
  /*  434 */  pRegGov_rule,
  /*  435 */  iRegINoSp_rule,
  /*  436 */  iRegLNoSp_rule,
  /*  437 */  vRegF_rule,
  /*  438 */  vRegD_rule,
  /*  439 */  vRegF_rule,
  /*  440 */  vRegD_rule,
  /*  441 */  iRegINoSp_rule,
  /*  442 */  vRegF_rule,
  /*  443 */  iRegLNoSp_rule,
  /*  444 */  vRegD_rule,
  /*  445 */  iRegINoSp_rule,
  /*  446 */  vRegF_rule,
  /*  447 */  iRegLNoSp_rule,
  /*  448 */  vRegD_rule,
  /*  449 */  rFlagsReg_rule,
  /*  450 */  rFlagsReg_rule,
  /*  451 */  rFlagsReg_rule,
  /*  452 */  rFlagsReg_rule,
  /*  453 */  rFlagsReg_rule,
  /*  454 */  rFlagsReg_rule,
  /*  455 */  rFlagsReg_rule,
  /*  456 */  rFlagsReg_rule,
  /*  457 */  rFlagsReg_rule,
  /*  458 */  rFlagsReg_rule,
  /*  459 */  rFlagsReg_rule,
  /*  460 */  rFlagsReg_rule,
  /*  461 */  rFlagsReg_rule,
  /*  462 */  rFlagsReg_rule,
  /*  463 */  rFlagsReg_rule,
  /*  464 */  rFlagsReg_rule,
  /*  465 */  rFlagsRegU_rule,
  /*  466 */  rFlagsRegU_rule,
  /*  467 */  rFlagsRegU_rule,
  /*  468 */  rFlagsRegU_rule,
  /*  469 */  rFlagsReg_rule,
  /*  470 */  rFlagsReg_rule,
  /*  471 */  rFlagsReg_rule,
  /*  472 */  rFlagsReg_rule,
  /*  473 */  rFlagsRegU_rule,
  /*  474 */  rFlagsRegU_rule,
  /*  475 */  rFlagsRegU_rule,
  /*  476 */  rFlagsRegU_rule,
  /*  477 */  rFlagsRegU_rule,
  /*  478 */  rFlagsRegU_rule,
  /*  479 */  rFlagsRegU_rule,
  /*  480 */  rFlagsRegU_rule,
  /*  481 */  rFlagsReg_rule,
  /*  482 */  rFlagsReg_rule,
  /*  483 */  rFlagsReg_rule,
  /*  484 */  rFlagsReg_rule,
  /*  485 */  0,
  /*  486 */  rFlagsReg_rule,
  /*  487 */  rFlagsReg_rule,
  /*  488 */  rFlagsReg_rule,
  /*  489 */  rFlagsReg_rule,
  /*  490 */  rFlagsReg_rule,
  /*  491 */  rFlagsReg_rule,
  /*  492 */  rFlagsReg_rule,
  /*  493 */  rFlagsReg_rule,
  /*  494 */  rFlagsReg_rule,
  /*  495 */  thread_RegP_rule,
  /*  496 */  vReg_rule,
  /*  497 */  vReg_rule,
  /*  498 */  vReg_rule,
  /*  499 */  vReg_rule,
  /*  500 */  vReg_rule,
  /*  501 */  vReg_rule,
  /*  502 */  vReg_rule,
  /*  503 */  vReg_rule,
  /*  504 */  vReg_rule,
  /*  505 */  vReg_rule,
  /*  506 */  vReg_rule,
  /*  507 */  vReg_rule,
  /*  508 */  vReg_rule,
  /*  509 */  vReg_rule,
  /*  510 */  vReg_rule,
  /*  511 */  vReg_rule,
  /*  512 */  vReg_rule,
  /*  513 */  vReg_rule,
  /*  514 */  vReg_rule,
  /*  515 */  vReg_rule,
  /*  516 */  vReg_rule,
  /*  517 */  vReg_rule,
  /*  518 */  vReg_rule,
  /*  519 */  vReg_rule,
  /*  520 */  vReg_rule,
  /*  521 */  vReg_rule,
  /*  522 */  vReg_rule,
  /*  523 */  vReg_rule,
  /*  524 */  vReg_rule,
  /*  525 */  vReg_rule,
  /*  526 */  vReg_rule,
  /*  527 */  vReg_rule,
  /*  528 */  vReg_rule,
  /*  529 */  vReg_rule,
  /*  530 */  vReg_rule,
  /*  531 */  vReg_rule,
  /*  532 */  vReg_rule,
  /*  533 */  vReg_rule,
  /*  534 */  vReg_rule,
  /*  535 */  vReg_rule,
  /*  536 */  vReg_rule,
  /*  537 */  vReg_rule,
  /*  538 */  vReg_rule,
  /*  539 */  vReg_rule,
  /*  540 */  pReg_rule,
  /*  541 */  pReg_rule,
  /*  542 */  pReg_rule,
  /*  543 */  iRegINoSp_rule,
  /*  544 */  iRegINoSp_rule,
  /*  545 */  iRegINoSp_rule,
  /*  546 */  iRegLNoSp_rule,
  /*  547 */  vReg_rule,
  /*  548 */  vReg_rule,
  /*  549 */  rFlagsReg_rule,
  /*  550 */  rFlagsReg_rule,
  /*  551 */  rFlagsReg_rule,
  /*  552 */  rFlagsReg_rule,
  /*  553 */  vReg_rule,
  /*  554 */  vReg_rule,
  /*  555 */  vReg_rule,
  /*  556 */  vReg_rule,
  /*  557 */  vReg_rule,
  /*  558 */  iRegINoSp_rule,
  /*  559 */  iRegLNoSp_rule,
  /*  560 */  iRegINoSp_rule,
  /*  561 */  iRegLNoSp_rule,
  /*  562 */  iRegINoSp_rule,
  /*  563 */  iRegLNoSp_rule,
  /*  564 */  iRegINoSp_rule,
  /*  565 */  iRegLNoSp_rule,
  /*  566 */  iRegINoSp_rule,
  /*  567 */  iRegLNoSp_rule,
  /*  568 */  iRegLNoSp_rule,
  /*  569 */  iRegLNoSp_rule,
  /*  570 */  iRegINoSp_rule,
  /*  571 */  iRegPNoSp_rule,
  /*  572 */  iRegNNoSp_rule,
  /*  573 */  iRegPNoSp_rule,
  /*  574 */  iRegNNoSp_rule,
  /*  575 */  vRegF_rule,
  /*  576 */  vRegD_rule,
  /*  577 */  Universe_rule,
  /*  578 */  Universe_rule,
  /*  579 */  Universe_rule,
  /*  580 */  Universe_rule,
  /*  581 */  Universe_rule,
  /*  582 */  Universe_rule,
  /*  583 */  Universe_rule,
  /*  584 */  Universe_rule,
  /*  585 */  Universe_rule,
  /*  586 */  Universe_rule,
  /*  587 */  Universe_rule,
  /*  588 */  Universe_rule,
  /*  589 */  Universe_rule,
  /*  590 */  Universe_rule,
  /*  591 */  Universe_rule,
  /*  592 */  Universe_rule,
  /*  593 */  Universe_rule,
  /*  594 */  Universe_rule,
  /*  595 */  iRegINoSp_rule,
  /*  596 */  iRegLNoSp_rule,
  /*  597 */  iRegINoSp_rule,
  /*  598 */  iRegLNoSp_rule,
  /*  599 */  iRegINoSp_rule,
  /*  600 */  iRegINoSp_rule,
  /*  601 */  iRegLNoSp_rule,
  /*  602 */  iRegLNoSp_rule,
  /*  603 */  iRegINoSp_rule,
  /*  604 */  iRegLNoSp_rule,
  /*  605 */  iRegLNoSp_rule,
  /*  606 */  iRegPNoSp_rule,
  /*  607 */  iRegNNoSp_rule,
  /*  608 */  vRegF_rule,
  /*  609 */  vRegD_rule,
  /*  610 */  Universe_rule,
  /*  611 */  Universe_rule,
  /*  612 */  Universe_rule,
  /*  613 */  Universe_rule,
  /*  614 */  Universe_rule,
  /*  615 */  Universe_rule,
  /*  616 */  Universe_rule,
  /*  617 */  Universe_rule,
  /*  618 */  Universe_rule,
  /*  619 */  Universe_rule,
  /*  620 */  Universe_rule,
  /*  621 */  Universe_rule,
  /*  622 */  Universe_rule,
  /*  623 */  Universe_rule,
  /*  624 */  Universe_rule,
  /*  625 */  Universe_rule,
  /*  626 */  Universe_rule,
  /*  627 */  iRegINoSp_rule,
  /*  628 */  iRegLNoSp_rule,
  /*  629 */  iRegINoSp_rule,
  /*  630 */  iRegINoSp_rule,
  /*  631 */  iRegINoSp_rule,
  /*  632 */  iRegINoSp_rule,
  /*  633 */  iRegINoSp_rule,
  /*  634 */  iRegINoSp_rule,
  /*  635 */  iRegP_rule,
  /*  636 */  Universe_rule,
  /*  637 */  Universe_rule,
  /*  638 */  Universe_rule,
  /*  639 */  Universe_rule,
  /*  640 */  Universe_rule,
  /*  641 */  Universe_rule,
  /*  642 */  Universe_rule,
  /*  643 */  Universe_rule,
  /*  644 */  Universe_rule,
  /*  645 */  Universe_rule,
  /*  646 */  Universe_rule,
  /*  647 */  Universe_rule,
  /*  648 */  iRegINoSp_rule,
  /*  649 */  iRegINoSp_rule,
  /*  650 */  iRegNNoSp_rule,
  /*  651 */  iRegNNoSp_rule,
  /*  652 */  iRegPNoSp_rule,
  /*  653 */  iRegPNoSp_rule,
  /*  654 */  iRegNNoSp_rule,
  /*  655 */  iRegPNoSp_rule,
  /*  656 */  iRegINoSp_rule,
  /*  657 */  iRegINoSp_rule,
  /*  658 */  iRegINoSp_rule,
  /*  659 */  iRegINoSp_rule,
  /*  660 */  iRegINoSp_rule,
  /*  661 */  iRegINoSp_rule,
  /*  662 */  iRegINoSp_rule,
  /*  663 */  iRegINoSp_rule,
  /*  664 */  iRegINoSp_rule,
  /*  665 */  iRegINoSp_rule,
  /*  666 */  iRegINoSp_rule,
  /*  667 */  iRegINoSp_rule,
  /*  668 */  iRegINoSp_rule,
  /*  669 */  iRegINoSp_rule,
  /*  670 */  iRegINoSp_rule,
  /*  671 */  iRegLNoSp_rule,
  /*  672 */  iRegNNoSp_rule,
  /*  673 */  iRegPNoSp_rule,
  /*  674 */  iRegINoSp_rule,
  /*  675 */  iRegINoSp_rule,
  /*  676 */  iRegINoSp_rule,
  /*  677 */  iRegLNoSp_rule,
  /*  678 */  iRegNNoSp_rule,
  /*  679 */  iRegPNoSp_rule,
  /*  680 */  iRegINoSp_rule,
  /*  681 */  iRegINoSp_rule,
  /*  682 */  iRegINoSp_rule,
  /*  683 */  iRegINoSp_rule,
  /*  684 */  iRegINoSp_rule,
  /*  685 */  iRegINoSp_rule,
  /*  686 */  iRegINoSp_rule,
  /*  687 */  iRegINoSp_rule,
  /*  688 */  iRegINoSp_rule,
  /*  689 */  iRegINoSp_rule,
  /*  690 */  iRegINoSp_rule,
  /*  691 */  iRegINoSp_rule,
  /*  692 */  iRegINoSp_rule,
  /*  693 */  iRegLNoSp_rule,
  /*  694 */  iRegINoSp_rule,
  /*  695 */  iRegPNoSp_rule,
  /*  696 */  iRegINoSp_rule,
  /*  697 */  iRegLNoSp_rule,
  /*  698 */  iRegINoSp_rule,
  /*  699 */  iRegPNoSp_rule,
  /*  700 */  iRegLNoSp_rule,
  /*  701 */  Universe_rule,
  /*  702 */  iRegLNoSp_rule,
  /*  703 */  Universe_rule,
  /*  704 */  iRegINoSp_rule,
  /*  705 */  Universe_rule,
  /*  706 */  iRegINoSp_rule,
  /*  707 */  Universe_rule,
  /*  708 */  iRegLNoSp_rule,
  /*  709 */  Universe_rule,
  /*  710 */  iRegLNoSp_rule,
  /*  711 */  Universe_rule,
  /*  712 */  iRegINoSp_rule,
  /*  713 */  Universe_rule,
  /*  714 */  iRegINoSp_rule,
  /*  715 */  Universe_rule,
  /*  716 */  iRegINoSp_rule,
  /*  717 */  iRegINoSp_rule,
  /*  718 */  iRegINoSp_rule,
  /*  719 */  iRegINoSp_rule,
  /*  720 */  iRegINoSp_rule,
  /*  721 */  iRegINoSp_rule,
  /*  722 */  iRegINoSp_rule,
  /*  723 */  iRegINoSp_rule,
  /*  724 */  iRegINoSp_rule,
  /*  725 */  iRegINoSp_rule,
  /*  726 */  iRegINoSp_rule,
  /*  727 */  iRegINoSp_rule,
  /*  728 */  iRegINoSp_rule,
  /*  729 */  iRegINoSp_rule,
  /*  730 */  iRegLNoSp_rule,
  /*  731 */  iRegLNoSp_rule,
  /*  732 */  iRegLNoSp_rule,
  /*  733 */  iRegLNoSp_rule,
  /*  734 */  iRegLNoSp_rule,
  /*  735 */  iRegLNoSp_rule,
  /*  736 */  iRegPNoSp_rule,
  /*  737 */  iRegPNoSp_rule,
  /*  738 */  iRegPNoSp_rule,
  /*  739 */  iRegPNoSp_rule,
  /*  740 */  iRegPNoSp_rule,
  /*  741 */  iRegPNoSp_rule,
  /*  742 */  iRegNNoSp_rule,
  /*  743 */  iRegNNoSp_rule,
  /*  744 */  iRegNNoSp_rule,
  /*  745 */  iRegNNoSp_rule,
  /*  746 */  iRegNNoSp_rule,
  /*  747 */  iRegNNoSp_rule,
  /*  748 */  vRegF_rule,
  /*  749 */  vRegF_rule,
  /*  750 */  vRegD_rule,
  /*  751 */  vRegD_rule,
  /*  752 */  iRegINoSp_rule,
  /*  753 */  iRegINoSp_rule,
  /*  754 */  iRegINoSp_rule,
  /*  755 */  iRegPNoSp_rule,
  /*  756 */  iRegPNoSp_rule,
  /*  757 */  iRegPNoSp_rule,
  /*  758 */  iRegPNoSp_rule,
  /*  759 */  iRegLNoSp_rule,
  /*  760 */  iRegPNoSp_rule,
  /*  761 */  iRegLNoSp_rule,
  /*  762 */  iRegLNoSp_rule,
  /*  763 */  iRegINoSp_rule,
  /*  764 */  iRegINoSp_rule,
  /*  765 */  iRegLNoSp_rule,
  /*  766 */  iRegLNoSp_rule,
  /*  767 */  iRegINoSp_rule,
  /*  768 */  iRegLNoSp_rule,
  /*  769 */  iRegINoSp_rule,
  /*  770 */  iRegLNoSp_rule,
  /*  771 */  iRegLNoSp_rule,
  /*  772 */  iRegLNoSp_rule,
  /*  773 */  iRegLNoSp_rule,
  /*  774 */  iRegLNoSp_rule,
  /*  775 */  iRegINoSp_rule,
  /*  776 */  iRegINoSp_rule,
  /*  777 */  iRegINoSp_rule,
  /*  778 */  iRegINoSp_rule,
  /*  779 */  iRegINoSp_rule,
  /*  780 */  iRegLNoSp_rule,
  /*  781 */  iRegLNoSp_rule,
  /*  782 */  iRegLNoSp_rule,
  /*  783 */  iRegLNoSp_rule,
  /*  784 */  iRegLNoSp_rule,
  /*  785 */  iRegLNoSp_rule,
  /*  786 */  iRegLNoSp_rule,
  /*  787 */  iRegLNoSp_rule,
  /*  788 */  iRegLNoSp_rule,
  /*  789 */  iRegLNoSp_rule,
  /*  790 */  iRegLNoSp_rule,
  /*  791 */  iRegLNoSp_rule,
  /*  792 */  iRegLNoSp_rule,
  /*  793 */  iRegINoSp_rule,
  /*  794 */  iRegINoSp_rule,
  /*  795 */  iRegLNoSp_rule,
  /*  796 */  iRegINoSp_rule,
  /*  797 */  iRegLNoSp_rule,
  /*  798 */  iRegINoSp_rule,
  /*  799 */  iRegLNoSp_rule,
  /*  800 */  iRegINoSp_rule,
  /*  801 */  iRegLNoSp_rule,
  /*  802 */  iRegINoSp_rule,
  /*  803 */  iRegINoSp_rule,
  /*  804 */  iRegINoSp_rule,
  /*  805 */  iRegINoSp_rule,
  /*  806 */  iRegINoSp_rule,
  /*  807 */  iRegINoSp_rule,
  /*  808 */  iRegLNoSp_rule,
  /*  809 */  iRegLNoSp_rule,
  /*  810 */  iRegLNoSp_rule,
  /*  811 */  iRegLNoSp_rule,
  /*  812 */  iRegLNoSp_rule,
  /*  813 */  iRegLNoSp_rule,
  /*  814 */  iRegLNoSp_rule,
  /*  815 */  iRegLNoSp_rule,
  /*  816 */  iRegINoSp_rule,
  /*  817 */  iRegINoSp_rule,
  /*  818 */  iRegINoSp_rule,
  /*  819 */  iRegINoSp_rule,
  /*  820 */  iRegLNoSp_rule,
  /*  821 */  iRegLNoSp_rule,
  /*  822 */  iRegLNoSp_rule,
  /*  823 */  iRegINoSp_rule,
  /*  824 */  iRegINoSp_rule,
  /*  825 */  iRegLNoSp_rule,
  /*  826 */  iRegLNoSp_rule,
  /*  827 */  iRegINoSp_rule,
  /*  828 */  iRegINoSp_rule,
  /*  829 */  iRegLNoSp_rule,
  /*  830 */  iRegLNoSp_rule,
  /*  831 */  iRegINoSp_rule,
  /*  832 */  iRegINoSp_rule,
  /*  833 */  iRegLNoSp_rule,
  /*  834 */  iRegLNoSp_rule,
  /*  835 */  iRegINoSp_rule,
  /*  836 */  iRegINoSp_rule,
  /*  837 */  iRegLNoSp_rule,
  /*  838 */  iRegLNoSp_rule,
  /*  839 */  iRegINoSp_rule,
  /*  840 */  iRegINoSp_rule,
  /*  841 */  iRegLNoSp_rule,
  /*  842 */  iRegLNoSp_rule,
  /*  843 */  iRegINoSp_rule,
  /*  844 */  iRegINoSp_rule,
  /*  845 */  iRegLNoSp_rule,
  /*  846 */  iRegLNoSp_rule,
  /*  847 */  iRegINoSp_rule,
  /*  848 */  iRegINoSp_rule,
  /*  849 */  iRegLNoSp_rule,
  /*  850 */  iRegLNoSp_rule,
  /*  851 */  iRegINoSp_rule,
  /*  852 */  iRegINoSp_rule,
  /*  853 */  iRegINoSp_rule,
  /*  854 */  iRegINoSp_rule,
  /*  855 */  iRegLNoSp_rule,
  /*  856 */  iRegLNoSp_rule,
  /*  857 */  iRegLNoSp_rule,
  /*  858 */  iRegLNoSp_rule,
  /*  859 */  iRegINoSp_rule,
  /*  860 */  iRegINoSp_rule,
  /*  861 */  iRegINoSp_rule,
  /*  862 */  iRegINoSp_rule,
  /*  863 */  iRegLNoSp_rule,
  /*  864 */  iRegLNoSp_rule,
  /*  865 */  iRegLNoSp_rule,
  /*  866 */  iRegLNoSp_rule,
  /*  867 */  iRegINoSp_rule,
  /*  868 */  iRegINoSp_rule,
  /*  869 */  iRegINoSp_rule,
  /*  870 */  iRegINoSp_rule,
  /*  871 */  iRegLNoSp_rule,
  /*  872 */  iRegLNoSp_rule,
  /*  873 */  iRegLNoSp_rule,
  /*  874 */  iRegLNoSp_rule,
  /*  875 */  iRegINoSp_rule,
  /*  876 */  iRegINoSp_rule,
  /*  877 */  iRegINoSp_rule,
  /*  878 */  iRegINoSp_rule,
  /*  879 */  iRegLNoSp_rule,
  /*  880 */  iRegLNoSp_rule,
  /*  881 */  iRegLNoSp_rule,
  /*  882 */  iRegLNoSp_rule,
  /*  883 */  iRegINoSp_rule,
  /*  884 */  iRegINoSp_rule,
  /*  885 */  iRegLNoSp_rule,
  /*  886 */  iRegLNoSp_rule,
  /*  887 */  iRegINoSp_rule,
  /*  888 */  iRegINoSp_rule,
  /*  889 */  iRegLNoSp_rule,
  /*  890 */  iRegLNoSp_rule,
  /*  891 */  iRegINoSp_rule,
  /*  892 */  iRegINoSp_rule,
  /*  893 */  iRegLNoSp_rule,
  /*  894 */  iRegLNoSp_rule,
  /*  895 */  iRegINoSp_rule,
  /*  896 */  iRegINoSp_rule,
  /*  897 */  iRegLNoSp_rule,
  /*  898 */  iRegLNoSp_rule,
  /*  899 */  iRegINoSp_rule,
  /*  900 */  iRegINoSp_rule,
  /*  901 */  iRegLNoSp_rule,
  /*  902 */  iRegLNoSp_rule,
  /*  903 */  iRegINoSp_rule,
  /*  904 */  iRegINoSp_rule,
  /*  905 */  iRegLNoSp_rule,
  /*  906 */  iRegLNoSp_rule,
  /*  907 */  iRegINoSp_rule,
  /*  908 */  iRegINoSp_rule,
  /*  909 */  iRegLNoSp_rule,
  /*  910 */  iRegLNoSp_rule,
  /*  911 */  iRegINoSp_rule,
  /*  912 */  iRegINoSp_rule,
  /*  913 */  iRegLNoSp_rule,
  /*  914 */  iRegLNoSp_rule,
  /*  915 */  iRegINoSp_rule,
  /*  916 */  iRegINoSp_rule,
  /*  917 */  iRegLNoSp_rule,
  /*  918 */  iRegLNoSp_rule,
  /*  919 */  iRegINoSp_rule,
  /*  920 */  iRegINoSp_rule,
  /*  921 */  iRegLNoSp_rule,
  /*  922 */  iRegLNoSp_rule,
  /*  923 */  iRegINoSp_rule,
  /*  924 */  iRegINoSp_rule,
  /*  925 */  iRegLNoSp_rule,
  /*  926 */  iRegLNoSp_rule,
  /*  927 */  iRegINoSp_rule,
  /*  928 */  iRegINoSp_rule,
  /*  929 */  iRegLNoSp_rule,
  /*  930 */  iRegLNoSp_rule,
  /*  931 */  iRegINoSp_rule,
  /*  932 */  iRegINoSp_rule,
  /*  933 */  iRegLNoSp_rule,
  /*  934 */  iRegLNoSp_rule,
  /*  935 */  iRegINoSp_rule,
  /*  936 */  iRegINoSp_rule,
  /*  937 */  iRegLNoSp_rule,
  /*  938 */  iRegLNoSp_rule,
  /*  939 */  iRegINoSp_rule,
  /*  940 */  iRegINoSp_rule,
  /*  941 */  iRegLNoSp_rule,
  /*  942 */  iRegLNoSp_rule,
  /*  943 */  iRegINoSp_rule,
  /*  944 */  iRegINoSp_rule,
  /*  945 */  iRegLNoSp_rule,
  /*  946 */  iRegLNoSp_rule,
  /*  947 */  iRegINoSp_rule,
  /*  948 */  iRegINoSp_rule,
  /*  949 */  iRegLNoSp_rule,
  /*  950 */  iRegLNoSp_rule,
  /*  951 */  iRegINoSp_rule,
  /*  952 */  iRegINoSp_rule,
  /*  953 */  iRegLNoSp_rule,
  /*  954 */  iRegLNoSp_rule,
  /*  955 */  iRegINoSp_rule,
  /*  956 */  iRegINoSp_rule,
  /*  957 */  iRegLNoSp_rule,
  /*  958 */  iRegLNoSp_rule,
  /*  959 */  iRegINoSp_rule,
  /*  960 */  iRegLNoSp_rule,
  /*  961 */  iRegINoSp_rule,
  /*  962 */  iRegLNoSp_rule,
  /*  963 */  iRegINoSp_rule,
  /*  964 */  iRegLNoSp_rule,
  /*  965 */  iRegLNoSp_rule,
  /*  966 */  iRegINoSp_rule,
  /*  967 */  iRegLNoSp_rule,
  /*  968 */  iRegINoSp_rule,
  /*  969 */  iRegINoSp_rule,
  /*  970 */  iRegLNoSp_rule,
  /*  971 */  iRegLNoSp_rule,
  /*  972 */  iRegINoSp_rule,
  /*  973 */  iRegLNoSp_rule,
  /*  974 */  iRegLNoSp_rule,
  /*  975 */  iRegINoSp_rule,
  /*  976 */  iRegLNoSp_rule,
  /*  977 */  iRegINoSp_rule,
  /*  978 */  iRegLNoSp_rule,
  /*  979 */  iRegLNoSp_rule,
  /*  980 */  iRegLNoSp_rule,
  /*  981 */  iRegINoSp_rule,
  /*  982 */  iRegINoSp_rule,
  /*  983 */  iRegLNoSp_rule,
  /*  984 */  iRegLNoSp_rule,
  /*  985 */  iRegINoSp_rule,
  /*  986 */  iRegINoSp_rule,
  /*  987 */  iRegINoSp_rule,
  /*  988 */  iRegLNoSp_rule,
  /*  989 */  iRegINoSp_rule,
  /*  990 */  iRegLNoSp_rule,
  /*  991 */  iRegINoSp_rule,
  /*  992 */  iRegLNoSp_rule,
  /*  993 */  iRegLNoSp_rule,
  /*  994 */  iRegLNoSp_rule,
  /*  995 */  iRegLNoSp_rule,
  /*  996 */  iRegINoSp_rule,
  /*  997 */  iRegINoSp_rule,
  /*  998 */  iRegINoSp_rule,
  /*  999 */  iRegINoSp_rule,
  /* 1000 */  iRegINoSp_rule,
  /* 1001 */  iRegINoSp_rule,
  /* 1002 */  iRegLNoSp_rule,
  /* 1003 */  iRegLNoSp_rule,
  /* 1004 */  iRegLNoSp_rule,
  /* 1005 */  iRegLNoSp_rule,
  /* 1006 */  iRegLNoSp_rule,
  /* 1007 */  iRegLNoSp_rule,
  /* 1008 */  iRegLNoSp_rule,
  /* 1009 */  iRegLNoSp_rule,
  /* 1010 */  iRegINoSp_rule,
  /* 1011 */  iRegINoSp_rule,
  /* 1012 */  iRegINoSp_rule,
  /* 1013 */  iRegINoSp_rule,
  /* 1014 */  iRegLNoSp_rule,
  /* 1015 */  iRegLNoSp_rule,
  /* 1016 */  iRegLNoSp_rule,
  /* 1017 */  iRegLNoSp_rule,
  /* 1018 */  iRegLNoSp_rule,
  /* 1019 */  iRegLNoSp_rule,
  /* 1020 */  iRegINoSp_rule,
  /* 1021 */  iRegINoSp_rule,
  /* 1022 */  iRegLNoSp_rule,
  /* 1023 */  iRegLNoSp_rule,
  /* 1024 */  iRegLNoSp_rule,
  /* 1025 */  iRegLNoSp_rule,
  /* 1026 */  iRegLNoSp_rule,
  /* 1027 */  iRegLNoSp_rule,
  /* 1028 */  iRegLNoSp_rule,
  /* 1029 */  iRegLNoSp_rule,
  /* 1030 */  iRegLNoSp_rule,
  /* 1031 */  iRegLNoSp_rule,
  /* 1032 */  iRegLNoSp_rule,
  /* 1033 */  iRegLNoSp_rule,
  /* 1034 */  iRegINoSp_rule,
  /* 1035 */  iRegINoSp_rule,
  /* 1036 */  iRegINoSp_rule,
  /* 1037 */  iRegINoSp_rule,
  /* 1038 */  iRegINoSp_rule,
  /* 1039 */  iRegINoSp_rule,
  /* 1040 */  iRegLNoSp_rule,
  /* 1041 */  iRegLNoSp_rule,
  /* 1042 */  iRegLNoSp_rule,
  /* 1043 */  iRegLNoSp_rule,
  /* 1044 */  iRegLNoSp_rule,
  /* 1045 */  iRegLNoSp_rule,
  /* 1046 */  iRegLNoSp_rule,
  /* 1047 */  iRegLNoSp_rule,
  /* 1048 */  iRegLNoSp_rule,
  /* 1049 */  iRegLNoSp_rule,
  /* 1050 */  iRegLNoSp_rule,
  /* 1051 */  iRegLNoSp_rule,
  /* 1052 */  iRegINoSp_rule,
  /* 1053 */  iRegINoSp_rule,
  /* 1054 */  iRegINoSp_rule,
  /* 1055 */  iRegINoSp_rule,
  /* 1056 */  iRegINoSp_rule,
  /* 1057 */  iRegINoSp_rule,
  /* 1058 */  0,
  /* 1059 */  0,
  /* 1060 */  0,
  /* 1061 */  0,
  /* 1062 */  0,
  /* 1063 */  0,
  /* 1064 */  0,
  /* 1065 */  0,
  /* 1066 */  iRegINoSp_rule,
  /* 1067 */  iRegINoSp_rule,
  /* 1068 */  iRegINoSp_rule,
  /* 1069 */  iRegINoSp_rule,
  /* 1070 */  iRegINoSp_rule,
  /* 1071 */  iRegINoSp_rule,
  /* 1072 */  iRegINoSp_rule,
  /* 1073 */  iRegINoSp_rule,
  /* 1074 */  iRegINoSp_rule,
  /* 1075 */  iRegINoSp_rule,
  /* 1076 */  iRegINoSp_rule,
  /* 1077 */  iRegINoSp_rule,
  /* 1078 */  vRegF_rule,
  /* 1079 */  vRegD_rule,
  /* 1080 */  vRegF_rule,
  /* 1081 */  vRegD_rule,
  /* 1082 */  vRegF_rule,
  /* 1083 */  vRegD_rule,
  /* 1084 */  vRegF_rule,
  /* 1085 */  vRegD_rule,
  /* 1086 */  vRegF_rule,
  /* 1087 */  vRegD_rule,
  /* 1088 */  vRegF_rule,
  /* 1089 */  vRegD_rule,
  /* 1090 */  vRegF_rule,
  /* 1091 */  vRegD_rule,
  /* 1092 */  vRegF_rule,
  /* 1093 */  vRegF_rule,
  /* 1094 */  vRegD_rule,
  /* 1095 */  vRegD_rule,
  /* 1096 */  vRegF_rule,
  /* 1097 */  vRegD_rule,
  /* 1098 */  iRegINoSp_rule,
  /* 1099 */  iRegLNoSp_rule,
  /* 1100 */  vRegF_rule,
  /* 1101 */  vRegD_rule,
  /* 1102 */  vRegD_rule,
  /* 1103 */  vRegF_rule,
  /* 1104 */  vRegD_rule,
  /* 1105 */  vRegD_rule,
  /* 1106 */  vRegF_rule,
  /* 1107 */  vRegD_rule,
  /* 1108 */  vRegF_rule,
  /* 1109 */  Universe_rule,
  /* 1110 */  iRegINoSp_rule,
  /* 1111 */  iRegINoSp_rule,
  /* 1112 */  iRegINoSp_rule,
  /* 1113 */  iRegINoSp_rule,
  /* 1114 */  iRegINoSp_rule,
  /* 1115 */  iRegINoSp_rule,
  /* 1116 */  iRegLNoSp_rule,
  /* 1117 */  iRegLNoSp_rule,
  /* 1118 */  iRegLNoSp_rule,
  /* 1119 */  iRegLNoSp_rule,
  /* 1120 */  iRegLNoSp_rule,
  /* 1121 */  iRegLNoSp_rule,
  /* 1122 */  iRegLNoSp_rule,
  /* 1123 */  iRegLNoSp_rule,
  /* 1124 */  iRegINoSp_rule,
  /* 1125 */  vRegF_rule,
  /* 1126 */  vRegD_rule,
  /* 1127 */  iRegINoSp_rule,
  /* 1128 */  iRegLNoSp_rule,
  /* 1129 */  iRegINoSp_rule,
  /* 1130 */  vRegF_rule,
  /* 1131 */  vRegF_rule,
  /* 1132 */  vRegF_rule,
  /* 1133 */  iRegINoSp_rule,
  /* 1134 */  iRegLNoSp_rule,
  /* 1135 */  vRegD_rule,
  /* 1136 */  vRegD_rule,
  /* 1137 */  iRegLNoSp_rule,
  /* 1138 */  iRegINoSp_rule,
  /* 1139 */  stackSlotI_rule,
  /* 1140 */  stackSlotF_rule,
  /* 1141 */  stackSlotL_rule,
  /* 1142 */  stackSlotD_rule,
  /* 1143 */  Universe_rule,
  /* 1144 */  Universe_rule,
  /* 1145 */  Universe_rule,
  /* 1146 */  Universe_rule,
  /* 1147 */  iRegINoSp_rule,
  /* 1148 */  iRegINoSp_rule,
  /* 1149 */  iRegINoSp_rule,
  /* 1150 */  iRegINoSp_rule,
  /* 1151 */  iRegINoSp_rule,
  /* 1152 */  iRegINoSp_rule,
  /* 1153 */  iRegINoSp_rule,
  /* 1154 */  iRegINoSp_rule,
  /* 1155 */  Universe_rule,
  /* 1156 */  Universe_rule,
  /* 1157 */  Universe_rule,
  /* 1158 */  Universe_rule,
  /* 1159 */  Universe_rule,
  /* 1160 */  Universe_rule,
  /* 1161 */  Universe_rule,
  /* 1162 */  Universe_rule,
  /* 1163 */  Universe_rule,
  /* 1164 */  Universe_rule,
  /* 1165 */  Universe_rule,
  /* 1166 */  Universe_rule,
  /* 1167 */  Universe_rule,
  /* 1168 */  Universe_rule,
  /* 1169 */  Universe_rule,
  /* 1170 */  Universe_rule,
  /* 1171 */  Universe_rule,
  /* 1172 */  Universe_rule,
  /* 1173 */  Universe_rule,
  /* 1174 */  Universe_rule,
  /* 1175 */  Universe_rule,
  /* 1176 */  Universe_rule,
  /* 1177 */  Universe_rule,
  /* 1178 */  Universe_rule,
  /* 1179 */  Universe_rule,
  /* 1180 */  Universe_rule,
  /* 1181 */  Universe_rule,
  /* 1182 */  iRegP_R0_rule,
  /* 1183 */  Universe_rule,
  /* 1184 */  Universe_rule,
  /* 1185 */  Universe_rule,
  /* 1186 */  iRegP_R5_rule,
  /* 1187 */  iRegI_R0_rule,
  /* 1188 */  iRegI_R0_rule,
  /* 1189 */  iRegI_R0_rule,
  /* 1190 */  iRegI_R0_rule,
  /* 1191 */  iRegI_R0_rule,
  /* 1192 */  iRegI_R0_rule,
  /* 1193 */  iRegI_R0_rule,
  /* 1194 */  iRegI_R0_rule,
  /* 1195 */  iRegI_R0_rule,
  /* 1196 */  iRegI_R0_rule,
  /* 1197 */  iRegI_R0_rule,
  /* 1198 */  iRegI_R0_rule,
  /* 1199 */  iRegI_R0_rule,
  /* 1200 */  iRegI_R0_rule,
  /* 1201 */  iRegI_R0_rule,
  /* 1202 */  iRegI_R0_rule,
  /* 1203 */  iRegI_R0_rule,
  /* 1204 */  iRegI_R0_rule,
  /* 1205 */  iRegI_R0_rule,
  /* 1206 */  iRegI_R0_rule,
  /* 1207 */  iRegI_R0_rule,
  /* 1208 */  iRegI_R0_rule,
  /* 1209 */  iRegI_R0_rule,
  /* 1210 */  Universe_rule,
  /* 1211 */  iRegI_R0_rule,
  /* 1212 */  iRegI_R0_rule,
  /* 1213 */  iRegINoSp_rule,
  /* 1214 */  iRegINoSp_rule,
  /* 1215 */  iRegLNoSp_rule,
  /* 1216 */  iRegLNoSp_rule,
  /* 1217 */  iRegINoSp_rule,
  /* 1218 */  iRegINoSp_rule,
  /* 1219 */  iRegLNoSp_rule,
  /* 1220 */  iRegINoSp_rule,
  /* 1221 */  vReg_rule,
  /* 1222 */  Universe_rule,
  /* 1223 */  vReg_rule,
  /* 1224 */  Universe_rule,
  /* 1225 */  vReg_rule,
  /* 1226 */  Universe_rule,
  /* 1227 */  vReg_rule,
  /* 1228 */  Universe_rule,
  /* 1229 */  vReg_rule,
  /* 1230 */  Universe_rule,
  /* 1231 */  vReg_rule,
  /* 1232 */  Universe_rule,
  /* 1233 */  vReg_rule,
  /* 1234 */  vReg_rule,
  /* 1235 */  vReg_rule,
  /* 1236 */  vReg_rule,
  /* 1237 */  vReg_rule,
  /* 1238 */  vReg_rule,
  /* 1239 */  vReg_rule,
  /* 1240 */  vReg_rule,
  /* 1241 */  vReg_rule,
  /* 1242 */  vReg_rule,
  /* 1243 */  vReg_rule,
  /* 1244 */  vReg_rule,
  /* 1245 */  vReg_rule,
  /* 1246 */  vReg_rule,
  /* 1247 */  vReg_rule,
  /* 1248 */  vReg_rule,
  /* 1249 */  vReg_rule,
  /* 1250 */  vReg_rule,
  /* 1251 */  vReg_rule,
  /* 1252 */  vReg_rule,
  /* 1253 */  vReg_rule,
  /* 1254 */  vReg_rule,
  /* 1255 */  vReg_rule,
  /* 1256 */  vReg_rule,
  /* 1257 */  vReg_rule,
  /* 1258 */  vReg_rule,
  /* 1259 */  vReg_rule,
  /* 1260 */  vReg_rule,
  /* 1261 */  vReg_rule,
  /* 1262 */  vReg_rule,
  /* 1263 */  vReg_rule,
  /* 1264 */  vReg_rule,
  /* 1265 */  vReg_rule,
  /* 1266 */  vReg_rule,
  /* 1267 */  vReg_rule,
  /* 1268 */  vReg_rule,
  /* 1269 */  vReg_rule,
  /* 1270 */  vReg_rule,
  /* 1271 */  vReg_rule,
  /* 1272 */  vReg_rule,
  /* 1273 */  vReg_rule,
  /* 1274 */  vReg_rule,
  /* 1275 */  vReg_rule,
  /* 1276 */  vReg_rule,
  /* 1277 */  vReg_rule,
  /* 1278 */  vReg_rule,
  /* 1279 */  vReg_rule,
  /* 1280 */  vReg_rule,
  /* 1281 */  vReg_rule,
  /* 1282 */  vReg_rule,
  /* 1283 */  vReg_rule,
  /* 1284 */  vReg_rule,
  /* 1285 */  vReg_rule,
  /* 1286 */  vReg_rule,
  /* 1287 */  vReg_rule,
  /* 1288 */  vReg_rule,
  /* 1289 */  vReg_rule,
  /* 1290 */  vReg_rule,
  /* 1291 */  vReg_rule,
  /* 1292 */  vReg_rule,
  /* 1293 */  vReg_rule,
  /* 1294 */  vReg_rule,
  /* 1295 */  vReg_rule,
  /* 1296 */  vReg_rule,
  /* 1297 */  vReg_rule,
  /* 1298 */  vReg_rule,
  /* 1299 */  vReg_rule,
  /* 1300 */  vReg_rule,
  /* 1301 */  vReg_rule,
  /* 1302 */  vReg_rule,
  /* 1303 */  vReg_rule,
  /* 1304 */  vReg_rule,
  /* 1305 */  vReg_rule,
  /* 1306 */  vReg_rule,
  /* 1307 */  vReg_rule,
  /* 1308 */  vReg_rule,
  /* 1309 */  vReg_rule,
  /* 1310 */  vReg_rule,
  /* 1311 */  vReg_rule,
  /* 1312 */  vReg_rule,
  /* 1313 */  vReg_rule,
  /* 1314 */  vReg_rule,
  /* 1315 */  vReg_rule,
  /* 1316 */  vReg_rule,
  /* 1317 */  vReg_rule,
  /* 1318 */  vReg_rule,
  /* 1319 */  vReg_rule,
  /* 1320 */  vReg_rule,
  /* 1321 */  vReg_rule,
  /* 1322 */  vReg_rule,
  /* 1323 */  vReg_rule,
  /* 1324 */  vReg_rule,
  /* 1325 */  vReg_rule,
  /* 1326 */  vReg_rule,
  /* 1327 */  vReg_rule,
  /* 1328 */  vReg_rule,
  /* 1329 */  vReg_rule,
  /* 1330 */  vReg_rule,
  /* 1331 */  vReg_rule,
  /* 1332 */  vReg_rule,
  /* 1333 */  vReg_rule,
  /* 1334 */  vReg_rule,
  /* 1335 */  vReg_rule,
  /* 1336 */  vReg_rule,
  /* 1337 */  vReg_rule,
  /* 1338 */  vReg_rule,
  /* 1339 */  vReg_rule,
  /* 1340 */  vReg_rule,
  /* 1341 */  vReg_rule,
  /* 1342 */  vReg_rule,
  /* 1343 */  vReg_rule,
  /* 1344 */  vReg_rule,
  /* 1345 */  vReg_rule,
  /* 1346 */  vReg_rule,
  /* 1347 */  vReg_rule,
  /* 1348 */  vReg_rule,
  /* 1349 */  vReg_rule,
  /* 1350 */  vReg_rule,
  /* 1351 */  vReg_rule,
  /* 1352 */  vReg_rule,
  /* 1353 */  vReg_rule,
  /* 1354 */  vReg_rule,
  /* 1355 */  vReg_rule,
  /* 1356 */  vReg_rule,
  /* 1357 */  vReg_rule,
  /* 1358 */  vReg_rule,
  /* 1359 */  vReg_rule,
  /* 1360 */  vReg_rule,
  /* 1361 */  vReg_rule,
  /* 1362 */  vReg_rule,
  /* 1363 */  vReg_rule,
  /* 1364 */  vReg_rule,
  /* 1365 */  vReg_rule,
  /* 1366 */  vReg_rule,
  /* 1367 */  vReg_rule,
  /* 1368 */  vReg_rule,
  /* 1369 */  vReg_rule,
  /* 1370 */  vReg_rule,
  /* 1371 */  vReg_rule,
  /* 1372 */  vReg_rule,
  /* 1373 */  vReg_rule,
  /* 1374 */  vReg_rule,
  /* 1375 */  vReg_rule,
  /* 1376 */  vReg_rule,
  /* 1377 */  vReg_rule,
  /* 1378 */  vReg_rule,
  /* 1379 */  vReg_rule,
  /* 1380 */  vReg_rule,
  /* 1381 */  vReg_rule,
  /* 1382 */  vReg_rule,
  /* 1383 */  vReg_rule,
  /* 1384 */  vReg_rule,
  /* 1385 */  vReg_rule,
  /* 1386 */  vReg_rule,
  /* 1387 */  vReg_rule,
  /* 1388 */  vReg_rule,
  /* 1389 */  vReg_rule,
  /* 1390 */  vReg_rule,
  /* 1391 */  vReg_rule,
  /* 1392 */  vReg_rule,
  /* 1393 */  vReg_rule,
  /* 1394 */  vReg_rule,
  /* 1395 */  vReg_rule,
  /* 1396 */  vReg_rule,
  /* 1397 */  vReg_rule,
  /* 1398 */  vReg_rule,
  /* 1399 */  vReg_rule,
  /* 1400 */  vReg_rule,
  /* 1401 */  vReg_rule,
  /* 1402 */  vReg_rule,
  /* 1403 */  vReg_rule,
  /* 1404 */  vReg_rule,
  /* 1405 */  vReg_rule,
  /* 1406 */  vReg_rule,
  /* 1407 */  vReg_rule,
  /* 1408 */  vReg_rule,
  /* 1409 */  vReg_rule,
  /* 1410 */  vReg_rule,
  /* 1411 */  vReg_rule,
  /* 1412 */  vReg_rule,
  /* 1413 */  vReg_rule,
  /* 1414 */  vReg_rule,
  /* 1415 */  vReg_rule,
  /* 1416 */  vReg_rule,
  /* 1417 */  vReg_rule,
  /* 1418 */  vReg_rule,
  /* 1419 */  vReg_rule,
  /* 1420 */  vReg_rule,
  /* 1421 */  vReg_rule,
  /* 1422 */  vReg_rule,
  /* 1423 */  vReg_rule,
  /* 1424 */  vReg_rule,
  /* 1425 */  vReg_rule,
  /* 1426 */  vReg_rule,
  /* 1427 */  vReg_rule,
  /* 1428 */  vReg_rule,
  /* 1429 */  vReg_rule,
  /* 1430 */  vReg_rule,
  /* 1431 */  vReg_rule,
  /* 1432 */  vReg_rule,
  /* 1433 */  vReg_rule,
  /* 1434 */  vReg_rule,
  /* 1435 */  vReg_rule,
  /* 1436 */  vReg_rule,
  /* 1437 */  vReg_rule,
  /* 1438 */  vReg_rule,
  /* 1439 */  vReg_rule,
  /* 1440 */  vReg_rule,
  /* 1441 */  vReg_rule,
  /* 1442 */  vReg_rule,
  /* 1443 */  vReg_rule,
  /* 1444 */  vReg_rule,
  /* 1445 */  vReg_rule,
  /* 1446 */  vReg_rule,
  /* 1447 */  vReg_rule,
  /* 1448 */  vReg_rule,
  /* 1449 */  vReg_rule,
  /* 1450 */  vReg_rule,
  /* 1451 */  vReg_rule,
  /* 1452 */  vReg_rule,
  /* 1453 */  vReg_rule,
  /* 1454 */  vReg_rule,
  /* 1455 */  vReg_rule,
  /* 1456 */  vReg_rule,
  /* 1457 */  vReg_rule,
  /* 1458 */  vReg_rule,
  /* 1459 */  vReg_rule,
  /* 1460 */  vReg_rule,
  /* 1461 */  vReg_rule,
  /* 1462 */  vReg_rule,
  /* 1463 */  vReg_rule,
  /* 1464 */  vReg_rule,
  /* 1465 */  vReg_rule,
  /* 1466 */  vReg_rule,
  /* 1467 */  vReg_rule,
  /* 1468 */  vReg_rule,
  /* 1469 */  vReg_rule,
  /* 1470 */  vReg_rule,
  /* 1471 */  vReg_rule,
  /* 1472 */  vReg_rule,
  /* 1473 */  vReg_rule,
  /* 1474 */  vReg_rule,
  /* 1475 */  vReg_rule,
  /* 1476 */  vReg_rule,
  /* 1477 */  vReg_rule,
  /* 1478 */  vReg_rule,
  /* 1479 */  vReg_rule,
  /* 1480 */  vReg_rule,
  /* 1481 */  vReg_rule,
  /* 1482 */  vReg_rule,
  /* 1483 */  vReg_rule,
  /* 1484 */  vReg_rule,
  /* 1485 */  vReg_rule,
  /* 1486 */  vReg_rule,
  /* 1487 */  vReg_rule,
  /* 1488 */  iRegINoSp_rule,
  /* 1489 */  iRegINoSp_rule,
  /* 1490 */  iRegLNoSp_rule,
  /* 1491 */  iRegLNoSp_rule,
  /* 1492 */  vRegF_rule,
  /* 1493 */  vRegF_rule,
  /* 1494 */  vRegF_rule,
  /* 1495 */  vRegD_rule,
  /* 1496 */  vRegD_rule,
  /* 1497 */  iRegINoSp_rule,
  /* 1498 */  iRegLNoSp_rule,
  /* 1499 */  vRegF_rule,
  /* 1500 */  vRegD_rule,
  /* 1501 */  iRegINoSp_rule,
  /* 1502 */  iRegLNoSp_rule,
  /* 1503 */  vRegF_rule,
  /* 1504 */  vRegD_rule,
  /* 1505 */  iRegINoSp_rule,
  /* 1506 */  iRegINoSp_rule,
  /* 1507 */  iRegLNoSp_rule,
  /* 1508 */  iRegLNoSp_rule,
  /* 1509 */  iRegINoSp_rule,
  /* 1510 */  iRegLNoSp_rule,
  /* 1511 */  iRegINoSp_rule,
  /* 1512 */  iRegINoSp_rule,
  /* 1513 */  iRegLNoSp_rule,
  /* 1514 */  iRegLNoSp_rule,
  /* 1515 */  iRegINoSp_rule,
  /* 1516 */  iRegLNoSp_rule,
  /* 1517 */  iRegINoSp_rule,
  /* 1518 */  iRegINoSp_rule,
  /* 1519 */  iRegLNoSp_rule,
  /* 1520 */  iRegLNoSp_rule,
  /* 1521 */  iRegINoSp_rule,
  /* 1522 */  iRegLNoSp_rule,
  /* 1523 */  iRegINoSp_rule,
  /* 1524 */  iRegINoSp_rule,
  /* 1525 */  iRegLNoSp_rule,
  /* 1526 */  iRegLNoSp_rule,
  /* 1527 */  vRegF_rule,
  /* 1528 */  vRegD_rule,
  /* 1529 */  iRegINoSp_rule,
  /* 1530 */  iRegLNoSp_rule,
  /* 1531 */  vRegF_rule,
  /* 1532 */  vRegD_rule,
  /* 1533 */  iRegINoSp_rule,
  /* 1534 */  iRegINoSp_rule,
  /* 1535 */  iRegLNoSp_rule,
  /* 1536 */  iRegLNoSp_rule,
  /* 1537 */  vRegF_rule,
  /* 1538 */  vRegD_rule,
  /* 1539 */  iRegINoSp_rule,
  /* 1540 */  iRegLNoSp_rule,
  /* 1541 */  vRegF_rule,
  /* 1542 */  vRegD_rule,
  /* 1543 */  vReg_rule,
  /* 1544 */  vReg_rule,
  /* 1545 */  vReg_rule,
  /* 1546 */  vReg_rule,
  /* 1547 */  vReg_rule,
  /* 1548 */  vReg_rule,
  /* 1549 */  vReg_rule,
  /* 1550 */  vReg_rule,
  /* 1551 */  vReg_rule,
  /* 1552 */  vReg_rule,
  /* 1553 */  vReg_rule,
  /* 1554 */  vReg_rule,
  /* 1555 */  vReg_rule,
  /* 1556 */  vReg_rule,
  /* 1557 */  vReg_rule,
  /* 1558 */  vReg_rule,
  /* 1559 */  vReg_rule,
  /* 1560 */  vReg_rule,
  /* 1561 */  vReg_rule,
  /* 1562 */  vReg_rule,
  /* 1563 */  vReg_rule,
  /* 1564 */  vReg_rule,
  /* 1565 */  vReg_rule,
  /* 1566 */  iRegINoSp_rule,
  /* 1567 */  iRegINoSp_rule,
  /* 1568 */  iRegINoSp_rule,
  /* 1569 */  iRegINoSp_rule,
  /* 1570 */  iRegINoSp_rule,
  /* 1571 */  iRegINoSp_rule,
  /* 1572 */  iRegINoSp_rule,
  /* 1573 */  iRegINoSp_rule,
  /* 1574 */  iRegINoSp_rule,
  /* 1575 */  iRegLNoSp_rule,
  /* 1576 */  iRegLNoSp_rule,
  /* 1577 */  vRegF_rule,
  /* 1578 */  vRegD_rule,
  /* 1579 */  pReg_rule,
  /* 1580 */  pReg_rule,
  /* 1581 */  pReg_rule,
  /* 1582 */  pReg_rule,
  /* 1583 */  vReg_rule,
  /* 1584 */  vReg_rule,
  /* 1585 */  vReg_rule,
  /* 1586 */  vReg_rule,
  /* 1587 */  pReg_rule,
  /* 1588 */  pReg_rule,
  /* 1589 */  pReg_rule,
  /* 1590 */  pReg_rule,
  /* 1591 */  Universe_rule,
  /* 1592 */  Universe_rule,
  /* 1593 */  Universe_rule,
  /* 1594 */  Universe_rule,
  /* 1595 */  pReg_rule,
  /* 1596 */  pReg_rule,
  /* 1597 */  pReg_rule,
  /* 1598 */  pReg_rule,
  /* 1599 */  pReg_rule,
  /* 1600 */  vReg_rule,
  /* 1601 */  vReg_rule,
  /* 1602 */  vReg_rule,
  /* 1603 */  vReg_rule,
  /* 1604 */  vReg_rule,
  /* 1605 */  pReg_rule,
  /* 1606 */  pReg_rule,
  /* 1607 */  pReg_rule,
  /* 1608 */  pReg_rule,
  /* 1609 */  pReg_rule,
  /* 1610 */  pReg_rule,
  /* 1611 */  pReg_rule,
  /* 1612 */  pReg_rule,
  /* 1613 */  iRegINoSp_rule,
  /* 1614 */  iRegINoSp_rule,
  /* 1615 */  iRegINoSp_rule,
  /* 1616 */  iRegINoSp_rule,
  /* 1617 */  iRegINoSp_rule,
  /* 1618 */  iRegLNoSp_rule,
  /* 1619 */  pReg_rule,
  /* 1620 */  pReg_rule,
  /* 1621 */  pReg_rule,
  /* 1622 */  pReg_rule,
  /* 1623 */  pReg_rule,
  /* 1624 */  pReg_rule,
  /* 1625 */  pReg_rule,
  /* 1626 */  pReg_rule,
  /* 1627 */  pReg_rule,
  /* 1628 */  pReg_rule,
  /* 1629 */  pReg_rule,
  /* 1630 */  vReg_rule,
  /* 1631 */  vReg_rule,
  /* 1632 */  vReg_rule,
  /* 1633 */  vReg_rule,
  /* 1634 */  vReg_rule,
  /* 1635 */  vReg_rule,
  /* 1636 */  vReg_rule,
  /* 1637 */  vReg_rule,
  /* 1638 */  vReg_rule,
  /* 1639 */  vReg_rule,
  /* 1640 */  vReg_rule,
  /* 1641 */  vReg_rule,
  /* 1642 */  vReg_rule,
  /* 1643 */  vReg_rule,
  /* 1644 */  vReg_rule,
  /* 1645 */  Universe_rule,
  /* 1646 */  Universe_rule,
  /* 1647 */  Universe_rule,
  /* 1648 */  Universe_rule,
  /* 1649 */  vReg_rule,
  /* 1650 */  vReg_rule,
  /* 1651 */  vReg_rule,
  /* 1652 */  vReg_rule,
  /* 1653 */  vReg_rule,
  /* 1654 */  pReg_rule,
  /* 1655 */  vReg_rule,
  /* 1656 */  vReg_rule,
  /* 1657 */  vReg_rule,
  /* 1658 */  vReg_rule,
  /* 1659 */  vReg_rule,
  /* 1660 */  vReg_rule,
  /* 1661 */  vReg_rule,
  /* 1662 */  vReg_rule,
  /* 1663 */  vReg_rule,
  /* 1664 */  vReg_rule,
  /* 1665 */  iRegINoSp_rule,
  /* 1666 */  iRegINoSp_rule,
  /* 1667 */  iRegINoSp_rule,
  /* 1668 */  iRegINoSp_rule,
  /* 1669 */  iRegNNoSp_rule,
  /* 1670 */  iRegPNoSp_rule,
  /* 1671 */  iRegNNoSp_rule,
  /* 1672 */  iRegPNoSp_rule,
  /* 1673 */  iRegINoSp_rule,
  /* 1674 */  iRegINoSp_rule,
  /* 1675 */  iRegINoSp_rule,
  /* 1676 */  iRegINoSp_rule,
  /* 1677 */  iRegPNoSp_rule,
  /* 1678 */  iRegPNoSp_rule,
  /* 1679 */  iRegINoSp_rule,
  /* 1680 */  iRegINoSp_rule,
  /* 1681 */  iRegINoSp_rule,
  /* 1682 */  iRegINoSp_rule,
  /* 1683 */  iRegPNoSp_rule,
  /* 1684 */  iRegPNoSp_rule,
  /* 1685 */  iRegPNoSp_rule,
  /* 1686 */  iRegPNoSp_rule,
  /* 1687 */  iRegPNoSp_rule,
  /* 1688 */  iRegPNoSp_rule,
  /* 1689 */  Universe_rule,
  /* 1690 */  Universe_rule,
  /* 1691 */  iRegINoSp_rule,
  /* 1692 */  iRegINoSp_rule,
  /* 1693 */  iRegINoSp_rule,
  /* 1694 */  iRegINoSp_rule,
  /* 1695 */  iRegPNoSp_rule,
  /* 1696 */  iRegPNoSp_rule,
  /* 1697 */  iRegPNoSp_rule,
  /* 1698 */  iRegPNoSp_rule,
  // last instruction
  0 // no trailing comma
};

const        int   leftOp[] = {
  /*    0 */  0,
  /*    1 */  0,
  /*    2 */  0,
  /*    3 */  0,
  /*    4 */  0,
  /*    5 */  0,
  /*    6 */  0,
  /*    7 */  0,
  /*    8 */  0,
  /*    9 */  0,
  /*   10 */  0,
  /*   11 */  0,
  /*   12 */  0,
  /*   13 */  0,
  /*   14 */  0,
  /*   15 */  0,
  /*   16 */  0,
  /*   17 */  0,
  /*   18 */  0,
  /*   19 */  0,
  /*   20 */  0,
  /*   21 */  0,
  /*   22 */  0,
  /*   23 */  0,
  /*   24 */  0,
  /*   25 */  0,
  /*   26 */  0,
  /*   27 */  0,
  /*   28 */  0,
  /*   29 */  0,
  /*   30 */  0,
  /*   31 */  0,
  /*   32 */  0,
  /*   33 */  0,
  /*   34 */  0,
  /*   35 */  0,
  /*   36 */  0,
  /*   37 */  0,
  /*   38 */  0,
  /*   39 */  0,
  /*   40 */  0,
  /*   41 */  0,
  /*   42 */  0,
  /*   43 */  0,
  /*   44 */  0,
  /*   45 */  0,
  /*   46 */  0,
  /*   47 */  0,
  /*   48 */  0,
  /*   49 */  0,
  /*   50 */  0,
  /*   51 */  0,
  /*   52 */  0,
  /*   53 */  0,
  /*   54 */  0,
  /*   55 */  0,
  /*   56 */  0,
  /*   57 */  0,
  /*   58 */  0,
  /*   59 */  0,
  /*   60 */  0,
  /*   61 */  0,
  /*   62 */  0,
  /*   63 */  0,
  /*   64 */  0,
  /*   65 */  0,
  /*   66 */  0,
  /*   67 */  0,
  /*   68 */  0,
  /*   69 */  0,
  /*   70 */  0,
  /*   71 */  0,
  /*   72 */  0,
  /*   73 */  0,
  /*   74 */  0,
  /*   75 */  0,
  /*   76 */  0,
  /*   77 */  0,
  /*   78 */  0,
  /*   79 */  0,
  /*   80 */  0,
  /*   81 */  0,
  /*   82 */  0,
  /*   83 */  0,
  /*   84 */  0,
  /*   85 */  0,
  /*   86 */  0,
  /*   87 */  0,
  /*   88 */  0,
  /*   89 */  0,
  /*   90 */  0,
  /*   91 */  0,
  /*   92 */  0,
  /*   93 */  0,
  /*   94 */  0,
  /*   95 */  0,
  /*   96 */  0,
  /*   97 */  0,
  /*   98 */  0,
  /*   99 */  0,
  /*  100 */  0,
  /*  101 */  0,
  /*  102 */  0,
  /*  103 */  0,
  /*  104 */  0,
  /*  105 */  0,
  /*  106 */  0,
  /*  107 */  0,
  /*  108 */  0,
  /*  109 */  0,
  /*  110 */  0,
  /*  111 */  0,
  /*  112 */  0,
  /*  113 */  0,
  /*  114 */  0,
  /*  115 */  0,
  /*  116 */  0,
  /*  117 */  0,
  /*  118 */  0,
  /*  119 */  0,
  /*  120 */  0,
  /*  121 */  iRegP_rule,
  /*  122 */  iRegP_rule,
  /*  123 */  iRegP_rule,
  /*  124 */  iRegP_rule,
  /*  125 */  iRegP_rule,
  /*  126 */  iRegP_rule,
  /*  127 */  iRegP_rule,
  /*  128 */  iRegP_rule,
  /*  129 */  iRegP_rule,
  /*  130 */  iRegP_rule,
  /*  131 */  iRegP_rule,
  /*  132 */  iRegP_rule,
  /*  133 */  iRegP_rule,
  /*  134 */  iRegP_rule,
  /*  135 */  iRegN_rule,
  /*  136 */  _DecodeN_iRegN__rule,
  /*  137 */  _DecodeN_iRegN__rule,
  /*  138 */  _DecodeN_iRegN__rule,
  /*  139 */  _DecodeN_iRegN__rule,
  /*  140 */  _DecodeN_iRegN__rule,
  /*  141 */  _DecodeN_iRegN__rule,
  /*  142 */  0,
  /*  143 */  0,
  /*  144 */  0,
  /*  145 */  0,
  /*  146 */  0,
  /*  147 */  0,
  /*  148 */  0,
  /*  149 */  0,
  /*  150 */  0,
  /*  151 */  0,
  /*  152 */  iRegL_rule,
  /*  153 */  0,
  /*  154 */  0,
  /*  155 */  iRegP_rule,
  /*  156 */  iRegP_rule,
  // last operand
  /*  157 */  0,
  /*  158 */  0,
  /*  159 */  0,
  /*  160 */  0,
  /*  161 */  0,
  /*  162 */  0,
  /*  163 */  0,
  /*  164 */  0,
  /*  165 */  0,
  /*  166 */  0,
  /*  167 */  0,
  // last operand class
  /*  168 */  iRegI_rule,
  /*  169 */  _ConvI2L_iRegI__rule,
  /*  170 */  iRegL_rule,
  /*  171 */  iRegN_rule,
  /*  172 */  memory1_rule,
  /*  173 */  memory1_rule,
  /*  174 */  memory2_rule,
  /*  175 */  memory2_rule,
  /*  176 */  memory4_rule,
  /*  177 */  _LoadI_memory4__rule,
  /*  178 */  indirect_rule,
  /*  179 */  indirect_rule,
  /*  180 */  indirect_rule,
  /*  181 */  indirect_rule,
  /*  182 */  indirect_rule,
  /*  183 */  _LoadI_indirect__rule,
  /*  184 */  memory8_rule,
  /*  185 */  iRegP_rule,
  /*  186 */  _DecodeN_iRegN__rule,
  /*  187 */  iRegINoSp_rule,
  /*  188 */  iRegLNoSp_rule,
  /*  189 */  iRegP_rule,
  /*  190 */  iRegNNoSp_rule,
  /*  191 */  iRegI_rule,
  /*  192 */  iRegL_rule,
  /*  193 */  iRegN_rule,
  /*  194 */  cmpOp_rule,
  /*  195 */  iRegIorL2I_rule,
  /*  196 */  cmpOpU_rule,
  /*  197 */  immI0_rule,
  /*  198 */  iRegIorL2I_rule,
  /*  199 */  immI_1_rule,
  /*  200 */  iRegL_rule,
  /*  201 */  immL0_rule,
  /*  202 */  iRegP_rule,
  /*  203 */  immP0_rule,
  /*  204 */  iRegN_rule,
  /*  205 */  immN0_rule,
  /*  206 */  vRegF_rule,
  /*  207 */  vRegD_rule,
  /*  208 */  iRegL_rule,
  /*  209 */  iRegIorL2I_rule,
  /*  210 */  _ConvI2L_iRegIorL2I__rule,
  /*  211 */  iRegIorL2I_rule,
  /*  212 */  immI0_rule,
  /*  213 */  iRegL_rule,
  /*  214 */  immL0_rule,
  /*  215 */  _ConvI2L_iRegIorL2I__rule,
  /*  216 */  immL0_rule,
  /*  217 */  iRegIorL2I_rule,
  /*  218 */  iRegIorL2I_rule,
  /*  219 */  iRegIorL2I_rule,
  /*  220 */  iRegL_rule,
  /*  221 */  iRegL_rule,
  /*  222 */  iRegL_rule,
  /*  223 */  iRegIorL2I_rule,
  /*  224 */  iRegL_rule,
  /*  225 */  iRegIorL2I_rule,
  /*  226 */  iRegL_rule,
  /*  227 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  228 */  _URShiftL_iRegL_immI_rule,
  /*  229 */  _RShiftI_iRegIorL2I_immI_rule,
  /*  230 */  _RShiftL_iRegL_immI_rule,
  /*  231 */  iRegIorL2I_rule,
  /*  232 */  _RotateRight_iRegIorL2I_immI_rule,
  /*  233 */  iRegL_rule,
  /*  234 */  _RotateRight_iRegL_immI_rule,
  /*  235 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  236 */  _LShiftL_iRegL_immI_rule,
  /*  237 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  238 */  iRegIorL2I_rule,
  /*  239 */  _URShiftL_iRegL_immI_rule,
  /*  240 */  iRegL_rule,
  /*  241 */  _RShiftI_iRegIorL2I_immI_rule,
  /*  242 */  iRegIorL2I_rule,
  /*  243 */  _RShiftL_iRegL_immI_rule,
  /*  244 */  iRegL_rule,
  /*  245 */  _RotateRight_iRegIorL2I_immI_rule,
  /*  246 */  iRegIorL2I_rule,
  /*  247 */  _RotateRight_iRegL_immI_rule,
  /*  248 */  iRegL_rule,
  /*  249 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  250 */  iRegIorL2I_rule,
  /*  251 */  _LShiftL_iRegL_immI_rule,
  /*  252 */  iRegL_rule,
  /*  253 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  254 */  iRegIorL2I_rule,
  /*  255 */  iRegL_rule,
  /*  256 */  _AndI_iRegIorL2I_immI_bitmask_rule,
  /*  257 */  iRegL_rule,
  /*  258 */  _AndL_iRegL_immL_positive_bitmaskI_rule,
  /*  259 */  _AndI_iRegIorL2I_immI_bitmask_rule,
  /*  260 */  _AndL_iRegL_immL_positive_bitmaskI_rule,
  /*  261 */  iRegI_rule,
  /*  262 */  iRegIorL2I_rule,
  /*  263 */  _LShiftI_iRegIorL2I_immI_16_rule,
  /*  264 */  iRegIorL2I_rule,
  /*  265 */  _LShiftI_iRegIorL2I_immI_24_rule,
  /*  266 */  _LShiftI_iRegIorL2I_immI_24_rule,
  /*  267 */  iRegL_rule,
  /*  268 */  _LShiftL_iRegL_immI_48_rule,
  /*  269 */  iRegL_rule,
  /*  270 */  _LShiftL_iRegL_immI_32_rule,
  /*  271 */  iRegL_rule,
  /*  272 */  _LShiftL_iRegL_immI_56_rule,
  /*  273 */  _LShiftL_iRegL_immI_56_rule,
  /*  274 */  iRegIorL2I_rule,
  /*  275 */  iRegIorL2I_rule,
  /*  276 */  iRegL_rule,
  /*  277 */  iRegL_rule,
  /*  278 */  iRegL_rule,
  /*  279 */  _RShiftL__LShiftL_iRegL_immI_56_immI_56_rule,
  /*  280 */  _RShiftL__LShiftL_iRegL_immI_48_immI_48_rule,
  /*  281 */  _RShiftL__LShiftL_iRegL_immI_32_immI_32_rule,
  /*  282 */  _RShiftI__LShiftI_iRegIorL2I_immI_24_immI_24_rule,
  /*  283 */  _RShiftI__LShiftI_iRegIorL2I_immI_16_immI_16_rule,
  /*  284 */  _ConvI2L_iRegIorL2I__rule,
  /*  285 */  _AndL_iRegL_immL_255_rule,
  /*  286 */  _AndL_iRegL_immL_65535_rule,
  /*  287 */  _AndL_iRegL_immL_4294967295_rule,
  /*  288 */  _AndI_iRegIorL2I_immI_255_rule,
  /*  289 */  _AndI_iRegIorL2I_immI_65535_rule,
  /*  290 */  vRegF_rule,
  /*  291 */  vRegF_rule,
  /*  292 */  vRegD_rule,
  /*  293 */  vRegD_rule,
  /*  294 */  vRegF_rule,
  /*  295 */  vRegD_rule,
  /*  296 */  iRegIorL2I_rule,
  /*  297 */  iRegL_rule,
  /*  298 */  iRegIorL2I_rule,
  /*  299 */  iRegL_rule,
  /*  300 */  iRegP_rule,
  /*  301 */  iRegN_rule,
  /*  302 */  _DecodeN_iRegN__rule,
  /*  303 */  iRegIorL2I_rule,
  /*  304 */  iRegL_rule,
  /*  305 */  iRegL_rule,
  /*  306 */  _AndL_iRegL_immL_rule,
  /*  307 */  iRegIorL2I_rule,
  /*  308 */  _AndI_iRegIorL2I_immI_rule,
  /*  309 */  iRegL_rule,
  /*  310 */  iRegIorL2I_rule,
  /*  311 */  iRegP_R4_rule,
  /*  312 */  iRegP_R1_rule,
  /*  313 */  iRegP_R3_rule,
  /*  314 */  iRegP_R1_rule,
  /*  315 */  iRegP_R3_rule,
  /*  316 */  iRegP_R3_rule,
  /*  317 */  iRegP_R3_rule,
  /*  318 */  iRegP_R1_rule,
  /*  319 */  iRegP_R1_rule,
  /*  320 */  vReg_rule,
  /*  321 */  vReg_rule,
  /*  322 */  immBAddSubV_rule,
  /*  323 */  immIAddSubV_rule,
  /*  324 */  immLAddSubV_rule,
  /*  325 */  immBLog_rule,
  /*  326 */  immSLog_rule,
  /*  327 */  immILog_rule,
  /*  328 */  immLLog_rule,
  /*  329 */  vReg_rule,
  /*  330 */  immI_M1_rule,
  /*  331 */  immL_M1_rule,
  /*  332 */  vReg_rule,
  /*  333 */  vReg_rule,
  /*  334 */  vReg_rule,
  /*  335 */  _Replicate_immI_M1__rule,
  /*  336 */  vReg_rule,
  /*  337 */  _Replicate_immL_M1__rule,
  /*  338 */  vReg_rule,
  /*  339 */  vReg_rule,
  /*  340 */  vReg_rule,
  /*  341 */  vReg_rule,
  /*  342 */  vReg_rule,
  /*  343 */  vReg_rule,
  /*  344 */  _Binary_vReg_vReg_rule,
  /*  345 */  _Binary_vReg_vReg_rule,
  /*  346 */  vReg_rule,
  /*  347 */  vReg_rule,
  /*  348 */  vReg_rule,
  /*  349 */  vReg_rule,
  /*  350 */  vReg_rule,
  /*  351 */  vReg_rule,
  /*  352 */  vReg_rule,
  /*  353 */  vReg_rule,
  /*  354 */  vReg_rule,
  /*  355 */  vReg_rule,
  /*  356 */  vReg_rule,
  /*  357 */  vReg_rule,
  /*  358 */  _NegVF_vReg__rule,
  /*  359 */  _NegVD_vReg__rule,
  /*  360 */  immI_rule,
  /*  361 */  immI_positive_rule,
  /*  362 */  vReg_rule,
  /*  363 */  vReg_rule,
  /*  364 */  vReg_rule,
  /*  365 */  vReg_rule,
  /*  366 */  vReg_rule,
  /*  367 */  vReg_rule,
  /*  368 */  vReg_rule,
  /*  369 */  vReg_rule,
  /*  370 */  vReg_rule,
  /*  371 */  vReg_rule,
  /*  372 */  iRegIorL2I_rule,
  /*  373 */  iRegL_rule,
  /*  374 */  vRegF_rule,
  /*  375 */  vRegD_rule,
  /*  376 */  vReg_rule,
  /*  377 */  vReg_rule,
  /*  378 */  vReg_rule,
  /*  379 */  vReg_rule,
  /*  380 */  indirect_rule,
  /*  381 */  vmemA_rule,
  /*  382 */  pReg_rule,
  /*  383 */  _VectorStoreMask_pReg_immI_gt_1_rule,
  /*  384 */  immI_M1_rule,
  /*  385 */  pReg_rule,
  /*  386 */  immL_M1_rule,
  /*  387 */  pReg_rule,
  /*  388 */  immI0_rule,
  /*  389 */  vReg_rule,
  /*  390 */  immL0_rule,
  /*  391 */  vReg_rule,
  /*  392 */  immF0_rule,
  /*  393 */  vReg_rule,
  /*  394 */  immD0_rule,
  /*  395 */  vReg_rule,
  /*  396 */  immI5_rule,
  /*  397 */  vReg_rule,
  /*  398 */  immIU7_rule,
  /*  399 */  vReg_rule,
  /*  400 */  immL5_rule,
  /*  401 */  vReg_rule,
  /*  402 */  immLU7_rule,
  /*  403 */  vReg_rule,
  /*  404 */  immI_rule,
  /*  405 */  vReg_rule,
  /*  406 */  iRegL_rule,
  /*  407 */  vReg_rule,
  // last internally defined operand
  /*  408 */  immI_rule,
  /*  409 */  immL_rule,
  /*  410 */  immP_rule,
  /*  411 */  immP0_rule,
  /*  412 */  immP_1_rule,
  /*  413 */  immByteMapBase_rule,
  /*  414 */  immN_rule,
  /*  415 */  immN0_rule,
  /*  416 */  immNKlass_rule,
  /*  417 */  immFPacked_rule,
  /*  418 */  immF_rule,
  /*  419 */  immDPacked_rule,
  /*  420 */  immD_rule,
  /*  421 */  iRegIorL2I_rule,
  /*  422 */  iRegL_rule,
  /*  423 */  iRegIorL2I_rule,
  /*  424 */  iRegL_rule,
  /*  425 */  iRegL_rule,
  /*  426 */  iRegP_rule,
  /*  427 */  iRegPNoSp_rule,
  /*  428 */  iRegPNoSp_rule,
  /*  429 */  iRegI_rule,
  /*  430 */  iRegL_rule,
  /*  431 */  vRegF_rule,
  /*  432 */  vRegD_rule,
  /*  433 */  vReg_rule,
  /*  434 */  pRegGov_rule,
  /*  435 */  iRegIorL2I_rule,
  /*  436 */  iRegL_rule,
  /*  437 */  vRegF_rule,
  /*  438 */  vRegD_rule,
  /*  439 */  vRegF_rule,
  /*  440 */  vRegD_rule,
  /*  441 */  stackSlotF_rule,
  /*  442 */  stackSlotI_rule,
  /*  443 */  stackSlotD_rule,
  /*  444 */  stackSlotL_rule,
  /*  445 */  vRegF_rule,
  /*  446 */  iRegI_rule,
  /*  447 */  vRegD_rule,
  /*  448 */  iRegL_rule,
  /*  449 */  iRegIorL2I_rule,
  /*  450 */  iRegIorL2I_rule,
  /*  451 */  iRegL_rule,
  /*  452 */  iRegL_rule,
  /*  453 */  iRegIorL2I_rule,
  /*  454 */  iRegIorL2I_rule,
  /*  455 */  iRegL_rule,
  /*  456 */  iRegL_rule,
  /*  457 */  immI0_rule,
  /*  458 */  immI0_rule,
  /*  459 */  iRegIorL2I_rule,
  /*  460 */  iRegL_rule,
  /*  461 */  iRegI_rule,
  /*  462 */  iRegI_rule,
  /*  463 */  iRegI_rule,
  /*  464 */  iRegI_rule,
  /*  465 */  iRegI_rule,
  /*  466 */  iRegI_rule,
  /*  467 */  iRegI_rule,
  /*  468 */  iRegI_rule,
  /*  469 */  iRegL_rule,
  /*  470 */  iRegL_rule,
  /*  471 */  iRegL_rule,
  /*  472 */  iRegL_rule,
  /*  473 */  iRegL_rule,
  /*  474 */  iRegL_rule,
  /*  475 */  iRegL_rule,
  /*  476 */  iRegL_rule,
  /*  477 */  iRegP_rule,
  /*  478 */  iRegN_rule,
  /*  479 */  iRegP_rule,
  /*  480 */  iRegN_rule,
  /*  481 */  vRegF_rule,
  /*  482 */  vRegF_rule,
  /*  483 */  vRegD_rule,
  /*  484 */  vRegD_rule,
  /*  485 */  0,
  /*  486 */  _AndL_iRegL_immL_rule,
  /*  487 */  _AndI_iRegIorL2I_immI_rule,
  /*  488 */  _AndL_iRegL_iRegL_rule,
  /*  489 */  _AndI_iRegIorL2I_iRegIorL2I_rule,
  /*  490 */  iRegP_rule,
  /*  491 */  iRegP_rule,
  /*  492 */  iRegP_rule,
  /*  493 */  iRegP_rule,
  /*  494 */  _PartialSubtypeCheck_iRegP_R4_iRegP_R0_rule,
  /*  495 */  0,
  /*  496 */  immI0_rule,
  /*  497 */  vReg_rule,
  /*  498 */  vReg_rule,
  /*  499 */  vReg_rule,
  /*  500 */  vReg_rule,
  /*  501 */  vReg_rule,
  /*  502 */  vReg_rule,
  /*  503 */  vReg_rule,
  /*  504 */  vReg_rule,
  /*  505 */  vReg_rule,
  /*  506 */  vReg_rule,
  /*  507 */  vReg_rule,
  /*  508 */  vReg_rule,
  /*  509 */  iRegIorL2I_rule,
  /*  510 */  iRegIorL2I_rule,
  /*  511 */  vReg_rule,
  /*  512 */  vReg_rule,
  /*  513 */  vReg_rule,
  /*  514 */  vReg_rule,
  /*  515 */  vReg_rule,
  /*  516 */  vReg_rule,
  /*  517 */  vReg_rule,
  /*  518 */  vReg_rule,
  /*  519 */  vReg_rule,
  /*  520 */  vReg_rule,
  /*  521 */  vReg_rule,
  /*  522 */  vReg_rule,
  /*  523 */  vReg_rule,
  /*  524 */  vReg_rule,
  /*  525 */  vReg_rule,
  /*  526 */  vReg_rule,
  /*  527 */  iRegIorL2I_rule,
  /*  528 */  iRegL_rule,
  /*  529 */  vRegF_rule,
  /*  530 */  vRegD_rule,
  /*  531 */  immI_rule,
  /*  532 */  immI8_rule,
  /*  533 */  immI8_shift8_rule,
  /*  534 */  immL_rule,
  /*  535 */  immL8_shift8_rule,
  /*  536 */  vReg_rule,
  /*  537 */  vReg_rule,
  /*  538 */  vReg_rule,
  /*  539 */  vReg_rule,
  /*  540 */  pReg_rule,
  /*  541 */  pReg_rule,
  /*  542 */  pReg_rule,
  /*  543 */  pReg_rule,
  /*  544 */  vReg_rule,
  /*  545 */  vReg_rule,
  /*  546 */  vReg_rule,
  /*  547 */  vReg_rule,
  /*  548 */  vReg_rule,
  /*  549 */  vReg_rule,
  /*  550 */  pReg_rule,
  /*  551 */  vReg_rule,
  /*  552 */  pReg_rule,
  /*  553 */  vReg_rule,
  /*  554 */  vReg_rule,
  /*  555 */  vReg_rule,
  /*  556 */  vReg_rule,
  /*  557 */  vReg_rule,
  /*  558 */  memory1_rule,
  /*  559 */  _LoadB_memory1__rule,
  /*  560 */  memory1_rule,
  /*  561 */  _LoadUB_memory1__rule,
  /*  562 */  memory2_rule,
  /*  563 */  _LoadS_memory2__rule,
  /*  564 */  memory2_rule,
  /*  565 */  _LoadUS_memory2__rule,
  /*  566 */  memory4_rule,
  /*  567 */  _LoadI_memory4__rule,
  /*  568 */  _ConvI2L__LoadI_memory4___rule,
  /*  569 */  memory8_rule,
  /*  570 */  memory4_rule,
  /*  571 */  memory8_rule,
  /*  572 */  memory4_rule,
  /*  573 */  memory8_rule,
  /*  574 */  memory4_rule,
  /*  575 */  memory4_rule,
  /*  576 */  memory8_rule,
  /*  577 */  memory1_rule,
  /*  578 */  memory1_rule,
  /*  579 */  memory1_rule,
  /*  580 */  memory1_rule,
  /*  581 */  memory2_rule,
  /*  582 */  memory2_rule,
  /*  583 */  memory4_rule,
  /*  584 */  memory4_rule,
  /*  585 */  memory8_rule,
  /*  586 */  memory8_rule,
  /*  587 */  memory8_rule,
  /*  588 */  memory8_rule,
  /*  589 */  memory4_rule,
  /*  590 */  memory4_rule,
  /*  591 */  memory4_rule,
  /*  592 */  memory8_rule,
  /*  593 */  memory4_rule,
  /*  594 */  memory8_rule,
  /*  595 */  indirect_rule,
  /*  596 */  _LoadB_indirect__rule,
  /*  597 */  indirect_rule,
  /*  598 */  _LoadUB_indirect__rule,
  /*  599 */  indirect_rule,
  /*  600 */  indirect_rule,
  /*  601 */  _LoadUS_indirect__rule,
  /*  602 */  _LoadS_indirect__rule,
  /*  603 */  indirect_rule,
  /*  604 */  _ConvI2L__LoadI_indirect___rule,
  /*  605 */  indirect_rule,
  /*  606 */  indirect_rule,
  /*  607 */  indirect_rule,
  /*  608 */  indirect_rule,
  /*  609 */  indirect_rule,
  /*  610 */  indirect_rule,
  /*  611 */  indirect_rule,
  /*  612 */  indirect_rule,
  /*  613 */  indirect_rule,
  /*  614 */  indirect_rule,
  /*  615 */  indirect_rule,
  /*  616 */  indirect_rule,
  /*  617 */  indirect_rule,
  /*  618 */  indirect_rule,
  /*  619 */  indirect_rule,
  /*  620 */  indirect_rule,
  /*  621 */  indirect_rule,
  /*  622 */  indirect_rule,
  /*  623 */  indirect_rule,
  /*  624 */  indirect_rule,
  /*  625 */  0,
  /*  626 */  0,
  /*  627 */  iRegIorL2I_rule,
  /*  628 */  iRegL_rule,
  /*  629 */  iRegIorL2I_rule,
  /*  630 */  iRegIorL2I_rule,
  /*  631 */  iRegIorL2I_rule,
  /*  632 */  _LoadI_memory4__rule,
  /*  633 */  iRegL_rule,
  /*  634 */  _LoadL_memory8__rule,
  /*  635 */  iRegP_rule,
  /*  636 */  0,
  /*  637 */  0,
  /*  638 */  0,
  /*  639 */  0,
  /*  640 */  0,
  /*  641 */  0,
  /*  642 */  0,
  /*  643 */  0,
  /*  644 */  0,
  /*  645 */  0,
  /*  646 */  0,
  /*  647 */  0,
  /*  648 */  _CastP2X_iRegP__rule,
  /*  649 */  _CastP2X__DecodeN_iRegN___rule,
  /*  650 */  iRegP_rule,
  /*  651 */  iRegP_rule,
  /*  652 */  iRegN_rule,
  /*  653 */  iRegN_rule,
  /*  654 */  iRegP_rule,
  /*  655 */  iRegN_rule,
  /*  656 */  indirect_rule,
  /*  657 */  indirect_rule,
  /*  658 */  indirect_rule,
  /*  659 */  indirect_rule,
  /*  660 */  indirect_rule,
  /*  661 */  indirect_rule,
  /*  662 */  indirect_rule,
  /*  663 */  indirect_rule,
  /*  664 */  indirect_rule,
  /*  665 */  indirect_rule,
  /*  666 */  indirect_rule,
  /*  667 */  indirect_rule,
  /*  668 */  indirect_rule,
  /*  669 */  indirect_rule,
  /*  670 */  indirect_rule,
  /*  671 */  indirect_rule,
  /*  672 */  indirect_rule,
  /*  673 */  indirect_rule,
  /*  674 */  indirect_rule,
  /*  675 */  indirect_rule,
  /*  676 */  indirect_rule,
  /*  677 */  indirect_rule,
  /*  678 */  indirect_rule,
  /*  679 */  indirect_rule,
  /*  680 */  indirect_rule,
  /*  681 */  indirect_rule,
  /*  682 */  indirect_rule,
  /*  683 */  indirect_rule,
  /*  684 */  indirect_rule,
  /*  685 */  indirect_rule,
  /*  686 */  indirect_rule,
  /*  687 */  indirect_rule,
  /*  688 */  indirect_rule,
  /*  689 */  indirect_rule,
  /*  690 */  indirect_rule,
  /*  691 */  indirect_rule,
  /*  692 */  indirect_rule,
  /*  693 */  indirect_rule,
  /*  694 */  indirect_rule,
  /*  695 */  indirect_rule,
  /*  696 */  indirect_rule,
  /*  697 */  indirect_rule,
  /*  698 */  indirect_rule,
  /*  699 */  indirect_rule,
  /*  700 */  indirect_rule,
  /*  701 */  indirect_rule,
  /*  702 */  indirect_rule,
  /*  703 */  indirect_rule,
  /*  704 */  indirect_rule,
  /*  705 */  indirect_rule,
  /*  706 */  indirect_rule,
  /*  707 */  indirect_rule,
  /*  708 */  indirect_rule,
  /*  709 */  indirect_rule,
  /*  710 */  indirect_rule,
  /*  711 */  indirect_rule,
  /*  712 */  indirect_rule,
  /*  713 */  indirect_rule,
  /*  714 */  indirect_rule,
  /*  715 */  indirect_rule,
  /*  716 */  iRegI_rule,
  /*  717 */  iRegI_rule,
  /*  718 */  iRegL_rule,
  /*  719 */  iRegL_rule,
  /*  720 */  iRegL_rule,
  /*  721 */  iRegL_rule,
  /*  722 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  723 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  724 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  725 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  726 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  727 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  728 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  729 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  730 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  731 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  732 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  733 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  734 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  735 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  736 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  737 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  738 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  739 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  740 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  741 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  742 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  743 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  744 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  745 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  746 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  747 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  748 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  749 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  750 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  751 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  752 */  iRegIorL2I_rule,
  /*  753 */  iRegIorL2I_rule,
  /*  754 */  _ConvL2I_iRegL__rule,
  /*  755 */  iRegP_rule,
  /*  756 */  iRegP_rule,
  /*  757 */  iRegP_rule,
  /*  758 */  iRegP_rule,
  /*  759 */  _ConvI2L_iRegIorL2I__rule,
  /*  760 */  iRegP_rule,
  /*  761 */  iRegL_rule,
  /*  762 */  iRegL_rule,
  /*  763 */  iRegIorL2I_rule,
  /*  764 */  iRegIorL2I_rule,
  /*  765 */  iRegL_rule,
  /*  766 */  iRegL_rule,
  /*  767 */  immI0_rule,
  /*  768 */  immL0_rule,
  /*  769 */  iRegIorL2I_rule,
  /*  770 */  _ConvI2L_iRegIorL2I__rule,
  /*  771 */  _ConvI2L_iRegIorL2I__rule,
  /*  772 */  iRegL_rule,
  /*  773 */  iRegL_rule,
  /*  774 */  iRegL_rule,
  /*  775 */  iRegIorL2I_rule,
  /*  776 */  _MulI_iRegIorL2I_iRegIorL2I_rule,
  /*  777 */  iRegIorL2I_rule,
  /*  778 */  _SubI_immI0_iRegIorL2I_rule,
  /*  779 */  iRegIorL2I_rule,
  /*  780 */  iRegL_rule,
  /*  781 */  _MulL_iRegL_iRegL_rule,
  /*  782 */  iRegL_rule,
  /*  783 */  _SubL_immL0_iRegL_rule,
  /*  784 */  iRegL_rule,
  /*  785 */  iRegLNoSp_rule,
  /*  786 */  _MulL__ConvI2L_iRegIorL2I___ConvI2L_iRegIorL2I__rule,
  /*  787 */  iRegLNoSp_rule,
  /*  788 */  _MulL__ConvI2L_iRegIorL2I___ConvI2L_iRegIorL2I__rule,
  /*  789 */  iRegLNoSp_rule,
  /*  790 */  iRegLNoSp_rule,
  /*  791 */  _SubL_immL0__ConvI2L_iRegIorL2I__rule,
  /*  792 */  _ConvI2L_iRegIorL2I__rule,
  /*  793 */  _Binary_iRegIorL2I_iRegIorL2I_rule,
  /*  794 */  iRegIorL2I_rule,
  /*  795 */  iRegL_rule,
  /*  796 */  iRegIorL2I_rule,
  /*  797 */  iRegL_rule,
  /*  798 */  iRegIorL2I_rule,
  /*  799 */  iRegL_rule,
  /*  800 */  iRegIorL2I_rule,
  /*  801 */  iRegL_rule,
  /*  802 */  iRegIorL2I_rule,
  /*  803 */  iRegIorL2I_rule,
  /*  804 */  iRegIorL2I_rule,
  /*  805 */  iRegIorL2I_rule,
  /*  806 */  iRegIorL2I_rule,
  /*  807 */  iRegIorL2I_rule,
  /*  808 */  iRegL_rule,
  /*  809 */  iRegL_rule,
  /*  810 */  iRegL_rule,
  /*  811 */  iRegL_rule,
  /*  812 */  _CastP2X_iRegP__rule,
  /*  813 */  iRegL_rule,
  /*  814 */  iRegL_rule,
  /*  815 */  iRegL_rule,
  /*  816 */  iRegIorL2I_rule,
  /*  817 */  immI0_rule,
  /*  818 */  immI0_rule,
  /*  819 */  immI0_rule,
  /*  820 */  immL0_rule,
  /*  821 */  immL0_rule,
  /*  822 */  immL0_rule,
  /*  823 */  iRegIorL2I_rule,
  /*  824 */  _XorI_iRegIorL2I_immI_M1_rule,
  /*  825 */  iRegL_rule,
  /*  826 */  _XorL_iRegL_immL_M1_rule,
  /*  827 */  iRegIorL2I_rule,
  /*  828 */  _XorI_iRegIorL2I_immI_M1_rule,
  /*  829 */  iRegL_rule,
  /*  830 */  _XorL_iRegL_immL_M1_rule,
  /*  831 */  immI_M1_rule,
  /*  832 */  _XorI_iRegIorL2I_iRegIorL2I_rule,
  /*  833 */  immL_M1_rule,
  /*  834 */  _XorL_iRegL_iRegL_rule,
  /*  835 */  iRegIorL2I_rule,
  /*  836 */  _XorI__URShiftI_iRegIorL2I_immI_immI_M1_rule,
  /*  837 */  iRegL_rule,
  /*  838 */  _XorL__URShiftL_iRegL_immI_immL_M1_rule,
  /*  839 */  iRegIorL2I_rule,
  /*  840 */  _XorI__RShiftI_iRegIorL2I_immI_immI_M1_rule,
  /*  841 */  iRegL_rule,
  /*  842 */  _XorL__RShiftL_iRegL_immI_immL_M1_rule,
  /*  843 */  iRegIorL2I_rule,
  /*  844 */  _XorI__RotateRight_iRegIorL2I_immI_immI_M1_rule,
  /*  845 */  iRegL_rule,
  /*  846 */  _XorL__RotateRight_iRegL_immI_immL_M1_rule,
  /*  847 */  iRegIorL2I_rule,
  /*  848 */  _XorI__LShiftI_iRegIorL2I_immI_immI_M1_rule,
  /*  849 */  iRegL_rule,
  /*  850 */  _XorL__LShiftL_iRegL_immI_immL_M1_rule,
  /*  851 */  immI_M1_rule,
  /*  852 */  _XorI__URShiftI_iRegIorL2I_immI_iRegIorL2I_rule,
  /*  853 */  immI_M1_rule,
  /*  854 */  _XorI_iRegIorL2I__URShiftI_iRegIorL2I_immI_rule,
  /*  855 */  immL_M1_rule,
  /*  856 */  _XorL__URShiftL_iRegL_immI_iRegL_rule,
  /*  857 */  immL_M1_rule,
  /*  858 */  _XorL_iRegL__URShiftL_iRegL_immI_rule,
  /*  859 */  immI_M1_rule,
  /*  860 */  _XorI__RShiftI_iRegIorL2I_immI_iRegIorL2I_rule,
  /*  861 */  immI_M1_rule,
  /*  862 */  _XorI_iRegIorL2I__RShiftI_iRegIorL2I_immI_rule,
  /*  863 */  immL_M1_rule,
  /*  864 */  _XorL__RShiftL_iRegL_immI_iRegL_rule,
  /*  865 */  immL_M1_rule,
  /*  866 */  _XorL_iRegL__RShiftL_iRegL_immI_rule,
  /*  867 */  immI_M1_rule,
  /*  868 */  _XorI__RotateRight_iRegIorL2I_immI_iRegIorL2I_rule,
  /*  869 */  immI_M1_rule,
  /*  870 */  _XorI_iRegIorL2I__RotateRight_iRegIorL2I_immI_rule,
  /*  871 */  immL_M1_rule,
  /*  872 */  _XorL__RotateRight_iRegL_immI_iRegL_rule,
  /*  873 */  immL_M1_rule,
  /*  874 */  _XorL_iRegL__RotateRight_iRegL_immI_rule,
  /*  875 */  immI_M1_rule,
  /*  876 */  _XorI__LShiftI_iRegIorL2I_immI_iRegIorL2I_rule,
  /*  877 */  immI_M1_rule,
  /*  878 */  _XorI_iRegIorL2I__LShiftI_iRegIorL2I_immI_rule,
  /*  879 */  immL_M1_rule,
  /*  880 */  _XorL__LShiftL_iRegL_immI_iRegL_rule,
  /*  881 */  immL_M1_rule,
  /*  882 */  _XorL_iRegL__LShiftL_iRegL_immI_rule,
  /*  883 */  iRegIorL2I_rule,
  /*  884 */  _XorI__URShiftI_iRegIorL2I_immI_immI_M1_rule,
  /*  885 */  iRegL_rule,
  /*  886 */  _XorL__URShiftL_iRegL_immI_immL_M1_rule,
  /*  887 */  iRegIorL2I_rule,
  /*  888 */  _XorI__RShiftI_iRegIorL2I_immI_immI_M1_rule,
  /*  889 */  iRegL_rule,
  /*  890 */  _XorL__RShiftL_iRegL_immI_immL_M1_rule,
  /*  891 */  iRegIorL2I_rule,
  /*  892 */  _XorI__RotateRight_iRegIorL2I_immI_immI_M1_rule,
  /*  893 */  iRegL_rule,
  /*  894 */  _XorL__RotateRight_iRegL_immI_immL_M1_rule,
  /*  895 */  iRegIorL2I_rule,
  /*  896 */  _XorI__LShiftI_iRegIorL2I_immI_immI_M1_rule,
  /*  897 */  iRegL_rule,
  /*  898 */  _XorL__LShiftL_iRegL_immI_immL_M1_rule,
  /*  899 */  iRegIorL2I_rule,
  /*  900 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  901 */  iRegL_rule,
  /*  902 */  _URShiftL_iRegL_immI_rule,
  /*  903 */  iRegIorL2I_rule,
  /*  904 */  _RShiftI_iRegIorL2I_immI_rule,
  /*  905 */  iRegL_rule,
  /*  906 */  _RShiftL_iRegL_immI_rule,
  /*  907 */  iRegIorL2I_rule,
  /*  908 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  909 */  iRegL_rule,
  /*  910 */  _LShiftL_iRegL_immI_rule,
  /*  911 */  iRegIorL2I_rule,
  /*  912 */  _RotateRight_iRegIorL2I_immI_rule,
  /*  913 */  iRegL_rule,
  /*  914 */  _RotateRight_iRegL_immI_rule,
  /*  915 */  iRegIorL2I_rule,
  /*  916 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  917 */  iRegL_rule,
  /*  918 */  _URShiftL_iRegL_immI_rule,
  /*  919 */  iRegIorL2I_rule,
  /*  920 */  _RShiftI_iRegIorL2I_immI_rule,
  /*  921 */  iRegL_rule,
  /*  922 */  _RShiftL_iRegL_immI_rule,
  /*  923 */  iRegIorL2I_rule,
  /*  924 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  925 */  iRegL_rule,
  /*  926 */  _LShiftL_iRegL_immI_rule,
  /*  927 */  iRegIorL2I_rule,
  /*  928 */  _RotateRight_iRegIorL2I_immI_rule,
  /*  929 */  iRegL_rule,
  /*  930 */  _RotateRight_iRegL_immI_rule,
  /*  931 */  iRegIorL2I_rule,
  /*  932 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  933 */  iRegL_rule,
  /*  934 */  _URShiftL_iRegL_immI_rule,
  /*  935 */  iRegIorL2I_rule,
  /*  936 */  _RShiftI_iRegIorL2I_immI_rule,
  /*  937 */  iRegL_rule,
  /*  938 */  _RShiftL_iRegL_immI_rule,
  /*  939 */  iRegIorL2I_rule,
  /*  940 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  941 */  iRegL_rule,
  /*  942 */  _LShiftL_iRegL_immI_rule,
  /*  943 */  iRegIorL2I_rule,
  /*  944 */  _RotateRight_iRegIorL2I_immI_rule,
  /*  945 */  iRegL_rule,
  /*  946 */  _RotateRight_iRegL_immI_rule,
  /*  947 */  iRegIorL2I_rule,
  /*  948 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  949 */  iRegL_rule,
  /*  950 */  _URShiftL_iRegL_immI_rule,
  /*  951 */  iRegIorL2I_rule,
  /*  952 */  _RShiftI_iRegIorL2I_immI_rule,
  /*  953 */  iRegL_rule,
  /*  954 */  _RShiftL_iRegL_immI_rule,
  /*  955 */  iRegIorL2I_rule,
  /*  956 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  957 */  iRegL_rule,
  /*  958 */  _LShiftL_iRegL_immI_rule,
  /*  959 */  iRegIorL2I_rule,
  /*  960 */  iRegL_rule,
  /*  961 */  iRegIorL2I_rule,
  /*  962 */  iRegL_rule,
  /*  963 */  iRegIorL2I_rule,
  /*  964 */  iRegL_rule,
  /*  965 */  _LShiftL_iRegL_immI_rule,
  /*  966 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  967 */  _LShiftL_iRegL_immI_rule,
  /*  968 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  969 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  970 */  _URShiftL_iRegL_immI_rule,
  /*  971 */  _AndI__URShiftI_iRegIorL2I_immI_immI_bitmask_rule,
  /*  972 */  _AndI_iRegIorL2I_immI_bitmask_rule,
  /*  973 */  _AndL_iRegL_immL_bitmask_rule,
  /*  974 */  _LShiftI__AndI_iRegIorL2I_immI_bitmask_immI_rule,
  /*  975 */  _LShiftL__AndL_iRegL_immL_positive_bitmaskI_immI_rule,
  /*  976 */  _ConvI2L__AndI_iRegIorL2I_immI_bitmask__rule,
  /*  977 */  _ConvL2I__AndL_iRegL_immL_positive_bitmaskI__rule,
  /*  978 */  _AndI_iRegI_immI_bitmask_rule,
  /*  979 */  _LShiftL_iRegL_immI_rule,
  /*  980 */  _URShiftL_iRegL_immI_rule,
  /*  981 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  982 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  983 */  _LShiftL_iRegL_immI_rule,
  /*  984 */  _URShiftL_iRegL_immI_rule,
  /*  985 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  986 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  987 */  iRegI_rule,
  /*  988 */  iRegL_rule,
  /*  989 */  iRegI_rule,
  /*  990 */  iRegL_rule,
  /*  991 */  iRegI_rule,
  /*  992 */  iRegL_rule,
  /*  993 */  iRegL_rule,
  /*  994 */  _ConvI2L_iRegIorL2I__rule,
  /*  995 */  iRegL_rule,
  /*  996 */  iRegIorL2I_rule,
  /*  997 */  _RShiftI__LShiftI_iRegIorL2I_immI_16_immI_16_rule,
  /*  998 */  iRegIorL2I_rule,
  /*  999 */  _RShiftI__LShiftI_iRegIorL2I_immI_24_immI_24_rule,
  /* 1000 */  iRegIorL2I_rule,
  /* 1001 */  _URShiftI__LShiftI_iRegIorL2I_immI_24_immI_24_rule,
  /* 1002 */  iRegL_rule,
  /* 1003 */  _RShiftL__LShiftL_iRegL_immI_48_immI_48_rule,
  /* 1004 */  iRegL_rule,
  /* 1005 */  _RShiftL__LShiftL_iRegL_immI_32_immI_32_rule,
  /* 1006 */  iRegL_rule,
  /* 1007 */  _RShiftL__LShiftL_iRegL_immI_56_immI_56_rule,
  /* 1008 */  iRegL_rule,
  /* 1009 */  _URShiftL__LShiftL_iRegL_immI_56_immI_56_rule,
  /* 1010 */  iRegIorL2I_rule,
  /* 1011 */  _AndI_iRegIorL2I_immI_255_rule,
  /* 1012 */  iRegIorL2I_rule,
  /* 1013 */  _AndI_iRegIorL2I_immI_65535_rule,
  /* 1014 */  iRegL_rule,
  /* 1015 */  _AndL_iRegL_immL_255_rule,
  /* 1016 */  iRegL_rule,
  /* 1017 */  _AndL_iRegL_immL_65535_rule,
  /* 1018 */  iRegL_rule,
  /* 1019 */  _AndL_iRegL_immL_4294967295_rule,
  /* 1020 */  iRegIorL2I_rule,
  /* 1021 */  iRegIorL2I_rule,
  /* 1022 */  iRegL_rule,
  /* 1023 */  iRegL_rule,
  /* 1024 */  iRegL_rule,
  /* 1025 */  iRegL_rule,
  /* 1026 */  _LShiftL__RShiftL__LShiftL_iRegL_immI_56_immI_56_immIExt_rule,
  /* 1027 */  iRegL_rule,
  /* 1028 */  _LShiftL__RShiftL__LShiftL_iRegL_immI_48_immI_48_immIExt_rule,
  /* 1029 */  iRegL_rule,
  /* 1030 */  _LShiftL__RShiftL__LShiftL_iRegL_immI_32_immI_32_immIExt_rule,
  /* 1031 */  iRegL_rule,
  /* 1032 */  iRegL_rule,
  /* 1033 */  iRegL_rule,
  /* 1034 */  iRegIorL2I_rule,
  /* 1035 */  _LShiftI__RShiftI__LShiftI_iRegIorL2I_immI_24_immI_24_immIExt_rule,
  /* 1036 */  iRegIorL2I_rule,
  /* 1037 */  _LShiftI__RShiftI__LShiftI_iRegIorL2I_immI_16_immI_16_immIExt_rule,
  /* 1038 */  iRegIorL2I_rule,
  /* 1039 */  iRegIorL2I_rule,
  /* 1040 */  iRegL_rule,
  /* 1041 */  _LShiftL__ConvI2L_iRegIorL2I__immIExt_rule,
  /* 1042 */  iRegL_rule,
  /* 1043 */  iRegL_rule,
  /* 1044 */  _LShiftL__AndL_iRegL_immL_255_immIExt_rule,
  /* 1045 */  iRegL_rule,
  /* 1046 */  _LShiftL__AndL_iRegL_immL_65535_immIExt_rule,
  /* 1047 */  iRegL_rule,
  /* 1048 */  _LShiftL__AndL_iRegL_immL_4294967295_immIExt_rule,
  /* 1049 */  iRegL_rule,
  /* 1050 */  iRegL_rule,
  /* 1051 */  iRegL_rule,
  /* 1052 */  iRegIorL2I_rule,
  /* 1053 */  _LShiftI__AndI_iRegIorL2I_immI_255_immIExt_rule,
  /* 1054 */  iRegIorL2I_rule,
  /* 1055 */  _LShiftI__AndI_iRegIorL2I_immI_65535_immIExt_rule,
  /* 1056 */  iRegIorL2I_rule,
  /* 1057 */  iRegIorL2I_rule,
  /* 1058 */  0,
  /* 1059 */  0,
  /* 1060 */  0,
  /* 1061 */  0,
  /* 1062 */  0,
  /* 1063 */  0,
  /* 1064 */  0,
  /* 1065 */  0,
  /* 1066 */  iRegIorL2I_rule,
  /* 1067 */  immI0_rule,
  /* 1068 */  iRegIorL2I_rule,
  /* 1069 */  immI_1_rule,
  /* 1070 */  iRegIorL2I_rule,
  /* 1071 */  immI_M1_rule,
  /* 1072 */  iRegIorL2I_rule,
  /* 1073 */  immI0_rule,
  /* 1074 */  iRegIorL2I_rule,
  /* 1075 */  immI_1_rule,
  /* 1076 */  iRegIorL2I_rule,
  /* 1077 */  immI_M1_rule,
  /* 1078 */  vRegF_rule,
  /* 1079 */  vRegD_rule,
  /* 1080 */  vRegF_rule,
  /* 1081 */  vRegD_rule,
  /* 1082 */  vRegF_rule,
  /* 1083 */  vRegD_rule,
  /* 1084 */  vRegF_rule,
  /* 1085 */  vRegD_rule,
  /* 1086 */  vRegF_rule,
  /* 1087 */  vRegD_rule,
  /* 1088 */  _NegF_vRegF__rule,
  /* 1089 */  _NegD_vRegD__rule,
  /* 1090 */  _NegF_vRegF__rule,
  /* 1091 */  _NegD_vRegD__rule,
  /* 1092 */  vRegF_rule,
  /* 1093 */  vRegF_rule,
  /* 1094 */  vRegD_rule,
  /* 1095 */  vRegD_rule,
  /* 1096 */  vRegF_rule,
  /* 1097 */  vRegD_rule,
  /* 1098 */  iRegIorL2I_rule,
  /* 1099 */  iRegL_rule,
  /* 1100 */  _SubF_vRegF_vRegF_rule,
  /* 1101 */  _SubD_vRegD_vRegD_rule,
  /* 1102 */  vRegD_rule,
  /* 1103 */  vRegF_rule,
  /* 1104 */  vRegD_rule,
  /* 1105 */  vRegD_rule,
  /* 1106 */  vRegF_rule,
  /* 1107 */  vRegD_rule,
  /* 1108 */  vRegF_rule,
  /* 1109 */  0,
  /* 1110 */  iRegIorL2I_rule,
  /* 1111 */  iRegIorL2I_rule,
  /* 1112 */  iRegIorL2I_rule,
  /* 1113 */  iRegIorL2I_rule,
  /* 1114 */  iRegIorL2I_rule,
  /* 1115 */  iRegIorL2I_rule,
  /* 1116 */  iRegL_rule,
  /* 1117 */  iRegL_rule,
  /* 1118 */  iRegL_rule,
  /* 1119 */  iRegL_rule,
  /* 1120 */  iRegL_rule,
  /* 1121 */  iRegL_rule,
  /* 1122 */  iRegIorL2I_rule,
  /* 1123 */  _ConvI2L_iRegIorL2I__rule,
  /* 1124 */  iRegL_rule,
  /* 1125 */  vRegD_rule,
  /* 1126 */  vRegF_rule,
  /* 1127 */  vRegF_rule,
  /* 1128 */  vRegF_rule,
  /* 1129 */  vRegF_rule,
  /* 1130 */  iRegINoSp_rule,
  /* 1131 */  iRegIorL2I_rule,
  /* 1132 */  iRegL_rule,
  /* 1133 */  vRegD_rule,
  /* 1134 */  vRegD_rule,
  /* 1135 */  iRegIorL2I_rule,
  /* 1136 */  iRegL_rule,
  /* 1137 */  vRegD_rule,
  /* 1138 */  vRegF_rule,
  /* 1139 */  vRegF_rule,
  /* 1140 */  iRegI_rule,
  /* 1141 */  vRegD_rule,
  /* 1142 */  iRegL_rule,
  /* 1143 */  iRegL_R11_rule,
  /* 1144 */  immL_rule,
  /* 1145 */  cmpOp_rule,
  /* 1146 */  cmpOp_rule,
  /* 1147 */  vRegF_rule,
  /* 1148 */  vRegD_rule,
  /* 1149 */  vRegF_rule,
  /* 1150 */  vRegD_rule,
  /* 1151 */  iRegIorL2I_rule,
  /* 1152 */  iRegIorL2I_rule,
  /* 1153 */  iRegIorL2I_rule,
  /* 1154 */  iRegIorL2I_rule,
  /* 1155 */  0,
  /* 1156 */  cmpOp_rule,
  /* 1157 */  cmpOpU_rule,
  /* 1158 */  cmpOpEqNe_rule,
  /* 1159 */  cmpOpEqNe_rule,
  /* 1160 */  cmpOpEqNe_rule,
  /* 1161 */  cmpOpEqNe_rule,
  /* 1162 */  cmpOpEqNe_rule,
  /* 1163 */  cmpOpUEqNeLtGe_rule,
  /* 1164 */  cmpOpUEqNeLtGe_rule,
  /* 1165 */  cmpOpLtGe_rule,
  /* 1166 */  cmpOpLtGe_rule,
  /* 1167 */  cmpOpEqNe_rule,
  /* 1168 */  cmpOpEqNe_rule,
  /* 1169 */  cmpOpLtGe_rule,
  /* 1170 */  cmpOpLtGe_rule,
  /* 1171 */  cmpOpEqNe_rule,
  /* 1172 */  cmpOpEqNe_rule,
  /* 1173 */  cmpOp_rule,
  /* 1174 */  iRegP_rule,
  /* 1175 */  0,
  /* 1176 */  0,
  /* 1177 */  0,
  /* 1178 */  0,
  /* 1179 */  0,
  /* 1180 */  iRegPNoSp_rule,
  /* 1181 */  iRegPNoSp_rule,
  /* 1182 */  0,
  /* 1183 */  0,
  /* 1184 */  0,
  /* 1185 */  0,
  /* 1186 */  iRegP_R4_rule,
  /* 1187 */  _Binary_iRegP_R1_iRegI_R2_rule,
  /* 1188 */  _Binary_iRegP_R1_iRegI_R2_rule,
  /* 1189 */  _Binary_iRegP_R1_iRegI_R2_rule,
  /* 1190 */  _Binary_iRegP_R1_iRegI_R2_rule,
  /* 1191 */  _Binary_iRegP_R1_iRegI_R2_rule,
  /* 1192 */  _Binary_iRegP_R1_iRegI_R2_rule,
  /* 1193 */  _Binary_iRegP_R1_iRegI_R2_rule,
  /* 1194 */  _Binary_iRegP_R1_iRegI_R2_rule,
  /* 1195 */  _Binary_iRegP_R1_iRegI_R4_rule,
  /* 1196 */  _Binary_iRegP_R1_iRegI_R4_rule,
  /* 1197 */  _Binary_iRegP_R1_iRegI_R4_rule,
  /* 1198 */  _Binary_iRegP_R1_iRegI_R4_rule,
  /* 1199 */  _Binary_iRegP_R1_iRegI_R4_rule,
  /* 1200 */  _Binary_iRegP_R1_iRegI_R4_rule,
  /* 1201 */  _Binary_iRegP_R1_iRegI_R2_rule,
  /* 1202 */  _Binary_iRegP_R1_iRegI_R2_rule,
  /* 1203 */  _Binary_iRegP_R1_iRegI_R2_rule,
  /* 1204 */  _Binary_iRegP_R1_iRegI_R2_rule,
  /* 1205 */  _Binary_iRegP_R1_iRegP_R3_rule,
  /* 1206 */  iRegP_R1_rule,
  /* 1207 */  iRegP_R1_rule,
  /* 1208 */  iRegP_R1_rule,
  /* 1209 */  iRegP_R2_rule,
  /* 1210 */  iRegP_R0_rule,
  /* 1211 */  iRegP_R2_rule,
  /* 1212 */  iRegP_R2_rule,
  /* 1213 */  iRegIorL2I_rule,
  /* 1214 */  _LoadI_memory4__rule,
  /* 1215 */  iRegL_rule,
  /* 1216 */  _LoadL_memory8__rule,
  /* 1217 */  iRegIorL2I_rule,
  /* 1218 */  _LoadI_memory4__rule,
  /* 1219 */  iRegL_rule,
  /* 1220 */  _LoadL_memory8__rule,
  /* 1221 */  vmem2_rule,
  /* 1222 */  vmem2_rule,
  /* 1223 */  vmem4_rule,
  /* 1224 */  vmem4_rule,
  /* 1225 */  vmem8_rule,
  /* 1226 */  vmem8_rule,
  /* 1227 */  vmem16_rule,
  /* 1228 */  vmem16_rule,
  /* 1229 */  vmemA_rule,
  /* 1230 */  vmemA_rule,
  /* 1231 */  vmemA_rule,
  /* 1232 */  vmemA_rule,
  /* 1233 */  vReg_rule,
  /* 1234 */  vReg_rule,
  /* 1235 */  vReg_rule,
  /* 1236 */  vReg_rule,
  /* 1237 */  vReg_rule,
  /* 1238 */  vReg_rule,
  /* 1239 */  _Binary_vReg_vReg_rule,
  /* 1240 */  _Binary_vReg_vReg_rule,
  /* 1241 */  _Binary_vReg_vReg_rule,
  /* 1242 */  _Binary_vReg_vReg_rule,
  /* 1243 */  _Binary_vReg_vReg_rule,
  /* 1244 */  _Binary_vReg_vReg_rule,
  /* 1245 */  vReg_rule,
  /* 1246 */  _Replicate_immBAddSubV__rule,
  /* 1247 */  vReg_rule,
  /* 1248 */  _Replicate_immIAddSubV__rule,
  /* 1249 */  vReg_rule,
  /* 1250 */  _Replicate_immIAddSubV__rule,
  /* 1251 */  vReg_rule,
  /* 1252 */  _Replicate_immLAddSubV__rule,
  /* 1253 */  vReg_rule,
  /* 1254 */  vReg_rule,
  /* 1255 */  vReg_rule,
  /* 1256 */  vReg_rule,
  /* 1257 */  vReg_rule,
  /* 1258 */  vReg_rule,
  /* 1259 */  _Binary_vReg_vReg_rule,
  /* 1260 */  _Binary_vReg_vReg_rule,
  /* 1261 */  _Binary_vReg_vReg_rule,
  /* 1262 */  _Binary_vReg_vReg_rule,
  /* 1263 */  _Binary_vReg_vReg_rule,
  /* 1264 */  _Binary_vReg_vReg_rule,
  /* 1265 */  vReg_rule,
  /* 1266 */  vReg_rule,
  /* 1267 */  vReg_rule,
  /* 1268 */  vReg_rule,
  /* 1269 */  vReg_rule,
  /* 1270 */  vReg_rule,
  /* 1271 */  vReg_rule,
  /* 1272 */  vReg_rule,
  /* 1273 */  vReg_rule,
  /* 1274 */  vReg_rule,
  /* 1275 */  _Binary_vReg_vReg_rule,
  /* 1276 */  _Binary_vReg_vReg_rule,
  /* 1277 */  _Binary_vReg_vReg_rule,
  /* 1278 */  _Binary_vReg_vReg_rule,
  /* 1279 */  _Binary_vReg_vReg_rule,
  /* 1280 */  _Binary_vReg_vReg_rule,
  /* 1281 */  vReg_rule,
  /* 1282 */  vReg_rule,
  /* 1283 */  vReg_rule,
  /* 1284 */  vReg_rule,
  /* 1285 */  _Binary_vReg_vReg_rule,
  /* 1286 */  _Binary_vReg_vReg_rule,
  /* 1287 */  vReg_rule,
  /* 1288 */  _Binary_vReg_vReg_rule,
  /* 1289 */  vReg_rule,
  /* 1290 */  _Replicate_immBLog__rule,
  /* 1291 */  vReg_rule,
  /* 1292 */  _Replicate_immSLog__rule,
  /* 1293 */  vReg_rule,
  /* 1294 */  _Replicate_immILog__rule,
  /* 1295 */  vReg_rule,
  /* 1296 */  _Replicate_immLLog__rule,
  /* 1297 */  vReg_rule,
  /* 1298 */  _Binary_vReg_vReg_rule,
  /* 1299 */  vReg_rule,
  /* 1300 */  _Replicate_immBLog__rule,
  /* 1301 */  vReg_rule,
  /* 1302 */  _Replicate_immSLog__rule,
  /* 1303 */  vReg_rule,
  /* 1304 */  _Replicate_immILog__rule,
  /* 1305 */  vReg_rule,
  /* 1306 */  _Replicate_immLLog__rule,
  /* 1307 */  vReg_rule,
  /* 1308 */  _Binary_vReg_vReg_rule,
  /* 1309 */  vReg_rule,
  /* 1310 */  _Replicate_immBLog__rule,
  /* 1311 */  vReg_rule,
  /* 1312 */  _Replicate_immSLog__rule,
  /* 1313 */  vReg_rule,
  /* 1314 */  _Replicate_immILog__rule,
  /* 1315 */  vReg_rule,
  /* 1316 */  _Replicate_immLLog__rule,
  /* 1317 */  vReg_rule,
  /* 1318 */  _XorV_vReg_vReg_rule,
  /* 1319 */  vReg_rule,
  /* 1320 */  _XorV_vReg_vReg_rule,
  /* 1321 */  vReg_rule,
  /* 1322 */  _Replicate_immI_M1__rule,
  /* 1323 */  vReg_rule,
  /* 1324 */  _Replicate_immL_M1__rule,
  /* 1325 */  _Binary_vReg__Replicate_immI_M1__rule,
  /* 1326 */  _Binary_vReg__Replicate_immL_M1__rule,
  /* 1327 */  vReg_rule,
  /* 1328 */  _XorV_vReg__Replicate_immI_M1__rule,
  /* 1329 */  vReg_rule,
  /* 1330 */  _XorV__Replicate_immI_M1__vReg_rule,
  /* 1331 */  vReg_rule,
  /* 1332 */  _XorV_vReg__Replicate_immL_M1__rule,
  /* 1333 */  vReg_rule,
  /* 1334 */  _XorV__Replicate_immL_M1__vReg_rule,
  /* 1335 */  _Binary_vReg__XorV_vReg__Replicate_immI_M1__rule,
  /* 1336 */  _Binary_vReg__XorV__Replicate_immI_M1__vReg_rule,
  /* 1337 */  _Binary_vReg__XorV_vReg__Replicate_immL_M1__rule,
  /* 1338 */  _Binary_vReg__XorV__Replicate_immL_M1__vReg_rule,
  /* 1339 */  vReg_rule,
  /* 1340 */  vReg_rule,
  /* 1341 */  vReg_rule,
  /* 1342 */  vReg_rule,
  /* 1343 */  vReg_rule,
  /* 1344 */  vReg_rule,
  /* 1345 */  _SubVF_vReg_vReg_rule,
  /* 1346 */  _SubVD_vReg_vReg_rule,
  /* 1347 */  _SubVF_vReg_vReg_rule,
  /* 1348 */  _SubVD_vReg_vReg_rule,
  /* 1349 */  _SubVF__Binary_vReg_vReg_pRegGov_rule,
  /* 1350 */  _SubVD__Binary_vReg_vReg_pRegGov_rule,
  /* 1351 */  vReg_rule,
  /* 1352 */  vReg_rule,
  /* 1353 */  vReg_rule,
  /* 1354 */  vReg_rule,
  /* 1355 */  vReg_rule,
  /* 1356 */  vReg_rule,
  /* 1357 */  vReg_rule,
  /* 1358 */  vReg_rule,
  /* 1359 */  vReg_rule,
  /* 1360 */  vReg_rule,
  /* 1361 */  _Binary_vReg_vReg_rule,
  /* 1362 */  vReg_rule,
  /* 1363 */  vReg_rule,
  /* 1364 */  vReg_rule,
  /* 1365 */  vReg_rule,
  /* 1366 */  _Binary_vReg_vReg_rule,
  /* 1367 */  vReg_rule,
  /* 1368 */  _MulVB_vReg_vReg_rule,
  /* 1369 */  vReg_rule,
  /* 1370 */  _MulVS_vReg_vReg_rule,
  /* 1371 */  vReg_rule,
  /* 1372 */  _MulVI_vReg_vReg_rule,
  /* 1373 */  vReg_rule,
  /* 1374 */  _MulVL_vReg_vReg_rule,
  /* 1375 */  _Binary_vReg__MulVB_vReg_vReg_rule,
  /* 1376 */  _Binary_vReg__MulVS_vReg_vReg_rule,
  /* 1377 */  _Binary_vReg__MulVI_vReg_vReg_rule,
  /* 1378 */  _Binary_vReg__MulVL_vReg_vReg_rule,
  /* 1379 */  vReg_rule,
  /* 1380 */  vReg_rule,
  /* 1381 */  _Binary_vReg_vReg_rule,
  /* 1382 */  _Binary_vReg_vReg_rule,
  /* 1383 */  vReg_rule,
  /* 1384 */  vReg_rule,
  /* 1385 */  vReg_rule,
  /* 1386 */  vReg_rule,
  /* 1387 */  _Binary_vReg__MulVB_vReg_vReg_rule,
  /* 1388 */  _Binary_vReg__MulVS_vReg_vReg_rule,
  /* 1389 */  _Binary_vReg__MulVI_vReg_vReg_rule,
  /* 1390 */  _Binary_vReg__MulVL_vReg_vReg_rule,
  /* 1391 */  vReg_rule,
  /* 1392 */  vReg_rule,
  /* 1393 */  _Binary_vReg__NegVF_vReg__rule,
  /* 1394 */  _Binary_vReg__NegVD_vReg__rule,
  /* 1395 */  _NegVF_vReg__rule,
  /* 1396 */  _NegVD_vReg__rule,
  /* 1397 */  _Binary_vReg__NegVF_vReg__rule,
  /* 1398 */  _Binary_vReg__NegVD_vReg__rule,
  /* 1399 */  _NegVF_vReg__rule,
  /* 1400 */  _NegVD_vReg__rule,
  /* 1401 */  _Binary_vReg_vReg_rule,
  /* 1402 */  _Binary_vReg_vReg_rule,
  /* 1403 */  vReg_rule,
  /* 1404 */  vReg_rule,
  /* 1405 */  vReg_rule,
  /* 1406 */  vReg_rule,
  /* 1407 */  vReg_rule,
  /* 1408 */  vReg_rule,
  /* 1409 */  vReg_rule,
  /* 1410 */  vReg_rule,
  /* 1411 */  vReg_rule,
  /* 1412 */  vReg_rule,
  /* 1413 */  vReg_rule,
  /* 1414 */  vReg_rule,
  /* 1415 */  vReg_rule,
  /* 1416 */  vReg_rule,
  /* 1417 */  vReg_rule,
  /* 1418 */  vReg_rule,
  /* 1419 */  vReg_rule,
  /* 1420 */  vReg_rule,
  /* 1421 */  vReg_rule,
  /* 1422 */  vReg_rule,
  /* 1423 */  vReg_rule,
  /* 1424 */  vReg_rule,
  /* 1425 */  vReg_rule,
  /* 1426 */  vReg_rule,
  /* 1427 */  vReg_rule,
  /* 1428 */  vReg_rule,
  /* 1429 */  vReg_rule,
  /* 1430 */  vReg_rule,
  /* 1431 */  vReg_rule,
  /* 1432 */  vReg_rule,
  /* 1433 */  vReg_rule,
  /* 1434 */  vReg_rule,
  /* 1435 */  vReg_rule,
  /* 1436 */  vReg_rule,
  /* 1437 */  vReg_rule,
  /* 1438 */  vReg_rule,
  /* 1439 */  vReg_rule,
  /* 1440 */  vReg_rule,
  /* 1441 */  vReg_rule,
  /* 1442 */  vReg_rule,
  /* 1443 */  vReg_rule,
  /* 1444 */  vReg_rule,
  /* 1445 */  vReg_rule,
  /* 1446 */  vReg_rule,
  /* 1447 */  vReg_rule,
  /* 1448 */  vReg_rule,
  /* 1449 */  _RShiftVB_vReg__RShiftCntV_immI_positive__rule,
  /* 1450 */  vReg_rule,
  /* 1451 */  _RShiftVS_vReg__RShiftCntV_immI_positive__rule,
  /* 1452 */  vReg_rule,
  /* 1453 */  _RShiftVI_vReg__RShiftCntV_immI_positive__rule,
  /* 1454 */  vReg_rule,
  /* 1455 */  _RShiftVL_vReg__RShiftCntV_immI_positive__rule,
  /* 1456 */  vReg_rule,
  /* 1457 */  _URShiftVB_vReg__RShiftCntV_immI_positive__rule,
  /* 1458 */  vReg_rule,
  /* 1459 */  _URShiftVS_vReg__RShiftCntV_immI_positive__rule,
  /* 1460 */  vReg_rule,
  /* 1461 */  _URShiftVI_vReg__RShiftCntV_immI_positive__rule,
  /* 1462 */  vReg_rule,
  /* 1463 */  _URShiftVL_vReg__RShiftCntV_immI_positive__rule,
  /* 1464 */  _Binary_vReg_vReg_rule,
  /* 1465 */  _Binary_vReg_vReg_rule,
  /* 1466 */  _Binary_vReg_vReg_rule,
  /* 1467 */  _Binary_vReg_vReg_rule,
  /* 1468 */  _Binary_vReg_vReg_rule,
  /* 1469 */  _Binary_vReg_vReg_rule,
  /* 1470 */  _Binary_vReg_vReg_rule,
  /* 1471 */  _Binary_vReg_vReg_rule,
  /* 1472 */  _Binary_vReg_vReg_rule,
  /* 1473 */  _Binary_vReg_vReg_rule,
  /* 1474 */  _Binary_vReg_vReg_rule,
  /* 1475 */  _Binary_vReg_vReg_rule,
  /* 1476 */  _Binary_vReg__LShiftCntV_immI__rule,
  /* 1477 */  _Binary_vReg__LShiftCntV_immI__rule,
  /* 1478 */  _Binary_vReg__LShiftCntV_immI__rule,
  /* 1479 */  _Binary_vReg__LShiftCntV_immI__rule,
  /* 1480 */  _Binary_vReg__RShiftCntV_immI_positive__rule,
  /* 1481 */  _Binary_vReg__RShiftCntV_immI_positive__rule,
  /* 1482 */  _Binary_vReg__RShiftCntV_immI_positive__rule,
  /* 1483 */  _Binary_vReg__RShiftCntV_immI_positive__rule,
  /* 1484 */  _Binary_vReg__RShiftCntV_immI_positive__rule,
  /* 1485 */  _Binary_vReg__RShiftCntV_immI_positive__rule,
  /* 1486 */  _Binary_vReg__RShiftCntV_immI_positive__rule,
  /* 1487 */  _Binary_vReg__RShiftCntV_immI_positive__rule,
  /* 1488 */  iRegIorL2I_rule,
  /* 1489 */  iRegIorL2I_rule,
  /* 1490 */  iRegL_rule,
  /* 1491 */  iRegL_rule,
  /* 1492 */  vRegF_rule,
  /* 1493 */  vRegF_rule,
  /* 1494 */  vRegF_rule,
  /* 1495 */  vRegD_rule,
  /* 1496 */  vRegD_rule,
  /* 1497 */  _Binary_iRegIorL2I_vReg_rule,
  /* 1498 */  _Binary_iRegL_vReg_rule,
  /* 1499 */  _Binary_vRegF_vReg_rule,
  /* 1500 */  _Binary_vRegD_vReg_rule,
  /* 1501 */  iRegIorL2I_rule,
  /* 1502 */  iRegL_rule,
  /* 1503 */  vRegF_rule,
  /* 1504 */  vRegD_rule,
  /* 1505 */  iRegIorL2I_rule,
  /* 1506 */  iRegIorL2I_rule,
  /* 1507 */  iRegL_rule,
  /* 1508 */  iRegL_rule,
  /* 1509 */  _Binary_iRegIorL2I_vReg_rule,
  /* 1510 */  _Binary_iRegL_vReg_rule,
  /* 1511 */  iRegIorL2I_rule,
  /* 1512 */  iRegIorL2I_rule,
  /* 1513 */  iRegL_rule,
  /* 1514 */  iRegL_rule,
  /* 1515 */  _Binary_iRegIorL2I_vReg_rule,
  /* 1516 */  _Binary_iRegL_vReg_rule,
  /* 1517 */  iRegIorL2I_rule,
  /* 1518 */  iRegIorL2I_rule,
  /* 1519 */  iRegL_rule,
  /* 1520 */  iRegL_rule,
  /* 1521 */  _Binary_iRegIorL2I_vReg_rule,
  /* 1522 */  _Binary_iRegL_vReg_rule,
  /* 1523 */  iRegIorL2I_rule,
  /* 1524 */  iRegIorL2I_rule,
  /* 1525 */  iRegL_rule,
  /* 1526 */  iRegL_rule,
  /* 1527 */  vRegF_rule,
  /* 1528 */  vRegD_rule,
  /* 1529 */  _Binary_iRegIorL2I_vReg_rule,
  /* 1530 */  _Binary_iRegL_vReg_rule,
  /* 1531 */  _Binary_vRegF_vReg_rule,
  /* 1532 */  _Binary_vRegD_vReg_rule,
  /* 1533 */  iRegIorL2I_rule,
  /* 1534 */  iRegIorL2I_rule,
  /* 1535 */  iRegL_rule,
  /* 1536 */  iRegL_rule,
  /* 1537 */  vRegF_rule,
  /* 1538 */  vRegD_rule,
  /* 1539 */  _Binary_iRegIorL2I_vReg_rule,
  /* 1540 */  _Binary_iRegL_vReg_rule,
  /* 1541 */  _Binary_vRegF_vReg_rule,
  /* 1542 */  _Binary_vRegD_vReg_rule,
  /* 1543 */  vReg_rule,
  /* 1544 */  vReg_rule,
  /* 1545 */  vReg_rule,
  /* 1546 */  vReg_rule,
  /* 1547 */  vReg_rule,
  /* 1548 */  vReg_rule,
  /* 1549 */  vReg_rule,
  /* 1550 */  vReg_rule,
  /* 1551 */  vReg_rule,
  /* 1552 */  vReg_rule,
  /* 1553 */  vReg_rule,
  /* 1554 */  vReg_rule,
  /* 1555 */  vReg_rule,
  /* 1556 */  _Binary_vReg_iRegIorL2I_rule,
  /* 1557 */  _Binary_vReg_iRegIorL2I_rule,
  /* 1558 */  _Binary_vReg_iRegIorL2I_rule,
  /* 1559 */  _Binary_vReg_iRegL_rule,
  /* 1560 */  _Binary_vReg_iRegL_rule,
  /* 1561 */  _Binary_vReg_vRegF_rule,
  /* 1562 */  _Binary_vReg_vRegF_rule,
  /* 1563 */  _Binary_vReg_vRegF_rule,
  /* 1564 */  _Binary_vReg_vRegD_rule,
  /* 1565 */  _Binary_vReg_vRegD_rule,
  /* 1566 */  vReg_rule,
  /* 1567 */  vReg_rule,
  /* 1568 */  vReg_rule,
  /* 1569 */  vReg_rule,
  /* 1570 */  vReg_rule,
  /* 1571 */  vReg_rule,
  /* 1572 */  vReg_rule,
  /* 1573 */  vReg_rule,
  /* 1574 */  vReg_rule,
  /* 1575 */  vReg_rule,
  /* 1576 */  vReg_rule,
  /* 1577 */  vReg_rule,
  /* 1578 */  vReg_rule,
  /* 1579 */  vReg_rule,
  /* 1580 */  vReg_rule,
  /* 1581 */  vReg_rule,
  /* 1582 */  vReg_rule,
  /* 1583 */  vReg_rule,
  /* 1584 */  vReg_rule,
  /* 1585 */  pReg_rule,
  /* 1586 */  pReg_rule,
  /* 1587 */  _LoadVector_indirect__rule,
  /* 1588 */  _LoadVector_indirect__rule,
  /* 1589 */  _LoadVectorMasked_vmemA_pRegGov_rule,
  /* 1590 */  _LoadVectorMasked_vmemA_pRegGov_rule,
  /* 1591 */  indirect_rule,
  /* 1592 */  indirect_rule,
  /* 1593 */  vmemA_rule,
  /* 1594 */  vmemA_rule,
  /* 1595 */  pReg_rule,
  /* 1596 */  pReg_rule,
  /* 1597 */  pReg_rule,
  /* 1598 */  pReg_rule,
  /* 1599 */  pReg_rule,
  /* 1600 */  _Binary_vReg_vReg_rule,
  /* 1601 */  _Binary_vReg__Replicate_immI0__rule,
  /* 1602 */  _Binary_vReg__Replicate_immL0__rule,
  /* 1603 */  _Binary_vReg__Replicate_immF0__rule,
  /* 1604 */  _Binary_vReg__Replicate_immD0__rule,
  /* 1605 */  _Binary_vReg_vReg_rule,
  /* 1606 */  _Binary_vReg__Replicate_immI5__rule,
  /* 1607 */  _Binary_vReg__Replicate_immIU7__rule,
  /* 1608 */  _Binary_vReg__Replicate_immL5__rule,
  /* 1609 */  _Binary_vReg__Replicate_immLU7__rule,
  /* 1610 */  _Binary_vReg_vReg_rule,
  /* 1611 */  pReg_rule,
  /* 1612 */  pReg_rule,
  /* 1613 */  vReg_rule,
  /* 1614 */  _VectorStoreMask_vReg_immI_gt_1_rule,
  /* 1615 */  pReg_rule,
  /* 1616 */  pReg_rule,
  /* 1617 */  pReg_rule,
  /* 1618 */  pReg_rule,
  /* 1619 */  iRegL_rule,
  /* 1620 */  immI_rule,
  /* 1621 */  iRegIorL2I_rule,
  /* 1622 */  iRegIorL2I_rule,
  /* 1623 */  immL_rule,
  /* 1624 */  iRegL_rule,
  /* 1625 */  iRegL_rule,
  /* 1626 */  _ConvI2L_iRegIorL2I__rule,
  /* 1627 */  iRegL_rule,
  /* 1628 */  immL_rule,
  /* 1629 */  _SubL_iRegL_iRegL_rule,
  /* 1630 */  vReg_rule,
  /* 1631 */  vReg_rule,
  /* 1632 */  _Binary_vReg_vReg_rule,
  /* 1633 */  _Binary_vReg_vReg_rule,
  /* 1634 */  vReg_rule,
  /* 1635 */  vReg_rule,
  /* 1636 */  vReg_rule,
  /* 1637 */  vReg_rule,
  /* 1638 */  vReg_rule,
  /* 1639 */  vReg_rule,
  /* 1640 */  vReg_rule,
  /* 1641 */  indirect_rule,
  /* 1642 */  indirect_rule,
  /* 1643 */  indirect_rule,
  /* 1644 */  indirect_rule,
  /* 1645 */  indirect_rule,
  /* 1646 */  indirect_rule,
  /* 1647 */  indirect_rule,
  /* 1648 */  indirect_rule,
  /* 1649 */  vReg_rule,
  /* 1650 */  vReg_rule,
  /* 1651 */  vReg_rule,
  /* 1652 */  vReg_rule,
  /* 1653 */  iRegIorL2I_rule,
  /* 1654 */  pReg_rule,
  /* 1655 */  vReg_rule,
  /* 1656 */  vReg_rule,
  /* 1657 */  vReg_rule,
  /* 1658 */  vReg_rule,
  /* 1659 */  vReg_rule,
  /* 1660 */  vReg_rule,
  /* 1661 */  vReg_rule,
  /* 1662 */  vReg_rule,
  /* 1663 */  vReg_rule,
  /* 1664 */  vReg_rule,
  /* 1665 */  indirect_rule,
  /* 1666 */  indirect_rule,
  /* 1667 */  indirect_rule,
  /* 1668 */  indirect_rule,
  /* 1669 */  indirect_rule,
  /* 1670 */  indirect_rule,
  /* 1671 */  indirect_rule,
  /* 1672 */  indirect_rule,
  /* 1673 */  indirect_rule,
  /* 1674 */  indirect_rule,
  /* 1675 */  indirect_rule,
  /* 1676 */  indirect_rule,
  /* 1677 */  memory8_rule,
  /* 1678 */  indirect_rule,
  /* 1679 */  indirect_rule,
  /* 1680 */  indirect_rule,
  /* 1681 */  indirect_rule,
  /* 1682 */  indirect_rule,
  /* 1683 */  indirect_rule,
  /* 1684 */  indirect_rule,
  /* 1685 */  indirect_rule,
  /* 1686 */  indirect_rule,
  /* 1687 */  memory8_rule,
  /* 1688 */  indirect_rule,
  /* 1689 */  memory_rule,
  /* 1690 */  indirect_rule,
  /* 1691 */  indirect_rule,
  /* 1692 */  indirect_rule,
  /* 1693 */  indirect_rule,
  /* 1694 */  indirect_rule,
  /* 1695 */  indirect_rule,
  /* 1696 */  indirect_rule,
  /* 1697 */  indirect_rule,
  /* 1698 */  indirect_rule,
  // last instruction
  0 // no trailing comma
};

const        int   rightOp[] = {
  /*    0 */  0,
  /*    1 */  0,
  /*    2 */  0,
  /*    3 */  0,
  /*    4 */  0,
  /*    5 */  0,
  /*    6 */  0,
  /*    7 */  0,
  /*    8 */  0,
  /*    9 */  0,
  /*   10 */  0,
  /*   11 */  0,
  /*   12 */  0,
  /*   13 */  0,
  /*   14 */  0,
  /*   15 */  0,
  /*   16 */  0,
  /*   17 */  0,
  /*   18 */  0,
  /*   19 */  0,
  /*   20 */  0,
  /*   21 */  0,
  /*   22 */  0,
  /*   23 */  0,
  /*   24 */  0,
  /*   25 */  0,
  /*   26 */  0,
  /*   27 */  0,
  /*   28 */  0,
  /*   29 */  0,
  /*   30 */  0,
  /*   31 */  0,
  /*   32 */  0,
  /*   33 */  0,
  /*   34 */  0,
  /*   35 */  0,
  /*   36 */  0,
  /*   37 */  0,
  /*   38 */  0,
  /*   39 */  0,
  /*   40 */  0,
  /*   41 */  0,
  /*   42 */  0,
  /*   43 */  0,
  /*   44 */  0,
  /*   45 */  0,
  /*   46 */  0,
  /*   47 */  0,
  /*   48 */  0,
  /*   49 */  0,
  /*   50 */  0,
  /*   51 */  0,
  /*   52 */  0,
  /*   53 */  0,
  /*   54 */  0,
  /*   55 */  0,
  /*   56 */  0,
  /*   57 */  0,
  /*   58 */  0,
  /*   59 */  0,
  /*   60 */  0,
  /*   61 */  0,
  /*   62 */  0,
  /*   63 */  0,
  /*   64 */  0,
  /*   65 */  0,
  /*   66 */  0,
  /*   67 */  0,
  /*   68 */  0,
  /*   69 */  0,
  /*   70 */  0,
  /*   71 */  0,
  /*   72 */  0,
  /*   73 */  0,
  /*   74 */  0,
  /*   75 */  0,
  /*   76 */  0,
  /*   77 */  0,
  /*   78 */  0,
  /*   79 */  0,
  /*   80 */  0,
  /*   81 */  0,
  /*   82 */  0,
  /*   83 */  0,
  /*   84 */  0,
  /*   85 */  0,
  /*   86 */  0,
  /*   87 */  0,
  /*   88 */  0,
  /*   89 */  0,
  /*   90 */  0,
  /*   91 */  0,
  /*   92 */  0,
  /*   93 */  0,
  /*   94 */  0,
  /*   95 */  0,
  /*   96 */  0,
  /*   97 */  0,
  /*   98 */  0,
  /*   99 */  0,
  /*  100 */  0,
  /*  101 */  0,
  /*  102 */  0,
  /*  103 */  0,
  /*  104 */  0,
  /*  105 */  0,
  /*  106 */  0,
  /*  107 */  0,
  /*  108 */  0,
  /*  109 */  0,
  /*  110 */  0,
  /*  111 */  0,
  /*  112 */  0,
  /*  113 */  0,
  /*  114 */  0,
  /*  115 */  0,
  /*  116 */  0,
  /*  117 */  0,
  /*  118 */  0,
  /*  119 */  0,
  /*  120 */  0,
  /*  121 */  _LShiftL__ConvI2L_iRegI__immIScale_rule,
  /*  122 */  _LShiftL_iRegL_immIScale_rule,
  /*  123 */  _ConvI2L_iRegI__rule,
  /*  124 */  iRegL_rule,
  /*  125 */  immIOffset1_rule,
  /*  126 */  immIOffset2_rule,
  /*  127 */  immIOffset4_rule,
  /*  128 */  immIOffset8_rule,
  /*  129 */  immIOffset16_rule,
  /*  130 */  immLoffset1_rule,
  /*  131 */  immLoffset2_rule,
  /*  132 */  immLoffset4_rule,
  /*  133 */  immLoffset8_rule,
  /*  134 */  immLoffset16_rule,
  /*  135 */  0,
  /*  136 */  _LShiftL__ConvI2L_iRegI__immIScale_rule,
  /*  137 */  _LShiftL_iRegL_immIScale_rule,
  /*  138 */  _ConvI2L_iRegI__rule,
  /*  139 */  iRegL_rule,
  /*  140 */  immIOffset_rule,
  /*  141 */  immLoffset_rule,
  /*  142 */  0,
  /*  143 */  0,
  /*  144 */  0,
  /*  145 */  0,
  /*  146 */  0,
  /*  147 */  0,
  /*  148 */  0,
  /*  149 */  0,
  /*  150 */  0,
  /*  151 */  0,
  /*  152 */  0,
  /*  153 */  0,
  /*  154 */  0,
  /*  155 */  vmemA_immIOffset4_rule,
  /*  156 */  vmemA_immLOffset4_rule,
  // last operand
  /*  157 */  0,
  /*  158 */  0,
  /*  159 */  0,
  /*  160 */  0,
  /*  161 */  0,
  /*  162 */  0,
  /*  163 */  0,
  /*  164 */  0,
  /*  165 */  0,
  /*  166 */  0,
  /*  167 */  0,
  // last operand class
  /*  168 */  0,
  /*  169 */  immIScale_rule,
  /*  170 */  immIScale_rule,
  /*  171 */  0,
  /*  172 */  0,
  /*  173 */  0,
  /*  174 */  0,
  /*  175 */  0,
  /*  176 */  0,
  /*  177 */  0,
  /*  178 */  0,
  /*  179 */  0,
  /*  180 */  0,
  /*  181 */  0,
  /*  182 */  0,
  /*  183 */  0,
  /*  184 */  0,
  /*  185 */  0,
  /*  186 */  0,
  /*  187 */  iRegINoSp_rule,
  /*  188 */  iRegLNoSp_rule,
  /*  189 */  iRegP_rule,
  /*  190 */  iRegNNoSp_rule,
  /*  191 */  iRegI_rule,
  /*  192 */  iRegL_rule,
  /*  193 */  iRegN_rule,
  /*  194 */  rFlagsReg_rule,
  /*  195 */  iRegIorL2I_rule,
  /*  196 */  rFlagsRegU_rule,
  /*  197 */  iRegIorL2I_rule,
  /*  198 */  immI0_rule,
  /*  199 */  immI0_rule,
  /*  200 */  immL0_rule,
  /*  201 */  iRegL_rule,
  /*  202 */  immP0_rule,
  /*  203 */  iRegP_rule,
  /*  204 */  immN0_rule,
  /*  205 */  iRegN_rule,
  /*  206 */  vRegF_rule,
  /*  207 */  vRegD_rule,
  /*  208 */  0,
  /*  209 */  0,
  /*  210 */  immIScale_rule,
  /*  211 */  iRegIorL2I_rule,
  /*  212 */  iRegIorL2I_rule,
  /*  213 */  iRegL_rule,
  /*  214 */  iRegL_rule,
  /*  215 */  _ConvI2L_iRegIorL2I__rule,
  /*  216 */  _ConvI2L_iRegIorL2I__rule,
  /*  217 */  immI_rule,
  /*  218 */  immI_rule,
  /*  219 */  immI_rule,
  /*  220 */  immI_rule,
  /*  221 */  immI_rule,
  /*  222 */  immI_rule,
  /*  223 */  immI_M1_rule,
  /*  224 */  immL_M1_rule,
  /*  225 */  iRegIorL2I_rule,
  /*  226 */  iRegL_rule,
  /*  227 */  immI_M1_rule,
  /*  228 */  immL_M1_rule,
  /*  229 */  immI_M1_rule,
  /*  230 */  immL_M1_rule,
  /*  231 */  immI_rule,
  /*  232 */  immI_M1_rule,
  /*  233 */  immI_rule,
  /*  234 */  immL_M1_rule,
  /*  235 */  immI_M1_rule,
  /*  236 */  immL_M1_rule,
  /*  237 */  iRegIorL2I_rule,
  /*  238 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  239 */  iRegL_rule,
  /*  240 */  _URShiftL_iRegL_immI_rule,
  /*  241 */  iRegIorL2I_rule,
  /*  242 */  _RShiftI_iRegIorL2I_immI_rule,
  /*  243 */  iRegL_rule,
  /*  244 */  _RShiftL_iRegL_immI_rule,
  /*  245 */  iRegIorL2I_rule,
  /*  246 */  _RotateRight_iRegIorL2I_immI_rule,
  /*  247 */  iRegL_rule,
  /*  248 */  _RotateRight_iRegL_immI_rule,
  /*  249 */  iRegIorL2I_rule,
  /*  250 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  251 */  iRegL_rule,
  /*  252 */  _LShiftL_iRegL_immI_rule,
  /*  253 */  immI_bitmask_rule,
  /*  254 */  immI_bitmask_rule,
  /*  255 */  immL_bitmask_rule,
  /*  256 */  immI_rule,
  /*  257 */  immL_positive_bitmaskI_rule,
  /*  258 */  immI_rule,
  /*  259 */  0,
  /*  260 */  0,
  /*  261 */  immI_bitmask_rule,
  /*  262 */  immI_16_rule,
  /*  263 */  immI_16_rule,
  /*  264 */  immI_24_rule,
  /*  265 */  immI_24_rule,
  /*  266 */  immI_24_rule,
  /*  267 */  immI_48_rule,
  /*  268 */  immI_48_rule,
  /*  269 */  immI_32_rule,
  /*  270 */  immI_32_rule,
  /*  271 */  immI_56_rule,
  /*  272 */  immI_56_rule,
  /*  273 */  immI_56_rule,
  /*  274 */  immI_255_rule,
  /*  275 */  immI_65535_rule,
  /*  276 */  immL_255_rule,
  /*  277 */  immL_65535_rule,
  /*  278 */  immL_4294967295_rule,
  /*  279 */  immIExt_rule,
  /*  280 */  immIExt_rule,
  /*  281 */  immIExt_rule,
  /*  282 */  immIExt_rule,
  /*  283 */  immIExt_rule,
  /*  284 */  immIExt_rule,
  /*  285 */  immIExt_rule,
  /*  286 */  immIExt_rule,
  /*  287 */  immIExt_rule,
  /*  288 */  immIExt_rule,
  /*  289 */  immIExt_rule,
  /*  290 */  0,
  /*  291 */  _NegF_vRegF__rule,
  /*  292 */  0,
  /*  293 */  _NegD_vRegD__rule,
  /*  294 */  vRegF_rule,
  /*  295 */  vRegD_rule,
  /*  296 */  iRegIorL2I_rule,
  /*  297 */  iRegL_rule,
  /*  298 */  immI0_rule,
  /*  299 */  immL0_rule,
  /*  300 */  immP0_rule,
  /*  301 */  immN0_rule,
  /*  302 */  immP0_rule,
  /*  303 */  immI0_rule,
  /*  304 */  immL0_rule,
  /*  305 */  immL_rule,
  /*  306 */  immL0_rule,
  /*  307 */  immI_rule,
  /*  308 */  immI0_rule,
  /*  309 */  iRegL_rule,
  /*  310 */  iRegIorL2I_rule,
  /*  311 */  iRegP_R0_rule,
  /*  312 */  iRegI_R2_rule,
  /*  313 */  iRegI_R4_rule,
  /*  314 */  iRegI_R4_rule,
  /*  315 */  iRegI_R2_rule,
  /*  316 */  immI_le_4_rule,
  /*  317 */  immI_1_rule,
  /*  318 */  iRegP_R3_rule,
  /*  319 */  iRegI_R3_rule,
  /*  320 */  pRegGov_rule,
  /*  321 */  vReg_rule,
  /*  322 */  0,
  /*  323 */  0,
  /*  324 */  0,
  /*  325 */  0,
  /*  326 */  0,
  /*  327 */  0,
  /*  328 */  0,
  /*  329 */  vReg_rule,
  /*  330 */  0,
  /*  331 */  0,
  /*  332 */  _Replicate_immI_M1__rule,
  /*  333 */  _Replicate_immL_M1__rule,
  /*  334 */  _Replicate_immI_M1__rule,
  /*  335 */  vReg_rule,
  /*  336 */  _Replicate_immL_M1__rule,
  /*  337 */  vReg_rule,
  /*  338 */  _XorV_vReg__Replicate_immI_M1__rule,
  /*  339 */  _XorV__Replicate_immI_M1__vReg_rule,
  /*  340 */  _XorV_vReg__Replicate_immL_M1__rule,
  /*  341 */  _XorV__Replicate_immL_M1__vReg_rule,
  /*  342 */  vReg_rule,
  /*  343 */  vReg_rule,
  /*  344 */  pRegGov_rule,
  /*  345 */  pRegGov_rule,
  /*  346 */  vReg_rule,
  /*  347 */  vReg_rule,
  /*  348 */  vReg_rule,
  /*  349 */  vReg_rule,
  /*  350 */  _MulVB_vReg_vReg_rule,
  /*  351 */  _MulVS_vReg_vReg_rule,
  /*  352 */  _MulVI_vReg_vReg_rule,
  /*  353 */  _MulVL_vReg_vReg_rule,
  /*  354 */  0,
  /*  355 */  _NegVF_vReg__rule,
  /*  356 */  0,
  /*  357 */  _NegVD_vReg__rule,
  /*  358 */  pRegGov_rule,
  /*  359 */  pRegGov_rule,
  /*  360 */  0,
  /*  361 */  0,
  /*  362 */  _RShiftCntV_immI_positive__rule,
  /*  363 */  _RShiftCntV_immI_positive__rule,
  /*  364 */  _RShiftCntV_immI_positive__rule,
  /*  365 */  _RShiftCntV_immI_positive__rule,
  /*  366 */  _RShiftCntV_immI_positive__rule,
  /*  367 */  _RShiftCntV_immI_positive__rule,
  /*  368 */  _RShiftCntV_immI_positive__rule,
  /*  369 */  _RShiftCntV_immI_positive__rule,
  /*  370 */  _LShiftCntV_immI__rule,
  /*  371 */  _RShiftCntV_immI_positive__rule,
  /*  372 */  vReg_rule,
  /*  373 */  vReg_rule,
  /*  374 */  vReg_rule,
  /*  375 */  vReg_rule,
  /*  376 */  iRegIorL2I_rule,
  /*  377 */  iRegL_rule,
  /*  378 */  vRegF_rule,
  /*  379 */  vRegD_rule,
  /*  380 */  0,
  /*  381 */  pRegGov_rule,
  /*  382 */  immI_gt_1_rule,
  /*  383 */  pRegGov_rule,
  /*  384 */  0,
  /*  385 */  _MaskAll_immI_M1__rule,
  /*  386 */  0,
  /*  387 */  _MaskAll_immL_M1__rule,
  /*  388 */  0,
  /*  389 */  _Replicate_immI0__rule,
  /*  390 */  0,
  /*  391 */  _Replicate_immL0__rule,
  /*  392 */  0,
  /*  393 */  _Replicate_immF0__rule,
  /*  394 */  0,
  /*  395 */  _Replicate_immD0__rule,
  /*  396 */  0,
  /*  397 */  _Replicate_immI5__rule,
  /*  398 */  0,
  /*  399 */  _Replicate_immIU7__rule,
  /*  400 */  0,
  /*  401 */  _Replicate_immL5__rule,
  /*  402 */  0,
  /*  403 */  _Replicate_immLU7__rule,
  /*  404 */  pRegGov_rule,
  /*  405 */  immI_gt_1_rule,
  /*  406 */  iRegL_rule,
  /*  407 */  _Binary_vReg_pRegGov_rule,
  // last internally defined operand
  /*  408 */  0,
  /*  409 */  0,
  /*  410 */  0,
  /*  411 */  0,
  /*  412 */  0,
  /*  413 */  0,
  /*  414 */  0,
  /*  415 */  0,
  /*  416 */  0,
  /*  417 */  0,
  /*  418 */  0,
  /*  419 */  0,
  /*  420 */  0,
  /*  421 */  0,
  /*  422 */  0,
  /*  423 */  0,
  /*  424 */  0,
  /*  425 */  0,
  /*  426 */  0,
  /*  427 */  0,
  /*  428 */  0,
  /*  429 */  0,
  /*  430 */  0,
  /*  431 */  0,
  /*  432 */  0,
  /*  433 */  0,
  /*  434 */  0,
  /*  435 */  0,
  /*  436 */  0,
  /*  437 */  0,
  /*  438 */  0,
  /*  439 */  0,
  /*  440 */  0,
  /*  441 */  0,
  /*  442 */  0,
  /*  443 */  0,
  /*  444 */  0,
  /*  445 */  0,
  /*  446 */  0,
  /*  447 */  0,
  /*  448 */  0,
  /*  449 */  iRegIorL2I_rule,
  /*  450 */  immIAddSub_rule,
  /*  451 */  iRegL_rule,
  /*  452 */  immLAddSub_rule,
  /*  453 */  iRegIorL2I_rule,
  /*  454 */  immIAddSub_rule,
  /*  455 */  iRegL_rule,
  /*  456 */  immLAddSub_rule,
  /*  457 */  iRegIorL2I_rule,
  /*  458 */  iRegL_rule,
  /*  459 */  iRegIorL2I_rule,
  /*  460 */  iRegL_rule,
  /*  461 */  iRegI_rule,
  /*  462 */  immI0_rule,
  /*  463 */  immIAddSub_rule,
  /*  464 */  immI_rule,
  /*  465 */  iRegI_rule,
  /*  466 */  immI0_rule,
  /*  467 */  immIAddSub_rule,
  /*  468 */  immI_rule,
  /*  469 */  iRegL_rule,
  /*  470 */  immL0_rule,
  /*  471 */  immLAddSub_rule,
  /*  472 */  immL_rule,
  /*  473 */  iRegL_rule,
  /*  474 */  immL0_rule,
  /*  475 */  immLAddSub_rule,
  /*  476 */  immL_rule,
  /*  477 */  iRegP_rule,
  /*  478 */  iRegN_rule,
  /*  479 */  immP0_rule,
  /*  480 */  immN0_rule,
  /*  481 */  vRegF_rule,
  /*  482 */  immF0_rule,
  /*  483 */  vRegD_rule,
  /*  484 */  immD0_rule,
  /*  485 */  0,
  /*  486 */  immL0_rule,
  /*  487 */  immI0_rule,
  /*  488 */  immL0_rule,
  /*  489 */  immI0_rule,
  /*  490 */  iRegP_rule,
  /*  491 */  iRegP_rule,
  /*  492 */  iRegP_rule,
  /*  493 */  iRegP_rule,
  /*  494 */  immP0_rule,
  /*  495 */  0,
  /*  496 */  0,
  /*  497 */  0,
  /*  498 */  0,
  /*  499 */  0,
  /*  500 */  0,
  /*  501 */  0,
  /*  502 */  0,
  /*  503 */  0,
  /*  504 */  0,
  /*  505 */  0,
  /*  506 */  0,
  /*  507 */  0,
  /*  508 */  0,
  /*  509 */  0,
  /*  510 */  0,
  /*  511 */  0,
  /*  512 */  0,
  /*  513 */  0,
  /*  514 */  0,
  /*  515 */  0,
  /*  516 */  0,
  /*  517 */  0,
  /*  518 */  0,
  /*  519 */  0,
  /*  520 */  0,
  /*  521 */  0,
  /*  522 */  0,
  /*  523 */  0,
  /*  524 */  0,
  /*  525 */  0,
  /*  526 */  0,
  /*  527 */  0,
  /*  528 */  0,
  /*  529 */  0,
  /*  530 */  0,
  /*  531 */  0,
  /*  532 */  0,
  /*  533 */  0,
  /*  534 */  0,
  /*  535 */  0,
  /*  536 */  0,
  /*  537 */  0,
  /*  538 */  0,
  /*  539 */  0,
  /*  540 */  0,
  /*  541 */  0,
  /*  542 */  0,
  /*  543 */  0,
  /*  544 */  0,
  /*  545 */  0,
  /*  546 */  0,
  /*  547 */  0,
  /*  548 */  0,
  /*  549 */  vReg_rule,
  /*  550 */  pReg_rule,
  /*  551 */  vReg_rule,
  /*  552 */  pReg_rule,
  /*  553 */  0,
  /*  554 */  0,
  /*  555 */  0,
  /*  556 */  0,
  /*  557 */  0,
  /*  558 */  0,
  /*  559 */  0,
  /*  560 */  0,
  /*  561 */  0,
  /*  562 */  0,
  /*  563 */  0,
  /*  564 */  0,
  /*  565 */  0,
  /*  566 */  0,
  /*  567 */  0,
  /*  568 */  immL_32bits_rule,
  /*  569 */  0,
  /*  570 */  0,
  /*  571 */  0,
  /*  572 */  0,
  /*  573 */  0,
  /*  574 */  0,
  /*  575 */  0,
  /*  576 */  0,
  /*  577 */  immI0_rule,
  /*  578 */  immI0_rule,
  /*  579 */  iRegIorL2I_rule,
  /*  580 */  immI0_rule,
  /*  581 */  iRegIorL2I_rule,
  /*  582 */  immI0_rule,
  /*  583 */  iRegIorL2I_rule,
  /*  584 */  immI0_rule,
  /*  585 */  iRegL_rule,
  /*  586 */  immL0_rule,
  /*  587 */  iRegP_rule,
  /*  588 */  immP0_rule,
  /*  589 */  iRegN_rule,
  /*  590 */  immN0_rule,
  /*  591 */  vRegF_rule,
  /*  592 */  vRegD_rule,
  /*  593 */  iRegN_rule,
  /*  594 */  0,
  /*  595 */  0,
  /*  596 */  0,
  /*  597 */  0,
  /*  598 */  0,
  /*  599 */  0,
  /*  600 */  0,
  /*  601 */  0,
  /*  602 */  0,
  /*  603 */  0,
  /*  604 */  immL_32bits_rule,
  /*  605 */  0,
  /*  606 */  0,
  /*  607 */  0,
  /*  608 */  0,
  /*  609 */  0,
  /*  610 */  iRegIorL2I_rule,
  /*  611 */  immI0_rule,
  /*  612 */  iRegIorL2I_rule,
  /*  613 */  immI0_rule,
  /*  614 */  iRegIorL2I_rule,
  /*  615 */  immI0_rule,
  /*  616 */  iRegL_rule,
  /*  617 */  immL0_rule,
  /*  618 */  iRegP_rule,
  /*  619 */  immP0_rule,
  /*  620 */  iRegN_rule,
  /*  621 */  immN0_rule,
  /*  622 */  vRegF_rule,
  /*  623 */  vRegD_rule,
  /*  624 */  0,
  /*  625 */  0,
  /*  626 */  0,
  /*  627 */  0,
  /*  628 */  0,
  /*  629 */  0,
  /*  630 */  0,
  /*  631 */  0,
  /*  632 */  0,
  /*  633 */  0,
  /*  634 */  0,
  /*  635 */  immL_positive_bitmaskI_rule,
  /*  636 */  0,
  /*  637 */  0,
  /*  638 */  0,
  /*  639 */  0,
  /*  640 */  0,
  /*  641 */  0,
  /*  642 */  0,
  /*  643 */  0,
  /*  644 */  0,
  /*  645 */  0,
  /*  646 */  0,
  /*  647 */  0,
  /*  648 */  0,
  /*  649 */  0,
  /*  650 */  0,
  /*  651 */  0,
  /*  652 */  0,
  /*  653 */  0,
  /*  654 */  0,
  /*  655 */  0,
  /*  656 */  _Binary_iRegINoSp_iRegINoSp_rule,
  /*  657 */  _Binary_iRegINoSp_iRegINoSp_rule,
  /*  658 */  _Binary_iRegINoSp_iRegINoSp_rule,
  /*  659 */  _Binary_iRegLNoSp_iRegLNoSp_rule,
  /*  660 */  _Binary_iRegP_iRegP_rule,
  /*  661 */  _Binary_iRegNNoSp_iRegNNoSp_rule,
  /*  662 */  _Binary_iRegINoSp_iRegINoSp_rule,
  /*  663 */  _Binary_iRegINoSp_iRegINoSp_rule,
  /*  664 */  _Binary_iRegINoSp_iRegINoSp_rule,
  /*  665 */  _Binary_iRegLNoSp_iRegLNoSp_rule,
  /*  666 */  _Binary_iRegP_iRegP_rule,
  /*  667 */  _Binary_iRegNNoSp_iRegNNoSp_rule,
  /*  668 */  _Binary_iRegI_iRegI_rule,
  /*  669 */  _Binary_iRegI_iRegI_rule,
  /*  670 */  _Binary_iRegI_iRegI_rule,
  /*  671 */  _Binary_iRegL_iRegL_rule,
  /*  672 */  _Binary_iRegN_iRegN_rule,
  /*  673 */  _Binary_iRegP_iRegP_rule,
  /*  674 */  _Binary_iRegI_iRegI_rule,
  /*  675 */  _Binary_iRegI_iRegI_rule,
  /*  676 */  _Binary_iRegI_iRegI_rule,
  /*  677 */  _Binary_iRegL_iRegL_rule,
  /*  678 */  _Binary_iRegN_iRegN_rule,
  /*  679 */  _Binary_iRegP_iRegP_rule,
  /*  680 */  _Binary_iRegI_iRegI_rule,
  /*  681 */  _Binary_iRegI_iRegI_rule,
  /*  682 */  _Binary_iRegI_iRegI_rule,
  /*  683 */  _Binary_iRegL_iRegL_rule,
  /*  684 */  _Binary_iRegN_iRegN_rule,
  /*  685 */  _Binary_iRegP_iRegP_rule,
  /*  686 */  _Binary_iRegI_iRegI_rule,
  /*  687 */  _Binary_iRegI_iRegI_rule,
  /*  688 */  _Binary_iRegI_iRegI_rule,
  /*  689 */  _Binary_iRegL_iRegL_rule,
  /*  690 */  _Binary_iRegN_iRegN_rule,
  /*  691 */  _Binary_iRegP_iRegP_rule,
  /*  692 */  iRegI_rule,
  /*  693 */  iRegL_rule,
  /*  694 */  iRegN_rule,
  /*  695 */  iRegP_rule,
  /*  696 */  iRegI_rule,
  /*  697 */  iRegL_rule,
  /*  698 */  iRegN_rule,
  /*  699 */  iRegP_rule,
  /*  700 */  iRegL_rule,
  /*  701 */  iRegL_rule,
  /*  702 */  immLAddSub_rule,
  /*  703 */  immLAddSub_rule,
  /*  704 */  iRegIorL2I_rule,
  /*  705 */  iRegIorL2I_rule,
  /*  706 */  immIAddSub_rule,
  /*  707 */  immIAddSub_rule,
  /*  708 */  iRegL_rule,
  /*  709 */  iRegL_rule,
  /*  710 */  immLAddSub_rule,
  /*  711 */  immLAddSub_rule,
  /*  712 */  iRegIorL2I_rule,
  /*  713 */  iRegIorL2I_rule,
  /*  714 */  immIAddSub_rule,
  /*  715 */  immIAddSub_rule,
  /*  716 */  iRegI_rule,
  /*  717 */  immIAddSub_rule,
  /*  718 */  iRegL_rule,
  /*  719 */  immLAddSub_rule,
  /*  720 */  iRegL_rule,
  /*  721 */  immLAddSub_rule,
  /*  722 */  _Binary_iRegIorL2I_iRegIorL2I_rule,
  /*  723 */  _Binary_iRegIorL2I_iRegIorL2I_rule,
  /*  724 */  _Binary_immI0_iRegIorL2I_rule,
  /*  725 */  _Binary_immI0_iRegIorL2I_rule,
  /*  726 */  _Binary_iRegIorL2I_immI0_rule,
  /*  727 */  _Binary_iRegIorL2I_immI0_rule,
  /*  728 */  _Binary_immI_1_immI0_rule,
  /*  729 */  _Binary_immI_1_immI0_rule,
  /*  730 */  _Binary_iRegL_iRegL_rule,
  /*  731 */  _Binary_iRegL_iRegL_rule,
  /*  732 */  _Binary_iRegL_immL0_rule,
  /*  733 */  _Binary_iRegL_immL0_rule,
  /*  734 */  _Binary_immL0_iRegL_rule,
  /*  735 */  _Binary_immL0_iRegL_rule,
  /*  736 */  _Binary_iRegP_iRegP_rule,
  /*  737 */  _Binary_iRegP_iRegP_rule,
  /*  738 */  _Binary_iRegP_immP0_rule,
  /*  739 */  _Binary_iRegP_immP0_rule,
  /*  740 */  _Binary_immP0_iRegP_rule,
  /*  741 */  _Binary_immP0_iRegP_rule,
  /*  742 */  _Binary_iRegN_iRegN_rule,
  /*  743 */  _Binary_iRegN_iRegN_rule,
  /*  744 */  _Binary_iRegN_immN0_rule,
  /*  745 */  _Binary_iRegN_immN0_rule,
  /*  746 */  _Binary_immN0_iRegN_rule,
  /*  747 */  _Binary_immN0_iRegN_rule,
  /*  748 */  _Binary_vRegF_vRegF_rule,
  /*  749 */  _Binary_vRegF_vRegF_rule,
  /*  750 */  _Binary_vRegD_vRegD_rule,
  /*  751 */  _Binary_vRegD_vRegD_rule,
  /*  752 */  iRegIorL2I_rule,
  /*  753 */  immIAddSub_rule,
  /*  754 */  immIAddSub_rule,
  /*  755 */  iRegL_rule,
  /*  756 */  _ConvI2L_iRegIorL2I__rule,
  /*  757 */  _LShiftL_iRegL_immIScale_rule,
  /*  758 */  _LShiftL__ConvI2L_iRegIorL2I__immIScale_rule,
  /*  759 */  immI_rule,
  /*  760 */  immLAddSub_rule,
  /*  761 */  iRegL_rule,
  /*  762 */  immLAddSub_rule,
  /*  763 */  iRegIorL2I_rule,
  /*  764 */  immIAddSub_rule,
  /*  765 */  iRegL_rule,
  /*  766 */  immLAddSub_rule,
  /*  767 */  iRegIorL2I_rule,
  /*  768 */  iRegL_rule,
  /*  769 */  iRegIorL2I_rule,
  /*  770 */  _ConvI2L_iRegIorL2I__rule,
  /*  771 */  _ConvI2L_iRegIorL2I__rule,
  /*  772 */  iRegL_rule,
  /*  773 */  iRegL_rule,
  /*  774 */  iRegL_rule,
  /*  775 */  _MulI_iRegIorL2I_iRegIorL2I_rule,
  /*  776 */  iRegIorL2I_rule,
  /*  777 */  _MulI_iRegIorL2I_iRegIorL2I_rule,
  /*  778 */  iRegIorL2I_rule,
  /*  779 */  _SubI_immI0_iRegIorL2I_rule,
  /*  780 */  _MulL_iRegL_iRegL_rule,
  /*  781 */  iRegL_rule,
  /*  782 */  _MulL_iRegL_iRegL_rule,
  /*  783 */  iRegL_rule,
  /*  784 */  _SubL_immL0_iRegL_rule,
  /*  785 */  _MulL__ConvI2L_iRegIorL2I___ConvI2L_iRegIorL2I__rule,
  /*  786 */  iRegLNoSp_rule,
  /*  787 */  _MulL__ConvI2L_iRegIorL2I___ConvI2L_iRegIorL2I__rule,
  /*  788 */  iRegLNoSp_rule,
  /*  789 */  _MulL__ConvI2L_iRegIorL2I___ConvI2L_iRegIorL2I__rule,
  /*  790 */  _MulL__ConvI2L_iRegIorL2I___ConvI2L_iRegIorL2I__rule,
  /*  791 */  _ConvI2L_iRegIorL2I__rule,
  /*  792 */  _SubL_immL0__ConvI2L_iRegIorL2I__rule,
  /*  793 */  _Binary_iRegIorL2I_iRegIorL2I_rule,
  /*  794 */  iRegIorL2I_rule,
  /*  795 */  iRegL_rule,
  /*  796 */  iRegIorL2I_rule,
  /*  797 */  iRegL_rule,
  /*  798 */  iRegIorL2I_rule,
  /*  799 */  iRegL_rule,
  /*  800 */  iRegIorL2I_rule,
  /*  801 */  iRegL_rule,
  /*  802 */  iRegIorL2I_rule,
  /*  803 */  immI_rule,
  /*  804 */  iRegIorL2I_rule,
  /*  805 */  immI_rule,
  /*  806 */  iRegIorL2I_rule,
  /*  807 */  immI_rule,
  /*  808 */  iRegIorL2I_rule,
  /*  809 */  immI_rule,
  /*  810 */  iRegIorL2I_rule,
  /*  811 */  immI_rule,
  /*  812 */  immI_rule,
  /*  813 */  iRegIorL2I_rule,
  /*  814 */  immI_rule,
  /*  815 */  immL_M1_rule,
  /*  816 */  immI_M1_rule,
  /*  817 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  818 */  _RShiftI_iRegIorL2I_immI_rule,
  /*  819 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  820 */  _URShiftL_iRegL_immI_rule,
  /*  821 */  _RShiftL_iRegL_immI_rule,
  /*  822 */  _LShiftL_iRegL_immI_rule,
  /*  823 */  _XorI_iRegIorL2I_immI_M1_rule,
  /*  824 */  iRegIorL2I_rule,
  /*  825 */  _XorL_iRegL_immL_M1_rule,
  /*  826 */  iRegL_rule,
  /*  827 */  _XorI_iRegIorL2I_immI_M1_rule,
  /*  828 */  iRegIorL2I_rule,
  /*  829 */  _XorL_iRegL_immL_M1_rule,
  /*  830 */  iRegL_rule,
  /*  831 */  _XorI_iRegIorL2I_iRegIorL2I_rule,
  /*  832 */  immI_M1_rule,
  /*  833 */  _XorL_iRegL_iRegL_rule,
  /*  834 */  immL_M1_rule,
  /*  835 */  _XorI__URShiftI_iRegIorL2I_immI_immI_M1_rule,
  /*  836 */  iRegIorL2I_rule,
  /*  837 */  _XorL__URShiftL_iRegL_immI_immL_M1_rule,
  /*  838 */  iRegL_rule,
  /*  839 */  _XorI__RShiftI_iRegIorL2I_immI_immI_M1_rule,
  /*  840 */  iRegIorL2I_rule,
  /*  841 */  _XorL__RShiftL_iRegL_immI_immL_M1_rule,
  /*  842 */  iRegL_rule,
  /*  843 */  _XorI__RotateRight_iRegIorL2I_immI_immI_M1_rule,
  /*  844 */  iRegIorL2I_rule,
  /*  845 */  _XorL__RotateRight_iRegL_immI_immL_M1_rule,
  /*  846 */  iRegL_rule,
  /*  847 */  _XorI__LShiftI_iRegIorL2I_immI_immI_M1_rule,
  /*  848 */  iRegIorL2I_rule,
  /*  849 */  _XorL__LShiftL_iRegL_immI_immL_M1_rule,
  /*  850 */  iRegL_rule,
  /*  851 */  _XorI__URShiftI_iRegIorL2I_immI_iRegIorL2I_rule,
  /*  852 */  immI_M1_rule,
  /*  853 */  _XorI_iRegIorL2I__URShiftI_iRegIorL2I_immI_rule,
  /*  854 */  immI_M1_rule,
  /*  855 */  _XorL__URShiftL_iRegL_immI_iRegL_rule,
  /*  856 */  immL_M1_rule,
  /*  857 */  _XorL_iRegL__URShiftL_iRegL_immI_rule,
  /*  858 */  immL_M1_rule,
  /*  859 */  _XorI__RShiftI_iRegIorL2I_immI_iRegIorL2I_rule,
  /*  860 */  immI_M1_rule,
  /*  861 */  _XorI_iRegIorL2I__RShiftI_iRegIorL2I_immI_rule,
  /*  862 */  immI_M1_rule,
  /*  863 */  _XorL__RShiftL_iRegL_immI_iRegL_rule,
  /*  864 */  immL_M1_rule,
  /*  865 */  _XorL_iRegL__RShiftL_iRegL_immI_rule,
  /*  866 */  immL_M1_rule,
  /*  867 */  _XorI__RotateRight_iRegIorL2I_immI_iRegIorL2I_rule,
  /*  868 */  immI_M1_rule,
  /*  869 */  _XorI_iRegIorL2I__RotateRight_iRegIorL2I_immI_rule,
  /*  870 */  immI_M1_rule,
  /*  871 */  _XorL__RotateRight_iRegL_immI_iRegL_rule,
  /*  872 */  immL_M1_rule,
  /*  873 */  _XorL_iRegL__RotateRight_iRegL_immI_rule,
  /*  874 */  immL_M1_rule,
  /*  875 */  _XorI__LShiftI_iRegIorL2I_immI_iRegIorL2I_rule,
  /*  876 */  immI_M1_rule,
  /*  877 */  _XorI_iRegIorL2I__LShiftI_iRegIorL2I_immI_rule,
  /*  878 */  immI_M1_rule,
  /*  879 */  _XorL__LShiftL_iRegL_immI_iRegL_rule,
  /*  880 */  immL_M1_rule,
  /*  881 */  _XorL_iRegL__LShiftL_iRegL_immI_rule,
  /*  882 */  immL_M1_rule,
  /*  883 */  _XorI__URShiftI_iRegIorL2I_immI_immI_M1_rule,
  /*  884 */  iRegIorL2I_rule,
  /*  885 */  _XorL__URShiftL_iRegL_immI_immL_M1_rule,
  /*  886 */  iRegL_rule,
  /*  887 */  _XorI__RShiftI_iRegIorL2I_immI_immI_M1_rule,
  /*  888 */  iRegIorL2I_rule,
  /*  889 */  _XorL__RShiftL_iRegL_immI_immL_M1_rule,
  /*  890 */  iRegL_rule,
  /*  891 */  _XorI__RotateRight_iRegIorL2I_immI_immI_M1_rule,
  /*  892 */  iRegIorL2I_rule,
  /*  893 */  _XorL__RotateRight_iRegL_immI_immL_M1_rule,
  /*  894 */  iRegL_rule,
  /*  895 */  _XorI__LShiftI_iRegIorL2I_immI_immI_M1_rule,
  /*  896 */  iRegIorL2I_rule,
  /*  897 */  _XorL__LShiftL_iRegL_immI_immL_M1_rule,
  /*  898 */  iRegL_rule,
  /*  899 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  900 */  iRegIorL2I_rule,
  /*  901 */  _URShiftL_iRegL_immI_rule,
  /*  902 */  iRegL_rule,
  /*  903 */  _RShiftI_iRegIorL2I_immI_rule,
  /*  904 */  iRegIorL2I_rule,
  /*  905 */  _RShiftL_iRegL_immI_rule,
  /*  906 */  iRegL_rule,
  /*  907 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  908 */  iRegIorL2I_rule,
  /*  909 */  _LShiftL_iRegL_immI_rule,
  /*  910 */  iRegL_rule,
  /*  911 */  _RotateRight_iRegIorL2I_immI_rule,
  /*  912 */  iRegIorL2I_rule,
  /*  913 */  _RotateRight_iRegL_immI_rule,
  /*  914 */  iRegL_rule,
  /*  915 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  916 */  iRegIorL2I_rule,
  /*  917 */  _URShiftL_iRegL_immI_rule,
  /*  918 */  iRegL_rule,
  /*  919 */  _RShiftI_iRegIorL2I_immI_rule,
  /*  920 */  iRegIorL2I_rule,
  /*  921 */  _RShiftL_iRegL_immI_rule,
  /*  922 */  iRegL_rule,
  /*  923 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  924 */  iRegIorL2I_rule,
  /*  925 */  _LShiftL_iRegL_immI_rule,
  /*  926 */  iRegL_rule,
  /*  927 */  _RotateRight_iRegIorL2I_immI_rule,
  /*  928 */  iRegIorL2I_rule,
  /*  929 */  _RotateRight_iRegL_immI_rule,
  /*  930 */  iRegL_rule,
  /*  931 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  932 */  iRegIorL2I_rule,
  /*  933 */  _URShiftL_iRegL_immI_rule,
  /*  934 */  iRegL_rule,
  /*  935 */  _RShiftI_iRegIorL2I_immI_rule,
  /*  936 */  iRegIorL2I_rule,
  /*  937 */  _RShiftL_iRegL_immI_rule,
  /*  938 */  iRegL_rule,
  /*  939 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  940 */  iRegIorL2I_rule,
  /*  941 */  _LShiftL_iRegL_immI_rule,
  /*  942 */  iRegL_rule,
  /*  943 */  _RotateRight_iRegIorL2I_immI_rule,
  /*  944 */  iRegIorL2I_rule,
  /*  945 */  _RotateRight_iRegL_immI_rule,
  /*  946 */  iRegL_rule,
  /*  947 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  948 */  iRegIorL2I_rule,
  /*  949 */  _URShiftL_iRegL_immI_rule,
  /*  950 */  iRegL_rule,
  /*  951 */  _RShiftI_iRegIorL2I_immI_rule,
  /*  952 */  iRegIorL2I_rule,
  /*  953 */  _RShiftL_iRegL_immI_rule,
  /*  954 */  iRegL_rule,
  /*  955 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  956 */  iRegIorL2I_rule,
  /*  957 */  _LShiftL_iRegL_immI_rule,
  /*  958 */  iRegL_rule,
  /*  959 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  960 */  _URShiftL_iRegL_immI_rule,
  /*  961 */  _RShiftI_iRegIorL2I_immI_rule,
  /*  962 */  _RShiftL_iRegL_immI_rule,
  /*  963 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  964 */  _LShiftL_iRegL_immI_rule,
  /*  965 */  immI_rule,
  /*  966 */  immI_rule,
  /*  967 */  immI_rule,
  /*  968 */  immI_rule,
  /*  969 */  immI_bitmask_rule,
  /*  970 */  immL_bitmask_rule,
  /*  971 */  0,
  /*  972 */  immI_rule,
  /*  973 */  immI_rule,
  /*  974 */  0,
  /*  975 */  0,
  /*  976 */  immI_rule,
  /*  977 */  immI_rule,
  /*  978 */  0,
  /*  979 */  _URShiftL_iRegL_immI_rule,
  /*  980 */  _LShiftL_iRegL_immI_rule,
  /*  981 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  982 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  983 */  _URShiftL_iRegL_immI_rule,
  /*  984 */  _LShiftL_iRegL_immI_rule,
  /*  985 */  _URShiftI_iRegIorL2I_immI_rule,
  /*  986 */  _LShiftI_iRegIorL2I_immI_rule,
  /*  987 */  immI_rule,
  /*  988 */  immI_rule,
  /*  989 */  iRegI_rule,
  /*  990 */  iRegI_rule,
  /*  991 */  iRegI_rule,
  /*  992 */  iRegI_rule,
  /*  993 */  _ConvI2L_iRegIorL2I__rule,
  /*  994 */  iRegL_rule,
  /*  995 */  _ConvI2L_iRegIorL2I__rule,
  /*  996 */  _RShiftI__LShiftI_iRegIorL2I_immI_16_immI_16_rule,
  /*  997 */  iRegIorL2I_rule,
  /*  998 */  _RShiftI__LShiftI_iRegIorL2I_immI_24_immI_24_rule,
  /*  999 */  iRegIorL2I_rule,
  /* 1000 */  _URShiftI__LShiftI_iRegIorL2I_immI_24_immI_24_rule,
  /* 1001 */  iRegIorL2I_rule,
  /* 1002 */  _RShiftL__LShiftL_iRegL_immI_48_immI_48_rule,
  /* 1003 */  iRegL_rule,
  /* 1004 */  _RShiftL__LShiftL_iRegL_immI_32_immI_32_rule,
  /* 1005 */  iRegL_rule,
  /* 1006 */  _RShiftL__LShiftL_iRegL_immI_56_immI_56_rule,
  /* 1007 */  iRegL_rule,
  /* 1008 */  _URShiftL__LShiftL_iRegL_immI_56_immI_56_rule,
  /* 1009 */  iRegL_rule,
  /* 1010 */  _AndI_iRegIorL2I_immI_255_rule,
  /* 1011 */  iRegIorL2I_rule,
  /* 1012 */  _AndI_iRegIorL2I_immI_65535_rule,
  /* 1013 */  iRegIorL2I_rule,
  /* 1014 */  _AndL_iRegL_immL_255_rule,
  /* 1015 */  iRegL_rule,
  /* 1016 */  _AndL_iRegL_immL_65535_rule,
  /* 1017 */  iRegL_rule,
  /* 1018 */  _AndL_iRegL_immL_4294967295_rule,
  /* 1019 */  iRegL_rule,
  /* 1020 */  _AndI_iRegIorL2I_immI_255_rule,
  /* 1021 */  _AndI_iRegIorL2I_immI_65535_rule,
  /* 1022 */  _AndL_iRegL_immL_255_rule,
  /* 1023 */  _AndL_iRegL_immL_65535_rule,
  /* 1024 */  _AndL_iRegL_immL_4294967295_rule,
  /* 1025 */  _LShiftL__RShiftL__LShiftL_iRegL_immI_56_immI_56_immIExt_rule,
  /* 1026 */  iRegL_rule,
  /* 1027 */  _LShiftL__RShiftL__LShiftL_iRegL_immI_48_immI_48_immIExt_rule,
  /* 1028 */  iRegL_rule,
  /* 1029 */  _LShiftL__RShiftL__LShiftL_iRegL_immI_32_immI_32_immIExt_rule,
  /* 1030 */  iRegL_rule,
  /* 1031 */  _LShiftL__RShiftL__LShiftL_iRegL_immI_56_immI_56_immIExt_rule,
  /* 1032 */  _LShiftL__RShiftL__LShiftL_iRegL_immI_48_immI_48_immIExt_rule,
  /* 1033 */  _LShiftL__RShiftL__LShiftL_iRegL_immI_32_immI_32_immIExt_rule,
  /* 1034 */  _LShiftI__RShiftI__LShiftI_iRegIorL2I_immI_24_immI_24_immIExt_rule,
  /* 1035 */  iRegIorL2I_rule,
  /* 1036 */  _LShiftI__RShiftI__LShiftI_iRegIorL2I_immI_16_immI_16_immIExt_rule,
  /* 1037 */  iRegIorL2I_rule,
  /* 1038 */  _LShiftI__RShiftI__LShiftI_iRegIorL2I_immI_24_immI_24_immIExt_rule,
  /* 1039 */  _LShiftI__RShiftI__LShiftI_iRegIorL2I_immI_16_immI_16_immIExt_rule,
  /* 1040 */  _LShiftL__ConvI2L_iRegIorL2I__immIExt_rule,
  /* 1041 */  iRegL_rule,
  /* 1042 */  _LShiftL__ConvI2L_iRegIorL2I__immIExt_rule,
  /* 1043 */  _LShiftL__AndL_iRegL_immL_255_immIExt_rule,
  /* 1044 */  iRegL_rule,
  /* 1045 */  _LShiftL__AndL_iRegL_immL_65535_immIExt_rule,
  /* 1046 */  iRegL_rule,
  /* 1047 */  _LShiftL__AndL_iRegL_immL_4294967295_immIExt_rule,
  /* 1048 */  iRegL_rule,
  /* 1049 */  _LShiftL__AndL_iRegL_immL_255_immIExt_rule,
  /* 1050 */  _LShiftL__AndL_iRegL_immL_65535_immIExt_rule,
  /* 1051 */  _LShiftL__AndL_iRegL_immL_4294967295_immIExt_rule,
  /* 1052 */  _LShiftI__AndI_iRegIorL2I_immI_255_immIExt_rule,
  /* 1053 */  iRegIorL2I_rule,
  /* 1054 */  _LShiftI__AndI_iRegIorL2I_immI_65535_immIExt_rule,
  /* 1055 */  iRegIorL2I_rule,
  /* 1056 */  _LShiftI__AndI_iRegIorL2I_immI_255_immIExt_rule,
  /* 1057 */  _LShiftI__AndI_iRegIorL2I_immI_65535_immIExt_rule,
  /* 1058 */  0,
  /* 1059 */  0,
  /* 1060 */  0,
  /* 1061 */  0,
  /* 1062 */  0,
  /* 1063 */  0,
  /* 1064 */  0,
  /* 1065 */  0,
  /* 1066 */  immI0_rule,
  /* 1067 */  iRegIorL2I_rule,
  /* 1068 */  immI_1_rule,
  /* 1069 */  iRegIorL2I_rule,
  /* 1070 */  immI_M1_rule,
  /* 1071 */  iRegIorL2I_rule,
  /* 1072 */  immI0_rule,
  /* 1073 */  iRegIorL2I_rule,
  /* 1074 */  immI_1_rule,
  /* 1075 */  iRegIorL2I_rule,
  /* 1076 */  immI_M1_rule,
  /* 1077 */  iRegIorL2I_rule,
  /* 1078 */  vRegF_rule,
  /* 1079 */  vRegD_rule,
  /* 1080 */  vRegF_rule,
  /* 1081 */  vRegD_rule,
  /* 1082 */  vRegF_rule,
  /* 1083 */  vRegD_rule,
  /* 1084 */  _Binary_vRegF_vRegF_rule,
  /* 1085 */  _Binary_vRegD_vRegD_rule,
  /* 1086 */  _Binary_vRegF__NegF_vRegF__rule,
  /* 1087 */  _Binary_vRegD__NegD_vRegD__rule,
  /* 1088 */  _Binary_vRegF__NegF_vRegF__rule,
  /* 1089 */  _Binary_vRegD__NegD_vRegD__rule,
  /* 1090 */  _Binary_vRegF_vRegF_rule,
  /* 1091 */  _Binary_vRegD_vRegD_rule,
  /* 1092 */  vRegF_rule,
  /* 1093 */  vRegF_rule,
  /* 1094 */  vRegD_rule,
  /* 1095 */  vRegD_rule,
  /* 1096 */  vRegF_rule,
  /* 1097 */  vRegD_rule,
  /* 1098 */  0,
  /* 1099 */  0,
  /* 1100 */  0,
  /* 1101 */  0,
  /* 1102 */  0,
  /* 1103 */  0,
  /* 1104 */  immI_rule,
  /* 1105 */  _Binary_vRegD_vRegD_rule,
  /* 1106 */  vRegF_rule,
  /* 1107 */  _Binary_vRegD_vRegD_rule,
  /* 1108 */  _Binary_vRegF_vRegF_rule,
  /* 1109 */  0,
  /* 1110 */  iRegIorL2I_rule,
  /* 1111 */  immILog_rule,
  /* 1112 */  iRegIorL2I_rule,
  /* 1113 */  immILog_rule,
  /* 1114 */  iRegIorL2I_rule,
  /* 1115 */  immILog_rule,
  /* 1116 */  iRegL_rule,
  /* 1117 */  immLLog_rule,
  /* 1118 */  iRegL_rule,
  /* 1119 */  immLLog_rule,
  /* 1120 */  iRegL_rule,
  /* 1121 */  immLLog_rule,
  /* 1122 */  0,
  /* 1123 */  immL_32bits_rule,
  /* 1124 */  0,
  /* 1125 */  0,
  /* 1126 */  0,
  /* 1127 */  0,
  /* 1128 */  0,
  /* 1129 */  0,
  /* 1130 */  0,
  /* 1131 */  0,
  /* 1132 */  0,
  /* 1133 */  0,
  /* 1134 */  0,
  /* 1135 */  0,
  /* 1136 */  0,
  /* 1137 */  0,
  /* 1138 */  0,
  /* 1139 */  0,
  /* 1140 */  0,
  /* 1141 */  0,
  /* 1142 */  0,
  /* 1143 */  iRegP_R10_rule,
  /* 1144 */  iRegP_R10_rule,
  /* 1145 */  _OverflowMulI_iRegIorL2I_iRegIorL2I_rule,
  /* 1146 */  _OverflowMulL_iRegL_iRegL_rule,
  /* 1147 */  vRegF_rule,
  /* 1148 */  vRegD_rule,
  /* 1149 */  immF0_rule,
  /* 1150 */  immD0_rule,
  /* 1151 */  iRegIorL2I_rule,
  /* 1152 */  immI0_rule,
  /* 1153 */  iRegIorL2I_rule,
  /* 1154 */  iRegIorL2I_rule,
  /* 1155 */  0,
  /* 1156 */  rFlagsReg_rule,
  /* 1157 */  rFlagsRegU_rule,
  /* 1158 */  _CmpI_iRegIorL2I_immI0_rule,
  /* 1159 */  _CmpL_iRegL_immL0_rule,
  /* 1160 */  _CmpP_iRegP_immP0_rule,
  /* 1161 */  _CmpN_iRegN_immN0_rule,
  /* 1162 */  _CmpP__DecodeN_iRegN__immP0_rule,
  /* 1163 */  _CmpU_iRegIorL2I_immI0_rule,
  /* 1164 */  _CmpUL_iRegL_immL0_rule,
  /* 1165 */  _CmpL_iRegL_immL0_rule,
  /* 1166 */  _CmpI_iRegIorL2I_immI0_rule,
  /* 1167 */  _CmpL__AndL_iRegL_immL_immL0_rule,
  /* 1168 */  _CmpI__AndI_iRegIorL2I_immI_immI0_rule,
  /* 1169 */  _CmpL_iRegL_immL0_rule,
  /* 1170 */  _CmpI_iRegIorL2I_immI0_rule,
  /* 1171 */  _CmpL__AndL_iRegL_immL_immL0_rule,
  /* 1172 */  _CmpI__AndI_iRegIorL2I_immI_immI0_rule,
  /* 1173 */  rFlagsReg_rule,
  /* 1174 */  0,
  /* 1175 */  0,
  /* 1176 */  0,
  /* 1177 */  0,
  /* 1178 */  0,
  /* 1179 */  0,
  /* 1180 */  inline_cache_RegP_rule,
  /* 1181 */  iRegP_R0_rule,
  /* 1182 */  0,
  /* 1183 */  0,
  /* 1184 */  0,
  /* 1185 */  0,
  /* 1186 */  iRegP_R0_rule,
  /* 1187 */  _Binary_iRegP_R3_iRegI_R4_rule,
  /* 1188 */  _Binary_iRegP_R3_iRegI_R4_rule,
  /* 1189 */  _Binary_iRegP_R3_iRegI_R4_rule,
  /* 1190 */  _Binary_iRegP_R3_iRegI_R4_rule,
  /* 1191 */  _Binary_iRegP_R3_iRegI_R4_rule,
  /* 1192 */  _Binary_iRegP_R3_iRegI_R4_rule,
  /* 1193 */  _Binary_iRegP_R3_iRegI_R4_rule,
  /* 1194 */  _Binary_iRegP_R3_iRegI_R4_rule,
  /* 1195 */  _Binary_iRegP_R3_iRegI_R2_rule,
  /* 1196 */  _Binary_iRegP_R3_iRegI_R2_rule,
  /* 1197 */  _Binary_iRegP_R3_iRegI_R2_rule,
  /* 1198 */  _Binary_iRegP_R3_immI_le_4_rule,
  /* 1199 */  _Binary_iRegP_R3_immI_le_4_rule,
  /* 1200 */  _Binary_iRegP_R3_immI_1_rule,
  /* 1201 */  iRegI_R3_rule,
  /* 1202 */  iRegI_R3_rule,
  /* 1203 */  iRegI_R3_rule,
  /* 1204 */  iRegI_R3_rule,
  /* 1205 */  iRegI_R4_rule,
  /* 1206 */  iRegP_R2_rule,
  /* 1207 */  iRegP_R2_rule,
  /* 1208 */  iRegI_R2_rule,
  /* 1209 */  _Binary_iRegP_R1_iRegI_R3_rule,
  /* 1210 */  _Binary_iRegP_R1_iRegI_R2_rule,
  /* 1211 */  _Binary_iRegP_R1_iRegI_R3_rule,
  /* 1212 */  _Binary_iRegP_R1_iRegI_R3_rule,
  /* 1213 */  iRegIorL2I_rule,
  /* 1214 */  immI_rule,
  /* 1215 */  iRegL_rule,
  /* 1216 */  immL_rule,
  /* 1217 */  iRegIorL2I_rule,
  /* 1218 */  immI_rule,
  /* 1219 */  iRegL_rule,
  /* 1220 */  immL_rule,
  /* 1221 */  0,
  /* 1222 */  vReg_rule,
  /* 1223 */  0,
  /* 1224 */  vReg_rule,
  /* 1225 */  0,
  /* 1226 */  vReg_rule,
  /* 1227 */  0,
  /* 1228 */  vReg_rule,
  /* 1229 */  0,
  /* 1230 */  vReg_rule,
  /* 1231 */  pRegGov_rule,
  /* 1232 */  _Binary_vReg_pRegGov_rule,
  /* 1233 */  vReg_rule,
  /* 1234 */  vReg_rule,
  /* 1235 */  vReg_rule,
  /* 1236 */  vReg_rule,
  /* 1237 */  vReg_rule,
  /* 1238 */  vReg_rule,
  /* 1239 */  pRegGov_rule,
  /* 1240 */  pRegGov_rule,
  /* 1241 */  pRegGov_rule,
  /* 1242 */  pRegGov_rule,
  /* 1243 */  pRegGov_rule,
  /* 1244 */  pRegGov_rule,
  /* 1245 */  _Replicate_immBAddSubV__rule,
  /* 1246 */  vReg_rule,
  /* 1247 */  _Replicate_immIAddSubV__rule,
  /* 1248 */  vReg_rule,
  /* 1249 */  _Replicate_immIAddSubV__rule,
  /* 1250 */  vReg_rule,
  /* 1251 */  _Replicate_immLAddSubV__rule,
  /* 1252 */  vReg_rule,
  /* 1253 */  vReg_rule,
  /* 1254 */  vReg_rule,
  /* 1255 */  vReg_rule,
  /* 1256 */  vReg_rule,
  /* 1257 */  vReg_rule,
  /* 1258 */  vReg_rule,
  /* 1259 */  pRegGov_rule,
  /* 1260 */  pRegGov_rule,
  /* 1261 */  pRegGov_rule,
  /* 1262 */  pRegGov_rule,
  /* 1263 */  pRegGov_rule,
  /* 1264 */  pRegGov_rule,
  /* 1265 */  vReg_rule,
  /* 1266 */  vReg_rule,
  /* 1267 */  vReg_rule,
  /* 1268 */  vReg_rule,
  /* 1269 */  vReg_rule,
  /* 1270 */  vReg_rule,
  /* 1271 */  vReg_rule,
  /* 1272 */  vReg_rule,
  /* 1273 */  vReg_rule,
  /* 1274 */  vReg_rule,
  /* 1275 */  pRegGov_rule,
  /* 1276 */  pRegGov_rule,
  /* 1277 */  pRegGov_rule,
  /* 1278 */  pRegGov_rule,
  /* 1279 */  pRegGov_rule,
  /* 1280 */  pRegGov_rule,
  /* 1281 */  vReg_rule,
  /* 1282 */  vReg_rule,
  /* 1283 */  vReg_rule,
  /* 1284 */  vReg_rule,
  /* 1285 */  pRegGov_rule,
  /* 1286 */  pRegGov_rule,
  /* 1287 */  vReg_rule,
  /* 1288 */  pRegGov_rule,
  /* 1289 */  _Replicate_immBLog__rule,
  /* 1290 */  vReg_rule,
  /* 1291 */  _Replicate_immSLog__rule,
  /* 1292 */  vReg_rule,
  /* 1293 */  _Replicate_immILog__rule,
  /* 1294 */  vReg_rule,
  /* 1295 */  _Replicate_immLLog__rule,
  /* 1296 */  vReg_rule,
  /* 1297 */  vReg_rule,
  /* 1298 */  pRegGov_rule,
  /* 1299 */  _Replicate_immBLog__rule,
  /* 1300 */  vReg_rule,
  /* 1301 */  _Replicate_immSLog__rule,
  /* 1302 */  vReg_rule,
  /* 1303 */  _Replicate_immILog__rule,
  /* 1304 */  vReg_rule,
  /* 1305 */  _Replicate_immLLog__rule,
  /* 1306 */  vReg_rule,
  /* 1307 */  vReg_rule,
  /* 1308 */  pRegGov_rule,
  /* 1309 */  _Replicate_immBLog__rule,
  /* 1310 */  vReg_rule,
  /* 1311 */  _Replicate_immSLog__rule,
  /* 1312 */  vReg_rule,
  /* 1313 */  _Replicate_immILog__rule,
  /* 1314 */  vReg_rule,
  /* 1315 */  _Replicate_immLLog__rule,
  /* 1316 */  vReg_rule,
  /* 1317 */  _XorV_vReg_vReg_rule,
  /* 1318 */  vReg_rule,
  /* 1319 */  _XorV_vReg_vReg_rule,
  /* 1320 */  vReg_rule,
  /* 1321 */  _Replicate_immI_M1__rule,
  /* 1322 */  vReg_rule,
  /* 1323 */  _Replicate_immL_M1__rule,
  /* 1324 */  vReg_rule,
  /* 1325 */  pRegGov_rule,
  /* 1326 */  pRegGov_rule,
  /* 1327 */  _XorV_vReg__Replicate_immI_M1__rule,
  /* 1328 */  vReg_rule,
  /* 1329 */  _XorV__Replicate_immI_M1__vReg_rule,
  /* 1330 */  vReg_rule,
  /* 1331 */  _XorV_vReg__Replicate_immL_M1__rule,
  /* 1332 */  vReg_rule,
  /* 1333 */  _XorV__Replicate_immL_M1__vReg_rule,
  /* 1334 */  vReg_rule,
  /* 1335 */  pRegGov_rule,
  /* 1336 */  pRegGov_rule,
  /* 1337 */  pRegGov_rule,
  /* 1338 */  pRegGov_rule,
  /* 1339 */  pRegGov_rule,
  /* 1340 */  pRegGov_rule,
  /* 1341 */  pRegGov_rule,
  /* 1342 */  pRegGov_rule,
  /* 1343 */  pRegGov_rule,
  /* 1344 */  pRegGov_rule,
  /* 1345 */  0,
  /* 1346 */  0,
  /* 1347 */  0,
  /* 1348 */  0,
  /* 1349 */  pRegGov_rule,
  /* 1350 */  pRegGov_rule,
  /* 1351 */  pRegGov_rule,
  /* 1352 */  pRegGov_rule,
  /* 1353 */  pRegGov_rule,
  /* 1354 */  pRegGov_rule,
  /* 1355 */  pRegGov_rule,
  /* 1356 */  pRegGov_rule,
  /* 1357 */  vReg_rule,
  /* 1358 */  vReg_rule,
  /* 1359 */  vReg_rule,
  /* 1360 */  vReg_rule,
  /* 1361 */  pRegGov_rule,
  /* 1362 */  vReg_rule,
  /* 1363 */  vReg_rule,
  /* 1364 */  vReg_rule,
  /* 1365 */  vReg_rule,
  /* 1366 */  pRegGov_rule,
  /* 1367 */  _MulVB_vReg_vReg_rule,
  /* 1368 */  vReg_rule,
  /* 1369 */  _MulVS_vReg_vReg_rule,
  /* 1370 */  vReg_rule,
  /* 1371 */  _MulVI_vReg_vReg_rule,
  /* 1372 */  vReg_rule,
  /* 1373 */  _MulVL_vReg_vReg_rule,
  /* 1374 */  vReg_rule,
  /* 1375 */  pRegGov_rule,
  /* 1376 */  pRegGov_rule,
  /* 1377 */  pRegGov_rule,
  /* 1378 */  pRegGov_rule,
  /* 1379 */  _Binary_vReg_vReg_rule,
  /* 1380 */  _Binary_vReg_vReg_rule,
  /* 1381 */  _Binary_vReg_pRegGov_rule,
  /* 1382 */  _Binary_vReg_pRegGov_rule,
  /* 1383 */  _MulVB_vReg_vReg_rule,
  /* 1384 */  _MulVS_vReg_vReg_rule,
  /* 1385 */  _MulVI_vReg_vReg_rule,
  /* 1386 */  _MulVL_vReg_vReg_rule,
  /* 1387 */  pRegGov_rule,
  /* 1388 */  pRegGov_rule,
  /* 1389 */  pRegGov_rule,
  /* 1390 */  pRegGov_rule,
  /* 1391 */  _Binary_vReg__NegVF_vReg__rule,
  /* 1392 */  _Binary_vReg__NegVD_vReg__rule,
  /* 1393 */  _Binary_vReg_pRegGov_rule,
  /* 1394 */  _Binary_vReg_pRegGov_rule,
  /* 1395 */  _Binary_vReg__NegVF_vReg__rule,
  /* 1396 */  _Binary_vReg__NegVD_vReg__rule,
  /* 1397 */  _Binary__NegVF_vReg__pRegGov_rule,
  /* 1398 */  _Binary__NegVD_vReg__pRegGov_rule,
  /* 1399 */  _Binary_vReg_vReg_rule,
  /* 1400 */  _Binary_vReg_vReg_rule,
  /* 1401 */  _Binary__NegVF_vReg__pRegGov_rule,
  /* 1402 */  _Binary__NegVD_vReg__pRegGov_rule,
  /* 1403 */  vReg_rule,
  /* 1404 */  vReg_rule,
  /* 1405 */  vReg_rule,
  /* 1406 */  vReg_rule,
  /* 1407 */  vReg_rule,
  /* 1408 */  vReg_rule,
  /* 1409 */  vReg_rule,
  /* 1410 */  vReg_rule,
  /* 1411 */  vReg_rule,
  /* 1412 */  vReg_rule,
  /* 1413 */  vReg_rule,
  /* 1414 */  vReg_rule,
  /* 1415 */  vReg_rule,
  /* 1416 */  vReg_rule,
  /* 1417 */  vReg_rule,
  /* 1418 */  vReg_rule,
  /* 1419 */  vReg_rule,
  /* 1420 */  vReg_rule,
  /* 1421 */  vReg_rule,
  /* 1422 */  vReg_rule,
  /* 1423 */  vReg_rule,
  /* 1424 */  vReg_rule,
  /* 1425 */  vReg_rule,
  /* 1426 */  vReg_rule,
  /* 1427 */  vReg_rule,
  /* 1428 */  vReg_rule,
  /* 1429 */  vReg_rule,
  /* 1430 */  vReg_rule,
  /* 1431 */  vReg_rule,
  /* 1432 */  vReg_rule,
  /* 1433 */  vReg_rule,
  /* 1434 */  vReg_rule,
  /* 1435 */  vReg_rule,
  /* 1436 */  _LShiftCntV_immI__rule,
  /* 1437 */  _LShiftCntV_immI__rule,
  /* 1438 */  _LShiftCntV_immI__rule,
  /* 1439 */  _LShiftCntV_immI__rule,
  /* 1440 */  _RShiftCntV_immI_positive__rule,
  /* 1441 */  _RShiftCntV_immI_positive__rule,
  /* 1442 */  _RShiftCntV_immI_positive__rule,
  /* 1443 */  _RShiftCntV_immI_positive__rule,
  /* 1444 */  _RShiftCntV_immI_positive__rule,
  /* 1445 */  _RShiftCntV_immI_positive__rule,
  /* 1446 */  _RShiftCntV_immI_positive__rule,
  /* 1447 */  _RShiftCntV_immI_positive__rule,
  /* 1448 */  _RShiftVB_vReg__RShiftCntV_immI_positive__rule,
  /* 1449 */  vReg_rule,
  /* 1450 */  _RShiftVS_vReg__RShiftCntV_immI_positive__rule,
  /* 1451 */  vReg_rule,
  /* 1452 */  _RShiftVI_vReg__RShiftCntV_immI_positive__rule,
  /* 1453 */  vReg_rule,
  /* 1454 */  _RShiftVL_vReg__RShiftCntV_immI_positive__rule,
  /* 1455 */  vReg_rule,
  /* 1456 */  _URShiftVB_vReg__RShiftCntV_immI_positive__rule,
  /* 1457 */  vReg_rule,
  /* 1458 */  _URShiftVS_vReg__RShiftCntV_immI_positive__rule,
  /* 1459 */  vReg_rule,
  /* 1460 */  _URShiftVI_vReg__RShiftCntV_immI_positive__rule,
  /* 1461 */  vReg_rule,
  /* 1462 */  _URShiftVL_vReg__RShiftCntV_immI_positive__rule,
  /* 1463 */  vReg_rule,
  /* 1464 */  pRegGov_rule,
  /* 1465 */  pRegGov_rule,
  /* 1466 */  pRegGov_rule,
  /* 1467 */  pRegGov_rule,
  /* 1468 */  pRegGov_rule,
  /* 1469 */  pRegGov_rule,
  /* 1470 */  pRegGov_rule,
  /* 1471 */  pRegGov_rule,
  /* 1472 */  pRegGov_rule,
  /* 1473 */  pRegGov_rule,
  /* 1474 */  pRegGov_rule,
  /* 1475 */  pRegGov_rule,
  /* 1476 */  pRegGov_rule,
  /* 1477 */  pRegGov_rule,
  /* 1478 */  pRegGov_rule,
  /* 1479 */  pRegGov_rule,
  /* 1480 */  pRegGov_rule,
  /* 1481 */  pRegGov_rule,
  /* 1482 */  pRegGov_rule,
  /* 1483 */  pRegGov_rule,
  /* 1484 */  pRegGov_rule,
  /* 1485 */  pRegGov_rule,
  /* 1486 */  pRegGov_rule,
  /* 1487 */  pRegGov_rule,
  /* 1488 */  vReg_rule,
  /* 1489 */  vReg_rule,
  /* 1490 */  vReg_rule,
  /* 1491 */  vReg_rule,
  /* 1492 */  vReg_rule,
  /* 1493 */  vReg_rule,
  /* 1494 */  vReg_rule,
  /* 1495 */  vReg_rule,
  /* 1496 */  vReg_rule,
  /* 1497 */  pRegGov_rule,
  /* 1498 */  pRegGov_rule,
  /* 1499 */  pRegGov_rule,
  /* 1500 */  pRegGov_rule,
  /* 1501 */  vReg_rule,
  /* 1502 */  vReg_rule,
  /* 1503 */  vReg_rule,
  /* 1504 */  vReg_rule,
  /* 1505 */  vReg_rule,
  /* 1506 */  vReg_rule,
  /* 1507 */  vReg_rule,
  /* 1508 */  vReg_rule,
  /* 1509 */  pRegGov_rule,
  /* 1510 */  pRegGov_rule,
  /* 1511 */  vReg_rule,
  /* 1512 */  vReg_rule,
  /* 1513 */  vReg_rule,
  /* 1514 */  vReg_rule,
  /* 1515 */  pRegGov_rule,
  /* 1516 */  pRegGov_rule,
  /* 1517 */  vReg_rule,
  /* 1518 */  vReg_rule,
  /* 1519 */  vReg_rule,
  /* 1520 */  vReg_rule,
  /* 1521 */  pRegGov_rule,
  /* 1522 */  pRegGov_rule,
  /* 1523 */  vReg_rule,
  /* 1524 */  vReg_rule,
  /* 1525 */  vReg_rule,
  /* 1526 */  vReg_rule,
  /* 1527 */  vReg_rule,
  /* 1528 */  vReg_rule,
  /* 1529 */  pRegGov_rule,
  /* 1530 */  pRegGov_rule,
  /* 1531 */  pRegGov_rule,
  /* 1532 */  pRegGov_rule,
  /* 1533 */  vReg_rule,
  /* 1534 */  vReg_rule,
  /* 1535 */  vReg_rule,
  /* 1536 */  vReg_rule,
  /* 1537 */  vReg_rule,
  /* 1538 */  vReg_rule,
  /* 1539 */  pRegGov_rule,
  /* 1540 */  pRegGov_rule,
  /* 1541 */  pRegGov_rule,
  /* 1542 */  pRegGov_rule,
  /* 1543 */  0,
  /* 1544 */  0,
  /* 1545 */  0,
  /* 1546 */  0,
  /* 1547 */  0,
  /* 1548 */  0,
  /* 1549 */  0,
  /* 1550 */  0,
  /* 1551 */  0,
  /* 1552 */  0,
  /* 1553 */  0,
  /* 1554 */  0,
  /* 1555 */  0,
  /* 1556 */  immI_rule,
  /* 1557 */  immI_rule,
  /* 1558 */  immI_rule,
  /* 1559 */  immI_rule,
  /* 1560 */  immI_rule,
  /* 1561 */  immI_rule,
  /* 1562 */  immI_rule,
  /* 1563 */  immI_rule,
  /* 1564 */  immI_rule,
  /* 1565 */  immI_rule,
  /* 1566 */  iRegI_rule,
  /* 1567 */  immI_rule,
  /* 1568 */  immI_rule,
  /* 1569 */  immI_rule,
  /* 1570 */  immI_rule,
  /* 1571 */  immI_rule,
  /* 1572 */  immI_rule,
  /* 1573 */  immI_rule,
  /* 1574 */  immI_rule,
  /* 1575 */  immI_rule,
  /* 1576 */  immI_rule,
  /* 1577 */  immI_rule,
  /* 1578 */  immI_rule,
  /* 1579 */  0,
  /* 1580 */  0,
  /* 1581 */  pRegGov_rule,
  /* 1582 */  pRegGov_rule,
  /* 1583 */  immI_1_rule,
  /* 1584 */  immI_gt_1_rule,
  /* 1585 */  immI_1_rule,
  /* 1586 */  immI_gt_1_rule,
  /* 1587 */  0,
  /* 1588 */  pRegGov_rule,
  /* 1589 */  0,
  /* 1590 */  pRegGov_rule,
  /* 1591 */  _VectorStoreMask_pReg_immI_gt_1_rule,
  /* 1592 */  _VectorStoreMask_pReg_immI_gt_1_rule,
  /* 1593 */  _Binary__VectorStoreMask_pReg_immI_gt_1_pRegGov_rule,
  /* 1594 */  _Binary__VectorStoreMask_pReg_immI_gt_1_pRegGov_rule,
  /* 1595 */  pReg_rule,
  /* 1596 */  pReg_rule,
  /* 1597 */  pReg_rule,
  /* 1598 */  _XorVMask_pReg__MaskAll_immI_M1__rule,
  /* 1599 */  _XorVMask_pReg__MaskAll_immL_M1__rule,
  /* 1600 */  immI_rule,
  /* 1601 */  immI_cmp_cond_rule,
  /* 1602 */  immI_cmp_cond_rule,
  /* 1603 */  immI_cmp_cond_rule,
  /* 1604 */  immI_cmp_cond_rule,
  /* 1605 */  immI_rule,
  /* 1606 */  immI_cmp_cond_rule,
  /* 1607 */  immI_cmpU_cond_rule,
  /* 1608 */  immI_cmp_cond_rule,
  /* 1609 */  immI_cmpU_cond_rule,
  /* 1610 */  _Binary_immI_pRegGov_rule,
  /* 1611 */  0,
  /* 1612 */  0,
  /* 1613 */  0,
  /* 1614 */  0,
  /* 1615 */  0,
  /* 1616 */  pReg_rule,
  /* 1617 */  0,
  /* 1618 */  0,
  /* 1619 */  0,
  /* 1620 */  0,
  /* 1621 */  0,
  /* 1622 */  pRegGov_rule,
  /* 1623 */  0,
  /* 1624 */  0,
  /* 1625 */  pRegGov_rule,
  /* 1626 */  0,
  /* 1627 */  0,
  /* 1628 */  0,
  /* 1629 */  0,
  /* 1630 */  pRegGov_rule,
  /* 1631 */  pRegGov_rule,
  /* 1632 */  vReg_rule,
  /* 1633 */  pReg_rule,
  /* 1634 */  0,
  /* 1635 */  0,
  /* 1636 */  0,
  /* 1637 */  0,
  /* 1638 */  immI_rule,
  /* 1639 */  vReg_rule,
  /* 1640 */  vReg_rule,
  /* 1641 */  vReg_rule,
  /* 1642 */  vReg_rule,
  /* 1643 */  _Binary_vReg_pRegGov_rule,
  /* 1644 */  _Binary_vReg_pRegGov_rule,
  /* 1645 */  _Binary_vReg_vReg_rule,
  /* 1646 */  _Binary_vReg_vReg_rule,
  /* 1647 */  _Binary_vReg__Binary_vReg_pRegGov_rule,
  /* 1648 */  _Binary_vReg__Binary_vReg_pRegGov_rule,
  /* 1649 */  pRegGov_rule,
  /* 1650 */  pRegGov_rule,
  /* 1651 */  pRegGov_rule,
  /* 1652 */  pRegGov_rule,
  /* 1653 */  immI_rule,
  /* 1654 */  0,
  /* 1655 */  pRegGov_rule,
  /* 1656 */  pReg_rule,
  /* 1657 */  pReg_rule,
  /* 1658 */  pRegGov_rule,
  /* 1659 */  _Binary_vReg_vReg_rule,
  /* 1660 */  _Binary_vReg_vReg_rule,
  /* 1661 */  _Binary_vReg_vReg_rule,
  /* 1662 */  _Binary_vReg_vReg_rule,
  /* 1663 */  vReg_rule,
  /* 1664 */  vReg_rule,
  /* 1665 */  _Binary_iRegP_iRegP_rule,
  /* 1666 */  _Binary_iRegN_iRegN_rule,
  /* 1667 */  _Binary_iRegP_iRegP_rule,
  /* 1668 */  _Binary_iRegN_iRegN_rule,
  /* 1669 */  _Binary_iRegN_iRegN_rule,
  /* 1670 */  _Binary_iRegP_iRegP_rule,
  /* 1671 */  _Binary_iRegN_iRegN_rule,
  /* 1672 */  _Binary_iRegP_iRegP_rule,
  /* 1673 */  _Binary_iRegN_iRegN_rule,
  /* 1674 */  _Binary_iRegP_iRegP_rule,
  /* 1675 */  _Binary_iRegN_iRegN_rule,
  /* 1676 */  _Binary_iRegP_iRegP_rule,
  /* 1677 */  0,
  /* 1678 */  0,
  /* 1679 */  _Binary_iRegP_iRegP_rule,
  /* 1680 */  _Binary_iRegP_iRegP_rule,
  /* 1681 */  _Binary_iRegP_iRegP_rule,
  /* 1682 */  _Binary_iRegP_iRegP_rule,
  /* 1683 */  _Binary_iRegP_iRegP_rule,
  /* 1684 */  _Binary_iRegP_iRegP_rule,
  /* 1685 */  iRegP_rule,
  /* 1686 */  iRegP_rule,
  /* 1687 */  0,
  /* 1688 */  0,
  /* 1689 */  iRegP_rule,
  /* 1690 */  iRegP_rule,
  /* 1691 */  _Binary_iRegP_iRegP_rule,
  /* 1692 */  _Binary_iRegP_iRegP_rule,
  /* 1693 */  _Binary_iRegP_iRegP_rule,
  /* 1694 */  _Binary_iRegP_iRegP_rule,
  /* 1695 */  _Binary_iRegP_iRegP_rule,
  /* 1696 */  _Binary_iRegP_iRegP_rule,
  /* 1697 */  iRegP_rule,
  /* 1698 */  iRegP_rule,
  // last instruction
  0 // no trailing comma
};

const char        *ruleName[] = {
  /*    0 */  "UNIVERSE",
  /*    1 */  "LABEL",
  /*    2 */  "SREGI",
  /*    3 */  "SREGP",
  /*    4 */  "SREGF",
  /*    5 */  "SREGD",
  /*    6 */  "SREGL",
  /*    7 */  "METHOD",
  /*    8 */  "IMMI",
  /*    9 */  "IMMI0",
  /*   10 */  "IMMI_1",
  /*   11 */  "IMMI_M1",
  /*   12 */  "IMMIEXT",
  /*   13 */  "IMMI_GT_1",
  /*   14 */  "IMMI_LE_4",
  /*   15 */  "IMMI_16",
  /*   16 */  "IMMI_24",
  /*   17 */  "IMMI_32",
  /*   18 */  "IMMI_48",
  /*   19 */  "IMMI_56",
  /*   20 */  "IMMI_255",
  /*   21 */  "IMMI_65535",
  /*   22 */  "IMMI_POSITIVE",
  /*   23 */  "IMMI_CMP_COND",
  /*   24 */  "IMMI_CMPU_COND",
  /*   25 */  "IMML_255",
  /*   26 */  "IMML_65535",
  /*   27 */  "IMML_4294967295",
  /*   28 */  "IMML_BITMASK",
  /*   29 */  "IMMI_BITMASK",
  /*   30 */  "IMML_POSITIVE_BITMASKI",
  /*   31 */  "IMMISCALE",
  /*   32 */  "IMMI5",
  /*   33 */  "IMMIU7",
  /*   34 */  "IMMIOFFSET",
  /*   35 */  "IMMIOFFSET1",
  /*   36 */  "IMMIOFFSET2",
  /*   37 */  "IMMIOFFSET4",
  /*   38 */  "IMMIOFFSET8",
  /*   39 */  "IMMIOFFSET16",
  /*   40 */  "IMMLOFFSET",
  /*   41 */  "IMMLOFFSET1",
  /*   42 */  "IMMLOFFSET2",
  /*   43 */  "IMMLOFFSET4",
  /*   44 */  "IMMLOFFSET8",
  /*   45 */  "IMMLOFFSET16",
  /*   46 */  "IMML5",
  /*   47 */  "IMMLU7",
  /*   48 */  "IMMI8",
  /*   49 */  "IMMI8_SHIFT8",
  /*   50 */  "IMML8_SHIFT8",
  /*   51 */  "IMMBADDSUBV",
  /*   52 */  "IMMIADDSUB",
  /*   53 */  "IMMIADDSUBV",
  /*   54 */  "IMMBLOG",
  /*   55 */  "IMMSLOG",
  /*   56 */  "IMMILOG",
  /*   57 */  "IMML",
  /*   58 */  "IMML0",
  /*   59 */  "IMML_M1",
  /*   60 */  "IMMLADDSUB",
  /*   61 */  "IMMLADDSUBV",
  /*   62 */  "IMMLLOG",
  /*   63 */  "IMML_32BITS",
  /*   64 */  "IMMP",
  /*   65 */  "IMMP0",
  /*   66 */  "IMMP_1",
  /*   67 */  "IMMBYTEMAPBASE",
  /*   68 */  "IMMD",
  /*   69 */  "IMMD0",
  /*   70 */  "IMMDPACKED",
  /*   71 */  "IMMF",
  /*   72 */  "IMMF0",
  /*   73 */  "IMMFPACKED",
  /*   74 */  "IMMN",
  /*   75 */  "IMMN0",
  /*   76 */  "IMMNKLASS",
  /*   77 */  "IREGI",
  /*   78 */  "IREGINOSP",
  /*   79 */  "IREGL",
  /*   80 */  "IREGLNOSP",
  /*   81 */  "IREGP",
  /*   82 */  "IREGPNOSP",
  /*   83 */  "IREGP_R0",
  /*   84 */  "IREGP_R1",
  /*   85 */  "IREGP_R2",
  /*   86 */  "IREGP_R3",
  /*   87 */  "IREGP_R4",
  /*   88 */  "IREGP_R5",
  /*   89 */  "IREGP_R10",
  /*   90 */  "IREGL_R0",
  /*   91 */  "IREGL_R11",
  /*   92 */  "IREGI_R0",
  /*   93 */  "IREGI_R2",
  /*   94 */  "IREGI_R3",
  /*   95 */  "IREGI_R4",
  /*   96 */  "IREGN",
  /*   97 */  "IREGNNOSP",
  /*   98 */  "VREGF",
  /*   99 */  "VREGD",
  /*  100 */  "VREG",
  /*  101 */  "VECA",
  /*  102 */  "VECD",
  /*  103 */  "VECX",
  /*  104 */  "VREGD_V0",
  /*  105 */  "VREGD_V1",
  /*  106 */  "VREGD_V2",
  /*  107 */  "VREGD_V3",
  /*  108 */  "VREGD_V4",
  /*  109 */  "VREGD_V5",
  /*  110 */  "VREGD_V6",
  /*  111 */  "VREGD_V7",
  /*  112 */  "PREG",
  /*  113 */  "PREGGOV",
  /*  114 */  "PREGGOV_P0",
  /*  115 */  "PREGGOV_P1",
  /*  116 */  "RFLAGSREG",
  /*  117 */  "RFLAGSREGU",
  /*  118 */  "INLINE_CACHE_REGP",
  /*  119 */  "THREAD_REGP",
  /*  120 */  "INDIRECT",
  /*  121 */  "INDINDEXSCALEDI2L",
  /*  122 */  "INDINDEXSCALED",
  /*  123 */  "INDINDEXI2L",
  /*  124 */  "INDINDEX",
  /*  125 */  "INDOFFI1",
  /*  126 */  "INDOFFI2",
  /*  127 */  "INDOFFI4",
  /*  128 */  "INDOFFI8",
  /*  129 */  "INDOFFI16",
  /*  130 */  "INDOFFL1",
  /*  131 */  "INDOFFL2",
  /*  132 */  "INDOFFL4",
  /*  133 */  "INDOFFL8",
  /*  134 */  "INDOFFL16",
  /*  135 */  "INDIRECTN",
  /*  136 */  "INDINDEXSCALEDI2LN",
  /*  137 */  "INDINDEXSCALEDN",
  /*  138 */  "INDINDEXI2LN",
  /*  139 */  "INDINDEXN",
  /*  140 */  "INDOFFIN",
  /*  141 */  "INDOFFLN",
  /*  142 */  "STACKSLOTP",
  /*  143 */  "STACKSLOTI",
  /*  144 */  "STACKSLOTF",
  /*  145 */  "STACKSLOTD",
  /*  146 */  "STACKSLOTL",
  /*  147 */  "CMPOP",
  /*  148 */  "CMPOPU",
  /*  149 */  "CMPOPEQNE",
  /*  150 */  "CMPOPLTGE",
  /*  151 */  "CMPOPUEQNELTGE",
  /*  152 */  "IREGL2I",
  /*  153 */  "VMEMA_IMMIOFFSET4",
  /*  154 */  "VMEMA_IMMLOFFSET4",
  /*  155 */  "VMEMA_INDOFFI4",
  /*  156 */  "VMEMA_INDOFFL4",
  // last operand
  /*  157 */  "VMEM2",
  /*  158 */  "VMEM4",
  /*  159 */  "VMEM8",
  /*  160 */  "VMEM16",
  /*  161 */  "MEMORY1",
  /*  162 */  "MEMORY2",
  /*  163 */  "MEMORY4",
  /*  164 */  "MEMORY8",
  /*  165 */  "MEMORY",
  /*  166 */  "IREGIORL2I",
  /*  167 */  "VMEMA",
  // last operand class
  /*  168 */  "_ConvI2L_iRegI_",
  /*  169 */  "_LShiftL__ConvI2L_iRegI__immIScale",
  /*  170 */  "_LShiftL_iRegL_immIScale",
  /*  171 */  "_DecodeN_iRegN_",
  /*  172 */  "_LoadB_memory1_",
  /*  173 */  "_LoadUB_memory1_",
  /*  174 */  "_LoadS_memory2_",
  /*  175 */  "_LoadUS_memory2_",
  /*  176 */  "_LoadI_memory4_",
  /*  177 */  "_ConvI2L__LoadI_memory4__",
  /*  178 */  "_LoadB_indirect_",
  /*  179 */  "_LoadUB_indirect_",
  /*  180 */  "_LoadUS_indirect_",
  /*  181 */  "_LoadS_indirect_",
  /*  182 */  "_LoadI_indirect_",
  /*  183 */  "_ConvI2L__LoadI_indirect__",
  /*  184 */  "_LoadL_memory8_",
  /*  185 */  "_CastP2X_iRegP_",
  /*  186 */  "_CastP2X__DecodeN_iRegN__",
  /*  187 */  "_Binary_iRegINoSp_iRegINoSp",
  /*  188 */  "_Binary_iRegLNoSp_iRegLNoSp",
  /*  189 */  "_Binary_iRegP_iRegP",
  /*  190 */  "_Binary_iRegNNoSp_iRegNNoSp",
  /*  191 */  "_Binary_iRegI_iRegI",
  /*  192 */  "_Binary_iRegL_iRegL",
  /*  193 */  "_Binary_iRegN_iRegN",
  /*  194 */  "_Binary_cmpOp_rFlagsReg",
  /*  195 */  "_Binary_iRegIorL2I_iRegIorL2I",
  /*  196 */  "_Binary_cmpOpU_rFlagsRegU",
  /*  197 */  "_Binary_immI0_iRegIorL2I",
  /*  198 */  "_Binary_iRegIorL2I_immI0",
  /*  199 */  "_Binary_immI_1_immI0",
  /*  200 */  "_Binary_iRegL_immL0",
  /*  201 */  "_Binary_immL0_iRegL",
  /*  202 */  "_Binary_iRegP_immP0",
  /*  203 */  "_Binary_immP0_iRegP",
  /*  204 */  "_Binary_iRegN_immN0",
  /*  205 */  "_Binary_immN0_iRegN",
  /*  206 */  "_Binary_vRegF_vRegF",
  /*  207 */  "_Binary_vRegD_vRegD",
  /*  208 */  "_ConvL2I_iRegL_",
  /*  209 */  "_ConvI2L_iRegIorL2I_",
  /*  210 */  "_LShiftL__ConvI2L_iRegIorL2I__immIScale",
  /*  211 */  "_MulI_iRegIorL2I_iRegIorL2I",
  /*  212 */  "_SubI_immI0_iRegIorL2I",
  /*  213 */  "_MulL_iRegL_iRegL",
  /*  214 */  "_SubL_immL0_iRegL",
  /*  215 */  "_MulL__ConvI2L_iRegIorL2I___ConvI2L_iRegIorL2I_",
  /*  216 */  "_SubL_immL0__ConvI2L_iRegIorL2I_",
  /*  217 */  "_URShiftI_iRegIorL2I_immI",
  /*  218 */  "_RShiftI_iRegIorL2I_immI",
  /*  219 */  "_LShiftI_iRegIorL2I_immI",
  /*  220 */  "_URShiftL_iRegL_immI",
  /*  221 */  "_RShiftL_iRegL_immI",
  /*  222 */  "_LShiftL_iRegL_immI",
  /*  223 */  "_XorI_iRegIorL2I_immI_M1",
  /*  224 */  "_XorL_iRegL_immL_M1",
  /*  225 */  "_XorI_iRegIorL2I_iRegIorL2I",
  /*  226 */  "_XorL_iRegL_iRegL",
  /*  227 */  "_XorI__URShiftI_iRegIorL2I_immI_immI_M1",
  /*  228 */  "_XorL__URShiftL_iRegL_immI_immL_M1",
  /*  229 */  "_XorI__RShiftI_iRegIorL2I_immI_immI_M1",
  /*  230 */  "_XorL__RShiftL_iRegL_immI_immL_M1",
  /*  231 */  "_RotateRight_iRegIorL2I_immI",
  /*  232 */  "_XorI__RotateRight_iRegIorL2I_immI_immI_M1",
  /*  233 */  "_RotateRight_iRegL_immI",
  /*  234 */  "_XorL__RotateRight_iRegL_immI_immL_M1",
  /*  235 */  "_XorI__LShiftI_iRegIorL2I_immI_immI_M1",
  /*  236 */  "_XorL__LShiftL_iRegL_immI_immL_M1",
  /*  237 */  "_XorI__URShiftI_iRegIorL2I_immI_iRegIorL2I",
  /*  238 */  "_XorI_iRegIorL2I__URShiftI_iRegIorL2I_immI",
  /*  239 */  "_XorL__URShiftL_iRegL_immI_iRegL",
  /*  240 */  "_XorL_iRegL__URShiftL_iRegL_immI",
  /*  241 */  "_XorI__RShiftI_iRegIorL2I_immI_iRegIorL2I",
  /*  242 */  "_XorI_iRegIorL2I__RShiftI_iRegIorL2I_immI",
  /*  243 */  "_XorL__RShiftL_iRegL_immI_iRegL",
  /*  244 */  "_XorL_iRegL__RShiftL_iRegL_immI",
  /*  245 */  "_XorI__RotateRight_iRegIorL2I_immI_iRegIorL2I",
  /*  246 */  "_XorI_iRegIorL2I__RotateRight_iRegIorL2I_immI",
  /*  247 */  "_XorL__RotateRight_iRegL_immI_iRegL",
  /*  248 */  "_XorL_iRegL__RotateRight_iRegL_immI",
  /*  249 */  "_XorI__LShiftI_iRegIorL2I_immI_iRegIorL2I",
  /*  250 */  "_XorI_iRegIorL2I__LShiftI_iRegIorL2I_immI",
  /*  251 */  "_XorL__LShiftL_iRegL_immI_iRegL",
  /*  252 */  "_XorL_iRegL__LShiftL_iRegL_immI",
  /*  253 */  "_AndI__URShiftI_iRegIorL2I_immI_immI_bitmask",
  /*  254 */  "_AndI_iRegIorL2I_immI_bitmask",
  /*  255 */  "_AndL_iRegL_immL_bitmask",
  /*  256 */  "_LShiftI__AndI_iRegIorL2I_immI_bitmask_immI",
  /*  257 */  "_AndL_iRegL_immL_positive_bitmaskI",
  /*  258 */  "_LShiftL__AndL_iRegL_immL_positive_bitmaskI_immI",
  /*  259 */  "_ConvI2L__AndI_iRegIorL2I_immI_bitmask_",
  /*  260 */  "_ConvL2I__AndL_iRegL_immL_positive_bitmaskI_",
  /*  261 */  "_AndI_iRegI_immI_bitmask",
  /*  262 */  "_LShiftI_iRegIorL2I_immI_16",
  /*  263 */  "_RShiftI__LShiftI_iRegIorL2I_immI_16_immI_16",
  /*  264 */  "_LShiftI_iRegIorL2I_immI_24",
  /*  265 */  "_RShiftI__LShiftI_iRegIorL2I_immI_24_immI_24",
  /*  266 */  "_URShiftI__LShiftI_iRegIorL2I_immI_24_immI_24",
  /*  267 */  "_LShiftL_iRegL_immI_48",
  /*  268 */  "_RShiftL__LShiftL_iRegL_immI_48_immI_48",
  /*  269 */  "_LShiftL_iRegL_immI_32",
  /*  270 */  "_RShiftL__LShiftL_iRegL_immI_32_immI_32",
  /*  271 */  "_LShiftL_iRegL_immI_56",
  /*  272 */  "_RShiftL__LShiftL_iRegL_immI_56_immI_56",
  /*  273 */  "_URShiftL__LShiftL_iRegL_immI_56_immI_56",
  /*  274 */  "_AndI_iRegIorL2I_immI_255",
  /*  275 */  "_AndI_iRegIorL2I_immI_65535",
  /*  276 */  "_AndL_iRegL_immL_255",
  /*  277 */  "_AndL_iRegL_immL_65535",
  /*  278 */  "_AndL_iRegL_immL_4294967295",
  /*  279 */  "_LShiftL__RShiftL__LShiftL_iRegL_immI_56_immI_56_immIExt",
  /*  280 */  "_LShiftL__RShiftL__LShiftL_iRegL_immI_48_immI_48_immIExt",
  /*  281 */  "_LShiftL__RShiftL__LShiftL_iRegL_immI_32_immI_32_immIExt",
  /*  282 */  "_LShiftI__RShiftI__LShiftI_iRegIorL2I_immI_24_immI_24_immIExt",
  /*  283 */  "_LShiftI__RShiftI__LShiftI_iRegIorL2I_immI_16_immI_16_immIExt",
  /*  284 */  "_LShiftL__ConvI2L_iRegIorL2I__immIExt",
  /*  285 */  "_LShiftL__AndL_iRegL_immL_255_immIExt",
  /*  286 */  "_LShiftL__AndL_iRegL_immL_65535_immIExt",
  /*  287 */  "_LShiftL__AndL_iRegL_immL_4294967295_immIExt",
  /*  288 */  "_LShiftI__AndI_iRegIorL2I_immI_255_immIExt",
  /*  289 */  "_LShiftI__AndI_iRegIorL2I_immI_65535_immIExt",
  /*  290 */  "_NegF_vRegF_",
  /*  291 */  "_Binary_vRegF__NegF_vRegF_",
  /*  292 */  "_NegD_vRegD_",
  /*  293 */  "_Binary_vRegD__NegD_vRegD_",
  /*  294 */  "_SubF_vRegF_vRegF",
  /*  295 */  "_SubD_vRegD_vRegD",
  /*  296 */  "_OverflowMulI_iRegIorL2I_iRegIorL2I",
  /*  297 */  "_OverflowMulL_iRegL_iRegL",
  /*  298 */  "_CmpI_iRegIorL2I_immI0",
  /*  299 */  "_CmpL_iRegL_immL0",
  /*  300 */  "_CmpP_iRegP_immP0",
  /*  301 */  "_CmpN_iRegN_immN0",
  /*  302 */  "_CmpP__DecodeN_iRegN__immP0",
  /*  303 */  "_CmpU_iRegIorL2I_immI0",
  /*  304 */  "_CmpUL_iRegL_immL0",
  /*  305 */  "_AndL_iRegL_immL",
  /*  306 */  "_CmpL__AndL_iRegL_immL_immL0",
  /*  307 */  "_AndI_iRegIorL2I_immI",
  /*  308 */  "_CmpI__AndI_iRegIorL2I_immI_immI0",
  /*  309 */  "_AndL_iRegL_iRegL",
  /*  310 */  "_AndI_iRegIorL2I_iRegIorL2I",
  /*  311 */  "_PartialSubtypeCheck_iRegP_R4_iRegP_R0",
  /*  312 */  "_Binary_iRegP_R1_iRegI_R2",
  /*  313 */  "_Binary_iRegP_R3_iRegI_R4",
  /*  314 */  "_Binary_iRegP_R1_iRegI_R4",
  /*  315 */  "_Binary_iRegP_R3_iRegI_R2",
  /*  316 */  "_Binary_iRegP_R3_immI_le_4",
  /*  317 */  "_Binary_iRegP_R3_immI_1",
  /*  318 */  "_Binary_iRegP_R1_iRegP_R3",
  /*  319 */  "_Binary_iRegP_R1_iRegI_R3",
  /*  320 */  "_Binary_vReg_pRegGov",
  /*  321 */  "_Binary_vReg_vReg",
  /*  322 */  "_Replicate_immBAddSubV_",
  /*  323 */  "_Replicate_immIAddSubV_",
  /*  324 */  "_Replicate_immLAddSubV_",
  /*  325 */  "_Replicate_immBLog_",
  /*  326 */  "_Replicate_immSLog_",
  /*  327 */  "_Replicate_immILog_",
  /*  328 */  "_Replicate_immLLog_",
  /*  329 */  "_XorV_vReg_vReg",
  /*  330 */  "_Replicate_immI_M1_",
  /*  331 */  "_Replicate_immL_M1_",
  /*  332 */  "_Binary_vReg__Replicate_immI_M1_",
  /*  333 */  "_Binary_vReg__Replicate_immL_M1_",
  /*  334 */  "_XorV_vReg__Replicate_immI_M1_",
  /*  335 */  "_XorV__Replicate_immI_M1__vReg",
  /*  336 */  "_XorV_vReg__Replicate_immL_M1_",
  /*  337 */  "_XorV__Replicate_immL_M1__vReg",
  /*  338 */  "_Binary_vReg__XorV_vReg__Replicate_immI_M1_",
  /*  339 */  "_Binary_vReg__XorV__Replicate_immI_M1__vReg",
  /*  340 */  "_Binary_vReg__XorV_vReg__Replicate_immL_M1_",
  /*  341 */  "_Binary_vReg__XorV__Replicate_immL_M1__vReg",
  /*  342 */  "_SubVF_vReg_vReg",
  /*  343 */  "_SubVD_vReg_vReg",
  /*  344 */  "_SubVF__Binary_vReg_vReg_pRegGov",
  /*  345 */  "_SubVD__Binary_vReg_vReg_pRegGov",
  /*  346 */  "_MulVB_vReg_vReg",
  /*  347 */  "_MulVS_vReg_vReg",
  /*  348 */  "_MulVI_vReg_vReg",
  /*  349 */  "_MulVL_vReg_vReg",
  /*  350 */  "_Binary_vReg__MulVB_vReg_vReg",
  /*  351 */  "_Binary_vReg__MulVS_vReg_vReg",
  /*  352 */  "_Binary_vReg__MulVI_vReg_vReg",
  /*  353 */  "_Binary_vReg__MulVL_vReg_vReg",
  /*  354 */  "_NegVF_vReg_",
  /*  355 */  "_Binary_vReg__NegVF_vReg_",
  /*  356 */  "_NegVD_vReg_",
  /*  357 */  "_Binary_vReg__NegVD_vReg_",
  /*  358 */  "_Binary__NegVF_vReg__pRegGov",
  /*  359 */  "_Binary__NegVD_vReg__pRegGov",
  /*  360 */  "_LShiftCntV_immI_",
  /*  361 */  "_RShiftCntV_immI_positive_",
  /*  362 */  "_RShiftVB_vReg__RShiftCntV_immI_positive_",
  /*  363 */  "_RShiftVS_vReg__RShiftCntV_immI_positive_",
  /*  364 */  "_RShiftVI_vReg__RShiftCntV_immI_positive_",
  /*  365 */  "_RShiftVL_vReg__RShiftCntV_immI_positive_",
  /*  366 */  "_URShiftVB_vReg__RShiftCntV_immI_positive_",
  /*  367 */  "_URShiftVS_vReg__RShiftCntV_immI_positive_",
  /*  368 */  "_URShiftVI_vReg__RShiftCntV_immI_positive_",
  /*  369 */  "_URShiftVL_vReg__RShiftCntV_immI_positive_",
  /*  370 */  "_Binary_vReg__LShiftCntV_immI_",
  /*  371 */  "_Binary_vReg__RShiftCntV_immI_positive_",
  /*  372 */  "_Binary_iRegIorL2I_vReg",
  /*  373 */  "_Binary_iRegL_vReg",
  /*  374 */  "_Binary_vRegF_vReg",
  /*  375 */  "_Binary_vRegD_vReg",
  /*  376 */  "_Binary_vReg_iRegIorL2I",
  /*  377 */  "_Binary_vReg_iRegL",
  /*  378 */  "_Binary_vReg_vRegF",
  /*  379 */  "_Binary_vReg_vRegD",
  /*  380 */  "_LoadVector_indirect_",
  /*  381 */  "_LoadVectorMasked_vmemA_pRegGov",
  /*  382 */  "_VectorStoreMask_pReg_immI_gt_1",
  /*  383 */  "_Binary__VectorStoreMask_pReg_immI_gt_1_pRegGov",
  /*  384 */  "_MaskAll_immI_M1_",
  /*  385 */  "_XorVMask_pReg__MaskAll_immI_M1_",
  /*  386 */  "_MaskAll_immL_M1_",
  /*  387 */  "_XorVMask_pReg__MaskAll_immL_M1_",
  /*  388 */  "_Replicate_immI0_",
  /*  389 */  "_Binary_vReg__Replicate_immI0_",
  /*  390 */  "_Replicate_immL0_",
  /*  391 */  "_Binary_vReg__Replicate_immL0_",
  /*  392 */  "_Replicate_immF0_",
  /*  393 */  "_Binary_vReg__Replicate_immF0_",
  /*  394 */  "_Replicate_immD0_",
  /*  395 */  "_Binary_vReg__Replicate_immD0_",
  /*  396 */  "_Replicate_immI5_",
  /*  397 */  "_Binary_vReg__Replicate_immI5_",
  /*  398 */  "_Replicate_immIU7_",
  /*  399 */  "_Binary_vReg__Replicate_immIU7_",
  /*  400 */  "_Replicate_immL5_",
  /*  401 */  "_Binary_vReg__Replicate_immL5_",
  /*  402 */  "_Replicate_immLU7_",
  /*  403 */  "_Binary_vReg__Replicate_immLU7_",
  /*  404 */  "_Binary_immI_pRegGov",
  /*  405 */  "_VectorStoreMask_vReg_immI_gt_1",
  /*  406 */  "_SubL_iRegL_iRegL",
  /*  407 */  "_Binary_vReg__Binary_vReg_pRegGov",
  // last internally defined operand
  /*  408 */  "loadConI",
  /*  409 */  "loadConL",
  /*  410 */  "loadConP",
  /*  411 */  "loadConP0",
  /*  412 */  "loadConP1",
  /*  413 */  "loadByteMapBase",
  /*  414 */  "loadConN",
  /*  415 */  "loadConN0",
  /*  416 */  "loadConNKlass",
  /*  417 */  "loadConF_packed",
  /*  418 */  "loadConF",
  /*  419 */  "loadConD_packed",
  /*  420 */  "loadConD",
  /*  421 */  "countLeadingZerosI",
  /*  422 */  "countLeadingZerosL",
  /*  423 */  "countTrailingZerosI",
  /*  424 */  "countTrailingZerosL",
  /*  425 */  "castX2P",
  /*  426 */  "castP2X",
  /*  427 */  "checkCastPP",
  /*  428 */  "castPP",
  /*  429 */  "castII",
  /*  430 */  "castLL",
  /*  431 */  "castFF",
  /*  432 */  "castDD",
  /*  433 */  "castVV",
  /*  434 */  "castVVMask",
  /*  435 */  "bits_reverse_I",
  /*  436 */  "bits_reverse_L",
  /*  437 */  "negF_reg_reg",
  /*  438 */  "negD_reg_reg",
  /*  439 */  "absF_reg",
  /*  440 */  "absD_reg",
  /*  441 */  "MoveF2I_stack_reg",
  /*  442 */  "MoveI2F_stack_reg",
  /*  443 */  "MoveD2L_stack_reg",
  /*  444 */  "MoveL2D_stack_reg",
  /*  445 */  "MoveF2I_reg_reg",
  /*  446 */  "MoveI2F_reg_reg",
  /*  447 */  "MoveD2L_reg_reg",
  /*  448 */  "MoveL2D_reg_reg",
  /*  449 */  "overflowAddI_reg_reg",
  /*  450 */  "overflowAddI_reg_imm",
  /*  451 */  "overflowAddL_reg_reg",
  /*  452 */  "overflowAddL_reg_imm",
  /*  453 */  "overflowSubI_reg_reg",
  /*  454 */  "overflowSubI_reg_imm",
  /*  455 */  "overflowSubL_reg_reg",
  /*  456 */  "overflowSubL_reg_imm",
  /*  457 */  "overflowNegI_reg",
  /*  458 */  "overflowNegL_reg",
  /*  459 */  "overflowMulI_reg",
  /*  460 */  "overflowMulL_reg",
  /*  461 */  "compI_reg_reg",
  /*  462 */  "compI_reg_immI0",
  /*  463 */  "compI_reg_immIAddSub",
  /*  464 */  "compI_reg_immI",
  /*  465 */  "compU_reg_reg",
  /*  466 */  "compU_reg_immI0",
  /*  467 */  "compU_reg_immIAddSub",
  /*  468 */  "compU_reg_immI",
  /*  469 */  "compL_reg_reg",
  /*  470 */  "compL_reg_immL0",
  /*  471 */  "compL_reg_immLAddSub",
  /*  472 */  "compL_reg_immL",
  /*  473 */  "compUL_reg_reg",
  /*  474 */  "compUL_reg_immL0",
  /*  475 */  "compUL_reg_immLAddSub",
  /*  476 */  "compUL_reg_immL",
  /*  477 */  "compP_reg_reg",
  /*  478 */  "compN_reg_reg",
  /*  479 */  "testP_reg",
  /*  480 */  "testN_reg",
  /*  481 */  "compF_reg_reg",
  /*  482 */  "compF_reg_zero",
  /*  483 */  "compD_reg_reg",
  /*  484 */  "compD_reg_zero",
  /*  485 */  "compI_reg_imm0",
  /*  486 */  "cmpL_and",
  /*  487 */  "cmpI_and",
  /*  488 */  "cmpL_and_reg",
  /*  489 */  "cmpI_and_reg",
  /*  490 */  "cmpFastLock",
  /*  491 */  "cmpFastUnlock",
  /*  492 */  "cmpFastLockLightweight",
  /*  493 */  "cmpFastUnlockLightweight",
  /*  494 */  "partialSubtypeCheckVsZero",
  /*  495 */  "tlsLoadP",
  /*  496 */  "vloadcon",
  /*  497 */  "vabsB",
  /*  498 */  "vabsS",
  /*  499 */  "vabsI",
  /*  500 */  "vabsL",
  /*  501 */  "vabsF",
  /*  502 */  "vabsD",
  /*  503 */  "vnegI",
  /*  504 */  "vnegL",
  /*  505 */  "vnegF",
  /*  506 */  "vnegD",
  /*  507 */  "vsqrtF",
  /*  508 */  "vsqrtD",
  /*  509 */  "vshiftcntL",
  /*  510 */  "vshiftcntR",
  /*  511 */  "reinterpret_same_size",
  /*  512 */  "reinterpret_resize_le128b",
  /*  513 */  "vzeroExtBtoX",
  /*  514 */  "vzeroExtStoX",
  /*  515 */  "vzeroExtItoX",
  /*  516 */  "vcvtBtoX",
  /*  517 */  "vcvtStoB_neon",
  /*  518 */  "vcvtStoX_extend",
  /*  519 */  "vcvtItoX",
  /*  520 */  "vcvtLtoI_neon",
  /*  521 */  "vcvtLtoD",
  /*  522 */  "vcvtFtoX",
  /*  523 */  "vcvtDtoL",
  /*  524 */  "vcvtDtoF_64b",
  /*  525 */  "vcvtHFtoF",
  /*  526 */  "vcvtFtoHF_neon",
  /*  527 */  "replicateI",
  /*  528 */  "replicateL",
  /*  529 */  "replicateF",
  /*  530 */  "replicateD",
  /*  531 */  "replicateI_imm_le128b",
  /*  532 */  "replicateB_imm8_gt128b",
  /*  533 */  "replicateI_imm8_gt128b",
  /*  534 */  "replicateL_imm_128b",
  /*  535 */  "replicateL_imm8_gt128b",
  /*  536 */  "vloadmask_neon",
  /*  537 */  "vmaskcast_same_esize_neon",
  /*  538 */  "vmaskcast_extend_neon",
  /*  539 */  "vmaskcast_narrow_neon",
  /*  540 */  "vmaskcast_same_esize_sve",
  /*  541 */  "vmaskcast_extend_sve",
  /*  542 */  "vmask_reinterpret_same_esize",
  /*  543 */  "vmask_truecount_sve",
  /*  544 */  "vmask_firsttrue_neon",
  /*  545 */  "vmask_lasttrue_neon",
  /*  546 */  "vmask_tolong_neon",
  /*  547 */  "vpopcountI",
  /*  548 */  "vpopcountL",
  /*  549 */  "vtest_anytrue_neon",
  /*  550 */  "vtest_anytrue_sve",
  /*  551 */  "vtest_alltrue_neon",
  /*  552 */  "vtest_alltrue_sve",
  /*  553 */  "loadshuffle",
  /*  554 */  "vcountLeadingZeros",
  /*  555 */  "vcountTrailingZeros",
  /*  556 */  "vreverse",
  /*  557 */  "vreverseBytes",
  /*  558 */  "loadB",
  /*  559 */  "loadB2L",
  /*  560 */  "loadUB",
  /*  561 */  "loadUB2L",
  /*  562 */  "loadS",
  /*  563 */  "loadS2L",
  /*  564 */  "loadUS",
  /*  565 */  "loadUS2L",
  /*  566 */  "loadI",
  /*  567 */  "loadI2L",
  /*  568 */  "loadUI2L",
  /*  569 */  "loadL",
  /*  570 */  "loadRange",
  /*  571 */  "loadP",
  /*  572 */  "loadN",
  /*  573 */  "loadKlass",
  /*  574 */  "loadNKlass",
  /*  575 */  "loadF",
  /*  576 */  "loadD",
  /*  577 */  "storeimmCM0",
  /*  578 */  "storeimmCM0_ordered",
  /*  579 */  "storeB",
  /*  580 */  "storeimmB0",
  /*  581 */  "storeC",
  /*  582 */  "storeimmC0",
  /*  583 */  "storeI",
  /*  584 */  "storeimmI0",
  /*  585 */  "storeL",
  /*  586 */  "storeimmL0",
  /*  587 */  "storeP",
  /*  588 */  "storeimmP0",
  /*  589 */  "storeN",
  /*  590 */  "storeImmN0",
  /*  591 */  "storeF",
  /*  592 */  "storeD",
  /*  593 */  "storeNKlass",
  /*  594 */  "prefetchalloc",
  /*  595 */  "loadB_volatile",
  /*  596 */  "loadB2L_volatile",
  /*  597 */  "loadUB_volatile",
  /*  598 */  "loadUB2L_volatile",
  /*  599 */  "loadS_volatile",
  /*  600 */  "loadUS_volatile",
  /*  601 */  "loadUS2L_volatile",
  /*  602 */  "loadS2L_volatile",
  /*  603 */  "loadI_volatile",
  /*  604 */  "loadUI2L_volatile",
  /*  605 */  "loadL_volatile",
  /*  606 */  "loadP_volatile",
  /*  607 */  "loadN_volatile",
  /*  608 */  "loadF_volatile",
  /*  609 */  "loadD_volatile",
  /*  610 */  "storeB_volatile",
  /*  611 */  "storeimmB0_volatile",
  /*  612 */  "storeC_volatile",
  /*  613 */  "storeimmC0_volatile",
  /*  614 */  "storeI_volatile",
  /*  615 */  "storeimmI0_volatile",
  /*  616 */  "storeL_volatile",
  /*  617 */  "storeimmL0_volatile",
  /*  618 */  "storeP_volatile",
  /*  619 */  "storeimmP0_volatile",
  /*  620 */  "storeN_volatile",
  /*  621 */  "storeimmN0_volatile",
  /*  622 */  "storeF_volatile",
  /*  623 */  "storeD_volatile",
  /*  624 */  "cacheWB",
  /*  625 */  "cacheWBPreSync",
  /*  626 */  "cacheWBPostSync",
  /*  627 */  "bytes_reverse_int",
  /*  628 */  "bytes_reverse_long",
  /*  629 */  "bytes_reverse_unsigned_short",
  /*  630 */  "bytes_reverse_short",
  /*  631 */  "popCountI",
  /*  632 */  "popCountI_mem",
  /*  633 */  "popCountL",
  /*  634 */  "popCountL_mem",
  /*  635 */  "verify_vector_alignment",
  /*  636 */  "load_fence",
  /*  637 */  "unnecessary_membar_acquire",
  /*  638 */  "membar_acquire",
  /*  639 */  "membar_acquire_lock",
  /*  640 */  "store_fence",
  /*  641 */  "unnecessary_membar_release",
  /*  642 */  "membar_release",
  /*  643 */  "membar_storestore",
  /*  644 */  "membar_storestore_0",
  /*  645 */  "membar_release_lock",
  /*  646 */  "unnecessary_membar_volatile",
  /*  647 */  "membar_volatile",
  /*  648 */  "convP2I",
  /*  649 */  "convN2I",
  /*  650 */  "encodeHeapOop",
  /*  651 */  "encodeHeapOop_not_null",
  /*  652 */  "decodeHeapOop",
  /*  653 */  "decodeHeapOop_not_null",
  /*  654 */  "encodeKlass_not_null",
  /*  655 */  "decodeKlass_not_null",
  /*  656 */  "compareAndSwapB",
  /*  657 */  "compareAndSwapS",
  /*  658 */  "compareAndSwapI",
  /*  659 */  "compareAndSwapL",
  /*  660 */  "compareAndSwapP",
  /*  661 */  "compareAndSwapN",
  /*  662 */  "compareAndSwapBAcq",
  /*  663 */  "compareAndSwapSAcq",
  /*  664 */  "compareAndSwapIAcq",
  /*  665 */  "compareAndSwapLAcq",
  /*  666 */  "compareAndSwapPAcq",
  /*  667 */  "compareAndSwapNAcq",
  /*  668 */  "compareAndExchangeB",
  /*  669 */  "compareAndExchangeS",
  /*  670 */  "compareAndExchangeI",
  /*  671 */  "compareAndExchangeL",
  /*  672 */  "compareAndExchangeN",
  /*  673 */  "compareAndExchangeP",
  /*  674 */  "compareAndExchangeBAcq",
  /*  675 */  "compareAndExchangeSAcq",
  /*  676 */  "compareAndExchangeIAcq",
  /*  677 */  "compareAndExchangeLAcq",
  /*  678 */  "compareAndExchangeNAcq",
  /*  679 */  "compareAndExchangePAcq",
  /*  680 */  "weakCompareAndSwapB",
  /*  681 */  "weakCompareAndSwapS",
  /*  682 */  "weakCompareAndSwapI",
  /*  683 */  "weakCompareAndSwapL",
  /*  684 */  "weakCompareAndSwapN",
  /*  685 */  "weakCompareAndSwapP",
  /*  686 */  "weakCompareAndSwapBAcq",
  /*  687 */  "weakCompareAndSwapSAcq",
  /*  688 */  "weakCompareAndSwapIAcq",
  /*  689 */  "weakCompareAndSwapLAcq",
  /*  690 */  "weakCompareAndSwapNAcq",
  /*  691 */  "weakCompareAndSwapPAcq",
  /*  692 */  "get_and_setI",
  /*  693 */  "get_and_setL",
  /*  694 */  "get_and_setN",
  /*  695 */  "get_and_setP",
  /*  696 */  "get_and_setIAcq",
  /*  697 */  "get_and_setLAcq",
  /*  698 */  "get_and_setNAcq",
  /*  699 */  "get_and_setPAcq",
  /*  700 */  "get_and_addL",
  /*  701 */  "get_and_addL_no_res",
  /*  702 */  "get_and_addLi",
  /*  703 */  "get_and_addLi_no_res",
  /*  704 */  "get_and_addI",
  /*  705 */  "get_and_addI_no_res",
  /*  706 */  "get_and_addIi",
  /*  707 */  "get_and_addIi_no_res",
  /*  708 */  "get_and_addLAcq",
  /*  709 */  "get_and_addL_no_resAcq",
  /*  710 */  "get_and_addLiAcq",
  /*  711 */  "get_and_addLi_no_resAcq",
  /*  712 */  "get_and_addIAcq",
  /*  713 */  "get_and_addI_no_resAcq",
  /*  714 */  "get_and_addIiAcq",
  /*  715 */  "get_and_addIi_no_resAcq",
  /*  716 */  "cmpU3_reg_reg",
  /*  717 */  "cmpU3_reg_imm",
  /*  718 */  "cmpUL3_reg_reg",
  /*  719 */  "cmpUL3_reg_imm",
  /*  720 */  "cmpL3_reg_reg",
  /*  721 */  "cmpL3_reg_imm",
  /*  722 */  "cmovI_reg_reg",
  /*  723 */  "cmovUI_reg_reg",
  /*  724 */  "cmovI_zero_reg",
  /*  725 */  "cmovUI_zero_reg",
  /*  726 */  "cmovI_reg_zero",
  /*  727 */  "cmovUI_reg_zero",
  /*  728 */  "cmovI_reg_zero_one",
  /*  729 */  "cmovUI_reg_zero_one",
  /*  730 */  "cmovL_reg_reg",
  /*  731 */  "cmovUL_reg_reg",
  /*  732 */  "cmovL_reg_zero",
  /*  733 */  "cmovUL_reg_zero",
  /*  734 */  "cmovL_zero_reg",
  /*  735 */  "cmovUL_zero_reg",
  /*  736 */  "cmovP_reg_reg",
  /*  737 */  "cmovUP_reg_reg",
  /*  738 */  "cmovP_reg_zero",
  /*  739 */  "cmovUP_reg_zero",
  /*  740 */  "cmovP_zero_reg",
  /*  741 */  "cmovUP_zero_reg",
  /*  742 */  "cmovN_reg_reg",
  /*  743 */  "cmovUN_reg_reg",
  /*  744 */  "cmovN_reg_zero",
  /*  745 */  "cmovUN_reg_zero",
  /*  746 */  "cmovN_zero_reg",
  /*  747 */  "cmovUN_zero_reg",
  /*  748 */  "cmovF_reg",
  /*  749 */  "cmovUF_reg",
  /*  750 */  "cmovD_reg",
  /*  751 */  "cmovUD_reg",
  /*  752 */  "addI_reg_reg",
  /*  753 */  "addI_reg_imm",
  /*  754 */  "addI_reg_imm_i2l",
  /*  755 */  "addP_reg_reg",
  /*  756 */  "addP_reg_reg_ext",
  /*  757 */  "addP_reg_reg_lsl",
  /*  758 */  "addP_reg_reg_ext_shift",
  /*  759 */  "lshift_ext",
  /*  760 */  "addP_reg_imm",
  /*  761 */  "addL_reg_reg",
  /*  762 */  "addL_reg_imm",
  /*  763 */  "subI_reg_reg",
  /*  764 */  "subI_reg_imm",
  /*  765 */  "subL_reg_reg",
  /*  766 */  "subL_reg_imm",
  /*  767 */  "negI_reg",
  /*  768 */  "negL_reg",
  /*  769 */  "mulI",
  /*  770 */  "smulI",
  /*  771 */  "smulI_0",
  /*  772 */  "mulL",
  /*  773 */  "mulHiL_rReg",
  /*  774 */  "umulHiL_rReg",
  /*  775 */  "maddI",
  /*  776 */  "maddI_0",
  /*  777 */  "msubI",
  /*  778 */  "mnegI",
  /*  779 */  "mnegI_0",
  /*  780 */  "maddL",
  /*  781 */  "maddL_0",
  /*  782 */  "msubL",
  /*  783 */  "mnegL",
  /*  784 */  "mnegL_0",
  /*  785 */  "smaddL",
  /*  786 */  "smaddL_1",
  /*  787 */  "smaddL_0",
  /*  788 */  "smaddL_2",
  /*  789 */  "smsubL",
  /*  790 */  "smsubL_0",
  /*  791 */  "smnegL",
  /*  792 */  "smnegL_0",
  /*  793 */  "muladdS2I",
  /*  794 */  "divI",
  /*  795 */  "divL",
  /*  796 */  "modI",
  /*  797 */  "modL",
  /*  798 */  "UdivI_reg_reg",
  /*  799 */  "UdivL_reg_reg",
  /*  800 */  "UmodI_reg_reg",
  /*  801 */  "UModL_reg_reg",
  /*  802 */  "lShiftI_reg_reg",
  /*  803 */  "lShiftI_reg_imm",
  /*  804 */  "urShiftI_reg_reg",
  /*  805 */  "urShiftI_reg_imm",
  /*  806 */  "rShiftI_reg_reg",
  /*  807 */  "rShiftI_reg_imm",
  /*  808 */  "lShiftL_reg_reg",
  /*  809 */  "lShiftL_reg_imm",
  /*  810 */  "urShiftL_reg_reg",
  /*  811 */  "urShiftL_reg_imm",
  /*  812 */  "urShiftP_reg_imm",
  /*  813 */  "rShiftL_reg_reg",
  /*  814 */  "rShiftL_reg_imm",
  /*  815 */  "regL_not_reg",
  /*  816 */  "regI_not_reg",
  /*  817 */  "NegI_reg_URShift_reg",
  /*  818 */  "NegI_reg_RShift_reg",
  /*  819 */  "NegI_reg_LShift_reg",
  /*  820 */  "NegL_reg_URShift_reg",
  /*  821 */  "NegL_reg_RShift_reg",
  /*  822 */  "NegL_reg_LShift_reg",
  /*  823 */  "AndI_reg_not_reg",
  /*  824 */  "AndI_reg_not_reg_0",
  /*  825 */  "AndL_reg_not_reg",
  /*  826 */  "AndL_reg_not_reg_0",
  /*  827 */  "OrI_reg_not_reg",
  /*  828 */  "OrI_reg_not_reg_0",
  /*  829 */  "OrL_reg_not_reg",
  /*  830 */  "OrL_reg_not_reg_0",
  /*  831 */  "XorI_reg_not_reg",
  /*  832 */  "XorI_reg_not_reg_0",
  /*  833 */  "XorL_reg_not_reg",
  /*  834 */  "XorL_reg_not_reg_0",
  /*  835 */  "AndI_reg_URShift_not_reg",
  /*  836 */  "AndI_reg_URShift_not_reg_0",
  /*  837 */  "AndL_reg_URShift_not_reg",
  /*  838 */  "AndL_reg_URShift_not_reg_0",
  /*  839 */  "AndI_reg_RShift_not_reg",
  /*  840 */  "AndI_reg_RShift_not_reg_0",
  /*  841 */  "AndL_reg_RShift_not_reg",
  /*  842 */  "AndL_reg_RShift_not_reg_0",
  /*  843 */  "AndI_reg_RotateRight_not_reg",
  /*  844 */  "AndI_reg_RotateRight_not_reg_0",
  /*  845 */  "AndL_reg_RotateRight_not_reg",
  /*  846 */  "AndL_reg_RotateRight_not_reg_0",
  /*  847 */  "AndI_reg_LShift_not_reg",
  /*  848 */  "AndI_reg_LShift_not_reg_0",
  /*  849 */  "AndL_reg_LShift_not_reg",
  /*  850 */  "AndL_reg_LShift_not_reg_0",
  /*  851 */  "XorI_reg_URShift_not_reg",
  /*  852 */  "XorI_reg_URShift_not_reg_1",
  /*  853 */  "XorI_reg_URShift_not_reg_0",
  /*  854 */  "XorI_reg_URShift_not_reg_2",
  /*  855 */  "XorL_reg_URShift_not_reg",
  /*  856 */  "XorL_reg_URShift_not_reg_1",
  /*  857 */  "XorL_reg_URShift_not_reg_0",
  /*  858 */  "XorL_reg_URShift_not_reg_2",
  /*  859 */  "XorI_reg_RShift_not_reg",
  /*  860 */  "XorI_reg_RShift_not_reg_1",
  /*  861 */  "XorI_reg_RShift_not_reg_0",
  /*  862 */  "XorI_reg_RShift_not_reg_2",
  /*  863 */  "XorL_reg_RShift_not_reg",
  /*  864 */  "XorL_reg_RShift_not_reg_1",
  /*  865 */  "XorL_reg_RShift_not_reg_0",
  /*  866 */  "XorL_reg_RShift_not_reg_2",
  /*  867 */  "XorI_reg_RotateRight_not_reg",
  /*  868 */  "XorI_reg_RotateRight_not_reg_1",
  /*  869 */  "XorI_reg_RotateRight_not_reg_0",
  /*  870 */  "XorI_reg_RotateRight_not_reg_2",
  /*  871 */  "XorL_reg_RotateRight_not_reg",
  /*  872 */  "XorL_reg_RotateRight_not_reg_1",
  /*  873 */  "XorL_reg_RotateRight_not_reg_0",
  /*  874 */  "XorL_reg_RotateRight_not_reg_2",
  /*  875 */  "XorI_reg_LShift_not_reg",
  /*  876 */  "XorI_reg_LShift_not_reg_1",
  /*  877 */  "XorI_reg_LShift_not_reg_0",
  /*  878 */  "XorI_reg_LShift_not_reg_2",
  /*  879 */  "XorL_reg_LShift_not_reg",
  /*  880 */  "XorL_reg_LShift_not_reg_1",
  /*  881 */  "XorL_reg_LShift_not_reg_0",
  /*  882 */  "XorL_reg_LShift_not_reg_2",
  /*  883 */  "OrI_reg_URShift_not_reg",
  /*  884 */  "OrI_reg_URShift_not_reg_0",
  /*  885 */  "OrL_reg_URShift_not_reg",
  /*  886 */  "OrL_reg_URShift_not_reg_0",
  /*  887 */  "OrI_reg_RShift_not_reg",
  /*  888 */  "OrI_reg_RShift_not_reg_0",
  /*  889 */  "OrL_reg_RShift_not_reg",
  /*  890 */  "OrL_reg_RShift_not_reg_0",
  /*  891 */  "OrI_reg_RotateRight_not_reg",
  /*  892 */  "OrI_reg_RotateRight_not_reg_0",
  /*  893 */  "OrL_reg_RotateRight_not_reg",
  /*  894 */  "OrL_reg_RotateRight_not_reg_0",
  /*  895 */  "OrI_reg_LShift_not_reg",
  /*  896 */  "OrI_reg_LShift_not_reg_0",
  /*  897 */  "OrL_reg_LShift_not_reg",
  /*  898 */  "OrL_reg_LShift_not_reg_0",
  /*  899 */  "AndI_reg_URShift_reg",
  /*  900 */  "AndI_reg_URShift_reg_0",
  /*  901 */  "AndL_reg_URShift_reg",
  /*  902 */  "AndL_reg_URShift_reg_0",
  /*  903 */  "AndI_reg_RShift_reg",
  /*  904 */  "AndI_reg_RShift_reg_0",
  /*  905 */  "AndL_reg_RShift_reg",
  /*  906 */  "AndL_reg_RShift_reg_0",
  /*  907 */  "AndI_reg_LShift_reg",
  /*  908 */  "AndI_reg_LShift_reg_0",
  /*  909 */  "AndL_reg_LShift_reg",
  /*  910 */  "AndL_reg_LShift_reg_0",
  /*  911 */  "AndI_reg_RotateRight_reg",
  /*  912 */  "AndI_reg_RotateRight_reg_0",
  /*  913 */  "AndL_reg_RotateRight_reg",
  /*  914 */  "AndL_reg_RotateRight_reg_0",
  /*  915 */  "XorI_reg_URShift_reg",
  /*  916 */  "XorI_reg_URShift_reg_0",
  /*  917 */  "XorL_reg_URShift_reg",
  /*  918 */  "XorL_reg_URShift_reg_0",
  /*  919 */  "XorI_reg_RShift_reg",
  /*  920 */  "XorI_reg_RShift_reg_0",
  /*  921 */  "XorL_reg_RShift_reg",
  /*  922 */  "XorL_reg_RShift_reg_0",
  /*  923 */  "XorI_reg_LShift_reg",
  /*  924 */  "XorI_reg_LShift_reg_0",
  /*  925 */  "XorL_reg_LShift_reg",
  /*  926 */  "XorL_reg_LShift_reg_0",
  /*  927 */  "XorI_reg_RotateRight_reg",
  /*  928 */  "XorI_reg_RotateRight_reg_0",
  /*  929 */  "XorL_reg_RotateRight_reg",
  /*  930 */  "XorL_reg_RotateRight_reg_0",
  /*  931 */  "OrI_reg_URShift_reg",
  /*  932 */  "OrI_reg_URShift_reg_0",
  /*  933 */  "OrL_reg_URShift_reg",
  /*  934 */  "OrL_reg_URShift_reg_0",
  /*  935 */  "OrI_reg_RShift_reg",
  /*  936 */  "OrI_reg_RShift_reg_0",
  /*  937 */  "OrL_reg_RShift_reg",
  /*  938 */  "OrL_reg_RShift_reg_0",
  /*  939 */  "OrI_reg_LShift_reg",
  /*  940 */  "OrI_reg_LShift_reg_0",
  /*  941 */  "OrL_reg_LShift_reg",
  /*  942 */  "OrL_reg_LShift_reg_0",
  /*  943 */  "OrI_reg_RotateRight_reg",
  /*  944 */  "OrI_reg_RotateRight_reg_0",
  /*  945 */  "OrL_reg_RotateRight_reg",
  /*  946 */  "OrL_reg_RotateRight_reg_0",
  /*  947 */  "AddI_reg_URShift_reg",
  /*  948 */  "AddI_reg_URShift_reg_0",
  /*  949 */  "AddL_reg_URShift_reg",
  /*  950 */  "AddL_reg_URShift_reg_0",
  /*  951 */  "AddI_reg_RShift_reg",
  /*  952 */  "AddI_reg_RShift_reg_0",
  /*  953 */  "AddL_reg_RShift_reg",
  /*  954 */  "AddL_reg_RShift_reg_0",
  /*  955 */  "AddI_reg_LShift_reg",
  /*  956 */  "AddI_reg_LShift_reg_0",
  /*  957 */  "AddL_reg_LShift_reg",
  /*  958 */  "AddL_reg_LShift_reg_0",
  /*  959 */  "SubI_reg_URShift_reg",
  /*  960 */  "SubL_reg_URShift_reg",
  /*  961 */  "SubI_reg_RShift_reg",
  /*  962 */  "SubL_reg_RShift_reg",
  /*  963 */  "SubI_reg_LShift_reg",
  /*  964 */  "SubL_reg_LShift_reg",
  /*  965 */  "sbfmL",
  /*  966 */  "sbfmwI",
  /*  967 */  "ubfmL",
  /*  968 */  "ubfmwI",
  /*  969 */  "ubfxwI",
  /*  970 */  "ubfxL",
  /*  971 */  "ubfxIConvI2L",
  /*  972 */  "ubfizwI",
  /*  973 */  "ubfizL",
  /*  974 */  "ubfizwIConvI2L",
  /*  975 */  "ubfizLConvL2I",
  /*  976 */  "ubfizIConvI2L",
  /*  977 */  "ubfizLConvL2Ix",
  /*  978 */  "ubfizIConvI2LAndI",
  /*  979 */  "extrOrL",
  /*  980 */  "extrOrL_0",
  /*  981 */  "extrOrI",
  /*  982 */  "extrOrI_0",
  /*  983 */  "extrAddL",
  /*  984 */  "extrAddL_0",
  /*  985 */  "extrAddI",
  /*  986 */  "extrAddI_0",
  /*  987 */  "rorI_imm",
  /*  988 */  "rorL_imm",
  /*  989 */  "rorI_reg",
  /*  990 */  "rorL_reg",
  /*  991 */  "rolI_reg",
  /*  992 */  "rolL_reg",
  /*  993 */  "AddExtI",
  /*  994 */  "AddExtI_0",
  /*  995 */  "SubExtI",
  /*  996 */  "AddExtI_sxth",
  /*  997 */  "AddExtI_sxth_0",
  /*  998 */  "AddExtI_sxtb",
  /*  999 */  "AddExtI_sxtb_0",
  /* 1000 */  "AddExtI_uxtb",
  /* 1001 */  "AddExtI_uxtb_0",
  /* 1002 */  "AddExtL_sxth",
  /* 1003 */  "AddExtL_sxth_0",
  /* 1004 */  "AddExtL_sxtw",
  /* 1005 */  "AddExtL_sxtw_0",
  /* 1006 */  "AddExtL_sxtb",
  /* 1007 */  "AddExtL_sxtb_0",
  /* 1008 */  "AddExtL_uxtb",
  /* 1009 */  "AddExtL_uxtb_0",
  /* 1010 */  "AddExtI_uxtb_and",
  /* 1011 */  "AddExtI_uxtb_and_0",
  /* 1012 */  "AddExtI_uxth_and",
  /* 1013 */  "AddExtI_uxth_and_0",
  /* 1014 */  "AddExtL_uxtb_and",
  /* 1015 */  "AddExtL_uxtb_and_0",
  /* 1016 */  "AddExtL_uxth_and",
  /* 1017 */  "AddExtL_uxth_and_0",
  /* 1018 */  "AddExtL_uxtw_and",
  /* 1019 */  "AddExtL_uxtw_and_0",
  /* 1020 */  "SubExtI_uxtb_and",
  /* 1021 */  "SubExtI_uxth_and",
  /* 1022 */  "SubExtL_uxtb_and",
  /* 1023 */  "SubExtL_uxth_and",
  /* 1024 */  "SubExtL_uxtw_and",
  /* 1025 */  "AddExtL_sxtb_shift",
  /* 1026 */  "AddExtL_sxtb_shift_0",
  /* 1027 */  "AddExtL_sxth_shift",
  /* 1028 */  "AddExtL_sxth_shift_0",
  /* 1029 */  "AddExtL_sxtw_shift",
  /* 1030 */  "AddExtL_sxtw_shift_0",
  /* 1031 */  "SubExtL_sxtb_shift",
  /* 1032 */  "SubExtL_sxth_shift",
  /* 1033 */  "SubExtL_sxtw_shift",
  /* 1034 */  "AddExtI_sxtb_shift",
  /* 1035 */  "AddExtI_sxtb_shift_0",
  /* 1036 */  "AddExtI_sxth_shift",
  /* 1037 */  "AddExtI_sxth_shift_0",
  /* 1038 */  "SubExtI_sxtb_shift",
  /* 1039 */  "SubExtI_sxth_shift",
  /* 1040 */  "AddExtI_shift",
  /* 1041 */  "AddExtI_shift_0",
  /* 1042 */  "SubExtI_shift",
  /* 1043 */  "AddExtL_uxtb_and_shift",
  /* 1044 */  "AddExtL_uxtb_and_shift_0",
  /* 1045 */  "AddExtL_uxth_and_shift",
  /* 1046 */  "AddExtL_uxth_and_shift_0",
  /* 1047 */  "AddExtL_uxtw_and_shift",
  /* 1048 */  "AddExtL_uxtw_and_shift_0",
  /* 1049 */  "SubExtL_uxtb_and_shift",
  /* 1050 */  "SubExtL_uxth_and_shift",
  /* 1051 */  "SubExtL_uxtw_and_shift",
  /* 1052 */  "AddExtI_uxtb_and_shift",
  /* 1053 */  "AddExtI_uxtb_and_shift_0",
  /* 1054 */  "AddExtI_uxth_and_shift",
  /* 1055 */  "AddExtI_uxth_and_shift_0",
  /* 1056 */  "SubExtI_uxtb_and_shift",
  /* 1057 */  "SubExtI_uxth_and_shift",
  /* 1058 */  "cmovI_reg_reg_lt",
  /* 1059 */  "cmovI_reg_reg_gt",
  /* 1060 */  "cmovI_reg_imm0_lt",
  /* 1061 */  "cmovI_reg_imm0_gt",
  /* 1062 */  "cmovI_reg_imm1_le",
  /* 1063 */  "cmovI_reg_imm1_gt",
  /* 1064 */  "cmovI_reg_immM1_lt",
  /* 1065 */  "cmovI_reg_immM1_ge",
  /* 1066 */  "minI_reg_imm0",
  /* 1067 */  "minI_imm0_reg",
  /* 1068 */  "minI_reg_imm1",
  /* 1069 */  "minI_imm1_reg",
  /* 1070 */  "minI_reg_immM1",
  /* 1071 */  "minI_immM1_reg",
  /* 1072 */  "maxI_reg_imm0",
  /* 1073 */  "maxI_imm0_reg",
  /* 1074 */  "maxI_reg_imm1",
  /* 1075 */  "maxI_imm1_reg",
  /* 1076 */  "maxI_reg_immM1",
  /* 1077 */  "maxI_immM1_reg",
  /* 1078 */  "addF_reg_reg",
  /* 1079 */  "addD_reg_reg",
  /* 1080 */  "subF_reg_reg",
  /* 1081 */  "subD_reg_reg",
  /* 1082 */  "mulF_reg_reg",
  /* 1083 */  "mulD_reg_reg",
  /* 1084 */  "maddF_reg_reg",
  /* 1085 */  "maddD_reg_reg",
  /* 1086 */  "msubF_reg_reg",
  /* 1087 */  "msubD_reg_reg",
  /* 1088 */  "mnaddF_reg_reg",
  /* 1089 */  "mnaddD_reg_reg",
  /* 1090 */  "mnsubF_reg_reg",
  /* 1091 */  "mnsubD_reg_reg",
  /* 1092 */  "maxF_reg_reg",
  /* 1093 */  "minF_reg_reg",
  /* 1094 */  "maxD_reg_reg",
  /* 1095 */  "minD_reg_reg",
  /* 1096 */  "divF_reg_reg",
  /* 1097 */  "divD_reg_reg",
  /* 1098 */  "absI_reg",
  /* 1099 */  "absL_reg",
  /* 1100 */  "absdF_reg",
  /* 1101 */  "absdD_reg",
  /* 1102 */  "sqrtD_reg",
  /* 1103 */  "sqrtF_reg",
  /* 1104 */  "roundD_reg",
  /* 1105 */  "copySignD_reg",
  /* 1106 */  "copySignF_reg",
  /* 1107 */  "signumD_reg",
  /* 1108 */  "signumF_reg",
  /* 1109 */  "onspinwait",
  /* 1110 */  "andI_reg_reg",
  /* 1111 */  "andI_reg_imm",
  /* 1112 */  "orI_reg_reg",
  /* 1113 */  "orI_reg_imm",
  /* 1114 */  "xorI_reg_reg",
  /* 1115 */  "xorI_reg_imm",
  /* 1116 */  "andL_reg_reg",
  /* 1117 */  "andL_reg_imm",
  /* 1118 */  "orL_reg_reg",
  /* 1119 */  "orL_reg_imm",
  /* 1120 */  "xorL_reg_reg",
  /* 1121 */  "xorL_reg_imm",
  /* 1122 */  "convI2L_reg_reg",
  /* 1123 */  "convUI2L_reg_reg",
  /* 1124 */  "convL2I_reg",
  /* 1125 */  "convD2F_reg",
  /* 1126 */  "convF2D_reg",
  /* 1127 */  "convF2I_reg_reg",
  /* 1128 */  "convF2L_reg_reg",
  /* 1129 */  "convF2HF_reg_reg",
  /* 1130 */  "convHF2F_reg_reg",
  /* 1131 */  "convI2F_reg_reg",
  /* 1132 */  "convL2F_reg_reg",
  /* 1133 */  "convD2I_reg_reg",
  /* 1134 */  "convD2L_reg_reg",
  /* 1135 */  "convI2D_reg_reg",
  /* 1136 */  "convL2D_reg_reg",
  /* 1137 */  "round_double_reg",
  /* 1138 */  "round_float_reg",
  /* 1139 */  "MoveF2I_reg_stack",
  /* 1140 */  "MoveI2F_reg_stack",
  /* 1141 */  "MoveD2L_reg_stack",
  /* 1142 */  "MoveL2D_reg_stack",
  /* 1143 */  "clearArray_reg_reg",
  /* 1144 */  "clearArray_imm_reg",
  /* 1145 */  "overflowMulI_reg_branch",
  /* 1146 */  "overflowMulL_reg_branch",
  /* 1147 */  "compF3_reg_reg",
  /* 1148 */  "compD3_reg_reg",
  /* 1149 */  "compF3_reg_immF0",
  /* 1150 */  "compD3_reg_immD0",
  /* 1151 */  "cmpLTMask_reg_reg",
  /* 1152 */  "cmpLTMask_reg_zero",
  /* 1153 */  "minI_reg_reg",
  /* 1154 */  "maxI_reg_reg",
  /* 1155 */  "branch",
  /* 1156 */  "branchCon",
  /* 1157 */  "branchConU",
  /* 1158 */  "cmpI_imm0_branch",
  /* 1159 */  "cmpL_imm0_branch",
  /* 1160 */  "cmpP_imm0_branch",
  /* 1161 */  "cmpN_imm0_branch",
  /* 1162 */  "cmpP_narrowOop_imm0_branch",
  /* 1163 */  "cmpUI_imm0_branch",
  /* 1164 */  "cmpUL_imm0_branch",
  /* 1165 */  "cmpL_branch_sign",
  /* 1166 */  "cmpI_branch_sign",
  /* 1167 */  "cmpL_branch_bit",
  /* 1168 */  "cmpI_branch_bit",
  /* 1169 */  "far_cmpL_branch_sign",
  /* 1170 */  "far_cmpI_branch_sign",
  /* 1171 */  "far_cmpL_branch_bit",
  /* 1172 */  "far_cmpI_branch_bit",
  /* 1173 */  "branchLoopEnd",
  /* 1174 */  "safePoint",
  /* 1175 */  "CallStaticJavaDirect",
  /* 1176 */  "CallDynamicJavaDirect",
  /* 1177 */  "CallRuntimeDirect",
  /* 1178 */  "CallLeafDirect",
  /* 1179 */  "CallLeafNoFPDirect",
  /* 1180 */  "TailCalljmpInd",
  /* 1181 */  "TailjmpInd",
  /* 1182 */  "CreateException",
  /* 1183 */  "RethrowException",
  /* 1184 */  "Ret",
  /* 1185 */  "ShouldNotReachHere",
  /* 1186 */  "partialSubtypeCheck",
  /* 1187 */  "string_compareU",
  /* 1188 */  "string_compareL",
  /* 1189 */  "string_compareUL",
  /* 1190 */  "string_compareLU",
  /* 1191 */  "string_compareLL_sve",
  /* 1192 */  "string_compareLU_sve",
  /* 1193 */  "string_compareUL_sve",
  /* 1194 */  "string_compareUU_sve",
  /* 1195 */  "string_indexofUU",
  /* 1196 */  "string_indexofLL",
  /* 1197 */  "string_indexofUL",
  /* 1198 */  "string_indexof_conUU",
  /* 1199 */  "string_indexof_conLL",
  /* 1200 */  "string_indexof_conUL",
  /* 1201 */  "string_indexof_char",
  /* 1202 */  "stringL_indexof_char",
  /* 1203 */  "stringL_indexof_char_sve",
  /* 1204 */  "stringU_indexof_char_sve",
  /* 1205 */  "string_equalsL",
  /* 1206 */  "array_equalsB",
  /* 1207 */  "array_equalsC",
  /* 1208 */  "count_positives",
  /* 1209 */  "string_compress",
  /* 1210 */  "string_inflate",
  /* 1211 */  "encode_iso_array",
  /* 1212 */  "encode_ascii_array",
  /* 1213 */  "compressBitsI_reg",
  /* 1214 */  "compressBitsI_memcon",
  /* 1215 */  "compressBitsL_reg",
  /* 1216 */  "compressBitsL_memcon",
  /* 1217 */  "expandBitsI_reg",
  /* 1218 */  "expandBitsI_memcon",
  /* 1219 */  "expandBitsL_reg",
  /* 1220 */  "expandBitsL_memcon",
  /* 1221 */  "loadV2",
  /* 1222 */  "storeV2",
  /* 1223 */  "loadV4",
  /* 1224 */  "storeV4",
  /* 1225 */  "loadV8",
  /* 1226 */  "storeV8",
  /* 1227 */  "loadV16",
  /* 1228 */  "storeV16",
  /* 1229 */  "loadV",
  /* 1230 */  "storeV",
  /* 1231 */  "loadV_masked",
  /* 1232 */  "storeV_masked",
  /* 1233 */  "vaddB",
  /* 1234 */  "vaddS",
  /* 1235 */  "vaddI",
  /* 1236 */  "vaddL",
  /* 1237 */  "vaddF",
  /* 1238 */  "vaddD",
  /* 1239 */  "vaddB_masked",
  /* 1240 */  "vaddS_masked",
  /* 1241 */  "vaddI_masked",
  /* 1242 */  "vaddL_masked",
  /* 1243 */  "vaddF_masked",
  /* 1244 */  "vaddD_masked",
  /* 1245 */  "vaddImmB",
  /* 1246 */  "vaddImmB_0",
  /* 1247 */  "vaddImmS",
  /* 1248 */  "vaddImmS_0",
  /* 1249 */  "vaddImmI",
  /* 1250 */  "vaddImmI_0",
  /* 1251 */  "vaddImmL",
  /* 1252 */  "vaddImmL_0",
  /* 1253 */  "vsubB",
  /* 1254 */  "vsubS",
  /* 1255 */  "vsubI",
  /* 1256 */  "vsubL",
  /* 1257 */  "vsubF",
  /* 1258 */  "vsubD",
  /* 1259 */  "vsubB_masked",
  /* 1260 */  "vsubS_masked",
  /* 1261 */  "vsubI_masked",
  /* 1262 */  "vsubL_masked",
  /* 1263 */  "vsubF_masked",
  /* 1264 */  "vsubD_masked",
  /* 1265 */  "vmulB_neon",
  /* 1266 */  "vmulB_sve",
  /* 1267 */  "vmulS_neon",
  /* 1268 */  "vmulS_sve",
  /* 1269 */  "vmulI_neon",
  /* 1270 */  "vmulI_sve",
  /* 1271 */  "vmulL_neon",
  /* 1272 */  "vmulL_sve",
  /* 1273 */  "vmulF",
  /* 1274 */  "vmulD",
  /* 1275 */  "vmulB_masked",
  /* 1276 */  "vmulS_masked",
  /* 1277 */  "vmulI_masked",
  /* 1278 */  "vmulL_masked",
  /* 1279 */  "vmulF_masked",
  /* 1280 */  "vmulD_masked",
  /* 1281 */  "vdivF_neon",
  /* 1282 */  "vdivF_sve",
  /* 1283 */  "vdivD_neon",
  /* 1284 */  "vdivD_sve",
  /* 1285 */  "vdivF_masked",
  /* 1286 */  "vdivD_masked",
  /* 1287 */  "vand",
  /* 1288 */  "vand_masked",
  /* 1289 */  "vandImmB",
  /* 1290 */  "vandImmB_0",
  /* 1291 */  "vandImmS",
  /* 1292 */  "vandImmS_0",
  /* 1293 */  "vandImmI",
  /* 1294 */  "vandImmI_0",
  /* 1295 */  "vandImmL",
  /* 1296 */  "vandImmL_0",
  /* 1297 */  "vor",
  /* 1298 */  "vor_masked",
  /* 1299 */  "vorImmB",
  /* 1300 */  "vorImmB_0",
  /* 1301 */  "vorImmS",
  /* 1302 */  "vorImmS_0",
  /* 1303 */  "vorImmI",
  /* 1304 */  "vorImmI_0",
  /* 1305 */  "vorImmL",
  /* 1306 */  "vorImmL_0",
  /* 1307 */  "vxor",
  /* 1308 */  "vxor_masked",
  /* 1309 */  "vxorImmB",
  /* 1310 */  "vxorImmB_0",
  /* 1311 */  "vxorImmS",
  /* 1312 */  "vxorImmS_0",
  /* 1313 */  "vxorImmI",
  /* 1314 */  "vxorImmI_0",
  /* 1315 */  "vxorImmL",
  /* 1316 */  "vxorImmL_0",
  /* 1317 */  "veor3_neon",
  /* 1318 */  "veor3_neon_0",
  /* 1319 */  "veor3_sve",
  /* 1320 */  "veor3_sve_0",
  /* 1321 */  "vnotI",
  /* 1322 */  "vnotI_0",
  /* 1323 */  "vnotL",
  /* 1324 */  "vnotL_0",
  /* 1325 */  "vnotI_masked",
  /* 1326 */  "vnotL_masked",
  /* 1327 */  "vand_notI",
  /* 1328 */  "vand_notI_1",
  /* 1329 */  "vand_notI_0",
  /* 1330 */  "vand_notI_2",
  /* 1331 */  "vand_notL",
  /* 1332 */  "vand_notL_1",
  /* 1333 */  "vand_notL_0",
  /* 1334 */  "vand_notL_2",
  /* 1335 */  "vand_notI_masked",
  /* 1336 */  "vand_notI_masked_0",
  /* 1337 */  "vand_notL_masked",
  /* 1338 */  "vand_notL_masked_0",
  /* 1339 */  "vabsB_masked",
  /* 1340 */  "vabsS_masked",
  /* 1341 */  "vabsI_masked",
  /* 1342 */  "vabsL_masked",
  /* 1343 */  "vabsF_masked",
  /* 1344 */  "vabsD_masked",
  /* 1345 */  "vfabd_neon",
  /* 1346 */  "vfabd_neon_0",
  /* 1347 */  "vfabd_sve",
  /* 1348 */  "vfabd_sve_0",
  /* 1349 */  "vfabd_masked",
  /* 1350 */  "vfabd_masked_0",
  /* 1351 */  "vnegI_masked",
  /* 1352 */  "vnegL_masked",
  /* 1353 */  "vnegF_masked",
  /* 1354 */  "vnegD_masked",
  /* 1355 */  "vsqrtF_masked",
  /* 1356 */  "vsqrtD_masked",
  /* 1357 */  "vminL_neon",
  /* 1358 */  "vminL_sve",
  /* 1359 */  "vmin_neon",
  /* 1360 */  "vmin_sve",
  /* 1361 */  "vmin_masked",
  /* 1362 */  "vmaxL_neon",
  /* 1363 */  "vmaxL_sve",
  /* 1364 */  "vmax_neon",
  /* 1365 */  "vmax_sve",
  /* 1366 */  "vmax_masked",
  /* 1367 */  "vmla",
  /* 1368 */  "vmla_0",
  /* 1369 */  "vmla_1",
  /* 1370 */  "vmla_2",
  /* 1371 */  "vmla_3",
  /* 1372 */  "vmla_4",
  /* 1373 */  "vmlaL",
  /* 1374 */  "vmlaL_0",
  /* 1375 */  "vmla_masked",
  /* 1376 */  "vmla_masked_0",
  /* 1377 */  "vmla_masked_1",
  /* 1378 */  "vmla_masked_2",
  /* 1379 */  "vfmla",
  /* 1380 */  "vfmla_0",
  /* 1381 */  "vfmad_masked",
  /* 1382 */  "vfmad_masked_0",
  /* 1383 */  "vmls",
  /* 1384 */  "vmls_0",
  /* 1385 */  "vmls_1",
  /* 1386 */  "vmlsL",
  /* 1387 */  "vmls_masked",
  /* 1388 */  "vmls_masked_0",
  /* 1389 */  "vmls_masked_1",
  /* 1390 */  "vmls_masked_2",
  /* 1391 */  "vfmls",
  /* 1392 */  "vfmls_0",
  /* 1393 */  "vfmsb_masked",
  /* 1394 */  "vfmsb_masked_0",
  /* 1395 */  "vfnmla",
  /* 1396 */  "vfnmla_0",
  /* 1397 */  "vfnmad_masked",
  /* 1398 */  "vfnmad_masked_0",
  /* 1399 */  "vfnmls",
  /* 1400 */  "vfnmls_0",
  /* 1401 */  "vfnmsb_masked",
  /* 1402 */  "vfnmsb_masked_0",
  /* 1403 */  "vmuladdS2I",
  /* 1404 */  "vlsl_neon",
  /* 1405 */  "vlsl_neon_0",
  /* 1406 */  "vlsl_neon_1",
  /* 1407 */  "vlsl_neon_2",
  /* 1408 */  "vlsl_sve",
  /* 1409 */  "vlsl_sve_0",
  /* 1410 */  "vlsl_sve_1",
  /* 1411 */  "vlsl_sve_2",
  /* 1412 */  "vasr_neon",
  /* 1413 */  "vasr_neon_0",
  /* 1414 */  "vasr_neon_1",
  /* 1415 */  "vasr_neon_2",
  /* 1416 */  "vasr_neon_var",
  /* 1417 */  "vasr_neon_var_0",
  /* 1418 */  "vasr_neon_var_1",
  /* 1419 */  "vasr_neon_var_2",
  /* 1420 */  "vasr_sve",
  /* 1421 */  "vasr_sve_0",
  /* 1422 */  "vasr_sve_1",
  /* 1423 */  "vasr_sve_2",
  /* 1424 */  "vlsr_neon",
  /* 1425 */  "vlsr_neon_0",
  /* 1426 */  "vlsr_neon_1",
  /* 1427 */  "vlsr_neon_2",
  /* 1428 */  "vlsr_neon_var",
  /* 1429 */  "vlsr_neon_var_0",
  /* 1430 */  "vlsr_neon_var_1",
  /* 1431 */  "vlsr_neon_var_2",
  /* 1432 */  "vlsr_sve",
  /* 1433 */  "vlsr_sve_0",
  /* 1434 */  "vlsr_sve_1",
  /* 1435 */  "vlsr_sve_2",
  /* 1436 */  "vlsl_imm",
  /* 1437 */  "vlsl_imm_0",
  /* 1438 */  "vlsl_imm_1",
  /* 1439 */  "vlsl_imm_2",
  /* 1440 */  "vasr_imm",
  /* 1441 */  "vasr_imm_0",
  /* 1442 */  "vasr_imm_1",
  /* 1443 */  "vasr_imm_2",
  /* 1444 */  "vlsr_imm",
  /* 1445 */  "vlsr_imm_0",
  /* 1446 */  "vlsr_imm_1",
  /* 1447 */  "vlsr_imm_2",
  /* 1448 */  "vasra_imm",
  /* 1449 */  "vasra_imm_0",
  /* 1450 */  "vasra_imm_1",
  /* 1451 */  "vasra_imm_2",
  /* 1452 */  "vasra_imm_3",
  /* 1453 */  "vasra_imm_4",
  /* 1454 */  "vasra_imm_5",
  /* 1455 */  "vasra_imm_6",
  /* 1456 */  "vlsra_imm",
  /* 1457 */  "vlsra_imm_0",
  /* 1458 */  "vlsra_imm_1",
  /* 1459 */  "vlsra_imm_2",
  /* 1460 */  "vlsra_imm_3",
  /* 1461 */  "vlsra_imm_4",
  /* 1462 */  "vlsra_imm_5",
  /* 1463 */  "vlsra_imm_6",
  /* 1464 */  "vlsl_masked",
  /* 1465 */  "vlsl_masked_0",
  /* 1466 */  "vlsl_masked_1",
  /* 1467 */  "vlsl_masked_2",
  /* 1468 */  "vasr_masked",
  /* 1469 */  "vasr_masked_0",
  /* 1470 */  "vasr_masked_1",
  /* 1471 */  "vasr_masked_2",
  /* 1472 */  "vlsr_masked",
  /* 1473 */  "vlsr_masked_0",
  /* 1474 */  "vlsr_masked_1",
  /* 1475 */  "vlsr_masked_2",
  /* 1476 */  "vlsl_imm_masked",
  /* 1477 */  "vlsl_imm_masked_0",
  /* 1478 */  "vlsl_imm_masked_1",
  /* 1479 */  "vlsl_imm_masked_2",
  /* 1480 */  "vasr_imm_masked",
  /* 1481 */  "vasr_imm_masked_0",
  /* 1482 */  "vasr_imm_masked_1",
  /* 1483 */  "vasr_imm_masked_2",
  /* 1484 */  "vlsr_imm_masked",
  /* 1485 */  "vlsr_imm_masked_0",
  /* 1486 */  "vlsr_imm_masked_1",
  /* 1487 */  "vlsr_imm_masked_2",
  /* 1488 */  "reduce_addI_neon",
  /* 1489 */  "reduce_addI_sve",
  /* 1490 */  "reduce_addL_neon",
  /* 1491 */  "reduce_addL_sve",
  /* 1492 */  "reduce_add2F_neon",
  /* 1493 */  "reduce_add4F_neon",
  /* 1494 */  "reduce_addF_sve",
  /* 1495 */  "reduce_addD_neon",
  /* 1496 */  "reduce_addD_sve",
  /* 1497 */  "reduce_addI_masked",
  /* 1498 */  "reduce_addL_masked",
  /* 1499 */  "reduce_addF_masked",
  /* 1500 */  "reduce_addD_masked",
  /* 1501 */  "reduce_mulI",
  /* 1502 */  "reduce_mulL",
  /* 1503 */  "reduce_mulF",
  /* 1504 */  "reduce_mulD",
  /* 1505 */  "reduce_andI_neon",
  /* 1506 */  "reduce_andI_sve",
  /* 1507 */  "reduce_andL_neon",
  /* 1508 */  "reduce_andL_sve",
  /* 1509 */  "reduce_andI_masked",
  /* 1510 */  "reduce_andL_masked",
  /* 1511 */  "reduce_orI_neon",
  /* 1512 */  "reduce_orI_sve",
  /* 1513 */  "reduce_orL_neon",
  /* 1514 */  "reduce_orL_sve",
  /* 1515 */  "reduce_orI_masked",
  /* 1516 */  "reduce_orL_masked",
  /* 1517 */  "reduce_xorI_neon",
  /* 1518 */  "reduce_xorI_sve",
  /* 1519 */  "reduce_xorL_neon",
  /* 1520 */  "reduce_xorL_sve",
  /* 1521 */  "reduce_xorI_masked",
  /* 1522 */  "reduce_xorL_masked",
  /* 1523 */  "reduce_maxI_neon",
  /* 1524 */  "reduce_maxI_sve",
  /* 1525 */  "reduce_maxL_neon",
  /* 1526 */  "reduce_maxL_sve",
  /* 1527 */  "reduce_maxF",
  /* 1528 */  "reduce_maxD",
  /* 1529 */  "reduce_maxI_masked",
  /* 1530 */  "reduce_maxL_masked",
  /* 1531 */  "reduce_maxF_masked",
  /* 1532 */  "reduce_maxD_masked",
  /* 1533 */  "reduce_minI_neon",
  /* 1534 */  "reduce_minI_sve",
  /* 1535 */  "reduce_minL_neon",
  /* 1536 */  "reduce_minL_sve",
  /* 1537 */  "reduce_minF",
  /* 1538 */  "reduce_minD",
  /* 1539 */  "reduce_minI_masked",
  /* 1540 */  "reduce_minL_masked",
  /* 1541 */  "reduce_minF_masked",
  /* 1542 */  "reduce_minD_masked",
  /* 1543 */  "reinterpret_resize_gt128b",
  /* 1544 */  "vcvtStoB_sve",
  /* 1545 */  "vcvtItoX_narrow_neon",
  /* 1546 */  "vcvtItoX_narrow_sve",
  /* 1547 */  "vcvtLtoI_sve",
  /* 1548 */  "vcvtLtoF_neon",
  /* 1549 */  "vcvtLtoF_sve",
  /* 1550 */  "vcvtFtoX_narrow_neon",
  /* 1551 */  "vcvtFtoX_narrow_sve",
  /* 1552 */  "vcvtDtoI_neon",
  /* 1553 */  "vcvtDtoI_sve",
  /* 1554 */  "vcvtDtoF_gt64b",
  /* 1555 */  "vcvtFtoHF_sve",
  /* 1556 */  "insertI_le128b",
  /* 1557 */  "insertI_index_lt32",
  /* 1558 */  "insertI_index_ge32",
  /* 1559 */  "insertL_128b",
  /* 1560 */  "insertL_gt128b",
  /* 1561 */  "insertF_le128b",
  /* 1562 */  "insertF_index_lt32",
  /* 1563 */  "insertF_index_ge32",
  /* 1564 */  "insertD_128b",
  /* 1565 */  "insertD_gt128b",
  /* 1566 */  "extractUB_ireg",
  /* 1567 */  "extractUB_index_lt16",
  /* 1568 */  "extractUB_index_ge16",
  /* 1569 */  "extractB_index_lt16",
  /* 1570 */  "extractB_index_ge16",
  /* 1571 */  "extractS_index_lt8",
  /* 1572 */  "extractS_index_ge8",
  /* 1573 */  "extractI_index_lt4",
  /* 1574 */  "extractI_index_ge4",
  /* 1575 */  "extractL_index_lt2",
  /* 1576 */  "extractL_index_ge2",
  /* 1577 */  "extractF",
  /* 1578 */  "extractD",
  /* 1579 */  "vloadmaskB_sve",
  /* 1580 */  "vloadmask_extend_sve",
  /* 1581 */  "vloadmaskB_masked",
  /* 1582 */  "vloadmask_extend_masked",
  /* 1583 */  "vstoremaskB_neon",
  /* 1584 */  "vstoremask_narrow_neon",
  /* 1585 */  "vstoremaskB_sve",
  /* 1586 */  "vstoremask_narrow_sve",
  /* 1587 */  "vloadmask_loadV",
  /* 1588 */  "vloadmask_loadV_masked",
  /* 1589 */  "vloadmask_loadVMasked",
  /* 1590 */  "vloadmask_loadVMasked_masked",
  /* 1591 */  "storeV_vstoremask",
  /* 1592 */  "storeV_vstoremask_masked",
  /* 1593 */  "storeVMasked_vstoremask",
  /* 1594 */  "storeVMasked_vstoremask_masked",
  /* 1595 */  "vmask_and",
  /* 1596 */  "vmask_or",
  /* 1597 */  "vmask_xor",
  /* 1598 */  "vmask_and_notI",
  /* 1599 */  "vmask_and_notL",
  /* 1600 */  "vmaskcmp_neon",
  /* 1601 */  "vmaskcmp_zeroI_neon",
  /* 1602 */  "vmaskcmp_zeroL_neon",
  /* 1603 */  "vmaskcmp_zeroF_neon",
  /* 1604 */  "vmaskcmp_zeroD_neon",
  /* 1605 */  "vmaskcmp_sve",
  /* 1606 */  "vmaskcmp_immI_sve",
  /* 1607 */  "vmaskcmpU_immI_sve",
  /* 1608 */  "vmaskcmp_immL_sve",
  /* 1609 */  "vmaskcmpU_immL_sve",
  /* 1610 */  "vmaskcmp_masked",
  /* 1611 */  "vmaskcast_narrow_sve",
  /* 1612 */  "vmask_reinterpret_diff_esize",
  /* 1613 */  "vmask_truecount_neon",
  /* 1614 */  "vstoremask_truecount_neon",
  /* 1615 */  "vmask_firsttrue_sve",
  /* 1616 */  "vmask_firsttrue_masked",
  /* 1617 */  "vmask_lasttrue_sve",
  /* 1618 */  "vmask_tolong_sve",
  /* 1619 */  "vmask_fromlong",
  /* 1620 */  "vmaskAll_immI",
  /* 1621 */  "vmaskAllI",
  /* 1622 */  "vmaskAllI_masked",
  /* 1623 */  "vmaskAll_immL",
  /* 1624 */  "vmaskAllL",
  /* 1625 */  "vmaskAllL_masked",
  /* 1626 */  "vmask_gen_I",
  /* 1627 */  "vmask_gen_L",
  /* 1628 */  "vmask_gen_imm",
  /* 1629 */  "vmask_gen_sub",
  /* 1630 */  "vpopcountI_masked",
  /* 1631 */  "vpopcountL_masked",
  /* 1632 */  "vblend_neon",
  /* 1633 */  "vblend_sve",
  /* 1634 */  "vround_le128b",
  /* 1635 */  "vround_le128b_0",
  /* 1636 */  "vround_gt128b",
  /* 1637 */  "vround_gt128b_0",
  /* 1638 */  "vroundD",
  /* 1639 */  "rearrange_HS_neon",
  /* 1640 */  "rearrange",
  /* 1641 */  "gather_loadS",
  /* 1642 */  "gather_loadD",
  /* 1643 */  "gather_loadS_masked",
  /* 1644 */  "gather_loadD_masked",
  /* 1645 */  "scatter_storeS",
  /* 1646 */  "scatter_storeD",
  /* 1647 */  "scatter_storeS_masked",
  /* 1648 */  "scatter_storeD_masked",
  /* 1649 */  "vcountLeadingZeros_masked",
  /* 1650 */  "vcountTrailingZeros_masked",
  /* 1651 */  "vreverse_masked",
  /* 1652 */  "vreverseBytes_masked",
  /* 1653 */  "populateindex",
  /* 1654 */  "mcompress",
  /* 1655 */  "vcompress",
  /* 1656 */  "vcompressB",
  /* 1657 */  "vcompressS",
  /* 1658 */  "vexpand",
  /* 1659 */  "vsignum_le128b",
  /* 1660 */  "vsignum_le128b_0",
  /* 1661 */  "vsignum_gt128b",
  /* 1662 */  "vsignum_gt128b_0",
  /* 1663 */  "vcompressBits",
  /* 1664 */  "vexpandBits",
  /* 1665 */  "compareAndSwapP_shenandoah",
  /* 1666 */  "compareAndSwapN_shenandoah",
  /* 1667 */  "compareAndSwapPAcq_shenandoah",
  /* 1668 */  "compareAndSwapNAcq_shenandoah",
  /* 1669 */  "compareAndExchangeN_shenandoah",
  /* 1670 */  "compareAndExchangeP_shenandoah",
  /* 1671 */  "compareAndExchangeNAcq_shenandoah",
  /* 1672 */  "compareAndExchangePAcq_shenandoah",
  /* 1673 */  "weakCompareAndSwapN_shenandoah",
  /* 1674 */  "weakCompareAndSwapP_shenandoah",
  /* 1675 */  "weakCompareAndSwapNAcq_shenandoah",
  /* 1676 */  "weakCompareAndSwapPAcq_shenandoah",
  /* 1677 */  "xLoadP",
  /* 1678 */  "xLoadPVolatile",
  /* 1679 */  "xCompareAndSwapP",
  /* 1680 */  "xCompareAndSwapP_0",
  /* 1681 */  "xCompareAndSwapPAcq",
  /* 1682 */  "xCompareAndSwapPAcq_0",
  /* 1683 */  "xCompareAndExchangeP",
  /* 1684 */  "xCompareAndExchangePAcq",
  /* 1685 */  "xGetAndSetP",
  /* 1686 */  "xGetAndSetPAcq",
  /* 1687 */  "zLoadP",
  /* 1688 */  "zLoadPVolatile",
  /* 1689 */  "zStoreP",
  /* 1690 */  "zStorePVolatile",
  /* 1691 */  "zCompareAndSwapP",
  /* 1692 */  "zCompareAndSwapP_0",
  /* 1693 */  "zCompareAndSwapPAcq",
  /* 1694 */  "zCompareAndSwapPAcq_0",
  /* 1695 */  "zCompareAndExchangeP",
  /* 1696 */  "zCompareAndExchangePAcq",
  /* 1697 */  "zGetAndSetP",
  /* 1698 */  "zGetAndSetPAcq",
  // last instruction
  "invalid rule name" // no trailing comma
};

const        bool  swallowed[] = {
  /*    0 */  false,
  /*    1 */  false,
  /*    2 */  false,
  /*    3 */  false,
  /*    4 */  false,
  /*    5 */  false,
  /*    6 */  false,
  /*    7 */  false,
  /*    8 */  true,
  /*    9 */  true,
  /*   10 */  true,
  /*   11 */  true,
  /*   12 */  true,
  /*   13 */  true,
  /*   14 */  true,
  /*   15 */  true,
  /*   16 */  true,
  /*   17 */  true,
  /*   18 */  true,
  /*   19 */  true,
  /*   20 */  true,
  /*   21 */  true,
  /*   22 */  true,
  /*   23 */  true,
  /*   24 */  true,
  /*   25 */  true,
  /*   26 */  true,
  /*   27 */  true,
  /*   28 */  true,
  /*   29 */  true,
  /*   30 */  true,
  /*   31 */  true,
  /*   32 */  true,
  /*   33 */  true,
  /*   34 */  true,
  /*   35 */  true,
  /*   36 */  true,
  /*   37 */  true,
  /*   38 */  true,
  /*   39 */  true,
  /*   40 */  true,
  /*   41 */  true,
  /*   42 */  true,
  /*   43 */  true,
  /*   44 */  true,
  /*   45 */  true,
  /*   46 */  true,
  /*   47 */  true,
  /*   48 */  true,
  /*   49 */  true,
  /*   50 */  true,
  /*   51 */  true,
  /*   52 */  true,
  /*   53 */  true,
  /*   54 */  true,
  /*   55 */  true,
  /*   56 */  true,
  /*   57 */  true,
  /*   58 */  true,
  /*   59 */  true,
  /*   60 */  true,
  /*   61 */  true,
  /*   62 */  true,
  /*   63 */  true,
  /*   64 */  true,
  /*   65 */  true,
  /*   66 */  true,
  /*   67 */  true,
  /*   68 */  true,
  /*   69 */  true,
  /*   70 */  true,
  /*   71 */  true,
  /*   72 */  true,
  /*   73 */  true,
  /*   74 */  true,
  /*   75 */  true,
  /*   76 */  true,
  /*   77 */  false,
  /*   78 */  false,
  /*   79 */  false,
  /*   80 */  false,
  /*   81 */  false,
  /*   82 */  false,
  /*   83 */  false,
  /*   84 */  false,
  /*   85 */  false,
  /*   86 */  false,
  /*   87 */  false,
  /*   88 */  false,
  /*   89 */  false,
  /*   90 */  false,
  /*   91 */  false,
  /*   92 */  false,
  /*   93 */  false,
  /*   94 */  false,
  /*   95 */  false,
  /*   96 */  false,
  /*   97 */  false,
  /*   98 */  false,
  /*   99 */  false,
  /*  100 */  false,
  /*  101 */  false,
  /*  102 */  false,
  /*  103 */  false,
  /*  104 */  false,
  /*  105 */  false,
  /*  106 */  false,
  /*  107 */  false,
  /*  108 */  false,
  /*  109 */  false,
  /*  110 */  false,
  /*  111 */  false,
  /*  112 */  false,
  /*  113 */  false,
  /*  114 */  false,
  /*  115 */  false,
  /*  116 */  false,
  /*  117 */  false,
  /*  118 */  false,
  /*  119 */  false,
  /*  120 */  false,
  /*  121 */  false,
  /*  122 */  false,
  /*  123 */  false,
  /*  124 */  false,
  /*  125 */  false,
  /*  126 */  false,
  /*  127 */  false,
  /*  128 */  false,
  /*  129 */  false,
  /*  130 */  false,
  /*  131 */  false,
  /*  132 */  false,
  /*  133 */  false,
  /*  134 */  false,
  /*  135 */  false,
  /*  136 */  false,
  /*  137 */  false,
  /*  138 */  false,
  /*  139 */  false,
  /*  140 */  false,
  /*  141 */  false,
  /*  142 */  false,
  /*  143 */  false,
  /*  144 */  false,
  /*  145 */  false,
  /*  146 */  false,
  /*  147 */  true,
  /*  148 */  true,
  /*  149 */  true,
  /*  150 */  true,
  /*  151 */  true,
  /*  152 */  false,
  /*  153 */  true,
  /*  154 */  true,
  /*  155 */  false,
  /*  156 */  false,
  // last operand
  /*  157 */  false,
  /*  158 */  false,
  /*  159 */  false,
  /*  160 */  false,
  /*  161 */  false,
  /*  162 */  false,
  /*  163 */  false,
  /*  164 */  false,
  /*  165 */  false,
  /*  166 */  false,
  /*  167 */  false,
  // last operand class
  /*  168 */  false,
  /*  169 */  false,
  /*  170 */  false,
  /*  171 */  false,
  /*  172 */  false,
  /*  173 */  false,
  /*  174 */  false,
  /*  175 */  false,
  /*  176 */  false,
  /*  177 */  false,
  /*  178 */  false,
  /*  179 */  false,
  /*  180 */  false,
  /*  181 */  false,
  /*  182 */  false,
  /*  183 */  false,
  /*  184 */  false,
  /*  185 */  false,
  /*  186 */  false,
  /*  187 */  false,
  /*  188 */  false,
  /*  189 */  false,
  /*  190 */  false,
  /*  191 */  false,
  /*  192 */  false,
  /*  193 */  false,
  /*  194 */  false,
  /*  195 */  false,
  /*  196 */  false,
  /*  197 */  false,
  /*  198 */  false,
  /*  199 */  false,
  /*  200 */  false,
  /*  201 */  false,
  /*  202 */  false,
  /*  203 */  false,
  /*  204 */  false,
  /*  205 */  false,
  /*  206 */  false,
  /*  207 */  false,
  /*  208 */  false,
  /*  209 */  false,
  /*  210 */  false,
  /*  211 */  false,
  /*  212 */  false,
  /*  213 */  false,
  /*  214 */  false,
  /*  215 */  false,
  /*  216 */  false,
  /*  217 */  false,
  /*  218 */  false,
  /*  219 */  false,
  /*  220 */  false,
  /*  221 */  false,
  /*  222 */  false,
  /*  223 */  false,
  /*  224 */  false,
  /*  225 */  false,
  /*  226 */  false,
  /*  227 */  false,
  /*  228 */  false,
  /*  229 */  false,
  /*  230 */  false,
  /*  231 */  false,
  /*  232 */  false,
  /*  233 */  false,
  /*  234 */  false,
  /*  235 */  false,
  /*  236 */  false,
  /*  237 */  false,
  /*  238 */  false,
  /*  239 */  false,
  /*  240 */  false,
  /*  241 */  false,
  /*  242 */  false,
  /*  243 */  false,
  /*  244 */  false,
  /*  245 */  false,
  /*  246 */  false,
  /*  247 */  false,
  /*  248 */  false,
  /*  249 */  false,
  /*  250 */  false,
  /*  251 */  false,
  /*  252 */  false,
  /*  253 */  false,
  /*  254 */  false,
  /*  255 */  false,
  /*  256 */  false,
  /*  257 */  false,
  /*  258 */  false,
  /*  259 */  false,
  /*  260 */  false,
  /*  261 */  false,
  /*  262 */  false,
  /*  263 */  false,
  /*  264 */  false,
  /*  265 */  false,
  /*  266 */  false,
  /*  267 */  false,
  /*  268 */  false,
  /*  269 */  false,
  /*  270 */  false,
  /*  271 */  false,
  /*  272 */  false,
  /*  273 */  false,
  /*  274 */  false,
  /*  275 */  false,
  /*  276 */  false,
  /*  277 */  false,
  /*  278 */  false,
  /*  279 */  false,
  /*  280 */  false,
  /*  281 */  false,
  /*  282 */  false,
  /*  283 */  false,
  /*  284 */  false,
  /*  285 */  false,
  /*  286 */  false,
  /*  287 */  false,
  /*  288 */  false,
  /*  289 */  false,
  /*  290 */  false,
  /*  291 */  false,
  /*  292 */  false,
  /*  293 */  false,
  /*  294 */  false,
  /*  295 */  false,
  /*  296 */  false,
  /*  297 */  false,
  /*  298 */  false,
  /*  299 */  false,
  /*  300 */  false,
  /*  301 */  false,
  /*  302 */  false,
  /*  303 */  false,
  /*  304 */  false,
  /*  305 */  false,
  /*  306 */  false,
  /*  307 */  false,
  /*  308 */  false,
  /*  309 */  false,
  /*  310 */  false,
  /*  311 */  false,
  /*  312 */  false,
  /*  313 */  false,
  /*  314 */  false,
  /*  315 */  false,
  /*  316 */  false,
  /*  317 */  false,
  /*  318 */  false,
  /*  319 */  false,
  /*  320 */  false,
  /*  321 */  false,
  /*  322 */  false,
  /*  323 */  false,
  /*  324 */  false,
  /*  325 */  false,
  /*  326 */  false,
  /*  327 */  false,
  /*  328 */  false,
  /*  329 */  false,
  /*  330 */  false,
  /*  331 */  false,
  /*  332 */  false,
  /*  333 */  false,
  /*  334 */  false,
  /*  335 */  false,
  /*  336 */  false,
  /*  337 */  false,
  /*  338 */  false,
  /*  339 */  false,
  /*  340 */  false,
  /*  341 */  false,
  /*  342 */  false,
  /*  343 */  false,
  /*  344 */  false,
  /*  345 */  false,
  /*  346 */  false,
  /*  347 */  false,
  /*  348 */  false,
  /*  349 */  false,
  /*  350 */  false,
  /*  351 */  false,
  /*  352 */  false,
  /*  353 */  false,
  /*  354 */  false,
  /*  355 */  false,
  /*  356 */  false,
  /*  357 */  false,
  /*  358 */  false,
  /*  359 */  false,
  /*  360 */  false,
  /*  361 */  false,
  /*  362 */  false,
  /*  363 */  false,
  /*  364 */  false,
  /*  365 */  false,
  /*  366 */  false,
  /*  367 */  false,
  /*  368 */  false,
  /*  369 */  false,
  /*  370 */  false,
  /*  371 */  false,
  /*  372 */  false,
  /*  373 */  false,
  /*  374 */  false,
  /*  375 */  false,
  /*  376 */  false,
  /*  377 */  false,
  /*  378 */  false,
  /*  379 */  false,
  /*  380 */  false,
  /*  381 */  false,
  /*  382 */  false,
  /*  383 */  false,
  /*  384 */  false,
  /*  385 */  false,
  /*  386 */  false,
  /*  387 */  false,
  /*  388 */  false,
  /*  389 */  false,
  /*  390 */  false,
  /*  391 */  false,
  /*  392 */  false,
  /*  393 */  false,
  /*  394 */  false,
  /*  395 */  false,
  /*  396 */  false,
  /*  397 */  false,
  /*  398 */  false,
  /*  399 */  false,
  /*  400 */  false,
  /*  401 */  false,
  /*  402 */  false,
  /*  403 */  false,
  /*  404 */  false,
  /*  405 */  false,
  /*  406 */  false,
  /*  407 */  false,
  // last internally defined operand
  /*  408 */  false,
  /*  409 */  false,
  /*  410 */  false,
  /*  411 */  false,
  /*  412 */  false,
  /*  413 */  false,
  /*  414 */  false,
  /*  415 */  false,
  /*  416 */  false,
  /*  417 */  false,
  /*  418 */  false,
  /*  419 */  false,
  /*  420 */  false,
  /*  421 */  false,
  /*  422 */  false,
  /*  423 */  false,
  /*  424 */  false,
  /*  425 */  false,
  /*  426 */  false,
  /*  427 */  false,
  /*  428 */  false,
  /*  429 */  false,
  /*  430 */  false,
  /*  431 */  false,
  /*  432 */  false,
  /*  433 */  false,
  /*  434 */  false,
  /*  435 */  false,
  /*  436 */  false,
  /*  437 */  false,
  /*  438 */  false,
  /*  439 */  false,
  /*  440 */  false,
  /*  441 */  false,
  /*  442 */  false,
  /*  443 */  false,
  /*  444 */  false,
  /*  445 */  false,
  /*  446 */  false,
  /*  447 */  false,
  /*  448 */  false,
  /*  449 */  false,
  /*  450 */  false,
  /*  451 */  false,
  /*  452 */  false,
  /*  453 */  false,
  /*  454 */  false,
  /*  455 */  false,
  /*  456 */  false,
  /*  457 */  false,
  /*  458 */  false,
  /*  459 */  false,
  /*  460 */  false,
  /*  461 */  false,
  /*  462 */  false,
  /*  463 */  false,
  /*  464 */  false,
  /*  465 */  false,
  /*  466 */  false,
  /*  467 */  false,
  /*  468 */  false,
  /*  469 */  false,
  /*  470 */  false,
  /*  471 */  false,
  /*  472 */  false,
  /*  473 */  false,
  /*  474 */  false,
  /*  475 */  false,
  /*  476 */  false,
  /*  477 */  false,
  /*  478 */  false,
  /*  479 */  false,
  /*  480 */  false,
  /*  481 */  false,
  /*  482 */  false,
  /*  483 */  false,
  /*  484 */  false,
  /*  485 */  false,
  /*  486 */  false,
  /*  487 */  false,
  /*  488 */  false,
  /*  489 */  false,
  /*  490 */  false,
  /*  491 */  false,
  /*  492 */  false,
  /*  493 */  false,
  /*  494 */  false,
  /*  495 */  false,
  /*  496 */  false,
  /*  497 */  false,
  /*  498 */  false,
  /*  499 */  false,
  /*  500 */  false,
  /*  501 */  false,
  /*  502 */  false,
  /*  503 */  false,
  /*  504 */  false,
  /*  505 */  false,
  /*  506 */  false,
  /*  507 */  false,
  /*  508 */  false,
  /*  509 */  false,
  /*  510 */  false,
  /*  511 */  false,
  /*  512 */  false,
  /*  513 */  false,
  /*  514 */  false,
  /*  515 */  false,
  /*  516 */  false,
  /*  517 */  false,
  /*  518 */  false,
  /*  519 */  false,
  /*  520 */  false,
  /*  521 */  false,
  /*  522 */  false,
  /*  523 */  false,
  /*  524 */  false,
  /*  525 */  false,
  /*  526 */  false,
  /*  527 */  false,
  /*  528 */  false,
  /*  529 */  false,
  /*  530 */  false,
  /*  531 */  false,
  /*  532 */  false,
  /*  533 */  false,
  /*  534 */  false,
  /*  535 */  false,
  /*  536 */  false,
  /*  537 */  false,
  /*  538 */  false,
  /*  539 */  false,
  /*  540 */  false,
  /*  541 */  false,
  /*  542 */  false,
  /*  543 */  false,
  /*  544 */  false,
  /*  545 */  false,
  /*  546 */  false,
  /*  547 */  false,
  /*  548 */  false,
  /*  549 */  false,
  /*  550 */  false,
  /*  551 */  false,
  /*  552 */  false,
  /*  553 */  false,
  /*  554 */  false,
  /*  555 */  false,
  /*  556 */  false,
  /*  557 */  false,
  /*  558 */  false,
  /*  559 */  false,
  /*  560 */  false,
  /*  561 */  false,
  /*  562 */  false,
  /*  563 */  false,
  /*  564 */  false,
  /*  565 */  false,
  /*  566 */  false,
  /*  567 */  false,
  /*  568 */  false,
  /*  569 */  false,
  /*  570 */  false,
  /*  571 */  false,
  /*  572 */  false,
  /*  573 */  false,
  /*  574 */  false,
  /*  575 */  false,
  /*  576 */  false,
  /*  577 */  false,
  /*  578 */  false,
  /*  579 */  false,
  /*  580 */  false,
  /*  581 */  false,
  /*  582 */  false,
  /*  583 */  false,
  /*  584 */  false,
  /*  585 */  false,
  /*  586 */  false,
  /*  587 */  false,
  /*  588 */  false,
  /*  589 */  false,
  /*  590 */  false,
  /*  591 */  false,
  /*  592 */  false,
  /*  593 */  false,
  /*  594 */  false,
  /*  595 */  false,
  /*  596 */  false,
  /*  597 */  false,
  /*  598 */  false,
  /*  599 */  false,
  /*  600 */  false,
  /*  601 */  false,
  /*  602 */  false,
  /*  603 */  false,
  /*  604 */  false,
  /*  605 */  false,
  /*  606 */  false,
  /*  607 */  false,
  /*  608 */  false,
  /*  609 */  false,
  /*  610 */  false,
  /*  611 */  false,
  /*  612 */  false,
  /*  613 */  false,
  /*  614 */  false,
  /*  615 */  false,
  /*  616 */  false,
  /*  617 */  false,
  /*  618 */  false,
  /*  619 */  false,
  /*  620 */  false,
  /*  621 */  false,
  /*  622 */  false,
  /*  623 */  false,
  /*  624 */  false,
  /*  625 */  false,
  /*  626 */  false,
  /*  627 */  false,
  /*  628 */  false,
  /*  629 */  false,
  /*  630 */  false,
  /*  631 */  false,
  /*  632 */  false,
  /*  633 */  false,
  /*  634 */  false,
  /*  635 */  false,
  /*  636 */  false,
  /*  637 */  false,
  /*  638 */  false,
  /*  639 */  false,
  /*  640 */  false,
  /*  641 */  false,
  /*  642 */  false,
  /*  643 */  false,
  /*  644 */  false,
  /*  645 */  false,
  /*  646 */  false,
  /*  647 */  false,
  /*  648 */  false,
  /*  649 */  false,
  /*  650 */  false,
  /*  651 */  false,
  /*  652 */  false,
  /*  653 */  false,
  /*  654 */  false,
  /*  655 */  false,
  /*  656 */  false,
  /*  657 */  false,
  /*  658 */  false,
  /*  659 */  false,
  /*  660 */  false,
  /*  661 */  false,
  /*  662 */  false,
  /*  663 */  false,
  /*  664 */  false,
  /*  665 */  false,
  /*  666 */  false,
  /*  667 */  false,
  /*  668 */  false,
  /*  669 */  false,
  /*  670 */  false,
  /*  671 */  false,
  /*  672 */  false,
  /*  673 */  false,
  /*  674 */  false,
  /*  675 */  false,
  /*  676 */  false,
  /*  677 */  false,
  /*  678 */  false,
  /*  679 */  false,
  /*  680 */  false,
  /*  681 */  false,
  /*  682 */  false,
  /*  683 */  false,
  /*  684 */  false,
  /*  685 */  false,
  /*  686 */  false,
  /*  687 */  false,
  /*  688 */  false,
  /*  689 */  false,
  /*  690 */  false,
  /*  691 */  false,
  /*  692 */  false,
  /*  693 */  false,
  /*  694 */  false,
  /*  695 */  false,
  /*  696 */  false,
  /*  697 */  false,
  /*  698 */  false,
  /*  699 */  false,
  /*  700 */  false,
  /*  701 */  false,
  /*  702 */  false,
  /*  703 */  false,
  /*  704 */  false,
  /*  705 */  false,
  /*  706 */  false,
  /*  707 */  false,
  /*  708 */  false,
  /*  709 */  false,
  /*  710 */  false,
  /*  711 */  false,
  /*  712 */  false,
  /*  713 */  false,
  /*  714 */  false,
  /*  715 */  false,
  /*  716 */  false,
  /*  717 */  false,
  /*  718 */  false,
  /*  719 */  false,
  /*  720 */  false,
  /*  721 */  false,
  /*  722 */  false,
  /*  723 */  false,
  /*  724 */  false,
  /*  725 */  false,
  /*  726 */  false,
  /*  727 */  false,
  /*  728 */  false,
  /*  729 */  false,
  /*  730 */  false,
  /*  731 */  false,
  /*  732 */  false,
  /*  733 */  false,
  /*  734 */  false,
  /*  735 */  false,
  /*  736 */  false,
  /*  737 */  false,
  /*  738 */  false,
  /*  739 */  false,
  /*  740 */  false,
  /*  741 */  false,
  /*  742 */  false,
  /*  743 */  false,
  /*  744 */  false,
  /*  745 */  false,
  /*  746 */  false,
  /*  747 */  false,
  /*  748 */  false,
  /*  749 */  false,
  /*  750 */  false,
  /*  751 */  false,
  /*  752 */  false,
  /*  753 */  false,
  /*  754 */  false,
  /*  755 */  false,
  /*  756 */  false,
  /*  757 */  false,
  /*  758 */  false,
  /*  759 */  false,
  /*  760 */  false,
  /*  761 */  false,
  /*  762 */  false,
  /*  763 */  false,
  /*  764 */  false,
  /*  765 */  false,
  /*  766 */  false,
  /*  767 */  false,
  /*  768 */  false,
  /*  769 */  false,
  /*  770 */  false,
  /*  771 */  false,
  /*  772 */  false,
  /*  773 */  false,
  /*  774 */  false,
  /*  775 */  false,
  /*  776 */  false,
  /*  777 */  false,
  /*  778 */  false,
  /*  779 */  false,
  /*  780 */  false,
  /*  781 */  false,
  /*  782 */  false,
  /*  783 */  false,
  /*  784 */  false,
  /*  785 */  false,
  /*  786 */  false,
  /*  787 */  false,
  /*  788 */  false,
  /*  789 */  false,
  /*  790 */  false,
  /*  791 */  false,
  /*  792 */  false,
  /*  793 */  false,
  /*  794 */  false,
  /*  795 */  false,
  /*  796 */  false,
  /*  797 */  false,
  /*  798 */  false,
  /*  799 */  false,
  /*  800 */  false,
  /*  801 */  false,
  /*  802 */  false,
  /*  803 */  false,
  /*  804 */  false,
  /*  805 */  false,
  /*  806 */  false,
  /*  807 */  false,
  /*  808 */  false,
  /*  809 */  false,
  /*  810 */  false,
  /*  811 */  false,
  /*  812 */  false,
  /*  813 */  false,
  /*  814 */  false,
  /*  815 */  false,
  /*  816 */  false,
  /*  817 */  false,
  /*  818 */  false,
  /*  819 */  false,
  /*  820 */  false,
  /*  821 */  false,
  /*  822 */  false,
  /*  823 */  false,
  /*  824 */  false,
  /*  825 */  false,
  /*  826 */  false,
  /*  827 */  false,
  /*  828 */  false,
  /*  829 */  false,
  /*  830 */  false,
  /*  831 */  false,
  /*  832 */  false,
  /*  833 */  false,
  /*  834 */  false,
  /*  835 */  false,
  /*  836 */  false,
  /*  837 */  false,
  /*  838 */  false,
  /*  839 */  false,
  /*  840 */  false,
  /*  841 */  false,
  /*  842 */  false,
  /*  843 */  false,
  /*  844 */  false,
  /*  845 */  false,
  /*  846 */  false,
  /*  847 */  false,
  /*  848 */  false,
  /*  849 */  false,
  /*  850 */  false,
  /*  851 */  false,
  /*  852 */  false,
  /*  853 */  false,
  /*  854 */  false,
  /*  855 */  false,
  /*  856 */  false,
  /*  857 */  false,
  /*  858 */  false,
  /*  859 */  false,
  /*  860 */  false,
  /*  861 */  false,
  /*  862 */  false,
  /*  863 */  false,
  /*  864 */  false,
  /*  865 */  false,
  /*  866 */  false,
  /*  867 */  false,
  /*  868 */  false,
  /*  869 */  false,
  /*  870 */  false,
  /*  871 */  false,
  /*  872 */  false,
  /*  873 */  false,
  /*  874 */  false,
  /*  875 */  false,
  /*  876 */  false,
  /*  877 */  false,
  /*  878 */  false,
  /*  879 */  false,
  /*  880 */  false,
  /*  881 */  false,
  /*  882 */  false,
  /*  883 */  false,
  /*  884 */  false,
  /*  885 */  false,
  /*  886 */  false,
  /*  887 */  false,
  /*  888 */  false,
  /*  889 */  false,
  /*  890 */  false,
  /*  891 */  false,
  /*  892 */  false,
  /*  893 */  false,
  /*  894 */  false,
  /*  895 */  false,
  /*  896 */  false,
  /*  897 */  false,
  /*  898 */  false,
  /*  899 */  false,
  /*  900 */  false,
  /*  901 */  false,
  /*  902 */  false,
  /*  903 */  false,
  /*  904 */  false,
  /*  905 */  false,
  /*  906 */  false,
  /*  907 */  false,
  /*  908 */  false,
  /*  909 */  false,
  /*  910 */  false,
  /*  911 */  false,
  /*  912 */  false,
  /*  913 */  false,
  /*  914 */  false,
  /*  915 */  false,
  /*  916 */  false,
  /*  917 */  false,
  /*  918 */  false,
  /*  919 */  false,
  /*  920 */  false,
  /*  921 */  false,
  /*  922 */  false,
  /*  923 */  false,
  /*  924 */  false,
  /*  925 */  false,
  /*  926 */  false,
  /*  927 */  false,
  /*  928 */  false,
  /*  929 */  false,
  /*  930 */  false,
  /*  931 */  false,
  /*  932 */  false,
  /*  933 */  false,
  /*  934 */  false,
  /*  935 */  false,
  /*  936 */  false,
  /*  937 */  false,
  /*  938 */  false,
  /*  939 */  false,
  /*  940 */  false,
  /*  941 */  false,
  /*  942 */  false,
  /*  943 */  false,
  /*  944 */  false,
  /*  945 */  false,
  /*  946 */  false,
  /*  947 */  false,
  /*  948 */  false,
  /*  949 */  false,
  /*  950 */  false,
  /*  951 */  false,
  /*  952 */  false,
  /*  953 */  false,
  /*  954 */  false,
  /*  955 */  false,
  /*  956 */  false,
  /*  957 */  false,
  /*  958 */  false,
  /*  959 */  false,
  /*  960 */  false,
  /*  961 */  false,
  /*  962 */  false,
  /*  963 */  false,
  /*  964 */  false,
  /*  965 */  false,
  /*  966 */  false,
  /*  967 */  false,
  /*  968 */  false,
  /*  969 */  false,
  /*  970 */  false,
  /*  971 */  false,
  /*  972 */  false,
  /*  973 */  false,
  /*  974 */  false,
  /*  975 */  false,
  /*  976 */  false,
  /*  977 */  false,
  /*  978 */  false,
  /*  979 */  false,
  /*  980 */  false,
  /*  981 */  false,
  /*  982 */  false,
  /*  983 */  false,
  /*  984 */  false,
  /*  985 */  false,
  /*  986 */  false,
  /*  987 */  false,
  /*  988 */  false,
  /*  989 */  false,
  /*  990 */  false,
  /*  991 */  false,
  /*  992 */  false,
  /*  993 */  false,
  /*  994 */  false,
  /*  995 */  false,
  /*  996 */  false,
  /*  997 */  false,
  /*  998 */  false,
  /*  999 */  false,
  /* 1000 */  false,
  /* 1001 */  false,
  /* 1002 */  false,
  /* 1003 */  false,
  /* 1004 */  false,
  /* 1005 */  false,
  /* 1006 */  false,
  /* 1007 */  false,
  /* 1008 */  false,
  /* 1009 */  false,
  /* 1010 */  false,
  /* 1011 */  false,
  /* 1012 */  false,
  /* 1013 */  false,
  /* 1014 */  false,
  /* 1015 */  false,
  /* 1016 */  false,
  /* 1017 */  false,
  /* 1018 */  false,
  /* 1019 */  false,
  /* 1020 */  false,
  /* 1021 */  false,
  /* 1022 */  false,
  /* 1023 */  false,
  /* 1024 */  false,
  /* 1025 */  false,
  /* 1026 */  false,
  /* 1027 */  false,
  /* 1028 */  false,
  /* 1029 */  false,
  /* 1030 */  false,
  /* 1031 */  false,
  /* 1032 */  false,
  /* 1033 */  false,
  /* 1034 */  false,
  /* 1035 */  false,
  /* 1036 */  false,
  /* 1037 */  false,
  /* 1038 */  false,
  /* 1039 */  false,
  /* 1040 */  false,
  /* 1041 */  false,
  /* 1042 */  false,
  /* 1043 */  false,
  /* 1044 */  false,
  /* 1045 */  false,
  /* 1046 */  false,
  /* 1047 */  false,
  /* 1048 */  false,
  /* 1049 */  false,
  /* 1050 */  false,
  /* 1051 */  false,
  /* 1052 */  false,
  /* 1053 */  false,
  /* 1054 */  false,
  /* 1055 */  false,
  /* 1056 */  false,
  /* 1057 */  false,
  /* 1058 */  false,
  /* 1059 */  false,
  /* 1060 */  false,
  /* 1061 */  false,
  /* 1062 */  false,
  /* 1063 */  false,
  /* 1064 */  false,
  /* 1065 */  false,
  /* 1066 */  false,
  /* 1067 */  false,
  /* 1068 */  false,
  /* 1069 */  false,
  /* 1070 */  false,
  /* 1071 */  false,
  /* 1072 */  false,
  /* 1073 */  false,
  /* 1074 */  false,
  /* 1075 */  false,
  /* 1076 */  false,
  /* 1077 */  false,
  /* 1078 */  false,
  /* 1079 */  false,
  /* 1080 */  false,
  /* 1081 */  false,
  /* 1082 */  false,
  /* 1083 */  false,
  /* 1084 */  false,
  /* 1085 */  false,
  /* 1086 */  false,
  /* 1087 */  false,
  /* 1088 */  false,
  /* 1089 */  false,
  /* 1090 */  false,
  /* 1091 */  false,
  /* 1092 */  false,
  /* 1093 */  false,
  /* 1094 */  false,
  /* 1095 */  false,
  /* 1096 */  false,
  /* 1097 */  false,
  /* 1098 */  false,
  /* 1099 */  false,
  /* 1100 */  false,
  /* 1101 */  false,
  /* 1102 */  false,
  /* 1103 */  false,
  /* 1104 */  false,
  /* 1105 */  false,
  /* 1106 */  false,
  /* 1107 */  false,
  /* 1108 */  false,
  /* 1109 */  false,
  /* 1110 */  false,
  /* 1111 */  false,
  /* 1112 */  false,
  /* 1113 */  false,
  /* 1114 */  false,
  /* 1115 */  false,
  /* 1116 */  false,
  /* 1117 */  false,
  /* 1118 */  false,
  /* 1119 */  false,
  /* 1120 */  false,
  /* 1121 */  false,
  /* 1122 */  false,
  /* 1123 */  false,
  /* 1124 */  false,
  /* 1125 */  false,
  /* 1126 */  false,
  /* 1127 */  false,
  /* 1128 */  false,
  /* 1129 */  false,
  /* 1130 */  false,
  /* 1131 */  false,
  /* 1132 */  false,
  /* 1133 */  false,
  /* 1134 */  false,
  /* 1135 */  false,
  /* 1136 */  false,
  /* 1137 */  false,
  /* 1138 */  false,
  /* 1139 */  false,
  /* 1140 */  false,
  /* 1141 */  false,
  /* 1142 */  false,
  /* 1143 */  false,
  /* 1144 */  false,
  /* 1145 */  false,
  /* 1146 */  false,
  /* 1147 */  false,
  /* 1148 */  false,
  /* 1149 */  false,
  /* 1150 */  false,
  /* 1151 */  false,
  /* 1152 */  false,
  /* 1153 */  false,
  /* 1154 */  false,
  /* 1155 */  false,
  /* 1156 */  false,
  /* 1157 */  false,
  /* 1158 */  false,
  /* 1159 */  false,
  /* 1160 */  false,
  /* 1161 */  false,
  /* 1162 */  false,
  /* 1163 */  false,
  /* 1164 */  false,
  /* 1165 */  false,
  /* 1166 */  false,
  /* 1167 */  false,
  /* 1168 */  false,
  /* 1169 */  false,
  /* 1170 */  false,
  /* 1171 */  false,
  /* 1172 */  false,
  /* 1173 */  false,
  /* 1174 */  false,
  /* 1175 */  false,
  /* 1176 */  false,
  /* 1177 */  false,
  /* 1178 */  false,
  /* 1179 */  false,
  /* 1180 */  false,
  /* 1181 */  false,
  /* 1182 */  false,
  /* 1183 */  false,
  /* 1184 */  false,
  /* 1185 */  false,
  /* 1186 */  false,
  /* 1187 */  false,
  /* 1188 */  false,
  /* 1189 */  false,
  /* 1190 */  false,
  /* 1191 */  false,
  /* 1192 */  false,
  /* 1193 */  false,
  /* 1194 */  false,
  /* 1195 */  false,
  /* 1196 */  false,
  /* 1197 */  false,
  /* 1198 */  false,
  /* 1199 */  false,
  /* 1200 */  false,
  /* 1201 */  false,
  /* 1202 */  false,
  /* 1203 */  false,
  /* 1204 */  false,
  /* 1205 */  false,
  /* 1206 */  false,
  /* 1207 */  false,
  /* 1208 */  false,
  /* 1209 */  false,
  /* 1210 */  false,
  /* 1211 */  false,
  /* 1212 */  false,
  /* 1213 */  false,
  /* 1214 */  false,
  /* 1215 */  false,
  /* 1216 */  false,
  /* 1217 */  false,
  /* 1218 */  false,
  /* 1219 */  false,
  /* 1220 */  false,
  /* 1221 */  false,
  /* 1222 */  false,
  /* 1223 */  false,
  /* 1224 */  false,
  /* 1225 */  false,
  /* 1226 */  false,
  /* 1227 */  false,
  /* 1228 */  false,
  /* 1229 */  false,
  /* 1230 */  false,
  /* 1231 */  false,
  /* 1232 */  false,
  /* 1233 */  false,
  /* 1234 */  false,
  /* 1235 */  false,
  /* 1236 */  false,
  /* 1237 */  false,
  /* 1238 */  false,
  /* 1239 */  false,
  /* 1240 */  false,
  /* 1241 */  false,
  /* 1242 */  false,
  /* 1243 */  false,
  /* 1244 */  false,
  /* 1245 */  false,
  /* 1246 */  false,
  /* 1247 */  false,
  /* 1248 */  false,
  /* 1249 */  false,
  /* 1250 */  false,
  /* 1251 */  false,
  /* 1252 */  false,
  /* 1253 */  false,
  /* 1254 */  false,
  /* 1255 */  false,
  /* 1256 */  false,
  /* 1257 */  false,
  /* 1258 */  false,
  /* 1259 */  false,
  /* 1260 */  false,
  /* 1261 */  false,
  /* 1262 */  false,
  /* 1263 */  false,
  /* 1264 */  false,
  /* 1265 */  false,
  /* 1266 */  false,
  /* 1267 */  false,
  /* 1268 */  false,
  /* 1269 */  false,
  /* 1270 */  false,
  /* 1271 */  false,
  /* 1272 */  false,
  /* 1273 */  false,
  /* 1274 */  false,
  /* 1275 */  false,
  /* 1276 */  false,
  /* 1277 */  false,
  /* 1278 */  false,
  /* 1279 */  false,
  /* 1280 */  false,
  /* 1281 */  false,
  /* 1282 */  false,
  /* 1283 */  false,
  /* 1284 */  false,
  /* 1285 */  false,
  /* 1286 */  false,
  /* 1287 */  false,
  /* 1288 */  false,
  /* 1289 */  false,
  /* 1290 */  false,
  /* 1291 */  false,
  /* 1292 */  false,
  /* 1293 */  false,
  /* 1294 */  false,
  /* 1295 */  false,
  /* 1296 */  false,
  /* 1297 */  false,
  /* 1298 */  false,
  /* 1299 */  false,
  /* 1300 */  false,
  /* 1301 */  false,
  /* 1302 */  false,
  /* 1303 */  false,
  /* 1304 */  false,
  /* 1305 */  false,
  /* 1306 */  false,
  /* 1307 */  false,
  /* 1308 */  false,
  /* 1309 */  false,
  /* 1310 */  false,
  /* 1311 */  false,
  /* 1312 */  false,
  /* 1313 */  false,
  /* 1314 */  false,
  /* 1315 */  false,
  /* 1316 */  false,
  /* 1317 */  false,
  /* 1318 */  false,
  /* 1319 */  false,
  /* 1320 */  false,
  /* 1321 */  false,
  /* 1322 */  false,
  /* 1323 */  false,
  /* 1324 */  false,
  /* 1325 */  false,
  /* 1326 */  false,
  /* 1327 */  false,
  /* 1328 */  false,
  /* 1329 */  false,
  /* 1330 */  false,
  /* 1331 */  false,
  /* 1332 */  false,
  /* 1333 */  false,
  /* 1334 */  false,
  /* 1335 */  false,
  /* 1336 */  false,
  /* 1337 */  false,
  /* 1338 */  false,
  /* 1339 */  false,
  /* 1340 */  false,
  /* 1341 */  false,
  /* 1342 */  false,
  /* 1343 */  false,
  /* 1344 */  false,
  /* 1345 */  false,
  /* 1346 */  false,
  /* 1347 */  false,
  /* 1348 */  false,
  /* 1349 */  false,
  /* 1350 */  false,
  /* 1351 */  false,
  /* 1352 */  false,
  /* 1353 */  false,
  /* 1354 */  false,
  /* 1355 */  false,
  /* 1356 */  false,
  /* 1357 */  false,
  /* 1358 */  false,
  /* 1359 */  false,
  /* 1360 */  false,
  /* 1361 */  false,
  /* 1362 */  false,
  /* 1363 */  false,
  /* 1364 */  false,
  /* 1365 */  false,
  /* 1366 */  false,
  /* 1367 */  false,
  /* 1368 */  false,
  /* 1369 */  false,
  /* 1370 */  false,
  /* 1371 */  false,
  /* 1372 */  false,
  /* 1373 */  false,
  /* 1374 */  false,
  /* 1375 */  false,
  /* 1376 */  false,
  /* 1377 */  false,
  /* 1378 */  false,
  /* 1379 */  false,
  /* 1380 */  false,
  /* 1381 */  false,
  /* 1382 */  false,
  /* 1383 */  false,
  /* 1384 */  false,
  /* 1385 */  false,
  /* 1386 */  false,
  /* 1387 */  false,
  /* 1388 */  false,
  /* 1389 */  false,
  /* 1390 */  false,
  /* 1391 */  false,
  /* 1392 */  false,
  /* 1393 */  false,
  /* 1394 */  false,
  /* 1395 */  false,
  /* 1396 */  false,
  /* 1397 */  false,
  /* 1398 */  false,
  /* 1399 */  false,
  /* 1400 */  false,
  /* 1401 */  false,
  /* 1402 */  false,
  /* 1403 */  false,
  /* 1404 */  false,
  /* 1405 */  false,
  /* 1406 */  false,
  /* 1407 */  false,
  /* 1408 */  false,
  /* 1409 */  false,
  /* 1410 */  false,
  /* 1411 */  false,
  /* 1412 */  false,
  /* 1413 */  false,
  /* 1414 */  false,
  /* 1415 */  false,
  /* 1416 */  false,
  /* 1417 */  false,
  /* 1418 */  false,
  /* 1419 */  false,
  /* 1420 */  false,
  /* 1421 */  false,
  /* 1422 */  false,
  /* 1423 */  false,
  /* 1424 */  false,
  /* 1425 */  false,
  /* 1426 */  false,
  /* 1427 */  false,
  /* 1428 */  false,
  /* 1429 */  false,
  /* 1430 */  false,
  /* 1431 */  false,
  /* 1432 */  false,
  /* 1433 */  false,
  /* 1434 */  false,
  /* 1435 */  false,
  /* 1436 */  false,
  /* 1437 */  false,
  /* 1438 */  false,
  /* 1439 */  false,
  /* 1440 */  false,
  /* 1441 */  false,
  /* 1442 */  false,
  /* 1443 */  false,
  /* 1444 */  false,
  /* 1445 */  false,
  /* 1446 */  false,
  /* 1447 */  false,
  /* 1448 */  false,
  /* 1449 */  false,
  /* 1450 */  false,
  /* 1451 */  false,
  /* 1452 */  false,
  /* 1453 */  false,
  /* 1454 */  false,
  /* 1455 */  false,
  /* 1456 */  false,
  /* 1457 */  false,
  /* 1458 */  false,
  /* 1459 */  false,
  /* 1460 */  false,
  /* 1461 */  false,
  /* 1462 */  false,
  /* 1463 */  false,
  /* 1464 */  false,
  /* 1465 */  false,
  /* 1466 */  false,
  /* 1467 */  false,
  /* 1468 */  false,
  /* 1469 */  false,
  /* 1470 */  false,
  /* 1471 */  false,
  /* 1472 */  false,
  /* 1473 */  false,
  /* 1474 */  false,
  /* 1475 */  false,
  /* 1476 */  false,
  /* 1477 */  false,
  /* 1478 */  false,
  /* 1479 */  false,
  /* 1480 */  false,
  /* 1481 */  false,
  /* 1482 */  false,
  /* 1483 */  false,
  /* 1484 */  false,
  /* 1485 */  false,
  /* 1486 */  false,
  /* 1487 */  false,
  /* 1488 */  false,
  /* 1489 */  false,
  /* 1490 */  false,
  /* 1491 */  false,
  /* 1492 */  false,
  /* 1493 */  false,
  /* 1494 */  false,
  /* 1495 */  false,
  /* 1496 */  false,
  /* 1497 */  false,
  /* 1498 */  false,
  /* 1499 */  false,
  /* 1500 */  false,
  /* 1501 */  false,
  /* 1502 */  false,
  /* 1503 */  false,
  /* 1504 */  false,
  /* 1505 */  false,
  /* 1506 */  false,
  /* 1507 */  false,
  /* 1508 */  false,
  /* 1509 */  false,
  /* 1510 */  false,
  /* 1511 */  false,
  /* 1512 */  false,
  /* 1513 */  false,
  /* 1514 */  false,
  /* 1515 */  false,
  /* 1516 */  false,
  /* 1517 */  false,
  /* 1518 */  false,
  /* 1519 */  false,
  /* 1520 */  false,
  /* 1521 */  false,
  /* 1522 */  false,
  /* 1523 */  false,
  /* 1524 */  false,
  /* 1525 */  false,
  /* 1526 */  false,
  /* 1527 */  false,
  /* 1528 */  false,
  /* 1529 */  false,
  /* 1530 */  false,
  /* 1531 */  false,
  /* 1532 */  false,
  /* 1533 */  false,
  /* 1534 */  false,
  /* 1535 */  false,
  /* 1536 */  false,
  /* 1537 */  false,
  /* 1538 */  false,
  /* 1539 */  false,
  /* 1540 */  false,
  /* 1541 */  false,
  /* 1542 */  false,
  /* 1543 */  false,
  /* 1544 */  false,
  /* 1545 */  false,
  /* 1546 */  false,
  /* 1547 */  false,
  /* 1548 */  false,
  /* 1549 */  false,
  /* 1550 */  false,
  /* 1551 */  false,
  /* 1552 */  false,
  /* 1553 */  false,
  /* 1554 */  false,
  /* 1555 */  false,
  /* 1556 */  false,
  /* 1557 */  false,
  /* 1558 */  false,
  /* 1559 */  false,
  /* 1560 */  false,
  /* 1561 */  false,
  /* 1562 */  false,
  /* 1563 */  false,
  /* 1564 */  false,
  /* 1565 */  false,
  /* 1566 */  false,
  /* 1567 */  false,
  /* 1568 */  false,
  /* 1569 */  false,
  /* 1570 */  false,
  /* 1571 */  false,
  /* 1572 */  false,
  /* 1573 */  false,
  /* 1574 */  false,
  /* 1575 */  false,
  /* 1576 */  false,
  /* 1577 */  false,
  /* 1578 */  false,
  /* 1579 */  false,
  /* 1580 */  false,
  /* 1581 */  false,
  /* 1582 */  false,
  /* 1583 */  false,
  /* 1584 */  false,
  /* 1585 */  false,
  /* 1586 */  false,
  /* 1587 */  false,
  /* 1588 */  false,
  /* 1589 */  false,
  /* 1590 */  false,
  /* 1591 */  false,
  /* 1592 */  false,
  /* 1593 */  false,
  /* 1594 */  false,
  /* 1595 */  false,
  /* 1596 */  false,
  /* 1597 */  false,
  /* 1598 */  false,
  /* 1599 */  false,
  /* 1600 */  false,
  /* 1601 */  false,
  /* 1602 */  false,
  /* 1603 */  false,
  /* 1604 */  false,
  /* 1605 */  false,
  /* 1606 */  false,
  /* 1607 */  false,
  /* 1608 */  false,
  /* 1609 */  false,
  /* 1610 */  false,
  /* 1611 */  false,
  /* 1612 */  false,
  /* 1613 */  false,
  /* 1614 */  false,
  /* 1615 */  false,
  /* 1616 */  false,
  /* 1617 */  false,
  /* 1618 */  false,
  /* 1619 */  false,
  /* 1620 */  false,
  /* 1621 */  false,
  /* 1622 */  false,
  /* 1623 */  false,
  /* 1624 */  false,
  /* 1625 */  false,
  /* 1626 */  false,
  /* 1627 */  false,
  /* 1628 */  false,
  /* 1629 */  false,
  /* 1630 */  false,
  /* 1631 */  false,
  /* 1632 */  false,
  /* 1633 */  false,
  /* 1634 */  false,
  /* 1635 */  false,
  /* 1636 */  false,
  /* 1637 */  false,
  /* 1638 */  false,
  /* 1639 */  false,
  /* 1640 */  false,
  /* 1641 */  false,
  /* 1642 */  false,
  /* 1643 */  false,
  /* 1644 */  false,
  /* 1645 */  false,
  /* 1646 */  false,
  /* 1647 */  false,
  /* 1648 */  false,
  /* 1649 */  false,
  /* 1650 */  false,
  /* 1651 */  false,
  /* 1652 */  false,
  /* 1653 */  false,
  /* 1654 */  false,
  /* 1655 */  false,
  /* 1656 */  false,
  /* 1657 */  false,
  /* 1658 */  false,
  /* 1659 */  false,
  /* 1660 */  false,
  /* 1661 */  false,
  /* 1662 */  false,
  /* 1663 */  false,
  /* 1664 */  false,
  /* 1665 */  false,
  /* 1666 */  false,
  /* 1667 */  false,
  /* 1668 */  false,
  /* 1669 */  false,
  /* 1670 */  false,
  /* 1671 */  false,
  /* 1672 */  false,
  /* 1673 */  false,
  /* 1674 */  false,
  /* 1675 */  false,
  /* 1676 */  false,
  /* 1677 */  false,
  /* 1678 */  false,
  /* 1679 */  false,
  /* 1680 */  false,
  /* 1681 */  false,
  /* 1682 */  false,
  /* 1683 */  false,
  /* 1684 */  false,
  /* 1685 */  false,
  /* 1686 */  false,
  /* 1687 */  false,
  /* 1688 */  false,
  /* 1689 */  false,
  /* 1690 */  false,
  /* 1691 */  false,
  /* 1692 */  false,
  /* 1693 */  false,
  /* 1694 */  false,
  /* 1695 */  false,
  /* 1696 */  false,
  /* 1697 */  false,
  /* 1698 */  false,
  // last instruction
  false // no trailing comma
};

// Mapping from machine-independent opcode to boolean
const        char must_clone[] = {
  0, // Node: 0
  0, // Set: 1
  0, // RegN: 2
  0, // RegI: 3
  0, // RegP: 4
  0, // RegF: 5
  0, // RegD: 6
  0, // RegL: 7
  0, // VecA: 8
  0, // VecS: 9
  0, // VecD: 10
  0, // VecX: 11
  0, // VecY: 12
  0, // VecZ: 13
  0, // RegVectMask: 14
  0, // RegFlags: 15
  0, // _last_machine_leaf: 16
  0, // AbsD: 17
  0, // AbsF: 18
  0, // AbsI: 19
  0, // AbsL: 20
  0, // AddD: 21
  0, // AddF: 22
  0, // AddI: 23
  0, // AddL: 24
  0, // AddP: 25
  0, // Allocate: 26
  0, // AllocateArray: 27
  0, // AndI: 28
  0, // AndL: 29
  0, // ArrayCopy: 30
  0, // AryEq: 31
  0, // AtanD: 32
  1, // Binary: 33
  0, // Blackhole: 34
  1, // Bool: 35
  0, // BoxLock: 36
  0, // ReverseBytesI: 37
  0, // ReverseBytesL: 38
  0, // ReverseBytesUS: 39
  0, // ReverseBytesS: 40
  0, // ReverseBytesV: 41
  0, // CProj: 42
  0, // CacheWB: 43
  0, // CacheWBPreSync: 44
  0, // CacheWBPostSync: 45
  0, // CallDynamicJava: 46
  0, // CallJava: 47
  0, // CallLeaf: 48
  0, // CallLeafNoFP: 49
  0, // CallLeafVector: 50
  0, // CallRuntime: 51
  0, // CallStaticJava: 52
  0, // CastDD: 53
  0, // CastFF: 54
  0, // CastII: 55
  0, // CastLL: 56
  0, // CastVV: 57
  0, // CastX2P: 58
  0, // CastP2X: 59
  0, // CastPP: 60
  0, // Catch: 61
  0, // CatchProj: 62
  0, // CheckCastPP: 63
  0, // ClearArray: 64
  0, // CompressBits: 65
  0, // ExpandBits: 66
  0, // CompressBitsV: 67
  0, // ExpandBitsV: 68
  0, // ConstraintCast: 69
  0, // CMoveD: 70
  0, // CMoveF: 71
  0, // CMoveI: 72
  0, // CMoveL: 73
  0, // CMoveP: 74
  0, // CMoveN: 75
  1, // CmpN: 76
  1, // CmpD: 77
  0, // CmpD3: 78
  1, // CmpF: 79
  0, // CmpF3: 80
  1, // CmpI: 81
  1, // CmpL: 82
  0, // CmpL3: 83
  0, // CmpLTMask: 84
  1, // CmpP: 85
  1, // CmpU: 86
  0, // CmpU3: 87
  1, // CmpUL: 88
  0, // CmpUL3: 89
  0, // CompareAndSwapB: 90
  0, // CompareAndSwapS: 91
  0, // CompareAndSwapI: 92
  0, // CompareAndSwapL: 93
  0, // CompareAndSwapP: 94
  0, // CompareAndSwapN: 95
  0, // WeakCompareAndSwapB: 96
  0, // WeakCompareAndSwapS: 97
  0, // WeakCompareAndSwapI: 98
  0, // WeakCompareAndSwapL: 99
  0, // WeakCompareAndSwapP: 100
  0, // WeakCompareAndSwapN: 101
  0, // CompareAndExchangeB: 102
  0, // CompareAndExchangeS: 103
  0, // CompareAndExchangeI: 104
  0, // CompareAndExchangeL: 105
  0, // CompareAndExchangeP: 106
  0, // CompareAndExchangeN: 107
  0, // GetAndAddB: 108
  0, // GetAndAddS: 109
  0, // GetAndAddI: 110
  0, // GetAndAddL: 111
  0, // GetAndSetB: 112
  0, // GetAndSetS: 113
  0, // GetAndSetI: 114
  0, // GetAndSetL: 115
  0, // GetAndSetP: 116
  0, // GetAndSetN: 117
  0, // Con: 118
  0, // ConN: 119
  0, // ConNKlass: 120
  0, // ConD: 121
  0, // ConF: 122
  0, // ConI: 123
  0, // ConL: 124
  0, // ConP: 125
  0, // Conv2B: 126
  0, // ConvD2F: 127
  0, // ConvD2I: 128
  0, // ConvD2L: 129
  0, // ConvF2D: 130
  0, // ConvF2I: 131
  0, // ConvF2L: 132
  0, // ConvI2D: 133
  0, // ConvI2F: 134
  0, // ConvI2L: 135
  0, // ConvL2D: 136
  0, // ConvL2F: 137
  0, // ConvL2I: 138
  0, // ConvF2HF: 139
  0, // ConvHF2F: 140
  0, // CountedLoop: 141
  0, // CountedLoopEnd: 142
  0, // OuterStripMinedLoop: 143
  0, // OuterStripMinedLoopEnd: 144
  0, // LongCountedLoop: 145
  0, // LongCountedLoopEnd: 146
  0, // CountLeadingZerosI: 147
  0, // CountLeadingZerosL: 148
  0, // CountLeadingZerosV: 149
  0, // CountTrailingZerosI: 150
  0, // CountTrailingZerosL: 151
  0, // CountTrailingZerosV: 152
  0, // CreateEx: 153
  0, // DecodeN: 154
  0, // DecodeNKlass: 155
  0, // DivD: 156
  0, // DivF: 157
  0, // DivI: 158
  0, // DivL: 159
  0, // UDivI: 160
  0, // UDivL: 161
  0, // DivMod: 162
  0, // DivModI: 163
  0, // DivModL: 164
  0, // UDivModI: 165
  0, // UDivModL: 166
  0, // EncodeISOArray: 167
  0, // EncodeP: 168
  0, // EncodePKlass: 169
  1, // FastLock: 170
  1, // FastUnlock: 171
  0, // FmaD: 172
  0, // FmaF: 173
  0, // Goto: 174
  0, // Halt: 175
  0, // CountPositives: 176
  0, // If: 177
  0, // RangeCheck: 178
  0, // IfFalse: 179
  0, // IfTrue: 180
  0, // Initialize: 181
  0, // JProj: 182
  0, // Jump: 183
  0, // JumpProj: 184
  0, // LShiftI: 185
  0, // LShiftL: 186
  0, // LoadB: 187
  0, // LoadUB: 188
  0, // LoadUS: 189
  0, // LoadD: 190
  0, // LoadD_unaligned: 191
  0, // LoadF: 192
  0, // LoadI: 193
  0, // LoadKlass: 194
  0, // LoadNKlass: 195
  0, // LoadL: 196
  0, // LoadL_unaligned: 197
  0, // LoadP: 198
  0, // LoadN: 199
  0, // LoadRange: 200
  0, // LoadS: 201
  0, // Lock: 202
  0, // Loop: 203
  0, // LoopLimit: 204
  0, // Mach: 205
  0, // MachNullCheck: 206
  0, // MachProj: 207
  0, // MulAddS2I: 208
  0, // MaxI: 209
  0, // MaxL: 210
  0, // MaxD: 211
  0, // MaxF: 212
  0, // MemBarAcquire: 213
  0, // LoadFence: 214
  0, // MemBarAcquireLock: 215
  0, // MemBarCPUOrder: 216
  0, // MemBarRelease: 217
  0, // StoreFence: 218
  0, // StoreStoreFence: 219
  0, // MemBarReleaseLock: 220
  0, // MemBarVolatile: 221
  0, // MemBarStoreStore: 222
  0, // MergeMem: 223
  0, // MinI: 224
  0, // MinL: 225
  0, // MinF: 226
  0, // MinD: 227
  0, // ModD: 228
  0, // ModF: 229
  0, // ModI: 230
  0, // ModL: 231
  0, // UModI: 232
  0, // UModL: 233
  0, // MoveI2F: 234
  0, // MoveF2I: 235
  0, // MoveL2D: 236
  0, // MoveD2L: 237
  0, // IsInfiniteF: 238
  0, // IsFiniteF: 239
  0, // IsInfiniteD: 240
  0, // IsFiniteD: 241
  0, // MulD: 242
  0, // MulF: 243
  0, // MulHiL: 244
  0, // UMulHiL: 245
  0, // MulI: 246
  0, // MulL: 247
  0, // Multi: 248
  0, // NegI: 249
  0, // NegL: 250
  0, // NegD: 251
  0, // NegF: 252
  0, // NeverBranch: 253
  0, // OnSpinWait: 254
  0, // Opaque1: 255
  0, // OpaqueLoopInit: 256
  0, // OpaqueLoopStride: 257
  0, // OpaqueZeroTripGuard: 258
  0, // Opaque3: 259
  0, // Opaque4: 260
  0, // ProfileBoolean: 261
  0, // OrI: 262
  0, // OrL: 263
  1, // OverflowAddI: 264
  1, // OverflowSubI: 265
  1, // OverflowMulI: 266
  1, // OverflowAddL: 267
  1, // OverflowSubL: 268
  1, // OverflowMulL: 269
  0, // PCTable: 270
  0, // Parm: 271
  0, // ParsePredicate: 272
  0, // PartialSubtypeCheck: 273
  0, // SubTypeCheck: 274
  0, // Phi: 275
  0, // PopCountI: 276
  0, // PopCountL: 277
  0, // PopCountVI: 278
  0, // PopCountVL: 279
  0, // PopulateIndex: 280
  0, // PrefetchAllocation: 281
  0, // Proj: 282
  0, // RShiftI: 283
  0, // RShiftL: 284
  0, // Region: 285
  0, // Rethrow: 286
  0, // Return: 287
  0, // ReverseI: 288
  0, // ReverseL: 289
  0, // ReverseV: 290
  0, // Root: 291
  0, // RoundDouble: 292
  0, // RoundDoubleMode: 293
  0, // RoundDoubleModeV: 294
  0, // RoundFloat: 295
  0, // RotateLeft: 296
  0, // RotateLeftV: 297
  0, // RotateRight: 298
  0, // RotateRightV: 299
  0, // SafePoint: 300
  0, // SafePointScalarObject: 301
  0, // SafePointScalarMerge: 302
  0, // ShenandoahCompareAndExchangeP: 303
  0, // ShenandoahCompareAndExchangeN: 304
  0, // ShenandoahCompareAndSwapN: 305
  0, // ShenandoahCompareAndSwapP: 306
  0, // ShenandoahWeakCompareAndSwapN: 307
  0, // ShenandoahWeakCompareAndSwapP: 308
  0, // ShenandoahIUBarrier: 309
  0, // ShenandoahLoadReferenceBarrier: 310
  0, // SCMemProj: 311
  0, // CopySignD: 312
  0, // CopySignF: 313
  0, // SignumD: 314
  0, // SignumF: 315
  0, // SignumVF: 316
  0, // SignumVD: 317
  0, // SqrtD: 318
  0, // SqrtF: 319
  0, // RoundF: 320
  0, // RoundD: 321
  0, // Start: 322
  0, // StartOSR: 323
  0, // StoreB: 324
  0, // StoreC: 325
  0, // StoreCM: 326
  0, // StoreD: 327
  0, // StoreF: 328
  0, // StoreI: 329
  0, // StoreL: 330
  0, // StoreP: 331
  0, // StoreN: 332
  0, // StoreNKlass: 333
  0, // StrComp: 334
  0, // StrCompressedCopy: 335
  0, // StrEquals: 336
  0, // StrIndexOf: 337
  0, // StrIndexOfChar: 338
  0, // StrInflatedCopy: 339
  0, // SubD: 340
  0, // SubF: 341
  0, // SubI: 342
  0, // SubL: 343
  0, // TailCall: 344
  0, // TailJump: 345
  0, // MacroLogicV: 346
  0, // ThreadLocal: 347
  0, // Unlock: 348
  0, // URShiftB: 349
  0, // URShiftS: 350
  0, // URShiftI: 351
  0, // URShiftL: 352
  0, // XorI: 353
  0, // XorL: 354
  0, // Vector: 355
  0, // AddVB: 356
  0, // AddVS: 357
  0, // AddVI: 358
  0, // AddReductionVI: 359
  0, // AddVL: 360
  0, // AddReductionVL: 361
  0, // AddVF: 362
  0, // AddReductionVF: 363
  0, // AddVD: 364
  0, // AddReductionVD: 365
  0, // SubVB: 366
  0, // SubVS: 367
  0, // SubVI: 368
  0, // SubVL: 369
  0, // SubVF: 370
  0, // SubVD: 371
  0, // MulVB: 372
  0, // MulVS: 373
  0, // MulVI: 374
  0, // MulReductionVI: 375
  0, // MulVL: 376
  0, // MulReductionVL: 377
  0, // MulVF: 378
  0, // MulReductionVF: 379
  0, // MulVD: 380
  0, // MulReductionVD: 381
  0, // MulAddVS2VI: 382
  0, // FmaVD: 383
  0, // FmaVF: 384
  0, // DivVF: 385
  0, // DivVD: 386
  0, // AbsVB: 387
  0, // AbsVS: 388
  0, // AbsVI: 389
  0, // AbsVL: 390
  0, // AbsVF: 391
  0, // AbsVD: 392
  0, // NegVI: 393
  0, // NegVL: 394
  0, // NegVF: 395
  0, // NegVD: 396
  0, // SqrtVD: 397
  0, // SqrtVF: 398
  0, // LShiftCntV: 399
  0, // RShiftCntV: 400
  0, // LShiftVB: 401
  0, // LShiftVS: 402
  0, // LShiftVI: 403
  0, // LShiftVL: 404
  0, // RShiftVB: 405
  0, // RShiftVS: 406
  0, // RShiftVI: 407
  0, // RShiftVL: 408
  0, // URShiftVB: 409
  0, // URShiftVS: 410
  0, // URShiftVI: 411
  0, // URShiftVL: 412
  0, // AndV: 413
  0, // AndReductionV: 414
  0, // OrV: 415
  0, // OrReductionV: 416
  0, // XorV: 417
  0, // XorReductionV: 418
  0, // MinV: 419
  0, // MaxV: 420
  0, // MinReductionV: 421
  0, // MaxReductionV: 422
  0, // CompressV: 423
  0, // CompressM: 424
  0, // ExpandV: 425
  0, // LoadVector: 426
  0, // LoadVectorGather: 427
  0, // LoadVectorGatherMasked: 428
  0, // StoreVector: 429
  0, // StoreVectorScatter: 430
  0, // StoreVectorScatterMasked: 431
  0, // LoadVectorMasked: 432
  0, // StoreVectorMasked: 433
  0, // VerifyVectorAlignment: 434
  0, // VectorCmpMasked: 435
  0, // VectorMaskGen: 436
  0, // VectorMaskOp: 437
  0, // VectorMaskTrueCount: 438
  0, // VectorMaskFirstTrue: 439
  0, // VectorMaskLastTrue: 440
  0, // VectorMaskToLong: 441
  0, // VectorLongToMask: 442
  0, // Pack: 443
  0, // PackB: 444
  0, // PackS: 445
  0, // PackI: 446
  0, // PackL: 447
  0, // PackF: 448
  0, // PackD: 449
  0, // Pack2L: 450
  0, // Pack2D: 451
  0, // Replicate: 452
  0, // RoundVF: 453
  0, // RoundVD: 454
  0, // Extract: 455
  0, // ExtractB: 456
  0, // ExtractUB: 457
  0, // ExtractC: 458
  0, // ExtractS: 459
  0, // ExtractI: 460
  0, // ExtractL: 461
  0, // ExtractF: 462
  0, // ExtractD: 463
  0, // Digit: 464
  0, // LowerCase: 465
  0, // UpperCase: 466
  0, // Whitespace: 467
  0, // VectorBox: 468
  0, // VectorBoxAllocate: 469
  0, // VectorUnbox: 470
  0, // VectorMaskWrapper: 471
  0, // VectorMaskCmp: 472
  0, // VectorMaskCast: 473
  1, // VectorTest: 474
  0, // VectorBlend: 475
  0, // VectorRearrange: 476
  0, // VectorLoadMask: 477
  0, // VectorLoadShuffle: 478
  0, // VectorLoadConst: 479
  0, // VectorStoreMask: 480
  0, // VectorReinterpret: 481
  0, // VectorCast: 482
  0, // VectorCastB2X: 483
  0, // VectorCastS2X: 484
  0, // VectorCastI2X: 485
  0, // VectorCastL2X: 486
  0, // VectorCastF2X: 487
  0, // VectorCastD2X: 488
  0, // VectorCastF2HF: 489
  0, // VectorCastHF2F: 490
  0, // VectorUCastB2X: 491
  0, // VectorUCastS2X: 492
  0, // VectorUCastI2X: 493
  0, // VectorizedHashCode: 494
  0, // VectorInsert: 495
  0, // MaskAll: 496
  0, // AndVMask: 497
  0, // OrVMask: 498
  0 // no trailing comma // XorVMask: 499
};
//  The following instructions can cisc-spill



// An array of character pointers to machine register names.
const char *Matcher::regName[REG_COUNT] = {
  "R10",
  "R10_H",
  "R11",
  "R11_H",
  "R12",
  "R12_H",
  "R13",
  "R13_H",
  "R14",
  "R14_H",
  "R15",
  "R15_H",
  "R16",
  "R16_H",
  "R17",
  "R17_H",
  "R18",
  "R18_H",
  "R0",
  "R0_H",
  "R1",
  "R1_H",
  "R2",
  "R2_H",
  "R3",
  "R3_H",
  "R4",
  "R4_H",
  "R5",
  "R5_H",
  "R6",
  "R6_H",
  "R7",
  "R7_H",
  "R19",
  "R19_H",
  "R20",
  "R20_H",
  "R21",
  "R21_H",
  "R22",
  "R22_H",
  "R23",
  "R23_H",
  "R24",
  "R24_H",
  "R25",
  "R25_H",
  "R26",
  "R26_H",
  "R27",
  "R27_H",
  "R28",
  "R28_H",
  "R29",
  "R29_H",
  "R30",
  "R30_H",
  "R31",
  "R31_H",
  "R8",
  "R8_H",
  "R9",
  "R9_H",
  "V16",
  "V16_H",
  "V16_J",
  "V16_K",
  "V17",
  "V17_H",
  "V17_J",
  "V17_K",
  "V18",
  "V18_H",
  "V18_J",
  "V18_K",
  "V19",
  "V19_H",
  "V19_J",
  "V19_K",
  "V20",
  "V20_H",
  "V20_J",
  "V20_K",
  "V21",
  "V21_H",
  "V21_J",
  "V21_K",
  "V22",
  "V22_H",
  "V22_J",
  "V22_K",
  "V23",
  "V23_H",
  "V23_J",
  "V23_K",
  "V24",
  "V24_H",
  "V24_J",
  "V24_K",
  "V25",
  "V25_H",
  "V25_J",
  "V25_K",
  "V26",
  "V26_H",
  "V26_J",
  "V26_K",
  "V27",
  "V27_H",
  "V27_J",
  "V27_K",
  "V28",
  "V28_H",
  "V28_J",
  "V28_K",
  "V29",
  "V29_H",
  "V29_J",
  "V29_K",
  "V30",
  "V30_H",
  "V30_J",
  "V30_K",
  "V31",
  "V31_H",
  "V31_J",
  "V31_K",
  "V0",
  "V0_H",
  "V0_J",
  "V0_K",
  "V1",
  "V1_H",
  "V1_J",
  "V1_K",
  "V2",
  "V2_H",
  "V2_J",
  "V2_K",
  "V3",
  "V3_H",
  "V3_J",
  "V3_K",
  "V4",
  "V4_H",
  "V4_J",
  "V4_K",
  "V5",
  "V5_H",
  "V5_J",
  "V5_K",
  "V6",
  "V6_H",
  "V6_J",
  "V6_K",
  "V7",
  "V7_H",
  "V7_J",
  "V7_K",
  "V8",
  "V8_H",
  "V8_J",
  "V8_K",
  "V9",
  "V9_H",
  "V9_J",
  "V9_K",
  "V10",
  "V10_H",
  "V10_J",
  "V10_K",
  "V11",
  "V11_H",
  "V11_J",
  "V11_K",
  "V12",
  "V12_H",
  "V12_J",
  "V12_K",
  "V13",
  "V13_H",
  "V13_J",
  "V13_K",
  "V14",
  "V14_H",
  "V14_J",
  "V14_K",
  "V15",
  "V15_H",
  "V15_J",
  "V15_K",
  "P0",
  "P1",
  "P2",
  "P3",
  "P4",
  "P5",
  "P6",
  "P8",
  "P9",
  "P10",
  "P11",
  "P12",
  "P13",
  "P14",
  "P15",
  "P7",
  "RFLAGS" // no trailing comma
};

// An array of character pointers to machine register names.
const VMReg OptoReg::opto2vm[REG_COUNT] = {
	r10->as_VMReg()        ,
	r10->as_VMReg()->next(),
	r11->as_VMReg()        ,
	r11->as_VMReg()->next(),
	r12->as_VMReg()        ,
	r12->as_VMReg()->next(),
	r13->as_VMReg()        ,
	r13->as_VMReg()->next(),
	r14->as_VMReg()        ,
	r14->as_VMReg()->next(),
	r15->as_VMReg()        ,
	r15->as_VMReg()->next(),
	r16->as_VMReg()        ,
	r16->as_VMReg()->next(),
	r17->as_VMReg()        ,
	r17->as_VMReg()->next(),
	r18_tls->as_VMReg()        ,
	r18_tls->as_VMReg()->next(),
	r0->as_VMReg()         ,
	r0->as_VMReg()->next() ,
	r1->as_VMReg()         ,
	r1->as_VMReg()->next() ,
	r2->as_VMReg()         ,
	r2->as_VMReg()->next() ,
	r3->as_VMReg()         ,
	r3->as_VMReg()->next() ,
	r4->as_VMReg()         ,
	r4->as_VMReg()->next() ,
	r5->as_VMReg()         ,
	r5->as_VMReg()->next() ,
	r6->as_VMReg()         ,
	r6->as_VMReg()->next() ,
	r7->as_VMReg()         ,
	r7->as_VMReg()->next() ,
	r19->as_VMReg()        ,
	r19->as_VMReg()->next(),
	r20->as_VMReg()        ,
	r20->as_VMReg()->next(),
	r21->as_VMReg()        ,
	r21->as_VMReg()->next(),
	r22->as_VMReg()        ,
	r22->as_VMReg()->next(),
	r23->as_VMReg()        ,
	r23->as_VMReg()->next(),
	r24->as_VMReg()        ,
	r24->as_VMReg()->next(),
	r25->as_VMReg()        ,
	r25->as_VMReg()->next(),
	r26->as_VMReg()        ,
	r26->as_VMReg()->next(),
	r27->as_VMReg()        ,
	r27->as_VMReg()->next(),
	r28->as_VMReg()        ,
	r28->as_VMReg()->next(),
	r29->as_VMReg()        ,
	r29->as_VMReg()->next(),
	r30->as_VMReg()        ,
	r30->as_VMReg()->next(),
	r31_sp->as_VMReg()     ,
	r31_sp->as_VMReg()->next(),
	r8->as_VMReg()         ,
	r8->as_VMReg()->next() ,
	r9->as_VMReg()         ,
	r9->as_VMReg()->next() ,
	v16->as_VMReg()          ,
	v16->as_VMReg()->next()  ,
	v16->as_VMReg()->next(2) ,
	v16->as_VMReg()->next(3) ,
	v17->as_VMReg()          ,
	v17->as_VMReg()->next()  ,
	v17->as_VMReg()->next(2) ,
	v17->as_VMReg()->next(3) ,
	v18->as_VMReg()          ,
	v18->as_VMReg()->next()  ,
	v18->as_VMReg()->next(2) ,
	v18->as_VMReg()->next(3) ,
	v19->as_VMReg()          ,
	v19->as_VMReg()->next()  ,
	v19->as_VMReg()->next(2) ,
	v19->as_VMReg()->next(3) ,
	v20->as_VMReg()          ,
	v20->as_VMReg()->next()  ,
	v20->as_VMReg()->next(2) ,
	v20->as_VMReg()->next(3) ,
	v21->as_VMReg()          ,
	v21->as_VMReg()->next()  ,
	v21->as_VMReg()->next(2) ,
	v21->as_VMReg()->next(3) ,
	v22->as_VMReg()          ,
	v22->as_VMReg()->next()  ,
	v22->as_VMReg()->next(2) ,
	v22->as_VMReg()->next(3) ,
	v23->as_VMReg()          ,
	v23->as_VMReg()->next()  ,
	v23->as_VMReg()->next(2) ,
	v23->as_VMReg()->next(3) ,
	v24->as_VMReg()          ,
	v24->as_VMReg()->next()  ,
	v24->as_VMReg()->next(2) ,
	v24->as_VMReg()->next(3) ,
	v25->as_VMReg()          ,
	v25->as_VMReg()->next()  ,
	v25->as_VMReg()->next(2) ,
	v25->as_VMReg()->next(3) ,
	v26->as_VMReg()          ,
	v26->as_VMReg()->next()  ,
	v26->as_VMReg()->next(2) ,
	v26->as_VMReg()->next(3) ,
	v27->as_VMReg()          ,
	v27->as_VMReg()->next()  ,
	v27->as_VMReg()->next(2) ,
	v27->as_VMReg()->next(3) ,
	v28->as_VMReg()          ,
	v28->as_VMReg()->next()  ,
	v28->as_VMReg()->next(2) ,
	v28->as_VMReg()->next(3) ,
	v29->as_VMReg()          ,
	v29->as_VMReg()->next()  ,
	v29->as_VMReg()->next(2) ,
	v29->as_VMReg()->next(3) ,
	v30->as_VMReg()          ,
	v30->as_VMReg()->next()  ,
	v30->as_VMReg()->next(2) ,
	v30->as_VMReg()->next(3) ,
	v31->as_VMReg()          ,
	v31->as_VMReg()->next()  ,
	v31->as_VMReg()->next(2) ,
	v31->as_VMReg()->next(3) ,
	v0->as_VMReg()          ,
	v0->as_VMReg()->next()  ,
	v0->as_VMReg()->next(2) ,
	v0->as_VMReg()->next(3) ,
	v1->as_VMReg()          ,
	v1->as_VMReg()->next()  ,
	v1->as_VMReg()->next(2) ,
	v1->as_VMReg()->next(3) ,
	v2->as_VMReg()          ,
	v2->as_VMReg()->next()  ,
	v2->as_VMReg()->next(2) ,
	v2->as_VMReg()->next(3) ,
	v3->as_VMReg()          ,
	v3->as_VMReg()->next()  ,
	v3->as_VMReg()->next(2) ,
	v3->as_VMReg()->next(3) ,
	v4->as_VMReg()          ,
	v4->as_VMReg()->next()  ,
	v4->as_VMReg()->next(2) ,
	v4->as_VMReg()->next(3) ,
	v5->as_VMReg()          ,
	v5->as_VMReg()->next()  ,
	v5->as_VMReg()->next(2) ,
	v5->as_VMReg()->next(3) ,
	v6->as_VMReg()          ,
	v6->as_VMReg()->next()  ,
	v6->as_VMReg()->next(2) ,
	v6->as_VMReg()->next(3) ,
	v7->as_VMReg()          ,
	v7->as_VMReg()->next()  ,
	v7->as_VMReg()->next(2) ,
	v7->as_VMReg()->next(3) ,
	v8->as_VMReg()          ,
	v8->as_VMReg()->next()  ,
	v8->as_VMReg()->next(2) ,
	v8->as_VMReg()->next(3) ,
	v9->as_VMReg()          ,
	v9->as_VMReg()->next()  ,
	v9->as_VMReg()->next(2) ,
	v9->as_VMReg()->next(3) ,
	v10->as_VMReg()          ,
	v10->as_VMReg()->next()  ,
	v10->as_VMReg()->next(2) ,
	v10->as_VMReg()->next(3) ,
	v11->as_VMReg()          ,
	v11->as_VMReg()->next()  ,
	v11->as_VMReg()->next(2) ,
	v11->as_VMReg()->next(3) ,
	v12->as_VMReg()          ,
	v12->as_VMReg()->next()  ,
	v12->as_VMReg()->next(2) ,
	v12->as_VMReg()->next(3) ,
	v13->as_VMReg()          ,
	v13->as_VMReg()->next()  ,
	v13->as_VMReg()->next(2) ,
	v13->as_VMReg()->next(3) ,
	v14->as_VMReg()          ,
	v14->as_VMReg()->next()  ,
	v14->as_VMReg()->next(2) ,
	v14->as_VMReg()->next(3) ,
	v15->as_VMReg()          ,
	v15->as_VMReg()->next()  ,
	v15->as_VMReg()->next(2) ,
	v15->as_VMReg()->next(3) ,
	p0->as_VMReg(),
	p1->as_VMReg(),
	p2->as_VMReg(),
	p3->as_VMReg(),
	p4->as_VMReg(),
	p5->as_VMReg(),
	p6->as_VMReg(),
	p8->as_VMReg(),
	p9->as_VMReg(),
	p10->as_VMReg(),
	p11->as_VMReg(),
	p12->as_VMReg(),
	p13->as_VMReg(),
	p14->as_VMReg(),
	p15->as_VMReg(),
	p7->as_VMReg(),
	VMRegImpl::Bad() // no trailing comma
	};

 OptoReg::Name OptoReg::vm2opto[ConcreteRegisterImpl::number_of_registers];

// An array of the machine register encode values
const unsigned char Matcher::_regEncode[REG_COUNT] = {
  (unsigned char)'\xA',  // R10
  (unsigned char)'\xA',  // R10_H
  (unsigned char)'\xB',  // R11
  (unsigned char)'\xB',  // R11_H
  (unsigned char)'\xC',  // R12
  (unsigned char)'\xC',  // R12_H
  (unsigned char)'\xD',  // R13
  (unsigned char)'\xD',  // R13_H
  (unsigned char)'\xE',  // R14
  (unsigned char)'\xE',  // R14_H
  (unsigned char)'\xF',  // R15
  (unsigned char)'\xF',  // R15_H
  (unsigned char)'\x10',  // R16
  (unsigned char)'\x10',  // R16_H
  (unsigned char)'\x11',  // R17
  (unsigned char)'\x11',  // R17_H
  (unsigned char)'\x12',  // R18
  (unsigned char)'\x12',  // R18_H
  (unsigned char)'\x0',  // R0
  (unsigned char)'\x0',  // R0_H
  (unsigned char)'\x1',  // R1
  (unsigned char)'\x1',  // R1_H
  (unsigned char)'\x2',  // R2
  (unsigned char)'\x2',  // R2_H
  (unsigned char)'\x3',  // R3
  (unsigned char)'\x3',  // R3_H
  (unsigned char)'\x4',  // R4
  (unsigned char)'\x4',  // R4_H
  (unsigned char)'\x5',  // R5
  (unsigned char)'\x5',  // R5_H
  (unsigned char)'\x6',  // R6
  (unsigned char)'\x6',  // R6_H
  (unsigned char)'\x7',  // R7
  (unsigned char)'\x7',  // R7_H
  (unsigned char)'\x13',  // R19
  (unsigned char)'\x13',  // R19_H
  (unsigned char)'\x14',  // R20
  (unsigned char)'\x14',  // R20_H
  (unsigned char)'\x15',  // R21
  (unsigned char)'\x15',  // R21_H
  (unsigned char)'\x16',  // R22
  (unsigned char)'\x16',  // R22_H
  (unsigned char)'\x17',  // R23
  (unsigned char)'\x17',  // R23_H
  (unsigned char)'\x18',  // R24
  (unsigned char)'\x18',  // R24_H
  (unsigned char)'\x19',  // R25
  (unsigned char)'\x19',  // R25_H
  (unsigned char)'\x1A',  // R26
  (unsigned char)'\x1A',  // R26_H
  (unsigned char)'\x1B',  // R27
  (unsigned char)'\x1B',  // R27_H
  (unsigned char)'\x1C',  // R28
  (unsigned char)'\x1C',  // R28_H
  (unsigned char)'\x1D',  // R29
  (unsigned char)'\x1D',  // R29_H
  (unsigned char)'\x1E',  // R30
  (unsigned char)'\x1E',  // R30_H
  (unsigned char)'\x1F',  // R31
  (unsigned char)'\x1F',  // R31_H
  (unsigned char)'\x8',  // R8
  (unsigned char)'\x8',  // R8_H
  (unsigned char)'\x9',  // R9
  (unsigned char)'\x9',  // R9_H
  (unsigned char)'\x10',  // V16
  (unsigned char)'\x10',  // V16_H
  (unsigned char)'\x10',  // V16_J
  (unsigned char)'\x10',  // V16_K
  (unsigned char)'\x11',  // V17
  (unsigned char)'\x11',  // V17_H
  (unsigned char)'\x11',  // V17_J
  (unsigned char)'\x11',  // V17_K
  (unsigned char)'\x12',  // V18
  (unsigned char)'\x12',  // V18_H
  (unsigned char)'\x12',  // V18_J
  (unsigned char)'\x12',  // V18_K
  (unsigned char)'\x13',  // V19
  (unsigned char)'\x13',  // V19_H
  (unsigned char)'\x13',  // V19_J
  (unsigned char)'\x13',  // V19_K
  (unsigned char)'\x14',  // V20
  (unsigned char)'\x14',  // V20_H
  (unsigned char)'\x14',  // V20_J
  (unsigned char)'\x14',  // V20_K
  (unsigned char)'\x15',  // V21
  (unsigned char)'\x15',  // V21_H
  (unsigned char)'\x15',  // V21_J
  (unsigned char)'\x15',  // V21_K
  (unsigned char)'\x16',  // V22
  (unsigned char)'\x16',  // V22_H
  (unsigned char)'\x16',  // V22_J
  (unsigned char)'\x16',  // V22_K
  (unsigned char)'\x17',  // V23
  (unsigned char)'\x17',  // V23_H
  (unsigned char)'\x17',  // V23_J
  (unsigned char)'\x17',  // V23_K
  (unsigned char)'\x18',  // V24
  (unsigned char)'\x18',  // V24_H
  (unsigned char)'\x18',  // V24_J
  (unsigned char)'\x18',  // V24_K
  (unsigned char)'\x19',  // V25
  (unsigned char)'\x19',  // V25_H
  (unsigned char)'\x19',  // V25_J
  (unsigned char)'\x19',  // V25_K
  (unsigned char)'\x1A',  // V26
  (unsigned char)'\x1A',  // V26_H
  (unsigned char)'\x1A',  // V26_J
  (unsigned char)'\x1A',  // V26_K
  (unsigned char)'\x1B',  // V27
  (unsigned char)'\x1B',  // V27_H
  (unsigned char)'\x1B',  // V27_J
  (unsigned char)'\x1B',  // V27_K
  (unsigned char)'\x1C',  // V28
  (unsigned char)'\x1C',  // V28_H
  (unsigned char)'\x1C',  // V28_J
  (unsigned char)'\x1C',  // V28_K
  (unsigned char)'\x1D',  // V29
  (unsigned char)'\x1D',  // V29_H
  (unsigned char)'\x1D',  // V29_J
  (unsigned char)'\x1D',  // V29_K
  (unsigned char)'\x1E',  // V30
  (unsigned char)'\x1E',  // V30_H
  (unsigned char)'\x1E',  // V30_J
  (unsigned char)'\x1E',  // V30_K
  (unsigned char)'\x1F',  // V31
  (unsigned char)'\x1F',  // V31_H
  (unsigned char)'\x1F',  // V31_J
  (unsigned char)'\x1F',  // V31_K
  (unsigned char)'\x0',  // V0
  (unsigned char)'\x0',  // V0_H
  (unsigned char)'\x0',  // V0_J
  (unsigned char)'\x0',  // V0_K
  (unsigned char)'\x1',  // V1
  (unsigned char)'\x1',  // V1_H
  (unsigned char)'\x1',  // V1_J
  (unsigned char)'\x1',  // V1_K
  (unsigned char)'\x2',  // V2
  (unsigned char)'\x2',  // V2_H
  (unsigned char)'\x2',  // V2_J
  (unsigned char)'\x2',  // V2_K
  (unsigned char)'\x3',  // V3
  (unsigned char)'\x3',  // V3_H
  (unsigned char)'\x3',  // V3_J
  (unsigned char)'\x3',  // V3_K
  (unsigned char)'\x4',  // V4
  (unsigned char)'\x4',  // V4_H
  (unsigned char)'\x4',  // V4_J
  (unsigned char)'\x4',  // V4_K
  (unsigned char)'\x5',  // V5
  (unsigned char)'\x5',  // V5_H
  (unsigned char)'\x5',  // V5_J
  (unsigned char)'\x5',  // V5_K
  (unsigned char)'\x6',  // V6
  (unsigned char)'\x6',  // V6_H
  (unsigned char)'\x6',  // V6_J
  (unsigned char)'\x6',  // V6_K
  (unsigned char)'\x7',  // V7
  (unsigned char)'\x7',  // V7_H
  (unsigned char)'\x7',  // V7_J
  (unsigned char)'\x7',  // V7_K
  (unsigned char)'\x8',  // V8
  (unsigned char)'\x8',  // V8_H
  (unsigned char)'\x8',  // V8_J
  (unsigned char)'\x8',  // V8_K
  (unsigned char)'\x9',  // V9
  (unsigned char)'\x9',  // V9_H
  (unsigned char)'\x9',  // V9_J
  (unsigned char)'\x9',  // V9_K
  (unsigned char)'\xA',  // V10
  (unsigned char)'\xA',  // V10_H
  (unsigned char)'\xA',  // V10_J
  (unsigned char)'\xA',  // V10_K
  (unsigned char)'\xB',  // V11
  (unsigned char)'\xB',  // V11_H
  (unsigned char)'\xB',  // V11_J
  (unsigned char)'\xB',  // V11_K
  (unsigned char)'\xC',  // V12
  (unsigned char)'\xC',  // V12_H
  (unsigned char)'\xC',  // V12_J
  (unsigned char)'\xC',  // V12_K
  (unsigned char)'\xD',  // V13
  (unsigned char)'\xD',  // V13_H
  (unsigned char)'\xD',  // V13_J
  (unsigned char)'\xD',  // V13_K
  (unsigned char)'\xE',  // V14
  (unsigned char)'\xE',  // V14_H
  (unsigned char)'\xE',  // V14_J
  (unsigned char)'\xE',  // V14_K
  (unsigned char)'\xF',  // V15
  (unsigned char)'\xF',  // V15_H
  (unsigned char)'\xF',  // V15_J
  (unsigned char)'\xF',  // V15_K
  (unsigned char)'\x0',  // P0
  (unsigned char)'\x1',  // P1
  (unsigned char)'\x2',  // P2
  (unsigned char)'\x3',  // P3
  (unsigned char)'\x4',  // P4
  (unsigned char)'\x5',  // P5
  (unsigned char)'\x6',  // P6
  (unsigned char)'\x8',  // P8
  (unsigned char)'\x9',  // P9
  (unsigned char)'\xA',  // P10
  (unsigned char)'\xB',  // P11
  (unsigned char)'\xC',  // P12
  (unsigned char)'\xD',  // P13
  (unsigned char)'\xE',  // P14
  (unsigned char)'\xF',  // P15
  (unsigned char)'\x7',  // P7
  (unsigned char)'\x20' // no trailing comma  // RFLAGS
};


//------------------Define classes derived from MachOper---------------------
MachOper  *labelOper::clone() const {
  return  new labelOper(_label, _block_num);
}
uint labelOper::opcode() const { return LABEL; }

const RegMask *sRegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *sRegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *sRegFOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *sRegDOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *sRegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

MachOper  *methodOper::clone() const {
  return  new methodOper(_method);
}
uint methodOper::opcode() const { return METHOD; }

const RegMask *iRegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &ANY_REG32_mask();
}

const RegMask *iRegINoSpOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &NO_SPECIAL_REG32_mask();
}

const RegMask *iRegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &ANY_REG_mask();
}

const RegMask *iRegLNoSpOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &NO_SPECIAL_REG_mask();
}

const RegMask *iRegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

const RegMask *iRegPNoSpOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &NO_SPECIAL_PTR_REG_mask();
}

const RegMask *iRegP_R0Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &R0_REG_mask();
}

const RegMask *iRegP_R1Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &R1_REG_mask();
}

const RegMask *iRegP_R2Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &R2_REG_mask();
}

const RegMask *iRegP_R3Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &R3_REG_mask();
}

const RegMask *iRegP_R4Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &R4_REG_mask();
}

const RegMask *iRegP_R5Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &R5_REG_mask();
}

const RegMask *iRegP_R10Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &R10_REG_mask();
}

const RegMask *iRegL_R0Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &R0_REG_mask();
}

const RegMask *iRegL_R11Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &R11_REG_mask();
}

const RegMask *iRegI_R0Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_R0_REG_mask();
}

const RegMask *iRegI_R2Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_R2_REG_mask();
}

const RegMask *iRegI_R3Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_R3_REG_mask();
}

const RegMask *iRegI_R4Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_R4_REG_mask();
}

const RegMask *iRegNOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &ANY_REG32_mask();
}

const RegMask *iRegNNoSpOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &NO_SPECIAL_REG32_mask();
}

const RegMask *vRegFOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &FLOAT_REG_mask();
}

const RegMask *vRegDOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &DOUBLE_REG_mask();
}

const RegMask *vRegOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &RegMask::Empty;
}

const RegMask *vecAOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &VECTORA_REG_mask();
}

const RegMask *vecDOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &VECTORD_REG_mask();
}

const RegMask *vecXOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &VECTORX_REG_mask();
}

const RegMask *vRegD_V0Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &V0_REG_mask();
}

const RegMask *vRegD_V1Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &V1_REG_mask();
}

const RegMask *vRegD_V2Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &V2_REG_mask();
}

const RegMask *vRegD_V3Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &V3_REG_mask();
}

const RegMask *vRegD_V4Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &V4_REG_mask();
}

const RegMask *vRegD_V5Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &V5_REG_mask();
}

const RegMask *vRegD_V6Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &V6_REG_mask();
}

const RegMask *vRegD_V7Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &V7_REG_mask();
}

const RegMask *pRegOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PR_REG_mask();
}

const RegMask *pRegGovOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &GOV_PR_mask();
}

const RegMask *pRegGov_P0Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &P0_REG_mask();
}

const RegMask *pRegGov_P1Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &P1_REG_mask();
}

const RegMask *rFlagsRegOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_FLAGS_mask();
}

const RegMask *rFlagsRegUOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_FLAGS_mask();
}

const RegMask *inline_cache_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &METHOD_REG_mask();
}

const RegMask *thread_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &THREAD_REG_mask();
}

const RegMask *indirectOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

const RegMask *indIndexScaledI2LOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &PTR_REG_mask();
  case 1: return &ANY_REG32_mask();
  }
  ShouldNotReachHere();
  return nullptr;
}

const RegMask *indIndexScaledOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &PTR_REG_mask();
  case 1: return &ANY_REG_mask();
  }
  ShouldNotReachHere();
  return nullptr;
}

const RegMask *indIndexI2LOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &PTR_REG_mask();
  case 1: return &ANY_REG32_mask();
  }
  ShouldNotReachHere();
  return nullptr;
}

const RegMask *indIndexOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &PTR_REG_mask();
  case 1: return &ANY_REG_mask();
  }
  ShouldNotReachHere();
  return nullptr;
}

const RegMask *indOffI1Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

const RegMask *indOffI2Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

const RegMask *indOffI4Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

const RegMask *indOffI8Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

const RegMask *indOffI16Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

const RegMask *indOffL1Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

const RegMask *indOffL2Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

const RegMask *indOffL4Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

const RegMask *indOffL8Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

const RegMask *indOffL16Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

const RegMask *indirectNOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &ANY_REG32_mask();
}

const RegMask *indIndexScaledI2LNOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  return &ANY_REG32_mask();
}

const RegMask *indIndexScaledNOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &ANY_REG32_mask();
  case 1: return &ANY_REG_mask();
  }
  ShouldNotReachHere();
  return nullptr;
}

const RegMask *indIndexI2LNOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  return &ANY_REG32_mask();
}

const RegMask *indIndexNOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &ANY_REG32_mask();
  case 1: return &ANY_REG_mask();
  }
  ShouldNotReachHere();
  return nullptr;
}

const RegMask *indOffINOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &ANY_REG32_mask();
}

const RegMask *indOffLNOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &ANY_REG32_mask();
}

const RegMask *stackSlotPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *stackSlotIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *stackSlotFOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *stackSlotDOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *stackSlotLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *iRegL2IOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &ANY_REG_mask();
}

const RegMask *vmemA_indOffI4Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

const RegMask *vmemA_indOffL4Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

//------------------Define members for classes derived from MachNode----------
// Build short branch version of this instruction
MachNode *far_cmpL_branch_signNode::short_branch_version() {
  cmpL_branch_signNode *node = new cmpL_branch_signNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  return node;
}

// Build short branch version of this instruction
MachNode *far_cmpI_branch_signNode::short_branch_version() {
  cmpI_branch_signNode *node = new cmpI_branch_signNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  return node;
}

// Build short branch version of this instruction
MachNode *far_cmpL_branch_bitNode::short_branch_version() {
  cmpL_branch_bitNode *node = new cmpL_branch_bitNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  return node;
}

// Build short branch version of this instruction
MachNode *far_cmpI_branch_bitNode::short_branch_version() {
  cmpI_branch_bitNode *node = new cmpI_branch_bitNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  return node;
}

void overflowMulI_reg_branchNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void overflowMulI_reg_branchNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void overflowMulL_reg_branchNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void overflowMulL_reg_branchNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void branchNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(1));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void branchNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(1));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void branchConNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void branchConNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void branchConUNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void branchConUNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void cmpI_imm0_branchNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void cmpI_imm0_branchNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void cmpL_imm0_branchNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void cmpL_imm0_branchNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void cmpP_imm0_branchNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void cmpP_imm0_branchNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void cmpN_imm0_branchNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void cmpN_imm0_branchNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void cmpP_narrowOop_imm0_branchNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void cmpP_narrowOop_imm0_branchNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void cmpUI_imm0_branchNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void cmpUI_imm0_branchNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void cmpUL_imm0_branchNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void cmpUL_imm0_branchNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void cmpL_branch_signNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void cmpL_branch_signNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void cmpI_branch_signNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void cmpI_branch_signNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void cmpL_branch_bitNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(5));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void cmpL_branch_bitNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(5));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void cmpI_branch_bitNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(5));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void cmpI_branch_bitNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(5));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void far_cmpL_branch_signNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void far_cmpL_branch_signNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void far_cmpI_branch_signNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void far_cmpI_branch_signNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(4));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void far_cmpL_branch_bitNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(5));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void far_cmpL_branch_bitNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(5));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void far_cmpI_branch_bitNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(5));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void far_cmpI_branch_bitNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(5));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void branchLoopEndNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void branchLoopEndNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void CallStaticJavaDirectNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

void CallDynamicJavaDirectNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

void CallRuntimeDirectNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

void CallLeafDirectNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

void CallLeafNoFPDirectNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

int loadBNode::reloc() const {
  return 1;
}

int loadB2LNode::reloc() const {
  return 1;
}

int loadUBNode::reloc() const {
  return 1;
}

int loadUB2LNode::reloc() const {
  return 1;
}

int loadSNode::reloc() const {
  return 1;
}

int loadS2LNode::reloc() const {
  return 1;
}

int loadUSNode::reloc() const {
  return 1;
}

int loadUS2LNode::reloc() const {
  return 1;
}

int loadINode::reloc() const {
  return 1;
}

int loadI2LNode::reloc() const {
  return 1;
}

int loadUI2LNode::reloc() const {
  return 1;
}

int loadLNode::reloc() const {
  return 1;
}

int loadRangeNode::reloc() const {
  return 1;
}

int loadPNode::reloc() const {
  return 1;
}

int loadNNode::reloc() const {
  return 1;
}

int loadKlassNode::reloc() const {
  return 1;
}

int loadNKlassNode::reloc() const {
  return 1;
}

int loadFNode::reloc() const {
  return 1;
}

int loadDNode::reloc() const {
  return 1;
}

int loadConPNode::reloc() const {
  return 1;
}

int loadConP0Node::reloc() const {
  return 1;
}

int loadConP1Node::reloc() const {
  return 1;
}

int loadByteMapBaseNode::reloc() const {
  return 1;
}

int loadConF_packedNode::reloc() const {
  return 2;
}

int loadConFNode::reloc() const {
  return 2;
}

int loadConD_packedNode::reloc() const {
  return 2;
}

int loadConDNode::reloc() const {
  return 2;
}

int storeimmCM0Node::reloc() const {
  return 2;
}

int storeimmCM0_orderedNode::reloc() const {
  return 2;
}

int storeBNode::reloc() const {
  return 3;
}

int storeimmB0Node::reloc() const {
  return 2;
}

int storeCNode::reloc() const {
  return 3;
}

int storeimmC0Node::reloc() const {
  return 2;
}

int storeINode::reloc() const {
  return 3;
}

int storeimmI0Node::reloc() const {
  return 2;
}

int storeLNode::reloc() const {
  return 2;
}

int storeimmL0Node::reloc() const {
  return 2;
}

int storePNode::reloc() const {
  return 2;
}

int storeimmP0Node::reloc() const {
  return 3;
}

int storeNNode::reloc() const {
  return 2;
}

int storeImmN0Node::reloc() const {
  return 2;
}

int storeFNode::reloc() const {
  return 2;
}

int storeDNode::reloc() const {
  return 2;
}

int storeNKlassNode::reloc() const {
  return 2;
}

int prefetchallocNode::reloc() const {
  return 1;
}

int storeB_volatileNode::reloc() const {
  return 1;
}

int storeC_volatileNode::reloc() const {
  return 1;
}

int storeI_volatileNode::reloc() const {
  return 1;
}

int storeimmP0_volatileNode::reloc() const {
  return 1;
}

int bytes_reverse_intNode::reloc() const {
  return 1;
}

int bytes_reverse_unsigned_shortNode::reloc() const {
  return 1;
}

int bytes_reverse_shortNode::reloc() const {
  return 1;
}

int countLeadingZerosINode::reloc() const {
  return 1;
}

int countTrailingZerosINode::reloc() const {
  return 1;
}

int popCountINode::reloc() const {
  return 1;
}

int popCountI_memNode::reloc() const {
  return 1;
}

int popCountL_memNode::reloc() const {
  return 1;
}

int get_and_addINode::reloc() const {
  return 1;
}

int get_and_addI_no_resNode::reloc() const {
  return 1;
}

int get_and_addIAcqNode::reloc() const {
  return 1;
}

int get_and_addI_no_resAcqNode::reloc() const {
  return 1;
}

int cmovI_reg_regNode::reloc() const {
  return 2;
}

int cmovUI_reg_regNode::reloc() const {
  return 2;
}

int cmovI_zero_regNode::reloc() const {
  return 1;
}

int cmovUI_zero_regNode::reloc() const {
  return 1;
}

int cmovI_reg_zeroNode::reloc() const {
  return 1;
}

int cmovUI_reg_zeroNode::reloc() const {
  return 1;
}

int cmovP_reg_zeroNode::reloc() const {
  return 1;
}

int cmovUP_reg_zeroNode::reloc() const {
  return 1;
}

int cmovP_zero_regNode::reloc() const {
  return 1;
}

int cmovUP_zero_regNode::reloc() const {
  return 1;
}

int addI_reg_regNode::reloc() const {
  return 2;
}

int addI_reg_immNode::reloc() const {
  return 1;
}

int addP_reg_reg_extNode::reloc() const {
  return 1;
}

int addP_reg_reg_ext_shiftNode::reloc() const {
  return 1;
}

int lshift_extNode::reloc() const {
  return 1;
}

int subI_reg_regNode::reloc() const {
  return 2;
}

int subI_reg_immNode::reloc() const {
  return 1;
}

int negI_regNode::reloc() const {
  return 1;
}

int mulINode::reloc() const {
  return 2;
}

int smulINode::reloc() const {
  return 2;
}

int smulI_0Node::reloc() const {
  return 2;
}

int maddINode::reloc() const {
  return 3;
}

int maddI_0Node::reloc() const {
  return 3;
}

int msubINode::reloc() const {
  return 3;
}

int mnegINode::reloc() const {
  return 2;
}

int mnegI_0Node::reloc() const {
  return 2;
}

int smaddLNode::reloc() const {
  return 2;
}

int smaddL_1Node::reloc() const {
  return 2;
}

int smaddL_0Node::reloc() const {
  return 2;
}

int smaddL_2Node::reloc() const {
  return 2;
}

int smsubLNode::reloc() const {
  return 2;
}

int smsubL_0Node::reloc() const {
  return 2;
}

int smnegLNode::reloc() const {
  return 2;
}

int smnegL_0Node::reloc() const {
  return 2;
}

int muladdS2INode::reloc() const {
  return 4;
}

int divINode::reloc() const {
  return 2;
}

int modINode::reloc() const {
  return 2;
}

int UdivI_reg_regNode::reloc() const {
  return 2;
}

int UmodI_reg_regNode::reloc() const {
  return 2;
}

int lShiftI_reg_regNode::reloc() const {
  return 2;
}

int lShiftI_reg_immNode::reloc() const {
  return 1;
}

int urShiftI_reg_regNode::reloc() const {
  return 2;
}

int urShiftI_reg_immNode::reloc() const {
  return 1;
}

int rShiftI_reg_regNode::reloc() const {
  return 2;
}

int rShiftI_reg_immNode::reloc() const {
  return 1;
}

int lShiftL_reg_regNode::reloc() const {
  return 1;
}

int urShiftL_reg_regNode::reloc() const {
  return 1;
}

int rShiftL_reg_regNode::reloc() const {
  return 1;
}

int regI_not_regNode::reloc() const {
  return 1;
}

int NegI_reg_URShift_regNode::reloc() const {
  return 1;
}

int NegI_reg_RShift_regNode::reloc() const {
  return 1;
}

int NegI_reg_LShift_regNode::reloc() const {
  return 1;
}

int AndI_reg_not_regNode::reloc() const {
  return 2;
}

int AndI_reg_not_reg_0Node::reloc() const {
  return 2;
}

int OrI_reg_not_regNode::reloc() const {
  return 2;
}

int OrI_reg_not_reg_0Node::reloc() const {
  return 2;
}

int XorI_reg_not_regNode::reloc() const {
  return 2;
}

int XorI_reg_not_reg_0Node::reloc() const {
  return 2;
}

int AndI_reg_URShift_not_regNode::reloc() const {
  return 2;
}

int AndI_reg_URShift_not_reg_0Node::reloc() const {
  return 2;
}

int AndI_reg_RShift_not_regNode::reloc() const {
  return 2;
}

int AndI_reg_RShift_not_reg_0Node::reloc() const {
  return 2;
}

int AndI_reg_RotateRight_not_regNode::reloc() const {
  return 2;
}

int AndI_reg_RotateRight_not_reg_0Node::reloc() const {
  return 2;
}

int AndI_reg_LShift_not_regNode::reloc() const {
  return 2;
}

int AndI_reg_LShift_not_reg_0Node::reloc() const {
  return 2;
}

int XorI_reg_URShift_not_regNode::reloc() const {
  return 2;
}

int XorI_reg_URShift_not_reg_1Node::reloc() const {
  return 2;
}

int XorI_reg_URShift_not_reg_0Node::reloc() const {
  return 2;
}

int XorI_reg_URShift_not_reg_2Node::reloc() const {
  return 2;
}

int XorI_reg_RShift_not_regNode::reloc() const {
  return 2;
}

int XorI_reg_RShift_not_reg_1Node::reloc() const {
  return 2;
}

int XorI_reg_RShift_not_reg_0Node::reloc() const {
  return 2;
}

int XorI_reg_RShift_not_reg_2Node::reloc() const {
  return 2;
}

int XorI_reg_RotateRight_not_regNode::reloc() const {
  return 2;
}

int XorI_reg_RotateRight_not_reg_1Node::reloc() const {
  return 2;
}

int XorI_reg_RotateRight_not_reg_0Node::reloc() const {
  return 2;
}

int XorI_reg_RotateRight_not_reg_2Node::reloc() const {
  return 2;
}

int XorI_reg_LShift_not_regNode::reloc() const {
  return 2;
}

int XorI_reg_LShift_not_reg_1Node::reloc() const {
  return 2;
}

int XorI_reg_LShift_not_reg_0Node::reloc() const {
  return 2;
}

int XorI_reg_LShift_not_reg_2Node::reloc() const {
  return 2;
}

int OrI_reg_URShift_not_regNode::reloc() const {
  return 2;
}

int OrI_reg_URShift_not_reg_0Node::reloc() const {
  return 2;
}

int OrI_reg_RShift_not_regNode::reloc() const {
  return 2;
}

int OrI_reg_RShift_not_reg_0Node::reloc() const {
  return 2;
}

int OrI_reg_RotateRight_not_regNode::reloc() const {
  return 2;
}

int OrI_reg_RotateRight_not_reg_0Node::reloc() const {
  return 2;
}

int OrI_reg_LShift_not_regNode::reloc() const {
  return 2;
}

int OrI_reg_LShift_not_reg_0Node::reloc() const {
  return 2;
}

int AndI_reg_URShift_regNode::reloc() const {
  return 2;
}

int AndI_reg_URShift_reg_0Node::reloc() const {
  return 2;
}

int AndI_reg_RShift_regNode::reloc() const {
  return 2;
}

int AndI_reg_RShift_reg_0Node::reloc() const {
  return 2;
}

int AndI_reg_LShift_regNode::reloc() const {
  return 2;
}

int AndI_reg_LShift_reg_0Node::reloc() const {
  return 2;
}

int AndI_reg_RotateRight_regNode::reloc() const {
  return 2;
}

int AndI_reg_RotateRight_reg_0Node::reloc() const {
  return 2;
}

int XorI_reg_URShift_regNode::reloc() const {
  return 2;
}

int XorI_reg_URShift_reg_0Node::reloc() const {
  return 2;
}

int XorI_reg_RShift_regNode::reloc() const {
  return 2;
}

int XorI_reg_RShift_reg_0Node::reloc() const {
  return 2;
}

int XorI_reg_LShift_regNode::reloc() const {
  return 2;
}

int XorI_reg_LShift_reg_0Node::reloc() const {
  return 2;
}

int XorI_reg_RotateRight_regNode::reloc() const {
  return 2;
}

int XorI_reg_RotateRight_reg_0Node::reloc() const {
  return 2;
}

int OrI_reg_URShift_regNode::reloc() const {
  return 2;
}

int OrI_reg_URShift_reg_0Node::reloc() const {
  return 2;
}

int OrI_reg_RShift_regNode::reloc() const {
  return 2;
}

int OrI_reg_RShift_reg_0Node::reloc() const {
  return 2;
}

int OrI_reg_LShift_regNode::reloc() const {
  return 2;
}

int OrI_reg_LShift_reg_0Node::reloc() const {
  return 2;
}

int OrI_reg_RotateRight_regNode::reloc() const {
  return 2;
}

int OrI_reg_RotateRight_reg_0Node::reloc() const {
  return 2;
}

int AddI_reg_URShift_regNode::reloc() const {
  return 2;
}

int AddI_reg_URShift_reg_0Node::reloc() const {
  return 2;
}

int AddI_reg_RShift_regNode::reloc() const {
  return 2;
}

int AddI_reg_RShift_reg_0Node::reloc() const {
  return 2;
}

int AddI_reg_LShift_regNode::reloc() const {
  return 2;
}

int AddI_reg_LShift_reg_0Node::reloc() const {
  return 2;
}

int SubI_reg_URShift_regNode::reloc() const {
  return 2;
}

int SubI_reg_RShift_regNode::reloc() const {
  return 2;
}

int SubI_reg_LShift_regNode::reloc() const {
  return 2;
}

int sbfmwINode::reloc() const {
  return 1;
}

int ubfmwINode::reloc() const {
  return 1;
}

int ubfxwINode::reloc() const {
  return 1;
}

int ubfxIConvI2LNode::reloc() const {
  return 1;
}

int ubfizwINode::reloc() const {
  return 1;
}

int ubfizwIConvI2LNode::reloc() const {
  return 1;
}

int ubfizIConvI2LNode::reloc() const {
  return 1;
}

int extrOrINode::reloc() const {
  return 2;
}

int extrOrI_0Node::reloc() const {
  return 2;
}

int extrAddINode::reloc() const {
  return 2;
}

int extrAddI_0Node::reloc() const {
  return 2;
}

int AddExtINode::reloc() const {
  return 1;
}

int AddExtI_0Node::reloc() const {
  return 1;
}

int SubExtINode::reloc() const {
  return 1;
}

int AddExtI_sxthNode::reloc() const {
  return 2;
}

int AddExtI_sxth_0Node::reloc() const {
  return 2;
}

int AddExtI_sxtbNode::reloc() const {
  return 2;
}

int AddExtI_sxtb_0Node::reloc() const {
  return 2;
}

int AddExtI_uxtbNode::reloc() const {
  return 2;
}

int AddExtI_uxtb_0Node::reloc() const {
  return 2;
}

int AddExtI_uxtb_andNode::reloc() const {
  return 2;
}

int AddExtI_uxtb_and_0Node::reloc() const {
  return 2;
}

int AddExtI_uxth_andNode::reloc() const {
  return 2;
}

int AddExtI_uxth_and_0Node::reloc() const {
  return 2;
}

int SubExtI_uxtb_andNode::reloc() const {
  return 2;
}

int SubExtI_uxth_andNode::reloc() const {
  return 2;
}

int AddExtI_sxtb_shiftNode::reloc() const {
  return 2;
}

int AddExtI_sxtb_shift_0Node::reloc() const {
  return 2;
}

int AddExtI_sxth_shiftNode::reloc() const {
  return 2;
}

int AddExtI_sxth_shift_0Node::reloc() const {
  return 2;
}

int SubExtI_sxtb_shiftNode::reloc() const {
  return 2;
}

int SubExtI_sxth_shiftNode::reloc() const {
  return 2;
}

int AddExtI_shiftNode::reloc() const {
  return 1;
}

int AddExtI_shift_0Node::reloc() const {
  return 1;
}

int SubExtI_shiftNode::reloc() const {
  return 1;
}

int AddExtI_uxtb_and_shiftNode::reloc() const {
  return 2;
}

int AddExtI_uxtb_and_shift_0Node::reloc() const {
  return 2;
}

int AddExtI_uxth_and_shiftNode::reloc() const {
  return 2;
}

int AddExtI_uxth_and_shift_0Node::reloc() const {
  return 2;
}

int SubExtI_uxtb_and_shiftNode::reloc() const {
  return 2;
}

int SubExtI_uxth_and_shiftNode::reloc() const {
  return 2;
}

int minI_reg_imm0Node::reloc() const {
  return 1;
}

int minI_imm0_regNode::reloc() const {
  return 1;
}

int minI_reg_imm1Node::reloc() const {
  return 1;
}

int minI_imm1_regNode::reloc() const {
  return 1;
}

int minI_reg_immM1Node::reloc() const {
  return 1;
}

int minI_immM1_regNode::reloc() const {
  return 1;
}

int maxI_reg_imm0Node::reloc() const {
  return 1;
}

int maxI_imm0_regNode::reloc() const {
  return 1;
}

int maxI_reg_imm1Node::reloc() const {
  return 1;
}

int maxI_imm1_regNode::reloc() const {
  return 1;
}

int maxI_reg_immM1Node::reloc() const {
  return 1;
}

int maxI_immM1_regNode::reloc() const {
  return 1;
}

int bits_reverse_INode::reloc() const {
  return 1;
}

int mnsubF_reg_regNode::reloc() const {
  return 1;
}

int mnsubD_reg_regNode::reloc() const {
  return 1;
}

int absI_regNode::reloc() const {
  return 1;
}

int andI_reg_regNode::reloc() const {
  return 2;
}

int andI_reg_immNode::reloc() const {
  return 1;
}

int orI_reg_regNode::reloc() const {
  return 2;
}

int orI_reg_immNode::reloc() const {
  return 1;
}

int xorI_reg_regNode::reloc() const {
  return 2;
}

int xorI_reg_immNode::reloc() const {
  return 1;
}

int convI2L_reg_regNode::reloc() const {
  return 1;
}

int convUI2L_reg_regNode::reloc() const {
  return 1;
}

int convI2F_reg_regNode::reloc() const {
  return 1;
}

int convI2D_reg_regNode::reloc() const {
  return 1;
}

int overflowAddI_reg_regNode::reloc() const {
  return 2;
}

int overflowAddI_reg_immNode::reloc() const {
  return 1;
}

int overflowSubI_reg_regNode::reloc() const {
  return 2;
}

int overflowSubI_reg_immNode::reloc() const {
  return 1;
}

int overflowNegI_regNode::reloc() const {
  return 1;
}

int overflowMulI_regNode::reloc() const {
  return 2;
}

int overflowMulI_reg_branchNode::reloc() const {
  return 2;
}

int testP_regNode::reloc() const {
  return 1;
}

int compF_reg_zeroNode::reloc() const {
  return 1;
}

int compD_reg_zeroNode::reloc() const {
  return 1;
}

int compF3_reg_immF0Node::reloc() const {
  return 1;
}

int compD3_reg_immD0Node::reloc() const {
  return 1;
}

int cmpLTMask_reg_regNode::reloc() const {
  return 2;
}

int cmpLTMask_reg_zeroNode::reloc() const {
  return 1;
}

int minI_reg_regNode::reloc() const {
  return 2;
}

int maxI_reg_regNode::reloc() const {
  return 2;
}

int cmpI_imm0_branchNode::reloc() const {
  return 1;
}

int cmpP_imm0_branchNode::reloc() const {
  return 1;
}

int cmpP_narrowOop_imm0_branchNode::reloc() const {
  return 1;
}

int cmpUI_imm0_branchNode::reloc() const {
  return 1;
}

int cmpI_branch_signNode::reloc() const {
  return 1;
}

int cmpI_branch_bitNode::reloc() const {
  return 1;
}

int far_cmpI_branch_signNode::reloc() const {
  return 1;
}

int far_cmpI_branch_bitNode::reloc() const {
  return 1;
}

int cmpI_andNode::reloc() const {
  return 1;
}

int cmpI_and_regNode::reloc() const {
  return 2;
}

int safePointNode::reloc() const {
  return 1;
}

int CallStaticJavaDirectNode::reloc() const {
  return 1;
}

int CallDynamicJavaDirectNode::reloc() const {
  return 1;
}

int CallRuntimeDirectNode::reloc() const {
  return 1;
}

int CallLeafDirectNode::reloc() const {
  return 1;
}

int CallLeafNoFPDirectNode::reloc() const {
  return 1;
}

int TailCalljmpIndNode::reloc() const {
  return 1;
}

int TailjmpIndNode::reloc() const {
  return 1;
}

int RethrowExceptionNode::reloc() const {
  return 1;
}

int RetNode::reloc() const {
  return 1;
}

int partialSubtypeCheckVsZeroNode::reloc() const {
  return 1;
}

int compressBitsI_regNode::reloc() const {
  return 2;
}

int compressBitsI_memconNode::reloc() const {
  return 1;
}

int compressBitsL_memconNode::reloc() const {
  return 1;
}

int expandBitsI_regNode::reloc() const {
  return 2;
}

int expandBitsI_memconNode::reloc() const {
  return 1;
}

int expandBitsL_memconNode::reloc() const {
  return 1;
}

int loadV2Node::reloc() const {
  return 1;
}

int storeV2Node::reloc() const {
  return 2;
}

int loadV4Node::reloc() const {
  return 1;
}

int storeV4Node::reloc() const {
  return 2;
}

int loadV8Node::reloc() const {
  return 1;
}

int storeV8Node::reloc() const {
  return 2;
}

int loadV16Node::reloc() const {
  return 1;
}

int storeV16Node::reloc() const {
  return 2;
}

int loadVNode::reloc() const {
  return 1;
}

int storeVNode::reloc() const {
  return 2;
}

int loadV_maskedNode::reloc() const {
  return 1;
}

int storeV_maskedNode::reloc() const {
  return 2;
}

int vshiftcntLNode::reloc() const {
  return 1;
}

int vshiftcntRNode::reloc() const {
  return 1;
}

int reduce_addI_neonNode::reloc() const {
  return 1;
}

int reduce_addI_sveNode::reloc() const {
  return 1;
}

int reduce_addI_maskedNode::reloc() const {
  return 1;
}

int reduce_mulINode::reloc() const {
  return 1;
}

int reduce_andI_neonNode::reloc() const {
  return 1;
}

int reduce_andI_sveNode::reloc() const {
  return 1;
}

int reduce_andI_maskedNode::reloc() const {
  return 1;
}

int reduce_orI_neonNode::reloc() const {
  return 1;
}

int reduce_orI_sveNode::reloc() const {
  return 1;
}

int reduce_orI_maskedNode::reloc() const {
  return 1;
}

int reduce_xorI_neonNode::reloc() const {
  return 1;
}

int reduce_xorI_sveNode::reloc() const {
  return 1;
}

int reduce_xorI_maskedNode::reloc() const {
  return 1;
}

int reduce_maxI_neonNode::reloc() const {
  return 1;
}

int reduce_maxI_sveNode::reloc() const {
  return 1;
}

int reduce_maxI_maskedNode::reloc() const {
  return 1;
}

int reduce_minI_neonNode::reloc() const {
  return 1;
}

int reduce_minI_sveNode::reloc() const {
  return 1;
}

int reduce_minI_maskedNode::reloc() const {
  return 1;
}

int replicateINode::reloc() const {
  return 1;
}

int insertI_le128bNode::reloc() const {
  return 1;
}

int insertI_index_lt32Node::reloc() const {
  return 1;
}

int insertI_index_ge32Node::reloc() const {
  return 1;
}

int vloadmask_loadVMaskedNode::reloc() const {
  return 1;
}

int vloadmask_loadVMasked_maskedNode::reloc() const {
  return 1;
}

int storeVMasked_vstoremaskNode::reloc() const {
  return 2;
}

int storeVMasked_vstoremask_maskedNode::reloc() const {
  return 2;
}

int vmaskcmp_zeroF_neonNode::reloc() const {
  return 1;
}

int vmaskcmp_zeroD_neonNode::reloc() const {
  return 1;
}

int vmaskAllINode::reloc() const {
  return 1;
}

int vmaskAllI_maskedNode::reloc() const {
  return 1;
}

int vmask_gen_INode::reloc() const {
  return 1;
}

int populateindexNode::reloc() const {
  return 1;
}

int xLoadPNode::reloc() const {
  return 1;
}

int zLoadPNode::reloc() const {
  return 1;
}

int zStorePNode::reloc() const {
  return 2;
}


void loadBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2832 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrsbw, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 1);
  
#line 14435 "ad_aarch64.cpp"
  }
}

void loadB2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2840 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrsb, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 1);
  
#line 14452 "ad_aarch64.cpp"
  }
}

void loadUBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2856 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrb, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 1);
  
#line 14469 "ad_aarch64.cpp"
  }
}

void loadUB2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2856 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrb, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 1);
  
#line 14486 "ad_aarch64.cpp"
  }
}

void loadSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2864 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrshw, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 2);
  
#line 14503 "ad_aarch64.cpp"
  }
}

void loadS2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2872 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrsh, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 2);
  
#line 14520 "ad_aarch64.cpp"
  }
}

void loadUSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2888 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrh, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 2);
  
#line 14537 "ad_aarch64.cpp"
  }
}

void loadUS2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2888 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrh, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 2);
  
#line 14554 "ad_aarch64.cpp"
  }
}

void loadINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2904 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrw, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
  
#line 14571 "ad_aarch64.cpp"
  }
}

void loadI2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2912 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrsw, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
  
#line 14588 "ad_aarch64.cpp"
  }
}

void loadUI2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {

#line 2904 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrw, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
  
#line 14606 "ad_aarch64.cpp"
  }
}

void loadLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2920 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 8);
  
#line 14623 "ad_aarch64.cpp"
  }
}

void loadRangeNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2904 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrw, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
  
#line 14640 "ad_aarch64.cpp"
  }
}

void loadPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2920 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 8);
  
#line 14657 "ad_aarch64.cpp"
  }
}

void loadNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2904 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrw, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
  
#line 14674 "ad_aarch64.cpp"
  }
}

void loadKlassNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2920 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 8);
  
#line 14691 "ad_aarch64.cpp"
  }
}

void loadNKlassNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2904 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrw, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
  
#line 14708 "ad_aarch64.cpp"
  }
}

void loadFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2928 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister dst_reg = as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrs, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
  
#line 14725 "ad_aarch64.cpp"
  }
}

void loadDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2936 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister dst_reg = as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrd, dst_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 8);
  
#line 14742 "ad_aarch64.cpp"
  }
}

void loadConINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 3396 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    uint32_t con = (uint32_t)opnd_array(1)->constant();
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    if (con == 0) {
      __ movw(dst_reg, zr);
    } else {
      __ movw(dst_reg, con);
    }
  
#line 14764 "ad_aarch64.cpp"
  }
}

void loadConLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 3407 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    uint64_t con = (uint64_t)opnd_array(1)->constantL();
    if (con == 0) {
      __ mov(dst_reg, zr);
    } else {
      __ mov(dst_reg, con);
    }
  
#line 14786 "ad_aarch64.cpp"
  }
}

void loadConPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {

#line 3418 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    address con = (address)opnd_array(1)->constant();
    if (con == nullptr || con == (address)1) {
      ShouldNotReachHere();
    } else {
      relocInfo::relocType rtype = opnd_array(1)->constant_reloc();
      if (rtype == relocInfo::oop_type) {
        __ movoop(dst_reg, (jobject)con);
      } else if (rtype == relocInfo::metadata_type) {
        __ mov_metadata(dst_reg, (Metadata*)con);
      } else {
        assert(rtype == relocInfo::none, "unexpected reloc type");
        if (! __ is_valid_AArch64_address(con) ||
            con < (address)(uintptr_t)os::vm_page_size()) {
          __ mov(dst_reg, con);
        } else {
          uint64_t offset;
          __ adrp(dst_reg, con, offset);
          __ add(dst_reg, dst_reg, offset);
        }
      }
    }
  
#line 14823 "ad_aarch64.cpp"
  }
}

void loadConP0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {

#line 3444 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    __ mov(dst_reg, zr);
  
#line 14840 "ad_aarch64.cpp"
  }
}

void loadConP1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {

#line 3450 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    __ mov(dst_reg, (uint64_t)1);
  
#line 14857 "ad_aarch64.cpp"
  }
}

void loadByteMapBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {

#line 3456 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    __ load_byte_map_base(opnd_array(0)->as_Register(ra_,this)/* dst */);
  
#line 14873 "ad_aarch64.cpp"
  }
}

void loadConNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {

#line 3461 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    address con = (address)opnd_array(1)->constant();
    if (con == nullptr) {
      ShouldNotReachHere();
    } else {
      relocInfo::relocType rtype = opnd_array(1)->constant_reloc();
      assert(rtype == relocInfo::oop_type, "unexpected reloc type");
      __ set_narrow_oop(dst_reg, (jobject)con);
    }
  
#line 14897 "ad_aarch64.cpp"
  }
}

void loadConN0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {

#line 3474 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    __ mov(dst_reg, zr);
  
#line 14914 "ad_aarch64.cpp"
  }
}

void loadConNKlassNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {

#line 3480 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    address con = (address)opnd_array(1)->constant();
    if (con == nullptr) {
      ShouldNotReachHere();
    } else {
      relocInfo::relocType rtype = opnd_array(1)->constant_reloc();
      assert(rtype == relocInfo::metadata_type, "unexpected reloc type");
      __ set_narrow_klass(dst_reg, (Klass *)con);
    }
  
#line 14938 "ad_aarch64.cpp"
  }
}

void loadConF_packedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6854 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fmovs(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), (double)opnd_array(1)->constantF());
  
#line 14954 "ad_aarch64.cpp"
  }
}

void loadConFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6872 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ldrs(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 14970 "ad_aarch64.cpp"
  }
}

void loadConFNode::eval_constant(Compile* C) {
  {

#line 6873 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"
    _constant = C->output()->constant_table().add(this, opnd_array(1));
#line 14979 "ad_aarch64.cpp"
  }
}
void loadConD_packedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6885 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fmovd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), opnd_array(1)->constantD());
  
#line 14994 "ad_aarch64.cpp"
  }
}

void loadConDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6902 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ldrd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 15010 "ad_aarch64.cpp"
  }
}

void loadConDNode::eval_constant(Compile* C) {
  {

#line 6903 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"
    _constant = C->output()->constant_table().add(this, opnd_array(1));
#line 15019 "ad_aarch64.cpp"
  }
}
void storeimmCM0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 2952 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    loadStore(_masm, &MacroAssembler::strb, zr, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 1);
  
#line 15036 "ad_aarch64.cpp"
  }
}

void storeimmCM0_orderedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 3032 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

      C2_MacroAssembler _masm(&cbuf);
      __ membar(Assembler::StoreStore);
      loadStore(_masm, &MacroAssembler::strb, zr, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 1);
  
#line 15055 "ad_aarch64.cpp"
  }
}

void storeBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2944 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register src_reg = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strb, src_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 1);
  
#line 15073 "ad_aarch64.cpp"
  }
}

void storeimmB0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 2952 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    loadStore(_masm, &MacroAssembler::strb, zr, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 1);
  
#line 15091 "ad_aarch64.cpp"
  }
}

void storeCNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2960 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register src_reg = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strh, src_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 2);
  
#line 15109 "ad_aarch64.cpp"
  }
}

void storeimmC0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 2968 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    loadStore(_masm, &MacroAssembler::strh, zr, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 2);
  
#line 15127 "ad_aarch64.cpp"
  }
}

void storeINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2976 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register src_reg = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strw, src_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
  
#line 15145 "ad_aarch64.cpp"
  }
}

void storeimmI0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 2984 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    loadStore(_masm, &MacroAssembler::strw, zr, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
  
#line 15163 "ad_aarch64.cpp"
  }
}

void storeLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2992 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register src_reg = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src */);
    // we sometimes get asked to store the stack pointer into the
    // current thread -- we cannot do that directly on AArch64
    if (src_reg == r31_sp) {
      C2_MacroAssembler _masm(&cbuf);
      assert(as_Register(opnd_array(1)->base(ra_,this,idx1)) == rthread, "unexpected store for sp");
      __ mov(rscratch2, sp);
      src_reg = rscratch2;
    }
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 8);
  
#line 15189 "ad_aarch64.cpp"
  }
}

void storeimmL0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 3008 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    loadStore(_masm, &MacroAssembler::str, zr, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 8);
  
#line 15207 "ad_aarch64.cpp"
  }
}

void storePNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2992 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register src_reg = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src */);
    // we sometimes get asked to store the stack pointer into the
    // current thread -- we cannot do that directly on AArch64
    if (src_reg == r31_sp) {
      C2_MacroAssembler _masm(&cbuf);
      assert(as_Register(opnd_array(1)->base(ra_,this,idx1)) == rthread, "unexpected store for sp");
      __ mov(rscratch2, sp);
      src_reg = rscratch2;
    }
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 8);
  
#line 15233 "ad_aarch64.cpp"
  }
}

void storeimmP0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 3008 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    loadStore(_masm, &MacroAssembler::str, zr, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 8);
  
#line 15251 "ad_aarch64.cpp"
  }
}

void storeNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2976 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register src_reg = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strw, src_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
  
#line 15269 "ad_aarch64.cpp"
  }
}

void storeImmN0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 2984 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    loadStore(_masm, &MacroAssembler::strw, zr, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
  
#line 15287 "ad_aarch64.cpp"
  }
}

void storeFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 3016 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister src_reg = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strs, src_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
  
#line 15305 "ad_aarch64.cpp"
  }
}

void storeDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 3024 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister src_reg = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strd, src_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 8);
  
#line 15323 "ad_aarch64.cpp"
  }
}

void storeNKlassNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2976 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register src_reg = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strw, src_reg, opnd_array(1)->opcode(),
               as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
  
#line 15341 "ad_aarch64.cpp"
  }
}

void prefetchallocNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// 
  {

#line 3375 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register base = as_Register(opnd_array(1)->base(ra_,this,idx1));
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    if (index == -1) {
      __ prfm(Address(base, disp), PSTL1KEEP);
    } else {
      Register index_reg = as_Register(index);
      if (disp == 0) {
        __ prfm(Address(base, index_reg, Address::lsl(scale)), PSTL1KEEP);
      } else {
        __ lea(rscratch1, Address(base, disp));
	__ prfm(Address(rscratch1, index_reg, Address::lsl(scale)), PSTL1KEEP);
      }
    }
  
#line 15371 "ad_aarch64.cpp"
  }
}

void loadB_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3129 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    MOV_VOLATILE(dst_reg, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
             rscratch1, ldarb);
    __ sxtb(dst_reg, dst_reg);
  
#line 15389 "ad_aarch64.cpp"
  }
}

void loadB2L_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3129 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    MOV_VOLATILE(dst_reg, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
             rscratch1, ldarb);
    __ sxtb(dst_reg, dst_reg);
  
#line 15407 "ad_aarch64.cpp"
  }
}

void loadUB_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3141 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
             rscratch1, ldarb);
  
#line 15423 "ad_aarch64.cpp"
  }
}

void loadUB2L_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3141 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
             rscratch1, ldarb);
  
#line 15439 "ad_aarch64.cpp"
  }
}

void loadS_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3146 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    MOV_VOLATILE(dst_reg, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
             rscratch1, ldarh);
    __ sxthw(dst_reg, dst_reg);
  
#line 15457 "ad_aarch64.cpp"
  }
}

void loadUS_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3160 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
             rscratch1, ldarh);
  
#line 15473 "ad_aarch64.cpp"
  }
}

void loadUS2L_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3165 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
             rscratch1, ldarh);
  
#line 15489 "ad_aarch64.cpp"
  }
}

void loadS2L_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3153 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    MOV_VOLATILE(dst_reg, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
             rscratch1, ldarh);
    __ sxth(dst_reg, dst_reg);
  
#line 15507 "ad_aarch64.cpp"
  }
}

void loadI_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3175 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
             rscratch1, ldarw);
  
#line 15523 "ad_aarch64.cpp"
  }
}

void loadUI2L_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {

#line 3175 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
             rscratch1, ldarw);
  
#line 15540 "ad_aarch64.cpp"
  }
}

void loadL_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3180 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
             rscratch1, ldar);
  
#line 15556 "ad_aarch64.cpp"
  }
}

void loadP_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3180 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
             rscratch1, ldar);
  
#line 15572 "ad_aarch64.cpp"
  }
}

void loadN_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3175 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
             rscratch1, ldarw);
  
#line 15588 "ad_aarch64.cpp"
  }
}

void loadF_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3185 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(rscratch1, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
             rscratch1, ldarw);
    __ fmovs(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), rscratch1);
  
#line 15605 "ad_aarch64.cpp"
  }
}

void loadD_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3191 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(rscratch1, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
             rscratch1, ldar);
    __ fmovd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), rscratch1);
  
#line 15622 "ad_aarch64.cpp"
  }
}

void storeB_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 3092 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src */), opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
                 rscratch1, stlrb);
  
#line 15639 "ad_aarch64.cpp"
  }
}

void storeimmB0_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 3097 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(zr, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
                 rscratch1, stlrb);
  
#line 15656 "ad_aarch64.cpp"
  }
}

void storeC_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 3102 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src */), opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
                 rscratch1, stlrh);
  
#line 15673 "ad_aarch64.cpp"
  }
}

void storeimmC0_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 3107 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(zr, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
                 rscratch1, stlrh);
  
#line 15690 "ad_aarch64.cpp"
  }
}

void storeI_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 3112 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src */), opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
                 rscratch1, stlrw);
  
#line 15707 "ad_aarch64.cpp"
  }
}

void storeimmI0_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 3117 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(zr, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
                 rscratch1, stlrw);
  
#line 15724 "ad_aarch64.cpp"
  }
}

void storeL_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 3197 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register src_reg = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src */);
    // we sometimes get asked to store the stack pointer into the
    // current thread -- we cannot do that directly on AArch64
    if (src_reg == r31_sp) {
      C2_MacroAssembler _masm(&cbuf);
      assert(as_Register(opnd_array(1)->base(ra_,this,idx1)) == rthread, "unexpected store for sp");
      __ mov(rscratch2, sp);
      src_reg = rscratch2;
    }
    MOV_VOLATILE(src_reg, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
                 rscratch1, stlr);
  
#line 15750 "ad_aarch64.cpp"
  }
}

void storeimmL0_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 3211 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(zr, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
                 rscratch1, stlr);
  
#line 15767 "ad_aarch64.cpp"
  }
}

void storeP_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 3197 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register src_reg = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src */);
    // we sometimes get asked to store the stack pointer into the
    // current thread -- we cannot do that directly on AArch64
    if (src_reg == r31_sp) {
      C2_MacroAssembler _masm(&cbuf);
      assert(as_Register(opnd_array(1)->base(ra_,this,idx1)) == rthread, "unexpected store for sp");
      __ mov(rscratch2, sp);
      src_reg = rscratch2;
    }
    MOV_VOLATILE(src_reg, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
                 rscratch1, stlr);
  
#line 15793 "ad_aarch64.cpp"
  }
}

void storeimmP0_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 3211 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(zr, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
                 rscratch1, stlr);
  
#line 15810 "ad_aarch64.cpp"
  }
}

void storeN_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 3112 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src */), opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
                 rscratch1, stlrw);
  
#line 15827 "ad_aarch64.cpp"
  }
}

void storeimmN0_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 3117 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    MOV_VOLATILE(zr, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
                 rscratch1, stlrw);
  
#line 15844 "ad_aarch64.cpp"
  }
}

void storeF_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 3216 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    {
      C2_MacroAssembler _masm(&cbuf);
      FloatRegister src_reg = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src */);
      __ fmovs(rscratch2, src_reg);
    }
    MOV_VOLATILE(rscratch2, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
                 rscratch1, stlrw);
  
#line 15866 "ad_aarch64.cpp"
  }
}

void storeD_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 3226 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    {
      C2_MacroAssembler _masm(&cbuf);
      FloatRegister src_reg = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src */);
      __ fmovd(rscratch2, src_reg);
    }
    MOV_VOLATILE(rscratch2, opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1),
                 rscratch1, stlr);
  
#line 15888 "ad_aarch64.cpp"
  }
}

void cacheWBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7557 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    assert(opnd_array(1)->index_position() < 0, "should be");
    assert(opnd_array(1)->disp(ra_,this,idx1)== 0, "should be");
    __ cache_wb(Address(as_Register(opnd_array(1)->base(ra_,this,idx1)), 0));
  
#line 15906 "ad_aarch64.cpp"
  }
}

void cacheWBPreSyncNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7572 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cache_wbsync(true);
  
#line 15922 "ad_aarch64.cpp"
  }
}

void cacheWBPostSyncNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7585 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cache_wbsync(false);
  
#line 15938 "ad_aarch64.cpp"
  }
}

void bytes_reverse_intNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7600 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ revw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 15954 "ad_aarch64.cpp"
  }
}

void bytes_reverse_longNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7613 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ rev(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 15970 "ad_aarch64.cpp"
  }
}

void bytes_reverse_unsigned_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7626 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ rev16w(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 15986 "ad_aarch64.cpp"
  }
}

void bytes_reverse_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7640 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ rev16w(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */));
    __ sbfmw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(0)->reg(ra_,this)/* dst */), 0U, 15U);
  
#line 16003 "ad_aarch64.cpp"
  }
}

void countLeadingZerosINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7656 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ clzw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 16019 "ad_aarch64.cpp"
  }
}

void countLeadingZerosLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7668 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ clz(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 16035 "ad_aarch64.cpp"
  }
}

void countTrailingZerosINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7681 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ rbitw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */));
    __ clzw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(0)->reg(ra_,this)/* dst */));
  
#line 16052 "ad_aarch64.cpp"
  }
}

void countTrailingZerosLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7695 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ rbit(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */));
    __ clz(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(0)->reg(ra_,this)/* dst */));
  
#line 16069 "ad_aarch64.cpp"
  }
}

void popCountINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7716 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ movw(opnd_array(1)->as_Register(ra_,this,idx1)/* src */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */); // ensure top 32 bits 0
    __ mov(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, __ D, 0, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ cnt(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, __ T8B, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */);
    __ addv(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, __ T8B, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */);
    __ mov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, __ D, 0);
  
#line 16090 "ad_aarch64.cpp"
  }
}

void popCountI_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7736 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister tmp_reg = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* tmp */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrs, tmp_reg, opnd_array(1)->opcode(),
              as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
    __ cnt(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, __ T8B, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */);
    __ addv(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, __ T8B, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */);
    __ mov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, __ D, 0);
  
#line 16112 "ad_aarch64.cpp"
  }
}

void popCountLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7758 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ mov(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, __ D, 0, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ cnt(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, __ T8B, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */);
    __ addv(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, __ T8B, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */);
    __ mov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, __ D, 0);
  
#line 16132 "ad_aarch64.cpp"
  }
}

void popCountL_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7777 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister tmp_reg = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* tmp */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrd, tmp_reg, opnd_array(1)->opcode(),
              as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 8);
    __ cnt(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, __ T8B, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */);
    __ addv(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, __ T8B, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */);
    __ mov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, __ D, 0);
  
#line 16154 "ad_aarch64.cpp"
  }
}

void verify_vector_alignmentNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// addr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7796 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label Lskip;
    // check if masked bits of addr are zero
    __ tst(opnd_array(1)->as_Register(ra_,this,idx1)/* addr */, opnd_array(2)->constantL());
    __ br(Assembler::EQ, Lskip);
    __ stop("verify_vector_alignment found a misaligned vector memory access");
    __ bind(Lskip);
  
#line 16176 "ad_aarch64.cpp"
  }
}

void load_fenceNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7816 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ membar(Assembler::LoadLoad|Assembler::LoadStore);
  
#line 16192 "ad_aarch64.cpp"
  }
}

void unnecessary_membar_acquireNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7829 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ block_comment("membar_acquire (elided)");
  
#line 16208 "ad_aarch64.cpp"
  }
}

void membar_acquireNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7843 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ block_comment("membar_acquire");
    __ membar(Assembler::LoadLoad|Assembler::LoadStore);
  
#line 16225 "ad_aarch64.cpp"
  }
}

void membar_acquire_lockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7858 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ block_comment("membar_acquire_lock (elided)");
  
#line 16241 "ad_aarch64.cpp"
  }
}

void store_fenceNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7871 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ membar(Assembler::LoadStore|Assembler::StoreStore);
  
#line 16257 "ad_aarch64.cpp"
  }
}

void unnecessary_membar_releaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7884 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ block_comment("membar_release (elided)");
  
#line 16273 "ad_aarch64.cpp"
  }
}

void membar_releaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7897 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ block_comment("membar_release");
    __ membar(Assembler::LoadStore|Assembler::StoreStore);
  
#line 16290 "ad_aarch64.cpp"
  }
}

void membar_storestoreNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7911 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ membar(Assembler::StoreStore);
  
#line 16306 "ad_aarch64.cpp"
  }
}

void membar_storestore_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7911 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ membar(Assembler::StoreStore);
  
#line 16322 "ad_aarch64.cpp"
  }
}

void membar_release_lockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7923 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ block_comment("membar_release_lock (elided)");
  
#line 16338 "ad_aarch64.cpp"
  }
}

void unnecessary_membar_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7937 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ block_comment("membar_volatile (elided)");
  
#line 16354 "ad_aarch64.cpp"
  }
}

void membar_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7951 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ block_comment("membar_volatile");
    __ membar(Assembler::StoreLoad);
  
#line 16371 "ad_aarch64.cpp"
  }
}

void castX2PNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7968 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */!= opnd_array(1)->reg(ra_,this,idx1)/* src */) {
      __ mov(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */));
    }
  
#line 16389 "ad_aarch64.cpp"
  }
}

void castP2XNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7983 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */!= opnd_array(1)->reg(ra_,this,idx1)/* src */) {
      __ mov(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */));
    }
  
#line 16407 "ad_aarch64.cpp"
  }
}

void convP2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 7998 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ movw(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 16423 "ad_aarch64.cpp"
  }
}

void convN2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8014 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ movw(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 16439 "ad_aarch64.cpp"
  }
}

void encodeHeapOopNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8029 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register s = opnd_array(1)->as_Register(ra_,this,idx1)/* src */;
    Register d = opnd_array(0)->as_Register(ra_,this)/* dst */;
    __ encode_heap_oop(d, s);
  
#line 16457 "ad_aarch64.cpp"
  }
}

void encodeHeapOop_not_nullNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8042 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ encode_heap_oop_not_null(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 16473 "ad_aarch64.cpp"
  }
}

void decodeHeapOopNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8054 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register s = opnd_array(1)->as_Register(ra_,this,idx1)/* src */;
    Register d = opnd_array(0)->as_Register(ra_,this)/* dst */;
    __ decode_heap_oop(d, s);
  
#line 16491 "ad_aarch64.cpp"
  }
}

void decodeHeapOop_not_nullNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8068 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register s = opnd_array(1)->as_Register(ra_,this,idx1)/* src */;
    Register d = opnd_array(0)->as_Register(ra_,this)/* dst */;
    __ decode_heap_oop_not_null(d, s);
  
#line 16509 "ad_aarch64.cpp"
  }
}

void encodeKlass_not_nullNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8086 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register src_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */);
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    __ encode_klass_not_null(dst_reg, src_reg);
  
#line 16527 "ad_aarch64.cpp"
  }
}

void decodeKlass_not_nullNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8101 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Register src_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */);
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    if (dst_reg != src_reg) {
      __ decode_klass_not_null(dst_reg, src_reg);
    } else {
      __ decode_klass_not_null(dst_reg);
    }
  
#line 16549 "ad_aarch64.cpp"
  }
}

void checkCastPPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  // User did not define which encode class to use.
}

uint checkCastPPNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void castPPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  // User did not define which encode class to use.
}

uint castPPNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void castIINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  // User did not define which encode class to use.
}

uint castIINode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void castLLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  // User did not define which encode class to use.
}

uint castLLNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void castFFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  // User did not define which encode class to use.
}

uint castFFNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void castDDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  // User did not define which encode class to use.
}

uint castDDNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void castVVNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  // User did not define which encode class to use.
}

uint castVVNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void castVVMaskNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  // User did not define which encode class to use.
}

uint castVVMaskNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void compareAndSwapBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 3321 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    guarantee(opnd_array(1)->index(ra_,this,idx1) == -1 && opnd_array(1)->disp(ra_,this,idx1) == 0, "impossible encoding");
    __ cmpxchg(as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::byte, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, noreg);
  
#line 16674 "ad_aarch64.cpp"
  }
  {

#line 3367 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register res_reg = as_Register(opnd_array(0)->reg(ra_,this)/* res */);
    __ cset(res_reg, Assembler::EQ);
  
#line 16684 "ad_aarch64.cpp"
  }
}

void compareAndSwapSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 3313 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    guarantee(opnd_array(1)->index(ra_,this,idx1) == -1 && opnd_array(1)->disp(ra_,this,idx1) == 0, "impossible encoding");
    __ cmpxchg(as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::halfword, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, noreg);
  
#line 16705 "ad_aarch64.cpp"
  }
  {

#line 3367 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register res_reg = as_Register(opnd_array(0)->reg(ra_,this)/* res */);
    __ cset(res_reg, Assembler::EQ);
  
#line 16715 "ad_aarch64.cpp"
  }
}

void compareAndSwapINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 3305 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    guarantee(opnd_array(1)->index(ra_,this,idx1) == -1 && opnd_array(1)->disp(ra_,this,idx1) == 0, "impossible encoding");
    __ cmpxchg(as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::word, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, noreg);
  
#line 16736 "ad_aarch64.cpp"
  }
  {

#line 3367 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register res_reg = as_Register(opnd_array(0)->reg(ra_,this)/* res */);
    __ cset(res_reg, Assembler::EQ);
  
#line 16746 "ad_aarch64.cpp"
  }
}

void compareAndSwapLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 3297 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    guarantee(opnd_array(1)->index(ra_,this,idx1) == -1 && opnd_array(1)->disp(ra_,this,idx1) == 0, "impossible encoding");
    __ cmpxchg(as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::xword, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, noreg);
  
#line 16767 "ad_aarch64.cpp"
  }
  {

#line 3367 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register res_reg = as_Register(opnd_array(0)->reg(ra_,this)/* res */);
    __ cset(res_reg, Assembler::EQ);
  
#line 16777 "ad_aarch64.cpp"
  }
}

void compareAndSwapPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 3297 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    guarantee(opnd_array(1)->index(ra_,this,idx1) == -1 && opnd_array(1)->disp(ra_,this,idx1) == 0, "impossible encoding");
    __ cmpxchg(as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::xword, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, noreg);
  
#line 16798 "ad_aarch64.cpp"
  }
  {

#line 3367 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register res_reg = as_Register(opnd_array(0)->reg(ra_,this)/* res */);
    __ cset(res_reg, Assembler::EQ);
  
#line 16808 "ad_aarch64.cpp"
  }
}

void compareAndSwapNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 3305 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    guarantee(opnd_array(1)->index(ra_,this,idx1) == -1 && opnd_array(1)->disp(ra_,this,idx1) == 0, "impossible encoding");
    __ cmpxchg(as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::word, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, noreg);
  
#line 16829 "ad_aarch64.cpp"
  }
  {

#line 3367 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register res_reg = as_Register(opnd_array(0)->reg(ra_,this)/* res */);
    __ cset(res_reg, Assembler::EQ);
  
#line 16839 "ad_aarch64.cpp"
  }
}

void compareAndSwapBAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 3358 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    guarantee(opnd_array(1)->index(ra_,this,idx1) == -1 && opnd_array(1)->disp(ra_,this,idx1) == 0, "impossible encoding");
    __ cmpxchg(as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::byte, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, noreg);
  
#line 16860 "ad_aarch64.cpp"
  }
  {

#line 3367 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register res_reg = as_Register(opnd_array(0)->reg(ra_,this)/* res */);
    __ cset(res_reg, Assembler::EQ);
  
#line 16870 "ad_aarch64.cpp"
  }
}

void compareAndSwapSAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 3350 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    guarantee(opnd_array(1)->index(ra_,this,idx1) == -1 && opnd_array(1)->disp(ra_,this,idx1) == 0, "impossible encoding");
    __ cmpxchg(as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::halfword, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, noreg);
  
#line 16891 "ad_aarch64.cpp"
  }
  {

#line 3367 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register res_reg = as_Register(opnd_array(0)->reg(ra_,this)/* res */);
    __ cset(res_reg, Assembler::EQ);
  
#line 16901 "ad_aarch64.cpp"
  }
}

void compareAndSwapIAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 3342 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    guarantee(opnd_array(1)->index(ra_,this,idx1) == -1 && opnd_array(1)->disp(ra_,this,idx1) == 0, "impossible encoding");
    __ cmpxchg(as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::word, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, noreg);
  
#line 16922 "ad_aarch64.cpp"
  }
  {

#line 3367 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register res_reg = as_Register(opnd_array(0)->reg(ra_,this)/* res */);
    __ cset(res_reg, Assembler::EQ);
  
#line 16932 "ad_aarch64.cpp"
  }
}

void compareAndSwapLAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 3334 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    guarantee(opnd_array(1)->index(ra_,this,idx1) == -1 && opnd_array(1)->disp(ra_,this,idx1) == 0, "impossible encoding");
    __ cmpxchg(as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::xword, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, noreg);
  
#line 16953 "ad_aarch64.cpp"
  }
  {

#line 3367 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register res_reg = as_Register(opnd_array(0)->reg(ra_,this)/* res */);
    __ cset(res_reg, Assembler::EQ);
  
#line 16963 "ad_aarch64.cpp"
  }
}

void compareAndSwapPAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 3334 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    guarantee(opnd_array(1)->index(ra_,this,idx1) == -1 && opnd_array(1)->disp(ra_,this,idx1) == 0, "impossible encoding");
    __ cmpxchg(as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::xword, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, noreg);
  
#line 16984 "ad_aarch64.cpp"
  }
  {

#line 3367 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register res_reg = as_Register(opnd_array(0)->reg(ra_,this)/* res */);
    __ cset(res_reg, Assembler::EQ);
  
#line 16994 "ad_aarch64.cpp"
  }
}

void compareAndSwapNAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 3342 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    guarantee(opnd_array(1)->index(ra_,this,idx1) == -1 && opnd_array(1)->disp(ra_,this,idx1) == 0, "impossible encoding");
    __ cmpxchg(as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::word, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, noreg);
  
#line 17015 "ad_aarch64.cpp"
  }
  {

#line 3367 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register res_reg = as_Register(opnd_array(0)->reg(ra_,this)/* res */);
    __ cset(res_reg, Assembler::EQ);
  
#line 17025 "ad_aarch64.cpp"
  }
}

void compareAndExchangeBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8459 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::byte, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
    __ sxtbw(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 17047 "ad_aarch64.cpp"
  }
}

void compareAndExchangeSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8477 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::halfword, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
    __ sxthw(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 17069 "ad_aarch64.cpp"
  }
}

void compareAndExchangeINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8495 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::word, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 17090 "ad_aarch64.cpp"
  }
}

void compareAndExchangeLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8512 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::xword, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 17111 "ad_aarch64.cpp"
  }
}

void compareAndExchangeNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8529 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::word, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 17132 "ad_aarch64.cpp"
  }
}

void compareAndExchangePNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8547 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::xword, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 17153 "ad_aarch64.cpp"
  }
}

void compareAndExchangeBAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8565 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::byte, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
    __ sxtbw(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 17175 "ad_aarch64.cpp"
  }
}

void compareAndExchangeSAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8584 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::halfword, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
    __ sxthw(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 17197 "ad_aarch64.cpp"
  }
}

void compareAndExchangeIAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8603 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::word, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 17218 "ad_aarch64.cpp"
  }
}

void compareAndExchangeLAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8621 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::xword, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 17239 "ad_aarch64.cpp"
  }
}

void compareAndExchangeNAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8639 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::word, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 17260 "ad_aarch64.cpp"
  }
}

void compareAndExchangePAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8657 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::xword, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 17281 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8675 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::byte, /*acquire*/ false, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* res */, Assembler::EQ);
  
#line 17302 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8694 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::halfword, /*acquire*/ false, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* res */, Assembler::EQ);
  
#line 17323 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8713 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::word, /*acquire*/ false, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* res */, Assembler::EQ);
  
#line 17344 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8732 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::xword, /*acquire*/ false, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* res */, Assembler::EQ);
  
#line 17365 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8751 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::word, /*acquire*/ false, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* res */, Assembler::EQ);
  
#line 17386 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8771 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::xword, /*acquire*/ false, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* res */, Assembler::EQ);
  
#line 17407 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapBAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8791 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::byte, /*acquire*/ true, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* res */, Assembler::EQ);
  
#line 17428 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapSAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8811 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::halfword, /*acquire*/ true, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* res */, Assembler::EQ);
  
#line 17449 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapIAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8831 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::word, /*acquire*/ true, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* res */, Assembler::EQ);
  
#line 17470 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapLAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8851 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::xword, /*acquire*/ true, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* res */, Assembler::EQ);
  
#line 17491 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapNAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8871 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::word, /*acquire*/ true, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* res */, Assembler::EQ);
  
#line 17512 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapPAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8891 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
               Assembler::xword, /*acquire*/ true, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* res */, Assembler::EQ);
  
#line 17533 "ad_aarch64.cpp"
  }
}

void get_and_setINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8907 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_xchgw(opnd_array(0)->as_Register(ra_,this)/* prev */, opnd_array(2)->as_Register(ra_,this,idx2)/* newv */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17550 "ad_aarch64.cpp"
  }
}

void get_and_setLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8917 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_xchg(opnd_array(0)->as_Register(ra_,this)/* prev */, opnd_array(2)->as_Register(ra_,this,idx2)/* newv */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17567 "ad_aarch64.cpp"
  }
}

void get_and_setNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8927 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_xchgw(opnd_array(0)->as_Register(ra_,this)/* prev */, opnd_array(2)->as_Register(ra_,this,idx2)/* newv */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17584 "ad_aarch64.cpp"
  }
}

void get_and_setPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8938 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_xchg(opnd_array(0)->as_Register(ra_,this)/* prev */, opnd_array(2)->as_Register(ra_,this,idx2)/* newv */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17601 "ad_aarch64.cpp"
  }
}

void get_and_setIAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8949 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_xchgalw(opnd_array(0)->as_Register(ra_,this)/* prev */, opnd_array(2)->as_Register(ra_,this,idx2)/* newv */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17618 "ad_aarch64.cpp"
  }
}

void get_and_setLAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8960 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_xchgal(opnd_array(0)->as_Register(ra_,this)/* prev */, opnd_array(2)->as_Register(ra_,this,idx2)/* newv */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17635 "ad_aarch64.cpp"
  }
}

void get_and_setNAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8971 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_xchgalw(opnd_array(0)->as_Register(ra_,this)/* prev */, opnd_array(2)->as_Register(ra_,this,idx2)/* newv */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17652 "ad_aarch64.cpp"
  }
}

void get_and_setPAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8982 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_xchgal(opnd_array(0)->as_Register(ra_,this)/* prev */, opnd_array(2)->as_Register(ra_,this,idx2)/* newv */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17669 "ad_aarch64.cpp"
  }
}

void get_and_addLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 8993 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_add(opnd_array(0)->as_Register(ra_,this)/* newval */, opnd_array(2)->as_Register(ra_,this,idx2)/* incr */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17686 "ad_aarch64.cpp"
  }
}

void get_and_addL_no_resNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9004 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_add(noreg, opnd_array(2)->as_Register(ra_,this,idx2)/* incr */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17703 "ad_aarch64.cpp"
  }
}

void get_and_addLiNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9014 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_add(opnd_array(0)->as_Register(ra_,this)/* newval */, opnd_array(2)->constantL(), as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17720 "ad_aarch64.cpp"
  }
}

void get_and_addLi_no_resNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9025 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_add(noreg, opnd_array(2)->constantL(), as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17737 "ad_aarch64.cpp"
  }
}

void get_and_addINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9035 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_addw(opnd_array(0)->as_Register(ra_,this)/* newval */, opnd_array(2)->as_Register(ra_,this,idx2)/* incr */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17754 "ad_aarch64.cpp"
  }
}

void get_and_addI_no_resNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9046 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_addw(noreg, opnd_array(2)->as_Register(ra_,this,idx2)/* incr */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17771 "ad_aarch64.cpp"
  }
}

void get_and_addIiNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9056 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_addw(opnd_array(0)->as_Register(ra_,this)/* newval */, opnd_array(2)->constant(), as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17788 "ad_aarch64.cpp"
  }
}

void get_and_addIi_no_resNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9067 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_addw(noreg, opnd_array(2)->constant(), as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17805 "ad_aarch64.cpp"
  }
}

void get_and_addLAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9078 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_addal(opnd_array(0)->as_Register(ra_,this)/* newval */, opnd_array(2)->as_Register(ra_,this,idx2)/* incr */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17822 "ad_aarch64.cpp"
  }
}

void get_and_addL_no_resAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9089 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_addal(noreg, opnd_array(2)->as_Register(ra_,this,idx2)/* incr */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17839 "ad_aarch64.cpp"
  }
}

void get_and_addLiAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9100 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_addal(opnd_array(0)->as_Register(ra_,this)/* newval */, opnd_array(2)->constantL(), as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17856 "ad_aarch64.cpp"
  }
}

void get_and_addLi_no_resAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9111 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_addal(noreg, opnd_array(2)->constantL(), as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17873 "ad_aarch64.cpp"
  }
}

void get_and_addIAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9122 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_addalw(opnd_array(0)->as_Register(ra_,this)/* newval */, opnd_array(2)->as_Register(ra_,this,idx2)/* incr */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17890 "ad_aarch64.cpp"
  }
}

void get_and_addI_no_resAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9133 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_addalw(noreg, opnd_array(2)->as_Register(ra_,this,idx2)/* incr */, as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17907 "ad_aarch64.cpp"
  }
}

void get_and_addIiAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9144 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_addalw(opnd_array(0)->as_Register(ra_,this)/* newval */, opnd_array(2)->constant(), as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17924 "ad_aarch64.cpp"
  }
}

void get_and_addIi_no_resAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9155 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ atomic_addalw(noreg, opnd_array(2)->constant(), as_Register(opnd_array(1)->base(ra_,this,idx1)));
  
#line 17941 "ad_aarch64.cpp"
  }
}

void cmpU3_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9174 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpw(opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* src2 */);
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* dst */, Assembler::NE);
    __ cnegw(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */, Assembler::LO);
  
#line 17960 "ad_aarch64.cpp"
  }
}

void cmpU3_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9194 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ subsw(zr, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */, (int32_t)opnd_array(2)->constant());
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* dst */, Assembler::NE);
    __ cnegw(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */, Assembler::LO);
  
#line 17979 "ad_aarch64.cpp"
  }
}

void cmpUL3_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9216 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmp(opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* src2 */);
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* dst */, Assembler::NE);
    __ cnegw(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */, Assembler::LO);
  
#line 17998 "ad_aarch64.cpp"
  }
}

void cmpUL3_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9236 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ subs(zr, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */, (int32_t)opnd_array(2)->constantL());
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* dst */, Assembler::NE);
    __ cnegw(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */, Assembler::LO);
  
#line 18017 "ad_aarch64.cpp"
  }
}

void cmpL3_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9258 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmp(opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* src2 */);
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* dst */, Assembler::NE);
    __ cnegw(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */, Assembler::LT);
  
#line 18036 "ad_aarch64.cpp"
  }
}

void cmpL3_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9278 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ subs(zr, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */, (int32_t)opnd_array(2)->constantL());
    __ csetw(opnd_array(0)->as_Register(ra_,this)/* dst */, Assembler::NE);
    __ cnegw(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */, Assembler::LT);
  
#line 18055 "ad_aarch64.cpp"
  }
}

void cmovI_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9306 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src2 */),
             as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
             (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18077 "ad_aarch64.cpp"
  }
}

void cmovUI_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9322 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src2 */),
             as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
             (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18099 "ad_aarch64.cpp"
  }
}

void cmovI_zero_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9347 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src */),
             zr,
             (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18121 "ad_aarch64.cpp"
  }
}

void cmovUI_zero_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9363 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src */),
             zr,
             (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18143 "ad_aarch64.cpp"
  }
}

void cmovI_reg_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9379 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             zr,
             as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src */),
             (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18165 "ad_aarch64.cpp"
  }
}

void cmovUI_reg_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9395 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             zr,
             as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src */),
             (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18187 "ad_aarch64.cpp"
  }
}

void cmovI_reg_zero_oneNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// one
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9416 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    // equivalently
    // cset(as_Register($dst$$reg),
    //      negate_condition((Assembler::Condition)$cmp$$cmpcode));
    __ csincw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             zr,
             zr,
             (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18212 "ad_aarch64.cpp"
  }
}

void cmovUI_reg_zero_oneNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// one
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9435 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    // equivalently
    // cset(as_Register($dst$$reg),
    //      negate_condition((Assembler::Condition)$cmp$$cmpcode));
    __ csincw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             zr,
             zr,
             (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18237 "ad_aarch64.cpp"
  }
}

void cmovL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9454 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csel(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src2 */),
            as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
            (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18259 "ad_aarch64.cpp"
  }
}

void cmovUL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9470 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csel(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src2 */),
            as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
            (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18281 "ad_aarch64.cpp"
  }
}

void cmovL_reg_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9488 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csel(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            zr,
            as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src */),
            (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18303 "ad_aarch64.cpp"
  }
}

void cmovUL_reg_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9504 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csel(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            zr,
            as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src */),
            (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18325 "ad_aarch64.cpp"
  }
}

void cmovL_zero_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9520 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csel(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src */),
            zr,
            (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18347 "ad_aarch64.cpp"
  }
}

void cmovUL_zero_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9536 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csel(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src */),
            zr,
            (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18369 "ad_aarch64.cpp"
  }
}

void cmovP_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9552 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csel(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src2 */),
            as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
            (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18391 "ad_aarch64.cpp"
  }
}

void cmovUP_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9568 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csel(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src2 */),
            as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
            (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18413 "ad_aarch64.cpp"
  }
}

void cmovP_reg_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9586 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csel(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            zr,
            as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src */),
            (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18435 "ad_aarch64.cpp"
  }
}

void cmovUP_reg_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9602 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csel(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            zr,
            as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src */),
            (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18457 "ad_aarch64.cpp"
  }
}

void cmovP_zero_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9618 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csel(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src */),
            zr,
            (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18479 "ad_aarch64.cpp"
  }
}

void cmovUP_zero_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9634 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csel(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src */),
            zr,
            (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18501 "ad_aarch64.cpp"
  }
}

void cmovN_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9650 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src2 */),
             as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
             (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18523 "ad_aarch64.cpp"
  }
}

void cmovUN_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9666 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src2 */),
             as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
             (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18545 "ad_aarch64.cpp"
  }
}

void cmovN_reg_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9684 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             zr,
             as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src */),
             (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18567 "ad_aarch64.cpp"
  }
}

void cmovUN_reg_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9700 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             zr,
             as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src */),
             (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18589 "ad_aarch64.cpp"
  }
}

void cmovN_zero_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9716 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src */),
             zr,
             (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18611 "ad_aarch64.cpp"
  }
}

void cmovUN_zero_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9732 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src */),
             zr,
             (Assembler::Condition)opnd_array(1)->ccode());
  
#line 18633 "ad_aarch64.cpp"
  }
}

void cmovF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9749 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    __ fcsels(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
              as_FloatRegister(opnd_array(4)->reg(ra_,this,idx4)/* src2 */),
              as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              cond);
  
#line 18656 "ad_aarch64.cpp"
  }
}

void cmovUF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9767 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    __ fcsels(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
              as_FloatRegister(opnd_array(4)->reg(ra_,this,idx4)/* src2 */),
              as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              cond);
  
#line 18679 "ad_aarch64.cpp"
  }
}

void cmovD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9785 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    __ fcseld(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
              as_FloatRegister(opnd_array(4)->reg(ra_,this,idx4)/* src2 */),
              as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              cond);
  
#line 18702 "ad_aarch64.cpp"
  }
}

void cmovUD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9803 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    __ fcseld(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
              as_FloatRegister(opnd_array(4)->reg(ra_,this,idx4)/* src2 */),
              as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              cond);
  
#line 18725 "ad_aarch64.cpp"
  }
}

void addI_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9832 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 18744 "ad_aarch64.cpp"
  }
}

void addI_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {

#line 3495 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    Register src_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */);
    int32_t con = (int32_t)opnd_array(2)->constant();
    // add has primary == 0, subtract has primary == 1
    if ((0x0 /*primary()*/)) { con = -con; }
    if (con < 0) {
      __ subw(dst_reg, src_reg, -con);
    } else {
      __ addw(dst_reg, src_reg, con);
    }
  
#line 18770 "ad_aarch64.cpp"
  }
}

void addI_reg_imm_i2lNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {

#line 3495 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    Register src_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */);
    int32_t con = (int32_t)opnd_array(2)->constant();
    // add has primary == 0, subtract has primary == 1
    if ((0x0 /*primary()*/)) { con = -con; }
    if (con < 0) {
      __ subw(dst_reg, src_reg, -con);
    } else {
      __ addw(dst_reg, src_reg, con);
    }
  
#line 18796 "ad_aarch64.cpp"
  }
}

void addP_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9876 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
           as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
           as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 18815 "ad_aarch64.cpp"
  }
}

void addP_reg_reg_extNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9891 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
           as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
           as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxtw);
  
#line 18834 "ad_aarch64.cpp"
  }
}

void addP_reg_reg_lslNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// scale
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9906 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ lea(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
           Address(as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */), as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
                   Address::lsl(opnd_array(3)->constant())));
  
#line 18854 "ad_aarch64.cpp"
  }
}

void addP_reg_reg_ext_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// scale
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9921 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ lea(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
           Address(as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */), as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
                   Address::sxtw(opnd_array(3)->constant())));
  
#line 18874 "ad_aarch64.cpp"
  }
}

void lshift_extNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// scale
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9936 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ sbfiz(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
          as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */),
          opnd_array(2)->constant()& 63, MIN2(32, (int)((-opnd_array(2)->constant()) & 63)));
  
#line 18893 "ad_aarch64.cpp"
  }
}

void addP_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {

#line 3509 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    Register src_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */);
    int32_t con = (int32_t)opnd_array(2)->constantL();
    // add has primary == 0, subtract has primary == 1
    if ((0x0 /*primary()*/)) { con = -con; }
    if (con < 0) {
      __ sub(dst_reg, src_reg, -con);
    } else {
      __ add(dst_reg, src_reg, con);
    }
  
#line 18919 "ad_aarch64.cpp"
  }
}

void addL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 9970 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
           as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
           as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 18938 "ad_aarch64.cpp"
  }
}

void addL_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {

#line 3509 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    Register src_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */);
    int32_t con = (int32_t)opnd_array(2)->constantL();
    // add has primary == 0, subtract has primary == 1
    if ((0x0 /*primary()*/)) { con = -con; }
    if (con < 0) {
      __ sub(dst_reg, src_reg, -con);
    } else {
      __ add(dst_reg, src_reg, con);
    }
  
#line 18964 "ad_aarch64.cpp"
  }
}

void subI_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10001 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ subw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 18983 "ad_aarch64.cpp"
  }
}

void subI_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {

#line 3495 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    Register src_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */);
    int32_t con = (int32_t)opnd_array(2)->constant();
    // add has primary == 0, subtract has primary == 1
    if ((0x1 /*primary()*/)) { con = -con; }
    if (con < 0) {
      __ subw(dst_reg, src_reg, -con);
    } else {
      __ addw(dst_reg, src_reg, con);
    }
  
#line 19009 "ad_aarch64.cpp"
  }
}

void subL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10033 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ sub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
           as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
           as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 19028 "ad_aarch64.cpp"
  }
}

void subL_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {

#line 3509 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    Register src_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */);
    int32_t con = (int32_t)opnd_array(2)->constantL();
    // add has primary == 0, subtract has primary == 1
    if ((0x1 /*primary()*/)) { con = -con; }
    if (con < 0) {
      __ sub(dst_reg, src_reg, -con);
    } else {
      __ add(dst_reg, src_reg, con);
    }
  
#line 19054 "ad_aarch64.cpp"
  }
}

void negI_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10065 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ negw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src */));
  
#line 19072 "ad_aarch64.cpp"
  }
}

void negL_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10081 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ neg(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
           as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src */));
  
#line 19090 "ad_aarch64.cpp"
  }
}

void mulINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10097 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ mulw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 19109 "ad_aarch64.cpp"
  }
}

void smulINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10112 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ smull(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 19128 "ad_aarch64.cpp"
  }
}

void smulI_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10112 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ smull(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
             as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */));
  
#line 19147 "ad_aarch64.cpp"
  }
}

void mulLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10129 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ mul(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
           as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
           as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 19166 "ad_aarch64.cpp"
  }
}

void mulHiL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10145 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ smulh(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 19185 "ad_aarch64.cpp"
  }
}

void umulHiL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10161 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ umulh(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 19204 "ad_aarch64.cpp"
  }
}

void maddINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10178 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ maddw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
             as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
             as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 19225 "ad_aarch64.cpp"
  }
}

void maddI_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10178 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ maddw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
             as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src3 */));
  
#line 19246 "ad_aarch64.cpp"
  }
}

void msubINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10194 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ msubw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
             as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
             as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 19267 "ad_aarch64.cpp"
  }
}

void mnegINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10212 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ mnegw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
             as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */));
  
#line 19287 "ad_aarch64.cpp"
  }
}

void mnegI_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10212 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ mnegw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
             as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */));
  
#line 19307 "ad_aarch64.cpp"
  }
}

void maddLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10229 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ madd(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
            as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 19328 "ad_aarch64.cpp"
  }
}

void maddL_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10229 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ madd(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
            as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src3 */));
  
#line 19349 "ad_aarch64.cpp"
  }
}

void msubLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10245 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ msub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
            as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 19370 "ad_aarch64.cpp"
  }
}

void mnegLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10263 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ mneg(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
            as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */));
  
#line 19390 "ad_aarch64.cpp"
  }
}

void mnegL_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10263 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ mneg(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */));
  
#line 19410 "ad_aarch64.cpp"
  }
}

void smaddLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10280 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ smaddl(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 19431 "ad_aarch64.cpp"
  }
}

void smaddL_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10280 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ smaddl(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src3 */));
  
#line 19452 "ad_aarch64.cpp"
  }
}

void smaddL_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10280 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ smaddl(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 19473 "ad_aarch64.cpp"
  }
}

void smaddL_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10280 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ smaddl(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src3 */));
  
#line 19494 "ad_aarch64.cpp"
  }
}

void smsubLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10296 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ smsubl(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 19515 "ad_aarch64.cpp"
  }
}

void smsubL_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10296 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ smsubl(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 19536 "ad_aarch64.cpp"
  }
}

void smnegLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10312 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ smnegl(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */));
  
#line 19556 "ad_aarch64.cpp"
  }
}

void smnegL_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10312 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ smnegl(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */));
  
#line 19576 "ad_aarch64.cpp"
  }
}

void muladdS2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10330 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ mulw(rscratch1, as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */), as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
    __ maddw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src3 */), as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src4 */), rscratch1); 
#line 19595 "ad_aarch64.cpp"
  }
}

void divINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {

#line 3523 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
   Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
   Register src1_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */);
   Register src2_reg = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */);
    __ corrected_idivl(dst_reg, src1_reg, src2_reg, false, rscratch1);
  
#line 19615 "ad_aarch64.cpp"
  }
}

void divLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {

#line 3531 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
   Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
   Register src1_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */);
   Register src2_reg = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */);
    __ corrected_idivq(dst_reg, src1_reg, src2_reg, false, rscratch1);
  
#line 19635 "ad_aarch64.cpp"
  }
}

void modINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {

#line 3539 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
   Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
   Register src1_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */);
   Register src2_reg = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */);
    __ corrected_idivl(dst_reg, src1_reg, src2_reg, true, rscratch1);
  
#line 19655 "ad_aarch64.cpp"
  }
}

void modLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {

#line 3547 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
   Register dst_reg = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
   Register src1_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */);
   Register src2_reg = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */);
    __ corrected_idivq(dst_reg, src1_reg, src2_reg, true, rscratch1);
  
#line 19675 "ad_aarch64.cpp"
  }
}

void UdivI_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10395 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ udivw(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* src2 */);
  
#line 19692 "ad_aarch64.cpp"
  }
}

void UdivL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10410 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ udiv(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* src2 */);
  
#line 19709 "ad_aarch64.cpp"
  }
}

void UmodI_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10426 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ udivw(rscratch1, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* src2 */);
    __ msubw(opnd_array(0)->as_Register(ra_,this)/* dst */, rscratch1, opnd_array(2)->as_Register(ra_,this,idx2)/* src2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
  
#line 19727 "ad_aarch64.cpp"
  }
}

void UModL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10443 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ udiv(rscratch1, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* src2 */);
    __ msub(opnd_array(0)->as_Register(ra_,this)/* dst */, rscratch1, opnd_array(2)->as_Register(ra_,this,idx2)/* src2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
  
#line 19745 "ad_aarch64.cpp"
  }
}

void lShiftI_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10460 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ lslvw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 19764 "ad_aarch64.cpp"
  }
}

void lShiftI_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10476 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ lslw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            opnd_array(2)->constant()& 0x1f);
  
#line 19783 "ad_aarch64.cpp"
  }
}

void urShiftI_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10492 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ lsrvw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 19802 "ad_aarch64.cpp"
  }
}

void urShiftI_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10508 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ lsrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            opnd_array(2)->constant()& 0x1f);
  
#line 19821 "ad_aarch64.cpp"
  }
}

void rShiftI_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10524 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ asrvw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 19840 "ad_aarch64.cpp"
  }
}

void rShiftI_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10540 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ asrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            opnd_array(2)->constant()& 0x1f);
  
#line 19859 "ad_aarch64.cpp"
  }
}

void lShiftL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10561 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ lslv(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 19878 "ad_aarch64.cpp"
  }
}

void lShiftL_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10577 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ lsl(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            opnd_array(2)->constant()& 0x3f);
  
#line 19897 "ad_aarch64.cpp"
  }
}

void urShiftL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10593 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ lsrv(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 19916 "ad_aarch64.cpp"
  }
}

void urShiftL_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10609 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ lsr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
           as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
           opnd_array(2)->constant()& 0x3f);
  
#line 19935 "ad_aarch64.cpp"
  }
}

void urShiftP_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10625 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ lsr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
           as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
           opnd_array(2)->constant()& 0x3f);
  
#line 19954 "ad_aarch64.cpp"
  }
}

void rShiftL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10641 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ asrv(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 19973 "ad_aarch64.cpp"
  }
}

void rShiftL_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10657 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ asr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
           as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
           opnd_array(2)->constant()& 0x3f);
  
#line 19992 "ad_aarch64.cpp"
  }
}

void regL_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10678 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              zr,
              Assembler::LSL, 0);
  
#line 20012 "ad_aarch64.cpp"
  }
}

void regI_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10697 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              zr,
              Assembler::LSL, 0);
  
#line 20032 "ad_aarch64.cpp"
  }
}

void NegI_reg_URShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10716 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ negw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
            Assembler::LSR, opnd_array(3)->constant()& 0x1f);
  
#line 20051 "ad_aarch64.cpp"
  }
}

void NegI_reg_RShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10733 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ negw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
            Assembler::ASR, opnd_array(3)->constant()& 0x1f);
  
#line 20070 "ad_aarch64.cpp"
  }
}

void NegI_reg_LShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10750 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ negw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
            Assembler::LSL, opnd_array(3)->constant()& 0x1f);
  
#line 20089 "ad_aarch64.cpp"
  }
}

void NegL_reg_URShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10767 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ neg(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
            Assembler::LSR, opnd_array(3)->constant()& 0x3f);
  
#line 20108 "ad_aarch64.cpp"
  }
}

void NegL_reg_RShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10784 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ neg(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
            Assembler::ASR, opnd_array(3)->constant()& 0x3f);
  
#line 20127 "ad_aarch64.cpp"
  }
}

void NegL_reg_LShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10801 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ neg(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
            Assembler::LSL, opnd_array(3)->constant()& 0x3f);
  
#line 20146 "ad_aarch64.cpp"
  }
}

void AndI_reg_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10817 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bicw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL, 0);
  
#line 20167 "ad_aarch64.cpp"
  }
}

void AndI_reg_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10817 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bicw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL, 0);
  
#line 20188 "ad_aarch64.cpp"
  }
}

void AndL_reg_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10835 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bic(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL, 0);
  
#line 20209 "ad_aarch64.cpp"
  }
}

void AndL_reg_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10835 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bic(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL, 0);
  
#line 20230 "ad_aarch64.cpp"
  }
}

void OrI_reg_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10853 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ornw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL, 0);
  
#line 20251 "ad_aarch64.cpp"
  }
}

void OrI_reg_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10853 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ornw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL, 0);
  
#line 20272 "ad_aarch64.cpp"
  }
}

void OrL_reg_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10871 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orn(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL, 0);
  
#line 20293 "ad_aarch64.cpp"
  }
}

void OrL_reg_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10871 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orn(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL, 0);
  
#line 20314 "ad_aarch64.cpp"
  }
}

void XorI_reg_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10889 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL, 0);
  
#line 20335 "ad_aarch64.cpp"
  }
}

void XorI_reg_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10889 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL, 0);
  
#line 20356 "ad_aarch64.cpp"
  }
}

void XorL_reg_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10907 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL, 0);
  
#line 20377 "ad_aarch64.cpp"
  }
}

void XorL_reg_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10907 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL, 0);
  
#line 20398 "ad_aarch64.cpp"
  }
}

void AndI_reg_URShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10927 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bicw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x1f);
  
#line 20421 "ad_aarch64.cpp"
  }
}

void AndI_reg_URShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10927 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bicw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSR,
              opnd_array(2)->constant()& 0x1f);
  
#line 20444 "ad_aarch64.cpp"
  }
}

void AndL_reg_URShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10948 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bic(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x3f);
  
#line 20467 "ad_aarch64.cpp"
  }
}

void AndL_reg_URShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10948 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bic(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSR,
              opnd_array(2)->constant()& 0x3f);
  
#line 20490 "ad_aarch64.cpp"
  }
}

void AndI_reg_RShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10969 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bicw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x1f);
  
#line 20513 "ad_aarch64.cpp"
  }
}

void AndI_reg_RShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10969 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bicw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ASR,
              opnd_array(2)->constant()& 0x1f);
  
#line 20536 "ad_aarch64.cpp"
  }
}

void AndL_reg_RShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10990 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bic(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x3f);
  
#line 20559 "ad_aarch64.cpp"
  }
}

void AndL_reg_RShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 10990 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bic(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ASR,
              opnd_array(2)->constant()& 0x3f);
  
#line 20582 "ad_aarch64.cpp"
  }
}

void AndI_reg_RotateRight_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11011 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bicw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ROR,
              opnd_array(3)->constant()& 0x1f);
  
#line 20605 "ad_aarch64.cpp"
  }
}

void AndI_reg_RotateRight_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11011 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bicw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ROR,
              opnd_array(2)->constant()& 0x1f);
  
#line 20628 "ad_aarch64.cpp"
  }
}

void AndL_reg_RotateRight_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11032 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bic(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ROR,
              opnd_array(3)->constant()& 0x3f);
  
#line 20651 "ad_aarch64.cpp"
  }
}

void AndL_reg_RotateRight_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11032 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bic(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ROR,
              opnd_array(2)->constant()& 0x3f);
  
#line 20674 "ad_aarch64.cpp"
  }
}

void AndI_reg_LShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11053 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bicw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x1f);
  
#line 20697 "ad_aarch64.cpp"
  }
}

void AndI_reg_LShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11053 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bicw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL,
              opnd_array(2)->constant()& 0x1f);
  
#line 20720 "ad_aarch64.cpp"
  }
}

void AndL_reg_LShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11074 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bic(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x3f);
  
#line 20743 "ad_aarch64.cpp"
  }
}

void AndL_reg_LShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11074 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ bic(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL,
              opnd_array(2)->constant()& 0x3f);
  
#line 20766 "ad_aarch64.cpp"
  }
}

void XorI_reg_URShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11095 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x1f);
  
#line 20789 "ad_aarch64.cpp"
  }
}

void XorI_reg_URShift_not_reg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11095 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSR,
              opnd_array(2)->constant()& 0x1f);
  
#line 20812 "ad_aarch64.cpp"
  }
}

void XorI_reg_URShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11095 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
              Assembler::LSR,
              opnd_array(4)->constant()& 0x1f);
  
#line 20835 "ad_aarch64.cpp"
  }
}

void XorI_reg_URShift_not_reg_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11095 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x1f);
  
#line 20858 "ad_aarch64.cpp"
  }
}

void XorL_reg_URShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11116 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x3f);
  
#line 20881 "ad_aarch64.cpp"
  }
}

void XorL_reg_URShift_not_reg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11116 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSR,
              opnd_array(2)->constant()& 0x3f);
  
#line 20904 "ad_aarch64.cpp"
  }
}

void XorL_reg_URShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11116 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
              Assembler::LSR,
              opnd_array(4)->constant()& 0x3f);
  
#line 20927 "ad_aarch64.cpp"
  }
}

void XorL_reg_URShift_not_reg_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11116 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x3f);
  
#line 20950 "ad_aarch64.cpp"
  }
}

void XorI_reg_RShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11137 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x1f);
  
#line 20973 "ad_aarch64.cpp"
  }
}

void XorI_reg_RShift_not_reg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11137 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ASR,
              opnd_array(2)->constant()& 0x1f);
  
#line 20996 "ad_aarch64.cpp"
  }
}

void XorI_reg_RShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11137 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
              Assembler::ASR,
              opnd_array(4)->constant()& 0x1f);
  
#line 21019 "ad_aarch64.cpp"
  }
}

void XorI_reg_RShift_not_reg_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11137 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x1f);
  
#line 21042 "ad_aarch64.cpp"
  }
}

void XorL_reg_RShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11158 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x3f);
  
#line 21065 "ad_aarch64.cpp"
  }
}

void XorL_reg_RShift_not_reg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11158 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ASR,
              opnd_array(2)->constant()& 0x3f);
  
#line 21088 "ad_aarch64.cpp"
  }
}

void XorL_reg_RShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11158 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
              Assembler::ASR,
              opnd_array(4)->constant()& 0x3f);
  
#line 21111 "ad_aarch64.cpp"
  }
}

void XorL_reg_RShift_not_reg_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11158 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x3f);
  
#line 21134 "ad_aarch64.cpp"
  }
}

void XorI_reg_RotateRight_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11179 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ROR,
              opnd_array(3)->constant()& 0x1f);
  
#line 21157 "ad_aarch64.cpp"
  }
}

void XorI_reg_RotateRight_not_reg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11179 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ROR,
              opnd_array(2)->constant()& 0x1f);
  
#line 21180 "ad_aarch64.cpp"
  }
}

void XorI_reg_RotateRight_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11179 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
              Assembler::ROR,
              opnd_array(4)->constant()& 0x1f);
  
#line 21203 "ad_aarch64.cpp"
  }
}

void XorI_reg_RotateRight_not_reg_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11179 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ROR,
              opnd_array(3)->constant()& 0x1f);
  
#line 21226 "ad_aarch64.cpp"
  }
}

void XorL_reg_RotateRight_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11200 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ROR,
              opnd_array(3)->constant()& 0x3f);
  
#line 21249 "ad_aarch64.cpp"
  }
}

void XorL_reg_RotateRight_not_reg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11200 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ROR,
              opnd_array(2)->constant()& 0x3f);
  
#line 21272 "ad_aarch64.cpp"
  }
}

void XorL_reg_RotateRight_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11200 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
              Assembler::ROR,
              opnd_array(4)->constant()& 0x3f);
  
#line 21295 "ad_aarch64.cpp"
  }
}

void XorL_reg_RotateRight_not_reg_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11200 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ROR,
              opnd_array(3)->constant()& 0x3f);
  
#line 21318 "ad_aarch64.cpp"
  }
}

void XorI_reg_LShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11221 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x1f);
  
#line 21341 "ad_aarch64.cpp"
  }
}

void XorI_reg_LShift_not_reg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11221 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL,
              opnd_array(2)->constant()& 0x1f);
  
#line 21364 "ad_aarch64.cpp"
  }
}

void XorI_reg_LShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11221 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
              Assembler::LSL,
              opnd_array(4)->constant()& 0x1f);
  
#line 21387 "ad_aarch64.cpp"
  }
}

void XorI_reg_LShift_not_reg_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11221 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eonw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x1f);
  
#line 21410 "ad_aarch64.cpp"
  }
}

void XorL_reg_LShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11242 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x3f);
  
#line 21433 "ad_aarch64.cpp"
  }
}

void XorL_reg_LShift_not_reg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11242 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL,
              opnd_array(2)->constant()& 0x3f);
  
#line 21456 "ad_aarch64.cpp"
  }
}

void XorL_reg_LShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11242 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
              Assembler::LSL,
              opnd_array(4)->constant()& 0x3f);
  
#line 21479 "ad_aarch64.cpp"
  }
}

void XorL_reg_LShift_not_reg_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11242 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eon(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x3f);
  
#line 21502 "ad_aarch64.cpp"
  }
}

void OrI_reg_URShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11263 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ornw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x1f);
  
#line 21525 "ad_aarch64.cpp"
  }
}

void OrI_reg_URShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11263 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ornw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSR,
              opnd_array(2)->constant()& 0x1f);
  
#line 21548 "ad_aarch64.cpp"
  }
}

void OrL_reg_URShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11284 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orn(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x3f);
  
#line 21571 "ad_aarch64.cpp"
  }
}

void OrL_reg_URShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11284 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orn(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSR,
              opnd_array(2)->constant()& 0x3f);
  
#line 21594 "ad_aarch64.cpp"
  }
}

void OrI_reg_RShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11305 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ornw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x1f);
  
#line 21617 "ad_aarch64.cpp"
  }
}

void OrI_reg_RShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11305 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ornw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ASR,
              opnd_array(2)->constant()& 0x1f);
  
#line 21640 "ad_aarch64.cpp"
  }
}

void OrL_reg_RShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11326 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orn(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x3f);
  
#line 21663 "ad_aarch64.cpp"
  }
}

void OrL_reg_RShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11326 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orn(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ASR,
              opnd_array(2)->constant()& 0x3f);
  
#line 21686 "ad_aarch64.cpp"
  }
}

void OrI_reg_RotateRight_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11347 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ornw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ROR,
              opnd_array(3)->constant()& 0x1f);
  
#line 21709 "ad_aarch64.cpp"
  }
}

void OrI_reg_RotateRight_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11347 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ornw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ROR,
              opnd_array(2)->constant()& 0x1f);
  
#line 21732 "ad_aarch64.cpp"
  }
}

void OrL_reg_RotateRight_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11368 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orn(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ROR,
              opnd_array(3)->constant()& 0x3f);
  
#line 21755 "ad_aarch64.cpp"
  }
}

void OrL_reg_RotateRight_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11368 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orn(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ROR,
              opnd_array(2)->constant()& 0x3f);
  
#line 21778 "ad_aarch64.cpp"
  }
}

void OrI_reg_LShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11389 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ornw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x1f);
  
#line 21801 "ad_aarch64.cpp"
  }
}

void OrI_reg_LShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11389 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ornw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL,
              opnd_array(2)->constant()& 0x1f);
  
#line 21824 "ad_aarch64.cpp"
  }
}

void OrL_reg_LShift_not_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11410 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orn(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x3f);
  
#line 21847 "ad_aarch64.cpp"
  }
}

void OrL_reg_LShift_not_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11410 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orn(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL,
              opnd_array(2)->constant()& 0x3f);
  
#line 21870 "ad_aarch64.cpp"
  }
}

void AndI_reg_URShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11431 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x1f);
  
#line 21892 "ad_aarch64.cpp"
  }
}

void AndI_reg_URShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11431 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSR,
              opnd_array(2)->constant()& 0x1f);
  
#line 21914 "ad_aarch64.cpp"
  }
}

void AndL_reg_URShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11452 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x3f);
  
#line 21936 "ad_aarch64.cpp"
  }
}

void AndL_reg_URShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11452 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSR,
              opnd_array(2)->constant()& 0x3f);
  
#line 21958 "ad_aarch64.cpp"
  }
}

void AndI_reg_RShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11473 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x1f);
  
#line 21980 "ad_aarch64.cpp"
  }
}

void AndI_reg_RShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11473 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ASR,
              opnd_array(2)->constant()& 0x1f);
  
#line 22002 "ad_aarch64.cpp"
  }
}

void AndL_reg_RShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11494 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x3f);
  
#line 22024 "ad_aarch64.cpp"
  }
}

void AndL_reg_RShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11494 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ASR,
              opnd_array(2)->constant()& 0x3f);
  
#line 22046 "ad_aarch64.cpp"
  }
}

void AndI_reg_LShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11515 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x1f);
  
#line 22068 "ad_aarch64.cpp"
  }
}

void AndI_reg_LShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11515 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL,
              opnd_array(2)->constant()& 0x1f);
  
#line 22090 "ad_aarch64.cpp"
  }
}

void AndL_reg_LShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11536 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x3f);
  
#line 22112 "ad_aarch64.cpp"
  }
}

void AndL_reg_LShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11536 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL,
              opnd_array(2)->constant()& 0x3f);
  
#line 22134 "ad_aarch64.cpp"
  }
}

void AndI_reg_RotateRight_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11557 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ROR,
              opnd_array(3)->constant()& 0x1f);
  
#line 22156 "ad_aarch64.cpp"
  }
}

void AndI_reg_RotateRight_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11557 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ROR,
              opnd_array(2)->constant()& 0x1f);
  
#line 22178 "ad_aarch64.cpp"
  }
}

void AndL_reg_RotateRight_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11578 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ROR,
              opnd_array(3)->constant()& 0x3f);
  
#line 22200 "ad_aarch64.cpp"
  }
}

void AndL_reg_RotateRight_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11578 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ROR,
              opnd_array(2)->constant()& 0x3f);
  
#line 22222 "ad_aarch64.cpp"
  }
}

void XorI_reg_URShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11599 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eorw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x1f);
  
#line 22244 "ad_aarch64.cpp"
  }
}

void XorI_reg_URShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11599 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eorw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSR,
              opnd_array(2)->constant()& 0x1f);
  
#line 22266 "ad_aarch64.cpp"
  }
}

void XorL_reg_URShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11620 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eor(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x3f);
  
#line 22288 "ad_aarch64.cpp"
  }
}

void XorL_reg_URShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11620 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eor(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSR,
              opnd_array(2)->constant()& 0x3f);
  
#line 22310 "ad_aarch64.cpp"
  }
}

void XorI_reg_RShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11641 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eorw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x1f);
  
#line 22332 "ad_aarch64.cpp"
  }
}

void XorI_reg_RShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11641 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eorw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ASR,
              opnd_array(2)->constant()& 0x1f);
  
#line 22354 "ad_aarch64.cpp"
  }
}

void XorL_reg_RShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11662 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eor(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x3f);
  
#line 22376 "ad_aarch64.cpp"
  }
}

void XorL_reg_RShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11662 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eor(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ASR,
              opnd_array(2)->constant()& 0x3f);
  
#line 22398 "ad_aarch64.cpp"
  }
}

void XorI_reg_LShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11683 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eorw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x1f);
  
#line 22420 "ad_aarch64.cpp"
  }
}

void XorI_reg_LShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11683 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eorw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL,
              opnd_array(2)->constant()& 0x1f);
  
#line 22442 "ad_aarch64.cpp"
  }
}

void XorL_reg_LShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11704 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eor(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x3f);
  
#line 22464 "ad_aarch64.cpp"
  }
}

void XorL_reg_LShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11704 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eor(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL,
              opnd_array(2)->constant()& 0x3f);
  
#line 22486 "ad_aarch64.cpp"
  }
}

void XorI_reg_RotateRight_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11725 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eorw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ROR,
              opnd_array(3)->constant()& 0x1f);
  
#line 22508 "ad_aarch64.cpp"
  }
}

void XorI_reg_RotateRight_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11725 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eorw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ROR,
              opnd_array(2)->constant()& 0x1f);
  
#line 22530 "ad_aarch64.cpp"
  }
}

void XorL_reg_RotateRight_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11746 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eor(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ROR,
              opnd_array(3)->constant()& 0x3f);
  
#line 22552 "ad_aarch64.cpp"
  }
}

void XorL_reg_RotateRight_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11746 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eor(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ROR,
              opnd_array(2)->constant()& 0x3f);
  
#line 22574 "ad_aarch64.cpp"
  }
}

void OrI_reg_URShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11767 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x1f);
  
#line 22596 "ad_aarch64.cpp"
  }
}

void OrI_reg_URShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11767 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSR,
              opnd_array(2)->constant()& 0x1f);
  
#line 22618 "ad_aarch64.cpp"
  }
}

void OrL_reg_URShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11788 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x3f);
  
#line 22640 "ad_aarch64.cpp"
  }
}

void OrL_reg_URShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11788 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSR,
              opnd_array(2)->constant()& 0x3f);
  
#line 22662 "ad_aarch64.cpp"
  }
}

void OrI_reg_RShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11809 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x1f);
  
#line 22684 "ad_aarch64.cpp"
  }
}

void OrI_reg_RShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11809 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ASR,
              opnd_array(2)->constant()& 0x1f);
  
#line 22706 "ad_aarch64.cpp"
  }
}

void OrL_reg_RShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11830 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x3f);
  
#line 22728 "ad_aarch64.cpp"
  }
}

void OrL_reg_RShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11830 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ASR,
              opnd_array(2)->constant()& 0x3f);
  
#line 22750 "ad_aarch64.cpp"
  }
}

void OrI_reg_LShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11851 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x1f);
  
#line 22772 "ad_aarch64.cpp"
  }
}

void OrI_reg_LShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11851 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL,
              opnd_array(2)->constant()& 0x1f);
  
#line 22794 "ad_aarch64.cpp"
  }
}

void OrL_reg_LShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11872 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x3f);
  
#line 22816 "ad_aarch64.cpp"
  }
}

void OrL_reg_LShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11872 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL,
              opnd_array(2)->constant()& 0x3f);
  
#line 22838 "ad_aarch64.cpp"
  }
}

void OrI_reg_RotateRight_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11893 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ROR,
              opnd_array(3)->constant()& 0x1f);
  
#line 22860 "ad_aarch64.cpp"
  }
}

void OrI_reg_RotateRight_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11893 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ROR,
              opnd_array(2)->constant()& 0x1f);
  
#line 22882 "ad_aarch64.cpp"
  }
}

void OrL_reg_RotateRight_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11914 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ROR,
              opnd_array(3)->constant()& 0x3f);
  
#line 22904 "ad_aarch64.cpp"
  }
}

void OrL_reg_RotateRight_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11914 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ROR,
              opnd_array(2)->constant()& 0x3f);
  
#line 22926 "ad_aarch64.cpp"
  }
}

void AddI_reg_URShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11935 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x1f);
  
#line 22948 "ad_aarch64.cpp"
  }
}

void AddI_reg_URShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11935 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSR,
              opnd_array(2)->constant()& 0x1f);
  
#line 22970 "ad_aarch64.cpp"
  }
}

void AddL_reg_URShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11956 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x3f);
  
#line 22992 "ad_aarch64.cpp"
  }
}

void AddL_reg_URShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11956 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSR,
              opnd_array(2)->constant()& 0x3f);
  
#line 23014 "ad_aarch64.cpp"
  }
}

void AddI_reg_RShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11977 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x1f);
  
#line 23036 "ad_aarch64.cpp"
  }
}

void AddI_reg_RShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11977 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ASR,
              opnd_array(2)->constant()& 0x1f);
  
#line 23058 "ad_aarch64.cpp"
  }
}

void AddL_reg_RShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11998 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x3f);
  
#line 23080 "ad_aarch64.cpp"
  }
}

void AddL_reg_RShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 11998 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::ASR,
              opnd_array(2)->constant()& 0x3f);
  
#line 23102 "ad_aarch64.cpp"
  }
}

void AddI_reg_LShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12019 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x1f);
  
#line 23124 "ad_aarch64.cpp"
  }
}

void AddI_reg_LShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12019 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL,
              opnd_array(2)->constant()& 0x1f);
  
#line 23146 "ad_aarch64.cpp"
  }
}

void AddL_reg_LShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12040 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x3f);
  
#line 23168 "ad_aarch64.cpp"
  }
}

void AddL_reg_LShift_reg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12040 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
              Assembler::LSL,
              opnd_array(2)->constant()& 0x3f);
  
#line 23190 "ad_aarch64.cpp"
  }
}

void SubI_reg_URShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12061 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ subw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x1f);
  
#line 23212 "ad_aarch64.cpp"
  }
}

void SubL_reg_URShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12082 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ sub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSR,
              opnd_array(3)->constant()& 0x3f);
  
#line 23234 "ad_aarch64.cpp"
  }
}

void SubI_reg_RShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12103 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ subw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x1f);
  
#line 23256 "ad_aarch64.cpp"
  }
}

void SubL_reg_RShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12124 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ sub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::ASR,
              opnd_array(3)->constant()& 0x3f);
  
#line 23278 "ad_aarch64.cpp"
  }
}

void SubI_reg_LShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12145 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ subw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x1f);
  
#line 23300 "ad_aarch64.cpp"
  }
}

void SubL_reg_LShift_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12166 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ sub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
              as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
              as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
              Assembler::LSL,
              opnd_array(3)->constant()& 0x3f);
  
#line 23322 "ad_aarch64.cpp"
  }
}

void sbfmLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift_count
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift_count
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12187 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int lshift = opnd_array(2)->constant()& 63;
    int rshift = opnd_array(3)->constant()& 63;
    int s = 63 - lshift;
    int r = (rshift - lshift) & 63;
    __ sbfm(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */),
            r, s);
  
#line 23346 "ad_aarch64.cpp"
  }
}

void sbfmwINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift_count
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift_count
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12210 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int lshift = opnd_array(2)->constant()& 31;
    int rshift = opnd_array(3)->constant()& 31;
    int s = 31 - lshift;
    int r = (rshift - lshift) & 31;
    __ sbfmw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */),
            r, s);
  
#line 23370 "ad_aarch64.cpp"
  }
}

void ubfmLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift_count
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift_count
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12233 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int lshift = opnd_array(2)->constant()& 63;
    int rshift = opnd_array(3)->constant()& 63;
    int s = 63 - lshift;
    int r = (rshift - lshift) & 63;
    __ ubfm(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */),
            r, s);
  
#line 23394 "ad_aarch64.cpp"
  }
}

void ubfmwINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift_count
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift_count
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12256 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int lshift = opnd_array(2)->constant()& 31;
    int rshift = opnd_array(3)->constant()& 31;
    int s = 31 - lshift;
    int r = (rshift - lshift) & 31;
    __ ubfmw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */),
            r, s);
  
#line 23418 "ad_aarch64.cpp"
  }
}

void ubfxwINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12281 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int rshift = opnd_array(2)->constant()& 31;
    intptr_t mask = opnd_array(3)->constant();
    int width = exact_log2(mask+1);
    __ ubfxw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), rshift, width);
  
#line 23440 "ad_aarch64.cpp"
  }
}

void ubfxLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12301 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int rshift = opnd_array(2)->constant()& 63;
    intptr_t mask = opnd_array(3)->constantL();
    int width = exact_log2_long(mask+1);
    __ ubfx(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), rshift, width);
  
#line 23462 "ad_aarch64.cpp"
  }
}

void ubfxIConvI2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12325 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int rshift = opnd_array(2)->constant()& 31;
    intptr_t mask = opnd_array(3)->constant();
    int width = exact_log2(mask+1);
    __ ubfx(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), rshift, width);
  
#line 23484 "ad_aarch64.cpp"
  }
}

void ubfizwINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12348 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int lshift = opnd_array(3)->constant()& 31;
    intptr_t mask = opnd_array(2)->constant();
    int width = exact_log2(mask+1);
    __ ubfizw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
          as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), lshift, width);
  
#line 23506 "ad_aarch64.cpp"
  }
}

void ubfizLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12370 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int lshift = opnd_array(3)->constant()& 63;
    intptr_t mask = opnd_array(2)->constantL();
    int width = exact_log2_long(mask+1);
    __ ubfiz(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
          as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), lshift, width);
  
#line 23528 "ad_aarch64.cpp"
  }
}

void ubfizwIConvI2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12392 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int lshift = opnd_array(3)->constant()& 31;
    intptr_t mask = opnd_array(2)->constant();
    int width = exact_log2(mask+1);
    __ ubfizw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
          as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), lshift, width);
  
#line 23550 "ad_aarch64.cpp"
  }
}

void ubfizLConvL2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12414 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int lshift = opnd_array(3)->constant()& 63;
    intptr_t mask = opnd_array(2)->constantL();
    int width = exact_log2_long(mask+1);
    __ ubfiz(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
          as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), lshift, width);
  
#line 23572 "ad_aarch64.cpp"
  }
}

void ubfizIConvI2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12436 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int lshift = opnd_array(3)->constant()& 63;
    intptr_t mask = opnd_array(2)->constant();
    int width = exact_log2(mask+1);
    __ ubfiz(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), lshift, width);
  
#line 23594 "ad_aarch64.cpp"
  }
}

void ubfizLConvL2IxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12457 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int lshift = opnd_array(3)->constant()& 31;
    intptr_t mask = opnd_array(2)->constantL();
    int width = exact_log2(mask+1);
    __ ubfiz(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
             as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), lshift, width);
  
#line 23616 "ad_aarch64.cpp"
  }
}

void ubfizIConvI2LAndINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// msk
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12476 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ubfiz(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), 0, exact_log2(opnd_array(2)->constant()+ 1));
  
#line 23633 "ad_aarch64.cpp"
  }
}

void extrOrLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12495 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ extr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */), as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
            opnd_array(4)->constant()& 63);
  
#line 23653 "ad_aarch64.cpp"
  }
}

void extrOrL_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12495 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ extr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
            opnd_array(2)->constant()& 63);
  
#line 23673 "ad_aarch64.cpp"
  }
}

void extrOrINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12513 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ extrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */), as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
            opnd_array(4)->constant()& 31);
  
#line 23693 "ad_aarch64.cpp"
  }
}

void extrOrI_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12513 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ extrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
            opnd_array(2)->constant()& 31);
  
#line 23713 "ad_aarch64.cpp"
  }
}

void extrAddLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12531 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ extr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */), as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
            opnd_array(4)->constant()& 63);
  
#line 23733 "ad_aarch64.cpp"
  }
}

void extrAddL_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12531 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ extr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
            opnd_array(2)->constant()& 63);
  
#line 23753 "ad_aarch64.cpp"
  }
}

void extrAddINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12549 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ extrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */), as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
            opnd_array(4)->constant()& 31);
  
#line 23773 "ad_aarch64.cpp"
  }
}

void extrAddI_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12549 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ extrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */),
            opnd_array(2)->constant()& 31);
  
#line 23793 "ad_aarch64.cpp"
  }
}

void rorI_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12565 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ extrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */),
               opnd_array(2)->constant()& 0x1f);
  
#line 23811 "ad_aarch64.cpp"
  }
}

void rorL_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12581 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ extr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */),
               opnd_array(2)->constant()& 0x3f);
  
#line 23829 "ad_aarch64.cpp"
  }
}

void rorI_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12597 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ rorvw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), as_Register(opnd_array(2)->reg(ra_,this,idx2)/* shift */));
  
#line 23846 "ad_aarch64.cpp"
  }
}

void rorL_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12612 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ rorv(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), as_Register(opnd_array(2)->reg(ra_,this,idx2)/* shift */));
  
#line 23863 "ad_aarch64.cpp"
  }
}

void rolI_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12627 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ subw(rscratch1, zr, as_Register(opnd_array(2)->reg(ra_,this,idx2)/* shift */));
     __ rorvw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), rscratch1);
  
#line 23881 "ad_aarch64.cpp"
  }
}

void rolL_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12643 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ subw(rscratch1, zr, as_Register(opnd_array(2)->reg(ra_,this,idx2)/* shift */));
     __ rorv(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), rscratch1);
  
#line 23899 "ad_aarch64.cpp"
  }
}

void AddExtINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12661 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxtw);
   
#line 23917 "ad_aarch64.cpp"
  }
}

void AddExtI_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12661 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::sxtw);
   
#line 23935 "ad_aarch64.cpp"
  }
}

void SubExtINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12676 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ sub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxtw);
   
#line 23953 "ad_aarch64.cpp"
  }
}

void AddExtI_sxthNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12691 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxth);
   
#line 23973 "ad_aarch64.cpp"
  }
}

void AddExtI_sxth_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12691 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::sxth);
   
#line 23993 "ad_aarch64.cpp"
  }
}

void AddExtI_sxtbNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12706 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxtb);
   
#line 24013 "ad_aarch64.cpp"
  }
}

void AddExtI_sxtb_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12706 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::sxtb);
   
#line 24033 "ad_aarch64.cpp"
  }
}

void AddExtI_uxtbNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12721 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxtb);
   
#line 24053 "ad_aarch64.cpp"
  }
}

void AddExtI_uxtb_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12721 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::uxtb);
   
#line 24073 "ad_aarch64.cpp"
  }
}

void AddExtL_sxthNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12736 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxth);
   
#line 24093 "ad_aarch64.cpp"
  }
}

void AddExtL_sxth_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12736 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::sxth);
   
#line 24113 "ad_aarch64.cpp"
  }
}

void AddExtL_sxtwNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12751 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxtw);
   
#line 24133 "ad_aarch64.cpp"
  }
}

void AddExtL_sxtw_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12751 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::sxtw);
   
#line 24153 "ad_aarch64.cpp"
  }
}

void AddExtL_sxtbNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12766 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxtb);
   
#line 24173 "ad_aarch64.cpp"
  }
}

void AddExtL_sxtb_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12766 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::sxtb);
   
#line 24193 "ad_aarch64.cpp"
  }
}

void AddExtL_uxtbNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12781 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxtb);
   
#line 24213 "ad_aarch64.cpp"
  }
}

void AddExtL_uxtb_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12781 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::uxtb);
   
#line 24233 "ad_aarch64.cpp"
  }
}

void AddExtI_uxtb_andNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12796 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxtb);
   
#line 24252 "ad_aarch64.cpp"
  }
}

void AddExtI_uxtb_and_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12796 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::uxtb);
   
#line 24271 "ad_aarch64.cpp"
  }
}

void AddExtI_uxth_andNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12811 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxth);
   
#line 24290 "ad_aarch64.cpp"
  }
}

void AddExtI_uxth_and_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12811 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::uxth);
   
#line 24309 "ad_aarch64.cpp"
  }
}

void AddExtL_uxtb_andNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12826 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxtb);
   
#line 24328 "ad_aarch64.cpp"
  }
}

void AddExtL_uxtb_and_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12826 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::uxtb);
   
#line 24347 "ad_aarch64.cpp"
  }
}

void AddExtL_uxth_andNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12841 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxth);
   
#line 24366 "ad_aarch64.cpp"
  }
}

void AddExtL_uxth_and_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12841 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::uxth);
   
#line 24385 "ad_aarch64.cpp"
  }
}

void AddExtL_uxtw_andNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12856 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxtw);
   
#line 24404 "ad_aarch64.cpp"
  }
}

void AddExtL_uxtw_and_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12856 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::uxtw);
   
#line 24423 "ad_aarch64.cpp"
  }
}

void SubExtI_uxtb_andNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12871 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ subw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxtb);
   
#line 24442 "ad_aarch64.cpp"
  }
}

void SubExtI_uxth_andNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12886 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ subw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxth);
   
#line 24461 "ad_aarch64.cpp"
  }
}

void SubExtL_uxtb_andNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12901 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ sub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxtb);
   
#line 24480 "ad_aarch64.cpp"
  }
}

void SubExtL_uxth_andNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12916 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ sub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxth);
   
#line 24499 "ad_aarch64.cpp"
  }
}

void SubExtL_uxtw_andNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12931 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ sub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxtw);
   
#line 24518 "ad_aarch64.cpp"
  }
}

void AddExtL_sxtb_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12947 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxtb, (opnd_array(5)->constant()));
   
#line 24539 "ad_aarch64.cpp"
  }
}

void AddExtL_sxtb_shift_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12947 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(5)->reg(ra_,this,idx5)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::sxtb, (opnd_array(4)->constant()));
   
#line 24560 "ad_aarch64.cpp"
  }
}

void AddExtL_sxth_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12962 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxth, (opnd_array(5)->constant()));
   
#line 24581 "ad_aarch64.cpp"
  }
}

void AddExtL_sxth_shift_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12962 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(5)->reg(ra_,this,idx5)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::sxth, (opnd_array(4)->constant()));
   
#line 24602 "ad_aarch64.cpp"
  }
}

void AddExtL_sxtw_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12977 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxtw, (opnd_array(5)->constant()));
   
#line 24623 "ad_aarch64.cpp"
  }
}

void AddExtL_sxtw_shift_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12977 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(5)->reg(ra_,this,idx5)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::sxtw, (opnd_array(4)->constant()));
   
#line 24644 "ad_aarch64.cpp"
  }
}

void SubExtL_sxtb_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 12992 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ sub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxtb, (opnd_array(5)->constant()));
   
#line 24665 "ad_aarch64.cpp"
  }
}

void SubExtL_sxth_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13007 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ sub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxth, (opnd_array(5)->constant()));
   
#line 24686 "ad_aarch64.cpp"
  }
}

void SubExtL_sxtw_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13022 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ sub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxtw, (opnd_array(5)->constant()));
   
#line 24707 "ad_aarch64.cpp"
  }
}

void AddExtI_sxtb_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13037 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxtb, (opnd_array(5)->constant()));
   
#line 24728 "ad_aarch64.cpp"
  }
}

void AddExtI_sxtb_shift_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13037 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(5)->reg(ra_,this,idx5)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::sxtb, (opnd_array(4)->constant()));
   
#line 24749 "ad_aarch64.cpp"
  }
}

void AddExtI_sxth_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13052 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxth, (opnd_array(5)->constant()));
   
#line 24770 "ad_aarch64.cpp"
  }
}

void AddExtI_sxth_shift_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13052 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(5)->reg(ra_,this,idx5)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::sxth, (opnd_array(4)->constant()));
   
#line 24791 "ad_aarch64.cpp"
  }
}

void SubExtI_sxtb_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13067 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ subw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxtb, (opnd_array(5)->constant()));
   
#line 24812 "ad_aarch64.cpp"
  }
}

void SubExtI_sxth_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13082 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ subw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxth, (opnd_array(5)->constant()));
   
#line 24833 "ad_aarch64.cpp"
  }
}

void AddExtI_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13097 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxtw, (opnd_array(3)->constant()));
   
#line 24852 "ad_aarch64.cpp"
  }
}

void AddExtI_shift_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13097 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(3)->reg(ra_,this,idx3)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::sxtw, (opnd_array(2)->constant()));
   
#line 24871 "ad_aarch64.cpp"
  }
}

void SubExtI_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13112 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ sub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::sxtw, (opnd_array(3)->constant()));
   
#line 24890 "ad_aarch64.cpp"
  }
}

void AddExtL_uxtb_and_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13127 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxtb, (opnd_array(4)->constant()));
   
#line 24910 "ad_aarch64.cpp"
  }
}

void AddExtL_uxtb_and_shift_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13127 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::uxtb, (opnd_array(3)->constant()));
   
#line 24930 "ad_aarch64.cpp"
  }
}

void AddExtL_uxth_and_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13142 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxth, (opnd_array(4)->constant()));
   
#line 24950 "ad_aarch64.cpp"
  }
}

void AddExtL_uxth_and_shift_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13142 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::uxth, (opnd_array(3)->constant()));
   
#line 24970 "ad_aarch64.cpp"
  }
}

void AddExtL_uxtw_and_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13157 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxtw, (opnd_array(4)->constant()));
   
#line 24990 "ad_aarch64.cpp"
  }
}

void AddExtL_uxtw_and_shift_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13157 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ add(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::uxtw, (opnd_array(3)->constant()));
   
#line 25010 "ad_aarch64.cpp"
  }
}

void SubExtL_uxtb_and_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13172 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ sub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxtb, (opnd_array(4)->constant()));
   
#line 25030 "ad_aarch64.cpp"
  }
}

void SubExtL_uxth_and_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13187 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ sub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxth, (opnd_array(4)->constant()));
   
#line 25050 "ad_aarch64.cpp"
  }
}

void SubExtL_uxtw_and_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13202 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ sub(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxtw, (opnd_array(4)->constant()));
   
#line 25070 "ad_aarch64.cpp"
  }
}

void AddExtI_uxtb_and_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13217 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxtb, (opnd_array(4)->constant()));
   
#line 25090 "ad_aarch64.cpp"
  }
}

void AddExtI_uxtb_and_shift_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13217 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::uxtb, (opnd_array(3)->constant()));
   
#line 25110 "ad_aarch64.cpp"
  }
}

void AddExtI_uxth_and_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13232 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxth, (opnd_array(4)->constant()));
   
#line 25130 "ad_aarch64.cpp"
  }
}

void AddExtI_uxth_and_shift_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13232 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ addw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(4)->reg(ra_,this,idx4)/* src1 */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src2 */), ext::uxth, (opnd_array(3)->constant()));
   
#line 25150 "ad_aarch64.cpp"
  }
}

void SubExtI_uxtb_and_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13247 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ subw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxtb, (opnd_array(4)->constant()));
   
#line 25170 "ad_aarch64.cpp"
  }
}

void SubExtI_uxth_and_shiftNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13262 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     __ subw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */), ext::uxth, (opnd_array(4)->constant()));
   
#line 25190 "ad_aarch64.cpp"
  }
}

void cmovI_reg_reg_ltNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13277 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(opnd_array(0)->as_Register(ra_,this)/* dst */,
             opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */,
             opnd_array(2)->as_Register(ra_,this,idx2)/* src2 */,
             Assembler::LT);
  
#line 25211 "ad_aarch64.cpp"
  }
}

void cmovI_reg_reg_gtNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13294 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(opnd_array(0)->as_Register(ra_,this)/* dst */,
             opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */,
             opnd_array(2)->as_Register(ra_,this,idx2)/* src2 */,
             Assembler::GT);
  
#line 25232 "ad_aarch64.cpp"
  }
}

void cmovI_reg_imm0_ltNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13311 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(opnd_array(0)->as_Register(ra_,this)/* dst */,
             opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */,
             zr,
             Assembler::LT);
  
#line 25252 "ad_aarch64.cpp"
  }
}

void cmovI_reg_imm0_gtNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13328 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cselw(opnd_array(0)->as_Register(ra_,this)/* dst */,
             opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */,
             zr,
             Assembler::GT);
  
#line 25272 "ad_aarch64.cpp"
  }
}

void cmovI_reg_imm1_leNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13345 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csincw(opnd_array(0)->as_Register(ra_,this)/* dst */,
             opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */,
             zr,
             Assembler::LE);
  
#line 25292 "ad_aarch64.cpp"
  }
}

void cmovI_reg_imm1_gtNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13362 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csincw(opnd_array(0)->as_Register(ra_,this)/* dst */,
             opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */,
             zr,
             Assembler::GT);
  
#line 25312 "ad_aarch64.cpp"
  }
}

void cmovI_reg_immM1_ltNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13379 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csinvw(opnd_array(0)->as_Register(ra_,this)/* dst */,
             opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */,
             zr,
             Assembler::LT);
  
#line 25332 "ad_aarch64.cpp"
  }
}

void cmovI_reg_immM1_geNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13396 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ csinvw(opnd_array(0)->as_Register(ra_,this)/* dst */,
             opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */,
             zr,
             Assembler::GE);
  
#line 25352 "ad_aarch64.cpp"
  }
}

void bits_reverse_INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13568 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ rbitw(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 25368 "ad_aarch64.cpp"
  }
}

void bits_reverse_LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13581 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ rbit(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 25384 "ad_aarch64.cpp"
  }
}

void addF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13600 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fadds(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 25403 "ad_aarch64.cpp"
  }
}

void addD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13615 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ faddd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 25422 "ad_aarch64.cpp"
  }
}

void subF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13630 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fsubs(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 25441 "ad_aarch64.cpp"
  }
}

void subD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13645 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fsubd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 25460 "ad_aarch64.cpp"
  }
}

void mulF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13660 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fmuls(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 25479 "ad_aarch64.cpp"
  }
}

void mulD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13675 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fmuld(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 25498 "ad_aarch64.cpp"
  }
}

void maddF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13690 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    __ fmadds(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
             as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 25520 "ad_aarch64.cpp"
  }
}

void maddD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13707 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    __ fmaddd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
             as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 25542 "ad_aarch64.cpp"
  }
}

void msubF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13725 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    __ fmsubs(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
              as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
              as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 25564 "ad_aarch64.cpp"
  }
}

void msubD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13743 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    __ fmsubd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
              as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
              as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 25586 "ad_aarch64.cpp"
  }
}

void mnaddF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13761 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    __ fnmadds(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
               as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
               as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
               as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 25608 "ad_aarch64.cpp"
  }
}

void mnaddD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13779 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    __ fnmaddd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
               as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
               as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
               as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 25630 "ad_aarch64.cpp"
  }
}

void mnsubF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13796 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    __ fnmsubs(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
               as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
               as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
               as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 25652 "ad_aarch64.cpp"
  }
}

void mnsubD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13813 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    // n.b. insn name should be fnmsubd
    __ fnmsub(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
              as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src1 */),
              as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* src2 */),
              as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src3 */));
  
#line 25675 "ad_aarch64.cpp"
  }
}

void maxF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13831 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fmaxs(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 25694 "ad_aarch64.cpp"
  }
}

void minF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13845 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fmins(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 25713 "ad_aarch64.cpp"
  }
}

void maxD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13859 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fmaxd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 25732 "ad_aarch64.cpp"
  }
}

void minD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13873 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fmind(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 25751 "ad_aarch64.cpp"
  }
}

void divF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13889 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fdivs(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 25770 "ad_aarch64.cpp"
  }
}

void divD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13904 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fdivd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 25789 "ad_aarch64.cpp"
  }
}

void negF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13919 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fnegs(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 25806 "ad_aarch64.cpp"
  }
}

void negD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13933 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fnegd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 25823 "ad_aarch64.cpp"
  }
}

void absI_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13951 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpw(as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), zr);
    __ cnegw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), Assembler::LT);
  
#line 25840 "ad_aarch64.cpp"
  }
}

void absL_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13968 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmp(as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), zr);
    __ cneg(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), Assembler::LT);
  
#line 25857 "ad_aarch64.cpp"
  }
}

void absF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13980 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fabss(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 25874 "ad_aarch64.cpp"
  }
}

void absD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 13993 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fabsd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 25891 "ad_aarch64.cpp"
  }
}

void absdF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14006 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fabds(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 25910 "ad_aarch64.cpp"
  }
}

void absdD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14020 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fabdd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
             as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 25929 "ad_aarch64.cpp"
  }
}

void sqrtD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14034 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fsqrtd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 25946 "ad_aarch64.cpp"
  }
}

void sqrtF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14047 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fsqrts(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
             as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 25963 "ad_aarch64.cpp"
  }
}

void roundD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rmode
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14059 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    switch (opnd_array(2)->constant()) {
      case RoundDoubleModeNode::rmode_rint:
        __ frintnd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
                   as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
        break;
      case RoundDoubleModeNode::rmode_floor:
        __ frintmd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
                   as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
        break;
      case RoundDoubleModeNode::rmode_ceil:
        __ frintpd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */),
                   as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
        break;
    }
  
#line 25993 "ad_aarch64.cpp"
  }
}

void copySignD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14082 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister dst = as_FloatRegister(opnd_array(4)->reg(ra_,this,idx4)/* dst */),
                  src1 = as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
                  src2 = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */),
                  zero = as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* zero */);
    __ fnegd(dst, zero);
    __ bsl(dst, __ T8B, src2, src1);
  
#line 26017 "ad_aarch64.cpp"
  }
}

void copySignF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14097 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister dst = as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* dst */),
                  src1 = as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
                  src2 = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */);
    __ movi(dst, __ T2S, 0x80, 24);
    __ bsl(dst, __ T8B, src2, src1);
  
#line 26039 "ad_aarch64.cpp"
  }
}

void signumD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// one
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14111 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister src = as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */),
                  dst = as_FloatRegister(opnd_array(4)->reg(ra_,this,idx4)/* dst */),
                  zero = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* zero */),
                  one = as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* one */);
    __ facgtd(dst, src, zero); // dst=0 for +-0.0 and NaN. 0xFFF..F otherwise
    __ ushrd(dst, dst, 1);     // dst=0 for +-0.0 and NaN. 0x7FF..F otherwise
    // Bit selection instruction gets bit from "one" for each enabled bit in
    // "dst", otherwise gets a bit from "src". For "src" that contains +-0.0 or
    // NaN the whole "src" will be copied because "dst" is zero. For all other
    // "src" values dst is 0x7FF..F, which means only the sign bit is copied
    // from "src", and all other bits are copied from 1.0.
    __ bsl(dst, __ T8B, one, src);
  
#line 26069 "ad_aarch64.cpp"
  }
}

void signumF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// one
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14132 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister src = as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */),
                  dst = as_FloatRegister(opnd_array(4)->reg(ra_,this,idx4)/* dst */),
                  zero = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* zero */),
                  one = as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* one */);
    __ facgts(dst, src, zero);    // dst=0 for +-0.0 and NaN. 0xFFF..F otherwise
    __ ushr(dst, __ T2S, dst, 1); // dst=0 for +-0.0 and NaN. 0x7FF..F otherwise
    // Bit selection instruction gets bit from "one" for each enabled bit in
    // "dst", otherwise gets a bit from "src". For "src" that contains +-0.0 or
    // NaN the whole "src" will be copied because "dst" is zero. For all other
    // "src" values dst is 0x7FF..F, which means only the sign bit is copied
    // from "src", and all other bits are copied from 1.0.
    __ bsl(dst, __ T8B, one, src);
  
#line 26099 "ad_aarch64.cpp"
  }
}

void onspinwaitNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14155 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ spin_wait();
  
#line 26115 "ad_aarch64.cpp"
  }
}

void andI_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14175 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 26134 "ad_aarch64.cpp"
  }
}

void andI_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14190 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            (uint64_t)(opnd_array(2)->constant()));
  
#line 26153 "ad_aarch64.cpp"
  }
}

void orI_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14207 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 26172 "ad_aarch64.cpp"
  }
}

void orI_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14222 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            (uint64_t)(opnd_array(2)->constant()));
  
#line 26191 "ad_aarch64.cpp"
  }
}

void xorI_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14239 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eorw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 26210 "ad_aarch64.cpp"
  }
}

void xorI_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14254 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eorw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            (uint64_t)(opnd_array(2)->constant()));
  
#line 26229 "ad_aarch64.cpp"
  }
}

void andL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14272 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 26248 "ad_aarch64.cpp"
  }
}

void andL_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14287 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ andr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
            as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
            (uint64_t)(opnd_array(2)->constantL()));
  
#line 26267 "ad_aarch64.cpp"
  }
}

void orL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14304 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
           as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
           as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 26286 "ad_aarch64.cpp"
  }
}

void orL_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14319 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ orr(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
           as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
           (uint64_t)(opnd_array(2)->constantL()));
  
#line 26305 "ad_aarch64.cpp"
  }
}

void xorL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14336 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eor(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
           as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
           as_Register(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 26324 "ad_aarch64.cpp"
  }
}

void xorL_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14351 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ eor(as_Register(opnd_array(0)->reg(ra_,this)/* dst */),
           as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src1 */),
           (uint64_t)(opnd_array(2)->constantL()));
  
#line 26343 "ad_aarch64.cpp"
  }
}

void convI2L_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14366 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ sbfm(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */, 0, 31);
  
#line 26359 "ad_aarch64.cpp"
  }
}

void convUI2L_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14379 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ubfm(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */, 0, 31);
  
#line 26376 "ad_aarch64.cpp"
  }
}

void convL2I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14392 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ movw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 26392 "ad_aarch64.cpp"
  }
}

void convD2F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14405 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fcvtd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 26408 "ad_aarch64.cpp"
  }
}

void convF2D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14418 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fcvts(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 26424 "ad_aarch64.cpp"
  }
}

void convF2I_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14431 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fcvtzsw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 26440 "ad_aarch64.cpp"
  }
}

void convF2L_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14444 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fcvtzs(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 26456 "ad_aarch64.cpp"
  }
}

void convF2HF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14457 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

      __ flt_to_flt16(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */);
  
#line 26473 "ad_aarch64.cpp"
  }
}

void convHF2F_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14469 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

      __ flt16_to_flt(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */);
  
#line 26490 "ad_aarch64.cpp"
  }
}

void convI2F_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14481 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ scvtfws(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 26506 "ad_aarch64.cpp"
  }
}

void convL2F_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14494 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ scvtfs(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 26522 "ad_aarch64.cpp"
  }
}

void convD2I_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14507 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fcvtzdw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 26538 "ad_aarch64.cpp"
  }
}

void convD2L_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14520 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fcvtzd(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 26554 "ad_aarch64.cpp"
  }
}

void convI2D_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14533 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ scvtfwd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 26570 "ad_aarch64.cpp"
  }
}

void convL2D_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14546 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ scvtfd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 26586 "ad_aarch64.cpp"
  }
}

void round_double_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ftmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14558 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ java_round_double(opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */),
                         as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* ftmp */));
  
#line 26605 "ad_aarch64.cpp"
  }
}

void round_float_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ftmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14570 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ java_round_float(opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */),
                        as_FloatRegister(opnd_array(3)->reg(ra_,this,idx3)/* ftmp */));
  
#line 26624 "ad_aarch64.cpp"
  }
}

void MoveF2I_stack_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14589 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ldrw(opnd_array(0)->as_Register(ra_,this)/* dst */, Address(sp, opnd_array(1)->disp(ra_,this,idx1)));
  
#line 26640 "ad_aarch64.cpp"
  }
}

void MoveI2F_stack_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14607 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ldrs(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), Address(sp, opnd_array(1)->disp(ra_,this,idx1)));
  
#line 26656 "ad_aarch64.cpp"
  }
}

void MoveD2L_stack_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14625 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ldr(opnd_array(0)->as_Register(ra_,this)/* dst */, Address(sp, opnd_array(1)->disp(ra_,this,idx1)));
  
#line 26672 "ad_aarch64.cpp"
  }
}

void MoveL2D_stack_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14643 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ ldrd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), Address(sp, opnd_array(1)->disp(ra_,this,idx1)));
  
#line 26688 "ad_aarch64.cpp"
  }
}

void MoveF2I_reg_stackNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14661 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ strs(as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */), Address(sp, opnd_array(0)->disp(ra_,this,0)));
  
#line 26704 "ad_aarch64.cpp"
  }
}

void MoveI2F_reg_stackNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14679 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ strw(opnd_array(1)->as_Register(ra_,this,idx1)/* src */, Address(sp, opnd_array(0)->disp(ra_,this,0)));
  
#line 26720 "ad_aarch64.cpp"
  }
}

void MoveD2L_reg_stackNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14697 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ strd(as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */), Address(sp, opnd_array(0)->disp(ra_,this,0)));
  
#line 26736 "ad_aarch64.cpp"
  }
}

void MoveL2D_reg_stackNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14715 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ str(opnd_array(1)->as_Register(ra_,this,idx1)/* src */, Address(sp, opnd_array(0)->disp(ra_,this,0)));
  
#line 26752 "ad_aarch64.cpp"
  }
}

void MoveF2I_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14733 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fmovs(opnd_array(0)->as_Register(ra_,this)/* dst */, as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 26768 "ad_aarch64.cpp"
  }
}

void MoveI2F_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14751 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fmovs(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 26784 "ad_aarch64.cpp"
  }
}

void MoveD2L_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14769 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fmovd(opnd_array(0)->as_Register(ra_,this)/* dst */, as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src */));
  
#line 26800 "ad_aarch64.cpp"
  }
}

void MoveL2D_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14787 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fmovd(as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */), opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 26816 "ad_aarch64.cpp"
  }
}

void clearArray_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// cnt
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// base
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14806 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    address tpc = __ zero_words(opnd_array(2)->as_Register(ra_,this,idx2)/* base */, opnd_array(1)->as_Register(ra_,this,idx1)/* cnt */);
    if (tpc == nullptr) {
      ciEnv::current()->record_failure("CodeCache is full");
      return;
    }
  
#line 26837 "ad_aarch64.cpp"
  }
}

void clearArray_imm_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// cnt
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// base
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// temp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14827 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    address tpc = __ zero_words(opnd_array(2)->as_Register(ra_,this,idx2)/* base */, (uint64_t)opnd_array(1)->constantL());
    if (tpc == nullptr) {
      ciEnv::current()->record_failure("CodeCache is full");
      return;
    }
  
#line 26859 "ad_aarch64.cpp"
  }
}

void overflowAddI_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14847 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmnw(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);
  
#line 26876 "ad_aarch64.cpp"
  }
}

void overflowAddI_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14860 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmnw(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->constant());
  
#line 26893 "ad_aarch64.cpp"
  }
}

void overflowAddL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14873 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmn(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);
  
#line 26910 "ad_aarch64.cpp"
  }
}

void overflowAddL_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14886 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ adds(zr, opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->constantL());
  
#line 26927 "ad_aarch64.cpp"
  }
}

void overflowSubI_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14899 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpw(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);
  
#line 26944 "ad_aarch64.cpp"
  }
}

void overflowSubI_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14912 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpw(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->constant());
  
#line 26961 "ad_aarch64.cpp"
  }
}

void overflowSubL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14925 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmp(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);
  
#line 26978 "ad_aarch64.cpp"
  }
}

void overflowSubL_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14938 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ subs(zr, opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->constantL());
  
#line 26995 "ad_aarch64.cpp"
  }
}

void overflowNegI_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14951 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpw(zr, opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */);
  
#line 27012 "ad_aarch64.cpp"
  }
}

void overflowNegL_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14964 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmp(zr, opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */);
  
#line 27029 "ad_aarch64.cpp"
  }
}

void overflowMulI_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 14981 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ smull(rscratch1, opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);
    __ subs(zr, rscratch1, rscratch1, ext::sxtw);      // NE => overflow
    __ movw(rscratch1, 0x80000000);                    // Develop 0 (EQ),
    __ cselw(rscratch1, rscratch1, zr, Assembler::NE); // or 0x80000000 (NE)
    __ cmpw(rscratch1, 1);                             // 0x80000000 - 1 => VS
  
#line 27050 "ad_aarch64.cpp"
  }
}

void overflowMulI_reg_branchNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15003 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(4)->label();
    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    __ smull(rscratch1, opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* op2 */);
    __ subs(zr, rscratch1, rscratch1, ext::sxtw);      // NE => overflow
    __ br(cond == Assembler::VS ? Assembler::NE : Assembler::EQ, *L);
  
#line 27073 "ad_aarch64.cpp"
  }
}

void overflowMulL_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15025 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ mul(rscratch1, opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);   // Result bits 0..63
    __ smulh(rscratch2, opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */); // Result bits 64..127
    __ cmp(rscratch2, rscratch1, Assembler::ASR, 63);    // Top is pure sign ext
    __ movw(rscratch1, 0x80000000);                    // Develop 0 (EQ),
    __ cselw(rscratch1, rscratch1, zr, Assembler::NE); // or 0x80000000 (NE)
    __ cmpw(rscratch1, 1);                             // 0x80000000 - 1 => VS
  
#line 27095 "ad_aarch64.cpp"
  }
}

void overflowMulL_reg_branchNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15049 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(4)->label();
    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    __ mul(rscratch1, opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* op2 */);   // Result bits 0..63
    __ smulh(rscratch2, opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* op2 */); // Result bits 64..127
    __ cmp(rscratch2, rscratch1, Assembler::ASR, 63);    // Top is pure sign ext
    __ br(cond == Assembler::VS ? Assembler::NE : Assembler::EQ, *L);
  
#line 27119 "ad_aarch64.cpp"
  }
}

void compI_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 3557 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg1 = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    Register reg2 = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* op2 */);
    __ cmpw(reg1, reg2);
  
#line 27138 "ad_aarch64.cpp"
  }
}

void compI_reg_immI0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 3564 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    int32_t val = opnd_array(2)->constant();
    if (val >= 0) {
      __ subsw(zr, reg, val);
    } else {
      __ addsw(zr, reg, -val);
    }
  
#line 27161 "ad_aarch64.cpp"
  }
}

void compI_reg_immIAddSubNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 3564 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    int32_t val = opnd_array(2)->constant();
    if (val >= 0) {
      __ subsw(zr, reg, val);
    } else {
      __ addsw(zr, reg, -val);
    }
  
#line 27184 "ad_aarch64.cpp"
  }
}

void compI_reg_immINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 3575 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg1 = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    uint32_t val = (uint32_t)opnd_array(2)->constant();
    __ movw(rscratch1, val);
    __ cmpw(reg1, rscratch1);
  
#line 27204 "ad_aarch64.cpp"
  }
}

void compU_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 3557 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg1 = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    Register reg2 = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* op2 */);
    __ cmpw(reg1, reg2);
  
#line 27223 "ad_aarch64.cpp"
  }
}

void compU_reg_immI0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 3564 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    int32_t val = opnd_array(2)->constant();
    if (val >= 0) {
      __ subsw(zr, reg, val);
    } else {
      __ addsw(zr, reg, -val);
    }
  
#line 27246 "ad_aarch64.cpp"
  }
}

void compU_reg_immIAddSubNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 3564 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    int32_t val = opnd_array(2)->constant();
    if (val >= 0) {
      __ subsw(zr, reg, val);
    } else {
      __ addsw(zr, reg, -val);
    }
  
#line 27269 "ad_aarch64.cpp"
  }
}

void compU_reg_immINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 3575 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg1 = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    uint32_t val = (uint32_t)opnd_array(2)->constant();
    __ movw(rscratch1, val);
    __ cmpw(reg1, rscratch1);
  
#line 27289 "ad_aarch64.cpp"
  }
}

void compL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 3583 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg1 = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    Register reg2 = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* op2 */);
    __ cmp(reg1, reg2);
  
#line 27308 "ad_aarch64.cpp"
  }
}

void compL_reg_immL0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 3590 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    int64_t val = opnd_array(2)->constantL();
    if (val >= 0) {
      __ subs(zr, reg, val);
    } else if (val != -val) {
      __ adds(zr, reg, -val);
    } else {
    // aargh, Long.MIN_VALUE is a special case
      __ orr(rscratch1, zr, (uint64_t)val);
      __ subs(zr, reg, rscratch1);
    }
  
#line 27335 "ad_aarch64.cpp"
  }
}

void compL_reg_immLAddSubNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 3590 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    int64_t val = opnd_array(2)->constantL();
    if (val >= 0) {
      __ subs(zr, reg, val);
    } else if (val != -val) {
      __ adds(zr, reg, -val);
    } else {
    // aargh, Long.MIN_VALUE is a special case
      __ orr(rscratch1, zr, (uint64_t)val);
      __ subs(zr, reg, rscratch1);
    }
  
#line 27362 "ad_aarch64.cpp"
  }
}

void compL_reg_immLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 3605 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg1 = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    uint64_t val = (uint64_t)opnd_array(2)->constantL();
    __ mov(rscratch1, val);
    __ cmp(reg1, rscratch1);
  
#line 27382 "ad_aarch64.cpp"
  }
}

void compUL_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 3583 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg1 = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    Register reg2 = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* op2 */);
    __ cmp(reg1, reg2);
  
#line 27401 "ad_aarch64.cpp"
  }
}

void compUL_reg_immL0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 3590 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    int64_t val = opnd_array(2)->constantL();
    if (val >= 0) {
      __ subs(zr, reg, val);
    } else if (val != -val) {
      __ adds(zr, reg, -val);
    } else {
    // aargh, Long.MIN_VALUE is a special case
      __ orr(rscratch1, zr, (uint64_t)val);
      __ subs(zr, reg, rscratch1);
    }
  
#line 27428 "ad_aarch64.cpp"
  }
}

void compUL_reg_immLAddSubNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 3590 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    int64_t val = opnd_array(2)->constantL();
    if (val >= 0) {
      __ subs(zr, reg, val);
    } else if (val != -val) {
      __ adds(zr, reg, -val);
    } else {
    // aargh, Long.MIN_VALUE is a special case
      __ orr(rscratch1, zr, (uint64_t)val);
      __ subs(zr, reg, rscratch1);
    }
  
#line 27455 "ad_aarch64.cpp"
  }
}

void compUL_reg_immLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 3605 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg1 = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    uint64_t val = (uint64_t)opnd_array(2)->constantL();
    __ mov(rscratch1, val);
    __ cmp(reg1, rscratch1);
  
#line 27475 "ad_aarch64.cpp"
  }
}

void compP_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 3613 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg1 = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    Register reg2 = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* op2 */);
    __ cmp(reg1, reg2);
  
#line 27494 "ad_aarch64.cpp"
  }
}

void compN_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 3620 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg1 = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    Register reg2 = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* op2 */);
    __ cmpw(reg1, reg2);
  
#line 27513 "ad_aarch64.cpp"
  }
}

void testP_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 3627 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    __ cmp(reg, zr);
  
#line 27531 "ad_aarch64.cpp"
  }
}

void testN_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 3633 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* op1 */);
    __ cmpw(reg, zr);
  
#line 27549 "ad_aarch64.cpp"
  }
}

void compF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15360 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fcmps(as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */), as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 27566 "ad_aarch64.cpp"
  }
}

void compF_reg_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15374 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fcmps(as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */), 0.0);
  
#line 27583 "ad_aarch64.cpp"
  }
}

void compD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15389 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fcmpd(as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */), as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */));
  
#line 27600 "ad_aarch64.cpp"
  }
}

void compD_reg_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15403 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fcmpd(as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */), 0.0);
  
#line 27617 "ad_aarch64.cpp"
  }
}

void compF3_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15421 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label done;
    FloatRegister s1 = as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */);
    FloatRegister s2 = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */);
    Register d = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    __ fcmps(s1, s2);
    // installs 0 if EQ else -1
    __ csinvw(d, zr, zr, Assembler::EQ);
    // keeps -1 if less or unordered else installs 1
    __ csnegw(d, d, d, Assembler::LT);
    __ bind(done);
  
#line 27643 "ad_aarch64.cpp"
  }
}

void compD3_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15449 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label done;
    FloatRegister s1 = as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */);
    FloatRegister s2 = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src2 */);
    Register d = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    __ fcmpd(s1, s2);
    // installs 0 if EQ else -1
    __ csinvw(d, zr, zr, Assembler::EQ);
    // keeps -1 if less or unordered else installs 1
    __ csnegw(d, d, d, Assembler::LT);
    __ bind(done);
  
#line 27669 "ad_aarch64.cpp"
  }
}

void compF3_reg_immF0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15476 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label done;
    FloatRegister s1 = as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */);
    Register d = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    __ fcmps(s1, 0.0);
    // installs 0 if EQ else -1
    __ csinvw(d, zr, zr, Assembler::EQ);
    // keeps -1 if less or unordered else installs 1
    __ csnegw(d, d, d, Assembler::LT);
    __ bind(done);
  
#line 27694 "ad_aarch64.cpp"
  }
}

void compD3_reg_immD0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15503 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label done;
    FloatRegister s1 = as_FloatRegister(opnd_array(1)->reg(ra_,this,idx1)/* src1 */);
    Register d = as_Register(opnd_array(0)->reg(ra_,this)/* dst */);
    __ fcmpd(s1, 0.0);
    // installs 0 if EQ else -1
    __ csinvw(d, zr, zr, Assembler::EQ);
    // keeps -1 if less or unordered else installs 1
    __ csnegw(d, d, d, Assembler::LT);
    __ bind(done);
  
#line 27719 "ad_aarch64.cpp"
  }
}

void cmpLTMask_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// p
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// q
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15530 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpw(as_Register(opnd_array(1)->reg(ra_,this,idx1)/* p */), as_Register(opnd_array(2)->reg(ra_,this,idx2)/* q */));
    __ csetw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), Assembler::LT);
    __ subw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), zr, as_Register(opnd_array(0)->reg(ra_,this)/* dst */));
  
#line 27738 "ad_aarch64.cpp"
  }
}

void cmpLTMask_reg_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15548 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ asrw(as_Register(opnd_array(0)->reg(ra_,this)/* dst */), as_Register(opnd_array(1)->reg(ra_,this,idx1)/* src */), 31);
  
#line 27755 "ad_aarch64.cpp"
  }
}

void compI_reg_imm0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15566 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ cmpw(opnd_array(1)->as_Register(ra_,this,idx1)/* src */, 0);
  
#line 27771 "ad_aarch64.cpp"
  }
}

void branchNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {

#line 3639 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Label *L = opnd_array(1)->label();
    __ b(*L);
  
#line 27788 "ad_aarch64.cpp"
  }
}

void branchConNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lbl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {

#line 3645 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Label *L = opnd_array(3)->label();
    __ br ((Assembler::Condition)opnd_array(1)->ccode(), *L);
  
#line 27807 "ad_aarch64.cpp"
  }
}

void branchConUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lbl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {

#line 3651 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Label *L = opnd_array(3)->label();
    __ br ((Assembler::Condition)opnd_array(1)->ccode(), *L);
  
#line 27826 "ad_aarch64.cpp"
  }
}

void cmpI_imm0_branchNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15667 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(4)->label();
    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    if (cond == Assembler::EQ)
      __ cbzw(opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, *L);
    else
      __ cbnzw(opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, *L);
  
#line 27850 "ad_aarch64.cpp"
  }
}

void cmpL_imm0_branchNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15684 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(4)->label();
    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    if (cond == Assembler::EQ)
      __ cbz(opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, *L);
    else
      __ cbnz(opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, *L);
  
#line 27874 "ad_aarch64.cpp"
  }
}

void cmpP_imm0_branchNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15701 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(4)->label();
    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    if (cond == Assembler::EQ)
      __ cbz(opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, *L);
    else
      __ cbnz(opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, *L);
  
#line 27898 "ad_aarch64.cpp"
  }
}

void cmpN_imm0_branchNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15718 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(4)->label();
    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    if (cond == Assembler::EQ)
      __ cbzw(opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, *L);
    else
      __ cbnzw(opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, *L);
  
#line 27922 "ad_aarch64.cpp"
  }
}

void cmpP_narrowOop_imm0_branchNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// oop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15735 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(4)->label();
    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    if (cond == Assembler::EQ)
      __ cbzw(opnd_array(2)->as_Register(ra_,this,idx2)/* oop */, *L);
    else
      __ cbnzw(opnd_array(2)->as_Register(ra_,this,idx2)/* oop */, *L);
  
#line 27946 "ad_aarch64.cpp"
  }
}

void cmpUI_imm0_branchNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15752 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(4)->label();
    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    if (cond == Assembler::EQ || cond == Assembler::LS)
      __ cbzw(opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, *L);
    else
      __ cbnzw(opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, *L);
  
#line 27970 "ad_aarch64.cpp"
  }
}

void cmpUL_imm0_branchNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15769 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(4)->label();
    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    if (cond == Assembler::EQ || cond == Assembler::LS)
      __ cbz(opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, *L);
    else
      __ cbnz(opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, *L);
  
#line 27994 "ad_aarch64.cpp"
  }
}

void cmpL_branch_signNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15789 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(4)->label();
    Assembler::Condition cond =
      ((Assembler::Condition)opnd_array(1)->ccode()== Assembler::LT) ? Assembler::NE : Assembler::EQ;
    __ tbr(cond, opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, 63, *L);
  
#line 28016 "ad_aarch64.cpp"
  }
}

void cmpI_branch_signNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15805 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(4)->label();
    Assembler::Condition cond =
      ((Assembler::Condition)opnd_array(1)->ccode()== Assembler::LT) ? Assembler::NE : Assembler::EQ;
    __ tbr(cond, opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, 31, *L);
  
#line 28038 "ad_aarch64.cpp"
  }
}

void cmpL_branch_bitNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// labl
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15822 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(5)->label();
    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    int bit = exact_log2_long(opnd_array(3)->constantL());
    __ tbr(cond, opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, bit, *L);
  
#line 28061 "ad_aarch64.cpp"
  }
}

void cmpI_branch_bitNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// labl
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15839 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(5)->label();
    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    int bit = exact_log2((juint)opnd_array(3)->constant());
    __ tbr(cond, opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, bit, *L);
  
#line 28084 "ad_aarch64.cpp"
  }
}

void far_cmpL_branch_signNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15856 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(4)->label();
    Assembler::Condition cond =
      ((Assembler::Condition)opnd_array(1)->ccode()== Assembler::LT) ? Assembler::NE : Assembler::EQ;
    __ tbr(cond, opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, 63, *L, /*far*/true);
  
#line 28106 "ad_aarch64.cpp"
  }
}

void far_cmpI_branch_signNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15871 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(4)->label();
    Assembler::Condition cond =
      ((Assembler::Condition)opnd_array(1)->ccode()== Assembler::LT) ? Assembler::NE : Assembler::EQ;
    __ tbr(cond, opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, 31, *L, /*far*/true);
  
#line 28128 "ad_aarch64.cpp"
  }
}

void far_cmpL_branch_bitNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// labl
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15887 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(5)->label();
    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    int bit = exact_log2_long(opnd_array(3)->constantL());
    __ tbr(cond, opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, bit, *L, /*far*/true);
  
#line 28151 "ad_aarch64.cpp"
  }
}

void far_cmpI_branch_bitNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// labl
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15903 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    Label* L = opnd_array(5)->label();
    Assembler::Condition cond = (Assembler::Condition)opnd_array(1)->ccode();
    int bit = exact_log2((juint)opnd_array(3)->constant());
    __ tbr(cond, opnd_array(2)->as_Register(ra_,this,idx2)/* op1 */, bit, *L, /*far*/true);
  
#line 28174 "ad_aarch64.cpp"
  }
}

void cmpL_andNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15921 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ tst(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->constantL());
  
#line 28192 "ad_aarch64.cpp"
  }
}

void cmpI_andNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15934 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ tstw(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->constant());
  
#line 28210 "ad_aarch64.cpp"
  }
}

void cmpL_and_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15945 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ tst(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);
  
#line 28228 "ad_aarch64.cpp"
  }
}

void cmpI_and_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15956 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ tstw(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);
  
#line 28246 "ad_aarch64.cpp"
  }
}

void branchLoopEndNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lbl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {

#line 3645 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Label *L = opnd_array(3)->label();
    __ br ((Assembler::Condition)opnd_array(1)->ccode(), *L);
  
#line 28265 "ad_aarch64.cpp"
  }
}

void cmpFastLockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// object
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// box
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 15999 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fast_lock(opnd_array(1)->as_Register(ra_,this,idx1)/* object */, opnd_array(2)->as_Register(ra_,this,idx2)/* box */, opnd_array(3)->as_Register(ra_,this,idx3)/* tmp */, opnd_array(4)->as_Register(ra_,this,idx4)/* tmp2 */, opnd_array(5)->as_Register(ra_,this,idx5)/* tmp3 */);
  
#line 28285 "ad_aarch64.cpp"
  }
}

void cmpFastUnlockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// object
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// box
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16015 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fast_unlock(opnd_array(1)->as_Register(ra_,this,idx1)/* object */, opnd_array(2)->as_Register(ra_,this,idx2)/* box */, opnd_array(3)->as_Register(ra_,this,idx3)/* tmp */, opnd_array(4)->as_Register(ra_,this,idx4)/* tmp2 */);
  
#line 28304 "ad_aarch64.cpp"
  }
}

void cmpFastLockLightweightNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// object
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// box
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16031 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fast_lock_lightweight(opnd_array(1)->as_Register(ra_,this,idx1)/* object */, opnd_array(2)->as_Register(ra_,this,idx2)/* box */, opnd_array(3)->as_Register(ra_,this,idx3)/* tmp */, opnd_array(4)->as_Register(ra_,this,idx4)/* tmp2 */);
  
#line 28323 "ad_aarch64.cpp"
  }
}

void cmpFastUnlockLightweightNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// object
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// box
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16047 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ fast_unlock_lightweight(opnd_array(1)->as_Register(ra_,this,idx1)/* object */, opnd_array(2)->as_Register(ra_,this,idx2)/* box */, opnd_array(3)->as_Register(ra_,this,idx3)/* tmp */, opnd_array(4)->as_Register(ra_,this,idx4)/* tmp2 */);
  
#line 28342 "ad_aarch64.cpp"
  }
}

void safePointNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// cr
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16068 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ read_polling_page(as_Register(opnd_array(1)->reg(ra_,this,idx1)/* poll */), relocInfo::poll_type);
  
#line 28358 "ad_aarch64.cpp"
  }
}

void CallStaticJavaDirectNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {

#line 3675 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);

    address addr = (address)opnd_array(1)->method();
    address call;
    if (!_method) {
      // A call to a runtime wrapper, e.g. new, new_typeArray_Java, uncommon_trap.
      call = __ trampoline_call(Address(addr, relocInfo::runtime_call_type));
      if (call == nullptr) {
        ciEnv::current()->record_failure("CodeCache is full");
        return;
      }
    } else if (_method->intrinsic_id() == vmIntrinsicID::_ensureMaterializedForStackWalk) {
      // The NOP here is purely to ensure that eliding a call to
      // JVM_EnsureMaterializedForStackWalk doesn't change the code size.
      __ nop();
      __ block_comment("call JVM_EnsureMaterializedForStackWalk (elided)");
    } else {
      int method_index = resolved_method_index(cbuf);
      RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
                                                  : static_call_Relocation::spec(method_index);
      call = __ trampoline_call(Address(addr, rspec));
      if (call == nullptr) {
        ciEnv::current()->record_failure("CodeCache is full");
        return;
      }
      if (CodeBuffer::supports_shared_stubs() && _method->can_be_statically_bound()) {
        // Calls of the same statically bound method can share
        // a stub to the interpreter.
        cbuf.shared_stub_to_interp_for(_method, call - cbuf.insts_begin());
      } else {
        // Emit stub for static call
        address stub = CompiledDirectCall::emit_to_interp_stub(cbuf, call);
        if (stub == nullptr) {
          ciEnv::current()->record_failure("CodeCache is full");
          return;
        }
      }
    }

    __ post_call_nop();

    // Only non uncommon_trap calls need to reinitialize ptrue.
    if (Compile::current()->max_vector_size() > 0 && uncommon_trap_request() == 0) {
      __ reinitialize_ptrue();
    }
  
#line 28417 "ad_aarch64.cpp"
  }
  {

#line 3737 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    if (VerifyStackAtCalls) {
      // Check that stack depth is unchanged: find majik cookie on stack
      __ call_Unimplemented();
    }
  
#line 28429 "ad_aarch64.cpp"
  }
}

void CallDynamicJavaDirectNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {

#line 3723 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    int method_index = resolved_method_index(cbuf);
    address call = __ ic_call((address)opnd_array(1)->method(), method_index);
    if (call == nullptr) {
      ciEnv::current()->record_failure("CodeCache is full");
      return;
    }
    __ post_call_nop();
    if (Compile::current()->max_vector_size() > 0) {
      __ reinitialize_ptrue();
    }
  
#line 28454 "ad_aarch64.cpp"
  }
  {

#line 3737 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    if (VerifyStackAtCalls) {
      // Check that stack depth is unchanged: find majik cookie on stack
      __ call_Unimplemented();
    }
  
#line 28466 "ad_aarch64.cpp"
  }
}

void CallRuntimeDirectNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {

#line 3745 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);

    // some calls to generated routines (arraycopy code) are scheduled
    // by C2 as runtime calls. if so we can call them using a br (they
    // will be in a reachable segment) otherwise we have to use a blr
    // which loads the absolute address into a register.
    address entry = (address)opnd_array(1)->method();
    CodeBlob *cb = CodeCache::find_blob(entry);
    if (cb) {
      address call = __ trampoline_call(Address(entry, relocInfo::runtime_call_type));
      if (call == nullptr) {
        ciEnv::current()->record_failure("CodeCache is full");
        return;
      }
      __ post_call_nop();
    } else {
      Label retaddr;
      __ adr(rscratch2, retaddr);
      __ lea(rscratch1, RuntimeAddress(entry));
      // Leave a breadcrumb for JavaFrameAnchor::capture_last_Java_pc()
      __ stp(zr, rscratch2, Address(__ pre(sp, -2 * wordSize)));
      __ blr(rscratch1);
      __ bind(retaddr);
      __ post_call_nop();
      __ add(sp, sp, 2 * wordSize);
    }
    if (Compile::current()->max_vector_size() > 0) {
      __ reinitialize_ptrue();
    }
  
#line 28509 "ad_aarch64.cpp"
  }
}

void CallLeafDirectNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {

#line 3745 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);

    // some calls to generated routines (arraycopy code) are scheduled
    // by C2 as runtime calls. if so we can call them using a br (they
    // will be in a reachable segment) otherwise we have to use a blr
    // which loads the absolute address into a register.
    address entry = (address)opnd_array(1)->method();
    CodeBlob *cb = CodeCache::find_blob(entry);
    if (cb) {
      address call = __ trampoline_call(Address(entry, relocInfo::runtime_call_type));
      if (call == nullptr) {
        ciEnv::current()->record_failure("CodeCache is full");
        return;
      }
      __ post_call_nop();
    } else {
      Label retaddr;
      __ adr(rscratch2, retaddr);
      __ lea(rscratch1, RuntimeAddress(entry));
      // Leave a breadcrumb for JavaFrameAnchor::capture_last_Java_pc()
      __ stp(zr, rscratch2, Address(__ pre(sp, -2 * wordSize)));
      __ blr(rscratch1);
      __ bind(retaddr);
      __ post_call_nop();
      __ add(sp, sp, 2 * wordSize);
    }
    if (Compile::current()->max_vector_size() > 0) {
      __ reinitialize_ptrue();
    }
  
#line 28552 "ad_aarch64.cpp"
  }
}

void CallLeafNoFPDirectNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {

#line 3745 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);

    // some calls to generated routines (arraycopy code) are scheduled
    // by C2 as runtime calls. if so we can call them using a br (they
    // will be in a reachable segment) otherwise we have to use a blr
    // which loads the absolute address into a register.
    address entry = (address)opnd_array(1)->method();
    CodeBlob *cb = CodeCache::find_blob(entry);
    if (cb) {
      address call = __ trampoline_call(Address(entry, relocInfo::runtime_call_type));
      if (call == nullptr) {
        ciEnv::current()->record_failure("CodeCache is full");
        return;
      }
      __ post_call_nop();
    } else {
      Label retaddr;
      __ adr(rscratch2, retaddr);
      __ lea(rscratch1, RuntimeAddress(entry));
      // Leave a breadcrumb for JavaFrameAnchor::capture_last_Java_pc()
      __ stp(zr, rscratch2, Address(__ pre(sp, -2 * wordSize)));
      __ blr(rscratch1);
      __ bind(retaddr);
      __ post_call_nop();
      __ add(sp, sp, 2 * wordSize);
    }
    if (Compile::current()->max_vector_size() > 0) {
      __ reinitialize_ptrue();
    }
  
#line 28595 "ad_aarch64.cpp"
  }
}

void TailCalljmpIndNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// method_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// 
  {

#line 3792 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register target_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* jump_target */);
    __ br(target_reg);
  
#line 28613 "ad_aarch64.cpp"
  }
}

void TailjmpIndNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// ex_oop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// 
  {

#line 3798 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    Register target_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* jump_target */);
    // exception oop should be in r0
    // ret addr has been popped into lr
    // callee expects it in r3
    __ mov(r3, lr);
    __ br(target_reg);
  
#line 28635 "ad_aarch64.cpp"
  }
}

void CreateExceptionNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  // User did not define which encode class to use.
}

uint CreateExceptionNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void RethrowExceptionNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// 
  {

#line 3777 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
    __ far_jump(RuntimeAddress(OptoRuntime::rethrow_stub()));
  
#line 28664 "ad_aarch64.cpp"
  }
}

void RetNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// 
  {

#line 3782 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    C2_MacroAssembler _masm(&cbuf);
#ifdef ASSERT
    if (Compile::current()->max_vector_size() > 0) {
      __ verify_ptrue();
    }
#endif
    __ ret(lr);
  
#line 28685 "ad_aarch64.cpp"
  }
}

void ShouldNotReachHereNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// 
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16248 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    if (is_reachable()) {
      __ stop(_halt_reason);
    }
  
#line 28703 "ad_aarch64.cpp"
  }
}

void partialSubtypeCheckNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// sub
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// super
  {

#line 3658 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     Register sub_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* sub */);
     Register super_reg = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* super */);
     Register temp_reg = as_Register(R2_enc);
     Register result_reg = as_Register(opnd_array(0)->reg(ra_,this)/* result */);

     Label miss;
     C2_MacroAssembler _masm(&cbuf);
     __ check_klass_subtype_slow_path(sub_reg, super_reg, temp_reg, result_reg,
                                     nullptr, &miss,
                                     /*set_cond_codes:*/ true);
     if ((0x1 /*primary()*/)) {
       __ mov(result_reg, zr);
     }
     __ bind(miss);
  
#line 28732 "ad_aarch64.cpp"
  }
}

void partialSubtypeCheckVsZeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// sub
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// super
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  {

#line 3658 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

     Register sub_reg = as_Register(opnd_array(1)->reg(ra_,this,idx1)/* sub */);
     Register super_reg = as_Register(opnd_array(2)->reg(ra_,this,idx2)/* super */);
     Register temp_reg = as_Register(R2_enc);
     Register result_reg = as_Register(R5_enc);

     Label miss;
     C2_MacroAssembler _masm(&cbuf);
     __ check_klass_subtype_slow_path(sub_reg, super_reg, temp_reg, result_reg,
                                     nullptr, &miss,
                                     /*set_cond_codes:*/ true);
     if ((0x0 /*primary()*/)) {
       __ mov(result_reg, zr);
     }
     __ bind(miss);
  
#line 28762 "ad_aarch64.cpp"
  }
}

void string_compareUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16305 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    // Count is in 8-bit bytes; non-Compact chars are 16 bits.
    __ string_compare(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */, opnd_array(0)->as_Register(ra_,this)/* result */,
                      as_Register(R10_enc), as_Register(R11_enc),
                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::UU);
  
#line 28785 "ad_aarch64.cpp"
  }
}

void string_compareLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16323 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ string_compare(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */, opnd_array(0)->as_Register(ra_,this)/* result */,
                      as_Register(R10_enc), as_Register(R11_enc),
                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::LL);
  
#line 28807 "ad_aarch64.cpp"
  }
}

void string_compareULNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16342 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ string_compare(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */, opnd_array(0)->as_Register(ra_,this)/* result */,
                      as_Register(R10_enc), as_Register(R11_enc),
                      as_FloatRegister(V0_enc), as_FloatRegister(V1_enc),
                      as_FloatRegister(V2_enc), pnoreg, pnoreg, StrIntrinsicNode::UL);
  
#line 28830 "ad_aarch64.cpp"
  }
}

void string_compareLUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16362 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ string_compare(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */, opnd_array(0)->as_Register(ra_,this)/* result */,
                      as_Register(R10_enc), as_Register(R11_enc),
                      as_FloatRegister(V0_enc), as_FloatRegister(V1_enc),
                      as_FloatRegister(V2_enc), pnoreg, pnoreg, StrIntrinsicNode::LU);
  
#line 28853 "ad_aarch64.cpp"
  }
}

void string_compareLL_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// vtmp1
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// vtmp2
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// pgtmp1
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// pgtmp2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16387 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    // Count is in 8-bit bytes; non-Compact chars are 16 bits.
    __ string_compare(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */, opnd_array(0)->as_Register(ra_,this)/* result */,
                      opnd_array(5)->as_Register(ra_,this,idx5)/* tmp1 */, opnd_array(6)->as_Register(ra_,this,idx6)/* tmp2 */,
                      opnd_array(7)->as_FloatRegister(ra_,this,idx7)/* vtmp1 */, opnd_array(8)->as_FloatRegister(ra_,this,idx8)/* vtmp2 */, fnoreg,
                      as_PRegister(opnd_array(9)->reg(ra_,this,idx9)/* pgtmp1 */), as_PRegister(opnd_array(10)->reg(ra_,this,idx10)/* pgtmp2 */),
                      StrIntrinsicNode::LL);
  
#line 28884 "ad_aarch64.cpp"
  }
}

void string_compareLU_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// vtmp1
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// vtmp2
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// pgtmp1
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// pgtmp2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16410 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    // Count is in 8-bit bytes; non-Compact chars are 16 bits.
    __ string_compare(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */, opnd_array(0)->as_Register(ra_,this)/* result */,
                      opnd_array(5)->as_Register(ra_,this,idx5)/* tmp1 */, opnd_array(6)->as_Register(ra_,this,idx6)/* tmp2 */,
                      opnd_array(7)->as_FloatRegister(ra_,this,idx7)/* vtmp1 */, opnd_array(8)->as_FloatRegister(ra_,this,idx8)/* vtmp2 */, fnoreg,
                      as_PRegister(opnd_array(9)->reg(ra_,this,idx9)/* pgtmp1 */), as_PRegister(opnd_array(10)->reg(ra_,this,idx10)/* pgtmp2 */),
                      StrIntrinsicNode::LU);
  
#line 28915 "ad_aarch64.cpp"
  }
}

void string_compareUL_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// vtmp1
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// vtmp2
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// pgtmp1
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// pgtmp2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16433 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    // Count is in 8-bit bytes; non-Compact chars are 16 bits.
    __ string_compare(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */, opnd_array(0)->as_Register(ra_,this)/* result */,
                      opnd_array(5)->as_Register(ra_,this,idx5)/* tmp1 */, opnd_array(6)->as_Register(ra_,this,idx6)/* tmp2 */,
                      opnd_array(7)->as_FloatRegister(ra_,this,idx7)/* vtmp1 */, opnd_array(8)->as_FloatRegister(ra_,this,idx8)/* vtmp2 */, fnoreg,
                      as_PRegister(opnd_array(9)->reg(ra_,this,idx9)/* pgtmp1 */), as_PRegister(opnd_array(10)->reg(ra_,this,idx10)/* pgtmp2 */),
                      StrIntrinsicNode::UL);
  
#line 28946 "ad_aarch64.cpp"
  }
}

void string_compareUU_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// vtmp1
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// vtmp2
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// pgtmp1
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// pgtmp2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16456 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    // Count is in 8-bit bytes; non-Compact chars are 16 bits.
    __ string_compare(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */, opnd_array(0)->as_Register(ra_,this)/* result */,
                      opnd_array(5)->as_Register(ra_,this,idx5)/* tmp1 */, opnd_array(6)->as_Register(ra_,this,idx6)/* tmp2 */,
                      opnd_array(7)->as_FloatRegister(ra_,this,idx7)/* vtmp1 */, opnd_array(8)->as_FloatRegister(ra_,this,idx8)/* vtmp2 */, fnoreg,
                      as_PRegister(opnd_array(9)->reg(ra_,this,idx9)/* pgtmp1 */), as_PRegister(opnd_array(10)->reg(ra_,this,idx10)/* pgtmp2 */),
                      StrIntrinsicNode::UU);
  
#line 28977 "ad_aarch64.cpp"
  }
}

void string_indexofUUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp3
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// tmp4
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// tmp5
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// tmp6
  unsigned idx11 = idx10 + opnd_array(10)->num_edges(); 	// vtmp0
  unsigned idx12 = idx11 + opnd_array(11)->num_edges(); 	// vtmp1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16481 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ string_indexof(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */,
                      opnd_array(5)->as_Register(ra_,this,idx5)/* tmp1 */, opnd_array(6)->as_Register(ra_,this,idx6)/* tmp2 */,
                      opnd_array(7)->as_Register(ra_,this,idx7)/* tmp3 */, opnd_array(8)->as_Register(ra_,this,idx8)/* tmp4 */,
                      opnd_array(9)->as_Register(ra_,this,idx9)/* tmp5 */, opnd_array(10)->as_Register(ra_,this,idx10)/* tmp6 */,
                      -1, opnd_array(0)->as_Register(ra_,this)/* result */, StrIntrinsicNode::UU);
  
#line 29009 "ad_aarch64.cpp"
  }
}

void string_indexofLLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp3
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// tmp4
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// tmp5
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// tmp6
  unsigned idx11 = idx10 + opnd_array(10)->num_edges(); 	// vtmp0
  unsigned idx12 = idx11 + opnd_array(11)->num_edges(); 	// vtmp1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16505 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ string_indexof(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */,
                      opnd_array(5)->as_Register(ra_,this,idx5)/* tmp1 */, opnd_array(6)->as_Register(ra_,this,idx6)/* tmp2 */,
                      opnd_array(7)->as_Register(ra_,this,idx7)/* tmp3 */, opnd_array(8)->as_Register(ra_,this,idx8)/* tmp4 */,
                      opnd_array(9)->as_Register(ra_,this,idx9)/* tmp5 */, opnd_array(10)->as_Register(ra_,this,idx10)/* tmp6 */,
                      -1, opnd_array(0)->as_Register(ra_,this)/* result */, StrIntrinsicNode::LL);
  
#line 29041 "ad_aarch64.cpp"
  }
}

void string_indexofULNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp3
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// tmp4
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// tmp5
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// tmp6
  unsigned idx11 = idx10 + opnd_array(10)->num_edges(); 	// vtmp0
  unsigned idx12 = idx11 + opnd_array(11)->num_edges(); 	// vtmp1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16529 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ string_indexof(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */,
                      opnd_array(5)->as_Register(ra_,this,idx5)/* tmp1 */, opnd_array(6)->as_Register(ra_,this,idx6)/* tmp2 */,
                      opnd_array(7)->as_Register(ra_,this,idx7)/* tmp3 */, opnd_array(8)->as_Register(ra_,this,idx8)/* tmp4 */,
                      opnd_array(9)->as_Register(ra_,this,idx9)/* tmp5 */, opnd_array(10)->as_Register(ra_,this,idx10)/* tmp6 */,
                      -1, opnd_array(0)->as_Register(ra_,this)/* result */, StrIntrinsicNode::UL);
  
#line 29073 "ad_aarch64.cpp"
  }
}

void string_indexof_conUUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// int_cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp3
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// tmp4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16551 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int icnt2 = (int)opnd_array(4)->constant();
    __ string_indexof(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, zr,
                      opnd_array(5)->as_Register(ra_,this,idx5)/* tmp1 */, opnd_array(6)->as_Register(ra_,this,idx6)/* tmp2 */,
                      opnd_array(7)->as_Register(ra_,this,idx7)/* tmp3 */, opnd_array(8)->as_Register(ra_,this,idx8)/* tmp4 */, zr, zr,
                      icnt2, opnd_array(0)->as_Register(ra_,this)/* result */, StrIntrinsicNode::UU);
  
#line 29101 "ad_aarch64.cpp"
  }
}

void string_indexof_conLLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// int_cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp3
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// tmp4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16573 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int icnt2 = (int)opnd_array(4)->constant();
    __ string_indexof(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, zr,
                      opnd_array(5)->as_Register(ra_,this,idx5)/* tmp1 */, opnd_array(6)->as_Register(ra_,this,idx6)/* tmp2 */,
                      opnd_array(7)->as_Register(ra_,this,idx7)/* tmp3 */, opnd_array(8)->as_Register(ra_,this,idx8)/* tmp4 */, zr, zr,
                      icnt2, opnd_array(0)->as_Register(ra_,this)/* result */, StrIntrinsicNode::LL);
  
#line 29129 "ad_aarch64.cpp"
  }
}

void string_indexof_conULNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// int_cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp3
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// tmp4
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16595 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    int icnt2 = (int)opnd_array(4)->constant();
    __ string_indexof(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, zr,
                      opnd_array(5)->as_Register(ra_,this,idx5)/* tmp1 */, opnd_array(6)->as_Register(ra_,this,idx6)/* tmp2 */,
                      opnd_array(7)->as_Register(ra_,this,idx7)/* tmp3 */, opnd_array(8)->as_Register(ra_,this,idx8)/* tmp4 */, zr, zr,
                      icnt2, opnd_array(0)->as_Register(ra_,this)/* result */, StrIntrinsicNode::UL);
  
#line 29157 "ad_aarch64.cpp"
  }
}

void string_indexof_charNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ch
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16617 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ string_indexof_char(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* ch */,
                           opnd_array(0)->as_Register(ra_,this)/* result */, opnd_array(4)->as_Register(ra_,this,idx4)/* tmp1 */, opnd_array(5)->as_Register(ra_,this,idx5)/* tmp2 */,
                           opnd_array(6)->as_Register(ra_,this,idx6)/* tmp3 */);
  
#line 29180 "ad_aarch64.cpp"
  }
}

void stringL_indexof_charNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ch
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16636 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ stringL_indexof_char(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* ch */,
                            opnd_array(0)->as_Register(ra_,this)/* result */, opnd_array(4)->as_Register(ra_,this,idx4)/* tmp1 */, opnd_array(5)->as_Register(ra_,this,idx5)/* tmp2 */,
                            opnd_array(6)->as_Register(ra_,this,idx6)/* tmp3 */);
  
#line 29203 "ad_aarch64.cpp"
  }
}

void stringL_indexof_char_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ch
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// ztmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ztmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// pgtmp
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// ptmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16651 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ string_indexof_char_sve(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* ch */,
                               opnd_array(0)->as_Register(ra_,this)/* result */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* ztmp1 */,
                               opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* ztmp2 */, opnd_array(6)->as_PRegister(ra_,this,idx6)/* pgtmp */,
                               opnd_array(7)->as_PRegister(ra_,this,idx7)/* ptmp */, true /* isL */);
  
#line 29228 "ad_aarch64.cpp"
  }
}

void stringU_indexof_char_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ch
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// ztmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ztmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// pgtmp
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// ptmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16667 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ string_indexof_char_sve(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* ch */,
                               opnd_array(0)->as_Register(ra_,this)/* result */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* ztmp1 */,
                               opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* ztmp2 */, opnd_array(6)->as_PRegister(ra_,this,idx6)/* pgtmp */,
                               opnd_array(7)->as_PRegister(ra_,this,idx7)/* ptmp */, false /* isL */);
  
#line 29253 "ad_aarch64.cpp"
  }
}

void string_equalsLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// str2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cnt
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16684 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    // Count is in 8-bit bytes; non-Compact chars are 16 bits.
    __ string_equals(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* str2 */,
                     opnd_array(0)->as_Register(ra_,this)/* result */, opnd_array(3)->as_Register(ra_,this,idx3)/* cnt */);
  
#line 29273 "ad_aarch64.cpp"
  }
}

void array_equalsBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// ary1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// ary2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp3
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// vtmp0
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// vtmp1
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// vtmp2
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// vtmp3
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// vtmp4
  unsigned idx11 = idx10 + opnd_array(10)->num_edges(); 	// vtmp5
  unsigned idx12 = idx11 + opnd_array(11)->num_edges(); 	// vtmp6
  unsigned idx13 = idx12 + opnd_array(12)->num_edges(); 	// vtmp7
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16705 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    address tpc = __ arrays_equals(opnd_array(1)->as_Register(ra_,this,idx1)/* ary1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* ary2 */,
                                   opnd_array(3)->as_Register(ra_,this,idx3)/* tmp1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* tmp2 */, opnd_array(5)->as_Register(ra_,this,idx5)/* tmp3 */,
                                   opnd_array(0)->as_Register(ra_,this)/* result */, as_Register(R10_enc), 1);
    if (tpc == nullptr) {
      ciEnv::current()->record_failure("CodeCache is full");
      return;
    }
  
#line 29307 "ad_aarch64.cpp"
  }
}

void array_equalsCNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// ary1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// ary2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp3
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// vtmp0
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// vtmp1
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// vtmp2
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// vtmp3
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// vtmp4
  unsigned idx11 = idx10 + opnd_array(10)->num_edges(); 	// vtmp5
  unsigned idx12 = idx11 + opnd_array(11)->num_edges(); 	// vtmp6
  unsigned idx13 = idx12 + opnd_array(12)->num_edges(); 	// vtmp7
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16730 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    address tpc = __ arrays_equals(opnd_array(1)->as_Register(ra_,this,idx1)/* ary1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* ary2 */,
                                   opnd_array(3)->as_Register(ra_,this,idx3)/* tmp1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* tmp2 */, opnd_array(5)->as_Register(ra_,this,idx5)/* tmp3 */,
                                   opnd_array(0)->as_Register(ra_,this)/* result */, as_Register(R10_enc), 2);
    if (tpc == nullptr) {
      ciEnv::current()->record_failure("CodeCache is full");
      return;
    }
  
#line 29341 "ad_aarch64.cpp"
  }
}

void count_positivesNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// ary1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// len
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16747 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    address tpc = __ count_positives(opnd_array(1)->as_Register(ra_,this,idx1)/* ary1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* len */, opnd_array(0)->as_Register(ra_,this)/* result */);
    if (tpc == nullptr) {
      ciEnv::current()->record_failure("CodeCache is full");
      return;
    }
  
#line 29362 "ad_aarch64.cpp"
  }
}

void string_compressNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// len
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp0
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// vtmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// vtmp3
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// vtmp4
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// vtmp5
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16768 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ char_array_compress(opnd_array(1)->as_Register(ra_,this,idx1)/* src */, opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, opnd_array(3)->as_Register(ra_,this,idx3)/* len */,
                           opnd_array(0)->as_Register(ra_,this)/* result */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* vtmp0 */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* vtmp1 */,
                           opnd_array(6)->as_FloatRegister(ra_,this,idx6)/* vtmp2 */, opnd_array(7)->as_FloatRegister(ra_,this,idx7)/* vtmp3 */,
                           opnd_array(8)->as_FloatRegister(ra_,this,idx8)/* vtmp4 */, opnd_array(9)->as_FloatRegister(ra_,this,idx9)/* vtmp5 */);
  
#line 29389 "ad_aarch64.cpp"
  }
}

void string_inflateNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// len
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp0
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// vtmp1
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// vtmp2
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// vtmp3
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// vtmp4
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// vtmp5
  unsigned idx11 = idx10 + opnd_array(10)->num_edges(); 	// vtmp6
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16788 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    address tpc = __ byte_array_inflate(opnd_array(1)->as_Register(ra_,this,idx1)/* src */, opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, opnd_array(3)->as_Register(ra_,this,idx3)/* len */,
                                        opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* vtmp0 */, opnd_array(6)->as_FloatRegister(ra_,this,idx6)/* vtmp1 */,
                                        opnd_array(7)->as_FloatRegister(ra_,this,idx7)/* vtmp2 */, opnd_array(4)->as_Register(ra_,this,idx4)/* tmp */);
    if (tpc == nullptr) {
      ciEnv::current()->record_failure("CodeCache is full");
      return;
    }
  
#line 29421 "ad_aarch64.cpp"
  }
}

void encode_iso_arrayNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// len
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16812 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ encode_iso_array(opnd_array(1)->as_Register(ra_,this,idx1)/* src */, opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, opnd_array(3)->as_Register(ra_,this,idx3)/* len */,
                        opnd_array(0)->as_Register(ra_,this)/* result */, false,
                        as_FloatRegister(V0_enc), as_FloatRegister(V1_enc),
                        as_FloatRegister(V2_enc), as_FloatRegister(V3_enc),
                        as_FloatRegister(V4_enc), as_FloatRegister(V5_enc));
  
#line 29443 "ad_aarch64.cpp"
  }
}

void encode_ascii_arrayNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// len
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16833 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ encode_iso_array(opnd_array(1)->as_Register(ra_,this,idx1)/* src */, opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, opnd_array(3)->as_Register(ra_,this,idx3)/* len */,
                        opnd_array(0)->as_Register(ra_,this)/* result */, true,
                        as_FloatRegister(V0_enc), as_FloatRegister(V1_enc),
                        as_FloatRegister(V2_enc), as_FloatRegister(V3_enc),
                        as_FloatRegister(V4_enc), as_FloatRegister(V5_enc));
  
#line 29465 "ad_aarch64.cpp"
  }
}

void compressBitsI_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tdst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tsrc
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16854 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ mov(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, __ S, 0, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ mov(opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */, __ S, 0, opnd_array(2)->as_Register(ra_,this,idx2)/* mask */);
    __ sve_bext(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ S, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */);
    __ mov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ S, 0);
  
#line 29488 "ad_aarch64.cpp"
  }
}

void compressBitsI_memconNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tdst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tsrc
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16872 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrs, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, opnd_array(1)->opcode(),
              as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
    __ ldrs(opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ sve_bext(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ S, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */);
    __ mov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ S, 0);
  
#line 29512 "ad_aarch64.cpp"
  }
}

void compressBitsI_memconNode::eval_constant(Compile* C) {
  {

#line 16875 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"
    _constant = C->output()->constant_table().add(this, opnd_array(2));
#line 29521 "ad_aarch64.cpp"
  }
}
void compressBitsL_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tdst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tsrc
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16891 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ mov(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, __ D, 0, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ mov(opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */, __ D, 0, opnd_array(2)->as_Register(ra_,this,idx2)/* mask */);
    __ sve_bext(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ D, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */);
    __ mov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ D, 0);
  
#line 29543 "ad_aarch64.cpp"
  }
}

void compressBitsL_memconNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tdst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tsrc
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16909 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrd, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, opnd_array(1)->opcode(),
              as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 8);
    __ ldrd(opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ sve_bext(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ D, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */);
    __ mov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ D, 0);
  
#line 29567 "ad_aarch64.cpp"
  }
}

void compressBitsL_memconNode::eval_constant(Compile* C) {
  {

#line 16912 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"
    _constant = C->output()->constant_table().add(this, opnd_array(2));
#line 29576 "ad_aarch64.cpp"
  }
}
void expandBitsI_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tdst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tsrc
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16928 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ mov(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, __ S, 0, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ mov(opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */, __ S, 0, opnd_array(2)->as_Register(ra_,this,idx2)/* mask */);
    __ sve_bdep(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ S, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */);
    __ mov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ S, 0);
  
#line 29598 "ad_aarch64.cpp"
  }
}

void expandBitsI_memconNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tdst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tsrc
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16946 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrs, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, opnd_array(1)->opcode(),
              as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 4);
    __ ldrs(opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ sve_bdep(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ S, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */);
    __ mov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ S, 0);
  
#line 29622 "ad_aarch64.cpp"
  }
}

void expandBitsI_memconNode::eval_constant(Compile* C) {
  {

#line 16949 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"
    _constant = C->output()->constant_table().add(this, opnd_array(2));
#line 29631 "ad_aarch64.cpp"
  }
}
void expandBitsL_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tdst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tsrc
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16965 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    __ mov(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, __ D, 0, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ mov(opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */, __ D, 0, opnd_array(2)->as_Register(ra_,this,idx2)/* mask */);
    __ sve_bdep(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ D, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */);
    __ mov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ D, 0);
  
#line 29653 "ad_aarch64.cpp"
  }
}

void expandBitsL_memconNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tdst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tsrc
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmask
  {
    C2_MacroAssembler _masm(&cbuf);

#line 16984 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrd, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, opnd_array(1)->opcode(),
              as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), 8);
    __ ldrd(opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ sve_bdep(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ D, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tsrc */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmask */);
    __ mov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tdst */, __ D, 0);
  
#line 29677 "ad_aarch64.cpp"
  }
}

void expandBitsL_memconNode::eval_constant(Compile* C) {
  {

#line 16987 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"
    _constant = C->output()->constant_table().add(this, opnd_array(2));
#line 29686 "ad_aarch64.cpp"
  }
}
void tlsLoadPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  // User did not define which encode class to use.
}

uint tlsLoadPNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void loadV2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3042 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister dst_reg = as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, MacroAssembler::H,
       opnd_array(1)->opcode(), as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 29715 "ad_aarch64.cpp"
  }
}

void storeV2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 3066 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister src_reg = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, MacroAssembler::H,
       opnd_array(1)->opcode(), as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 29733 "ad_aarch64.cpp"
  }
}

void loadV4Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3048 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister dst_reg = as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, MacroAssembler::S,
       opnd_array(1)->opcode(), as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 29750 "ad_aarch64.cpp"
  }
}

void storeV4Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 3072 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister src_reg = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, MacroAssembler::S,
       opnd_array(1)->opcode(), as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 29768 "ad_aarch64.cpp"
  }
}

void loadV8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3054 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister dst_reg = as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, MacroAssembler::D,
       opnd_array(1)->opcode(), as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 29785 "ad_aarch64.cpp"
  }
}

void storeV8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 3078 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister src_reg = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, MacroAssembler::D,
       opnd_array(1)->opcode(), as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 29803 "ad_aarch64.cpp"
  }
}

void loadV16Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 3060 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister dst_reg = as_FloatRegister(opnd_array(0)->reg(ra_,this)/* dst */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, MacroAssembler::Q,
       opnd_array(1)->opcode(), as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 29820 "ad_aarch64.cpp"
  }
}

void storeV16Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 3084 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    FloatRegister src_reg = as_FloatRegister(opnd_array(2)->reg(ra_,this,idx2)/* src */);
    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, MacroAssembler::Q,
       opnd_array(1)->opcode(), as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 29838 "ad_aarch64.cpp"
  }
}

void loadVNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    C2_MacroAssembler _masm(&cbuf);

#line 420 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    loadStoreA_predicated(C2_MacroAssembler(&cbuf), /* is_store */ false,
                          opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, ptrue, bt, bt, opnd_array(1)->opcode(),
                          as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 29860 "ad_aarch64.cpp"
  }
}

void storeVNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 437 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    loadStoreA_predicated(C2_MacroAssembler(&cbuf), /* is_store */ true,
                          opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, ptrue, bt, bt, opnd_array(1)->opcode(),
                          as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 29883 "ad_aarch64.cpp"
  }
}

void loadV_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 455 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    loadStoreA_predicated(C2_MacroAssembler(&cbuf), /* is_store */ false, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */,
                          opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, bt, bt, opnd_array(1)->opcode(),
                          as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 29903 "ad_aarch64.cpp"
  }
}

void storeV_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 468 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    loadStoreA_predicated(C2_MacroAssembler(&cbuf), /* is_store */ true, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */,
                          opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, bt, bt, opnd_array(1)->opcode(),
                          as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 29924 "ad_aarch64.cpp"
  }
}

void vloadconNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 482 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    if (UseSVE == 0) {
      uint length_in_bytes = Matcher::vector_length_in_bytes(this);
      assert(length_in_bytes <= 16, "must be");
      // The iota indices are ordered by type B/S/I/L/F/D, and the offset between two types is 16.
      int offset = exact_log2(type2aelembytes(bt)) << 4;
      if (is_floating_point_type(bt)) {
        offset += 32;
      }
      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices() + offset));
      if (length_in_bytes == 16) {
        __ ldrq(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, rscratch1);
      } else {
        __ ldrd(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, rscratch1);
      }
    } else {
      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
      __ sve_index(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, size, 0, 1);
      if (is_floating_point_type(bt)) {
        __ sve_scvtf(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, size, ptrue, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, size);
      }
    }
  
#line 29961 "ad_aarch64.cpp"
  }
}

void vaddBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 516 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ addv(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_add(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ B, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 29985 "ad_aarch64.cpp"
  }
}

void vaddSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 532 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ addv(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_add(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ H, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 30009 "ad_aarch64.cpp"
  }
}

void vaddINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 548 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ addv(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_add(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 30033 "ad_aarch64.cpp"
  }
}

void vaddLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 564 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ addv(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_add(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 30057 "ad_aarch64.cpp"
  }
}

void vaddFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 580 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fadd(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_fadd(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 30081 "ad_aarch64.cpp"
  }
}

void vaddDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 596 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fadd(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_fadd(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 30105 "ad_aarch64.cpp"
  }
}

void vaddB_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 615 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_add(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ B, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30123 "ad_aarch64.cpp"
  }
}

void vaddS_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 625 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_add(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ H, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30141 "ad_aarch64.cpp"
  }
}

void vaddI_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 635 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_add(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ S, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30159 "ad_aarch64.cpp"
  }
}

void vaddL_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 645 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_add(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ D, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30177 "ad_aarch64.cpp"
  }
}

void vaddF_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 655 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fadd(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ S, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30195 "ad_aarch64.cpp"
  }
}

void vaddD_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 665 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fadd(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ D, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30213 "ad_aarch64.cpp"
  }
}

void vaddImmBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 677 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    int val = (int)opnd_array(2)->constant();
    if (val > 0) {
      __ sve_add(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ B, val);
    } else {
      __ sve_sub(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ B, -val);
    }
  
#line 30235 "ad_aarch64.cpp"
  }
}

void vaddImmB_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 677 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    int val = (int)opnd_array(1)->constant();
    if (val > 0) {
      __ sve_add(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ B, val);
    } else {
      __ sve_sub(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ B, -val);
    }
  
#line 30257 "ad_aarch64.cpp"
  }
}

void vaddImmSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 692 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    int val = (int)opnd_array(2)->constant();
    if (val > 0) {
      __ sve_add(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ H, val);
    } else {
      __ sve_sub(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ H, -val);
    }
  
#line 30279 "ad_aarch64.cpp"
  }
}

void vaddImmS_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 692 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    int val = (int)opnd_array(1)->constant();
    if (val > 0) {
      __ sve_add(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ H, val);
    } else {
      __ sve_sub(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ H, -val);
    }
  
#line 30301 "ad_aarch64.cpp"
  }
}

void vaddImmINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 707 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    int val = (int)opnd_array(2)->constant();
    if (val > 0) {
      __ sve_add(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ S, val);
    } else {
      __ sve_sub(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ S, -val);
    }
  
#line 30323 "ad_aarch64.cpp"
  }
}

void vaddImmI_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 707 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    int val = (int)opnd_array(1)->constant();
    if (val > 0) {
      __ sve_add(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ S, val);
    } else {
      __ sve_sub(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ S, -val);
    }
  
#line 30345 "ad_aarch64.cpp"
  }
}

void vaddImmLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 722 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    int val = (int)opnd_array(2)->constantL();
    if (val > 0) {
      __ sve_add(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ D, val);
    } else {
      __ sve_sub(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ D, -val);
    }
  
#line 30367 "ad_aarch64.cpp"
  }
}

void vaddImmL_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 722 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    int val = (int)opnd_array(1)->constantL();
    if (val > 0) {
      __ sve_add(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ D, val);
    } else {
      __ sve_sub(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ D, -val);
    }
  
#line 30389 "ad_aarch64.cpp"
  }
}

void vsubBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 740 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ subv(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_sub(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ B, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 30413 "ad_aarch64.cpp"
  }
}

void vsubSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 756 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ subv(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_sub(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ H, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 30437 "ad_aarch64.cpp"
  }
}

void vsubINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 772 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ subv(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_sub(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 30461 "ad_aarch64.cpp"
  }
}

void vsubLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 788 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ subv(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_sub(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 30485 "ad_aarch64.cpp"
  }
}

void vsubFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 804 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fsub(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_fsub(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 30509 "ad_aarch64.cpp"
  }
}

void vsubDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 820 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fsub(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_fsub(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 30533 "ad_aarch64.cpp"
  }
}

void vsubB_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 839 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_sub(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ B, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30551 "ad_aarch64.cpp"
  }
}

void vsubS_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 849 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_sub(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ H, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30569 "ad_aarch64.cpp"
  }
}

void vsubI_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 859 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_sub(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ S, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30587 "ad_aarch64.cpp"
  }
}

void vsubL_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 869 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_sub(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ D, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30605 "ad_aarch64.cpp"
  }
}

void vsubF_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 879 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fsub(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ S, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30623 "ad_aarch64.cpp"
  }
}

void vsubD_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 889 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fsub(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ D, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30641 "ad_aarch64.cpp"
  }
}

void vmulB_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 903 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ mulv(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30659 "ad_aarch64.cpp"
  }
}

void vmulB_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 914 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_mul(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ B, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30677 "ad_aarch64.cpp"
  }
}

void vmulS_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 925 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ mulv(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30695 "ad_aarch64.cpp"
  }
}

void vmulS_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 936 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_mul(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ H, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30713 "ad_aarch64.cpp"
  }
}

void vmulI_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 947 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ mulv(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30731 "ad_aarch64.cpp"
  }
}

void vmulI_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 958 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_mul(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ S, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30749 "ad_aarch64.cpp"
  }
}

void vmulL_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 971 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == 16, "must be");
    __ umov(rscratch1, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, __ D, 0);
    __ umov(rscratch2, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, __ D, 0);
    __ mul(rscratch2, rscratch2, rscratch1);
    __ mov(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, 0, rscratch2);
    __ umov(rscratch1, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, __ D, 1);
    __ umov(rscratch2, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, __ D, 1);
    __ mul(rscratch2, rscratch2, rscratch1);
    __ mov(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, 1, rscratch2);
  
#line 30775 "ad_aarch64.cpp"
  }
}

void vmulL_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 990 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_mul(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ D, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30792 "ad_aarch64.cpp"
  }
}

void vmulFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1001 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fmul(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_fmul(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 30816 "ad_aarch64.cpp"
  }
}

void vmulDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1017 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fmul(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_fmul(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 30840 "ad_aarch64.cpp"
  }
}

void vmulB_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1036 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_mul(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ B, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30858 "ad_aarch64.cpp"
  }
}

void vmulS_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1046 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_mul(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ H, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30876 "ad_aarch64.cpp"
  }
}

void vmulI_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1056 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_mul(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ S, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30894 "ad_aarch64.cpp"
  }
}

void vmulL_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1066 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_mul(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ D, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30912 "ad_aarch64.cpp"
  }
}

void vmulF_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1076 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fmul(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ S, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30930 "ad_aarch64.cpp"
  }
}

void vmulD_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1086 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fmul(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ D, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30948 "ad_aarch64.cpp"
  }
}

void vdivF_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1100 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ fdiv(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30966 "ad_aarch64.cpp"
  }
}

void vdivF_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1111 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_fdiv(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ S, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 30984 "ad_aarch64.cpp"
  }
}

void vdivD_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1122 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ fdiv(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 31002 "ad_aarch64.cpp"
  }
}

void vdivD_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1133 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_fdiv(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ D, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 31020 "ad_aarch64.cpp"
  }
}

void vdivF_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1146 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fdiv(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ S, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 31038 "ad_aarch64.cpp"
  }
}

void vdivD_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1156 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fdiv(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ D, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 31056 "ad_aarch64.cpp"
  }
}

void vandNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1169 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ andr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_and(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 31080 "ad_aarch64.cpp"
  }
}

void vand_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1188 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_and(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 31100 "ad_aarch64.cpp"
  }
}

void vandImmBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1202 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_and(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ B, (uint64_t)(opnd_array(2)->constant()));
  
#line 31117 "ad_aarch64.cpp"
  }
}

void vandImmB_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1202 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_and(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ B, (uint64_t)(opnd_array(1)->constant()));
  
#line 31134 "ad_aarch64.cpp"
  }
}

void vandImmSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1212 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_and(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ H, (uint64_t)(opnd_array(2)->constant()));
  
#line 31151 "ad_aarch64.cpp"
  }
}

void vandImmS_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1212 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_and(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ H, (uint64_t)(opnd_array(1)->constant()));
  
#line 31168 "ad_aarch64.cpp"
  }
}

void vandImmINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1222 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_and(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ S, (uint64_t)(opnd_array(2)->constant()));
  
#line 31185 "ad_aarch64.cpp"
  }
}

void vandImmI_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1222 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_and(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ S, (uint64_t)(opnd_array(1)->constant()));
  
#line 31202 "ad_aarch64.cpp"
  }
}

void vandImmLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1232 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_and(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ D, (uint64_t)(opnd_array(2)->constantL()));
  
#line 31219 "ad_aarch64.cpp"
  }
}

void vandImmL_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1232 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_and(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ D, (uint64_t)(opnd_array(1)->constantL()));
  
#line 31236 "ad_aarch64.cpp"
  }
}

void vorNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1245 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ orr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_orr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 31260 "ad_aarch64.cpp"
  }
}

void vor_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1264 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_orr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 31280 "ad_aarch64.cpp"
  }
}

void vorImmBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1278 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_orr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ B, (uint64_t)(opnd_array(2)->constant()));
  
#line 31297 "ad_aarch64.cpp"
  }
}

void vorImmB_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1278 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_orr(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ B, (uint64_t)(opnd_array(1)->constant()));
  
#line 31314 "ad_aarch64.cpp"
  }
}

void vorImmSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1288 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_orr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ H, (uint64_t)(opnd_array(2)->constant()));
  
#line 31331 "ad_aarch64.cpp"
  }
}

void vorImmS_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1288 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_orr(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ H, (uint64_t)(opnd_array(1)->constant()));
  
#line 31348 "ad_aarch64.cpp"
  }
}

void vorImmINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1298 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_orr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ S, (uint64_t)(opnd_array(2)->constant()));
  
#line 31365 "ad_aarch64.cpp"
  }
}

void vorImmI_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1298 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_orr(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ S, (uint64_t)(opnd_array(1)->constant()));
  
#line 31382 "ad_aarch64.cpp"
  }
}

void vorImmLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1308 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_orr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ D, (uint64_t)(opnd_array(2)->constantL()));
  
#line 31399 "ad_aarch64.cpp"
  }
}

void vorImmL_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1308 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_orr(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ D, (uint64_t)(opnd_array(1)->constantL()));
  
#line 31416 "ad_aarch64.cpp"
  }
}

void vxorNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1321 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 31440 "ad_aarch64.cpp"
  }
}

void vxor_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1340 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_eor(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 31460 "ad_aarch64.cpp"
  }
}

void vxorImmBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1354 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_eor(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ B, (uint64_t)(opnd_array(2)->constant()));
  
#line 31477 "ad_aarch64.cpp"
  }
}

void vxorImmB_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1354 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_eor(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ B, (uint64_t)(opnd_array(1)->constant()));
  
#line 31494 "ad_aarch64.cpp"
  }
}

void vxorImmSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1364 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_eor(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ H, (uint64_t)(opnd_array(2)->constant()));
  
#line 31511 "ad_aarch64.cpp"
  }
}

void vxorImmS_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1364 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_eor(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ H, (uint64_t)(opnd_array(1)->constant()));
  
#line 31528 "ad_aarch64.cpp"
  }
}

void vxorImmINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1374 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_eor(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ S, (uint64_t)(opnd_array(2)->constant()));
  
#line 31545 "ad_aarch64.cpp"
  }
}

void vxorImmI_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1374 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_eor(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ S, (uint64_t)(opnd_array(1)->constant()));
  
#line 31562 "ad_aarch64.cpp"
  }
}

void vxorImmLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1384 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_eor(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ D, (uint64_t)(opnd_array(2)->constantL()));
  
#line 31579 "ad_aarch64.cpp"
  }
}

void vxorImmL_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1384 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_eor(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst_src */, __ D, (uint64_t)(opnd_array(1)->constantL()));
  
#line 31596 "ad_aarch64.cpp"
  }
}

void veor3_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1397 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ eor3(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T16B, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */,
            opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 31615 "ad_aarch64.cpp"
  }
}

void veor3_neon_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1397 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ eor3(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T16B, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src1 */,
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src2 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src3 */);
  
#line 31634 "ad_aarch64.cpp"
  }
}

void veor3_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1408 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_eor3(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 31652 "ad_aarch64.cpp"
  }
}

void veor3_sve_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst_src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1408 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_eor3(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst_src1 */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src2 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src3 */);
  
#line 31670 "ad_aarch64.cpp"
  }
}

void vnotINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1421 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ notr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_not(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 31694 "ad_aarch64.cpp"
  }
}

void vnotI_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1421 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ notr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
              opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_not(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */);
    }
  
#line 31718 "ad_aarch64.cpp"
  }
}

void vnotLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1437 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ notr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_not(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 31742 "ad_aarch64.cpp"
  }
}

void vnotL_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1437 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ notr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
              opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_not(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */);
    }
  
#line 31766 "ad_aarch64.cpp"
  }
}

void vnotI_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1456 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_not(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, get_reg_variant(this),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 31785 "ad_aarch64.cpp"
  }
}

void vnotL_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1467 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_not(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, get_reg_variant(this),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 31804 "ad_aarch64.cpp"
  }
}

void vand_notINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1481 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
             opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 31829 "ad_aarch64.cpp"
  }
}

void vand_notI_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1481 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
             opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src1 */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src1 */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src2 */);
    }
  
#line 31854 "ad_aarch64.cpp"
  }
}

void vand_notI_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1481 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
             opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src2 */);
    }
  
#line 31879 "ad_aarch64.cpp"
  }
}

void vand_notI_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1481 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
             opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 31904 "ad_aarch64.cpp"
  }
}

void vand_notLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1497 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
             opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 31929 "ad_aarch64.cpp"
  }
}

void vand_notL_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1497 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
             opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src1 */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src1 */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src2 */);
    }
  
#line 31954 "ad_aarch64.cpp"
  }
}

void vand_notL_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1497 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
             opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src2 */);
    }
  
#line 31979 "ad_aarch64.cpp"
  }
}

void vand_notL_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1497 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
             opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_bic(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 32004 "ad_aarch64.cpp"
  }
}

void vand_notI_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1516 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_bic(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, get_reg_variant(this),
               opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 32024 "ad_aarch64.cpp"
  }
}

void vand_notI_masked_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1516 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_bic(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, get_reg_variant(this),
               opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src2 */);
  
#line 32044 "ad_aarch64.cpp"
  }
}

void vand_notL_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1527 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_bic(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, get_reg_variant(this),
               opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 32064 "ad_aarch64.cpp"
  }
}

void vand_notL_masked_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1527 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_bic(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, get_reg_variant(this),
               opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src2 */);
  
#line 32084 "ad_aarch64.cpp"
  }
}

void vabsBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1541 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ absr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_abs(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ B, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 32106 "ad_aarch64.cpp"
  }
}

void vabsSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1556 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ absr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_abs(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ H, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 32128 "ad_aarch64.cpp"
  }
}

void vabsINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1571 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ absr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_abs(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 32150 "ad_aarch64.cpp"
  }
}

void vabsLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1586 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ absr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_abs(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 32172 "ad_aarch64.cpp"
  }
}

void vabsFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1601 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fabs(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_fabs(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 32194 "ad_aarch64.cpp"
  }
}

void vabsDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1616 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fabs(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_fabs(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 32216 "ad_aarch64.cpp"
  }
}

void vabsB_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1634 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_abs(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ B, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 32233 "ad_aarch64.cpp"
  }
}

void vabsS_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1644 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_abs(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ H, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 32250 "ad_aarch64.cpp"
  }
}

void vabsI_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1654 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_abs(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ S, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 32267 "ad_aarch64.cpp"
  }
}

void vabsL_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1664 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_abs(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ D, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 32284 "ad_aarch64.cpp"
  }
}

void vabsF_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1674 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fabs(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ S, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 32301 "ad_aarch64.cpp"
  }
}

void vabsD_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1684 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fabs(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ D, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 32318 "ad_aarch64.cpp"
  }
}

void vfabd_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1699 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ fabd(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 32336 "ad_aarch64.cpp"
  }
}

void vfabd_neon_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1699 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ fabd(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 32354 "ad_aarch64.cpp"
  }
}

void vfabd_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1711 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fabd(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 32374 "ad_aarch64.cpp"
  }
}

void vfabd_sve_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1711 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fabd(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 32394 "ad_aarch64.cpp"
  }
}

void vfabd_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1727 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fabd(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 32414 "ad_aarch64.cpp"
  }
}

void vfabd_masked_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1727 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fabd(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 32434 "ad_aarch64.cpp"
  }
}

void vnegINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1742 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ negr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      BasicType bt = Matcher::vector_element_basic_type(this);
      __ sve_neg(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
                 ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 32458 "ad_aarch64.cpp"
  }
}

void vnegLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1759 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ negr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_neg(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 32480 "ad_aarch64.cpp"
  }
}

void vnegFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1774 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fneg(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_fneg(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 32502 "ad_aarch64.cpp"
  }
}

void vnegDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1789 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fneg(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_fneg(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 32524 "ad_aarch64.cpp"
  }
}

void vnegI_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1807 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_neg(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 32543 "ad_aarch64.cpp"
  }
}

void vnegL_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1819 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_neg(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ D, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 32560 "ad_aarch64.cpp"
  }
}

void vnegF_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1829 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fneg(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ S, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 32577 "ad_aarch64.cpp"
  }
}

void vnegD_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1839 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fneg(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ D, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 32594 "ad_aarch64.cpp"
  }
}

void vsqrtFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1852 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fsqrt(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_fsqrt(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 32616 "ad_aarch64.cpp"
  }
}

void vsqrtDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1867 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fsqrt(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_fsqrt(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 32638 "ad_aarch64.cpp"
  }
}

void vsqrtF_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1885 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fsqrt(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ S, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 32655 "ad_aarch64.cpp"
  }
}

void vsqrtD_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1895 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fsqrt(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ D, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 32672 "ad_aarch64.cpp"
  }
}

void vminL_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1910 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ cm(Assembler::GT, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ T2D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    __ bsl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ T16B, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */);
  
#line 32691 "ad_aarch64.cpp"
  }
}

void vminL_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1921 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_smin(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ D, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 32708 "ad_aarch64.cpp"
  }
}

void vmin_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1934 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    if (is_floating_point_type(bt)) {
      __ fmin(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(is_integral_type(bt) && bt != T_LONG, "unsupported type");
      __ minv(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 32733 "ad_aarch64.cpp"
  }
}

void vmin_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1953 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    if (is_floating_point_type(bt)) {
      __ sve_fmin(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                  ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(is_integral_type(bt) && bt != T_LONG, "unsupported type");
      __ sve_smin(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                  ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 32759 "ad_aarch64.cpp"
  }
}

void vmin_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1974 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    if (is_floating_point_type(bt)) {
      __ sve_fmin(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                  opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(is_integral_type(bt), "unsupported type");
      __ sve_smin(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                  opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 32785 "ad_aarch64.cpp"
  }
}

void vmaxL_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 1997 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ cm(Assembler::GT, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ T2D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    __ bsl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ T16B, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 32804 "ad_aarch64.cpp"
  }
}

void vmaxL_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2008 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_smax(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ D, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 32821 "ad_aarch64.cpp"
  }
}

void vmax_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2021 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    if (is_floating_point_type(bt)) {
      __ fmax(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(is_integral_type(bt) && bt != T_LONG, "unsupported type");
      __ maxv(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 32846 "ad_aarch64.cpp"
  }
}

void vmax_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2040 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    if (is_floating_point_type(bt)) {
      __ sve_fmax(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                  ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(is_integral_type(bt) && bt != T_LONG, "unsupported type");
      __ sve_smax(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                  ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 32872 "ad_aarch64.cpp"
  }
}

void vmax_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2061 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    if (is_floating_point_type(bt)) {
      __ sve_fmax(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                  opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    } else {
      assert(is_integral_type(bt), "unsupported type");
      __ sve_smax(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                  opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    }
  
#line 32898 "ad_aarch64.cpp"
  }
}

void vmlaNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2085 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ mlav(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, get_arrangement(this),
              opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_mla(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    }
  
#line 32925 "ad_aarch64.cpp"
  }
}

void vmla_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst_src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2085 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ mlav(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst_src1 */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src2 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src3 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_mla(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src2 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src3 */);
    }
  
#line 32952 "ad_aarch64.cpp"
  }
}

void vmla_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2085 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ mlav(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, get_arrangement(this),
              opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_mla(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    }
  
#line 32979 "ad_aarch64.cpp"
  }
}

void vmla_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst_src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2085 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ mlav(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst_src1 */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src2 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src3 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_mla(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src2 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src3 */);
    }
  
#line 33006 "ad_aarch64.cpp"
  }
}

void vmla_3Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2085 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ mlav(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, get_arrangement(this),
              opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_mla(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    }
  
#line 33033 "ad_aarch64.cpp"
  }
}

void vmla_4Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst_src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2085 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ mlav(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst_src1 */, get_arrangement(this),
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src2 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src3 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_mla(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src2 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src3 */);
    }
  
#line 33060 "ad_aarch64.cpp"
  }
}

void vmlaLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2104 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_mla(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33080 "ad_aarch64.cpp"
  }
}

void vmlaL_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst_src1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2104 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_mla(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst_src1 */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src2 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src3 */);
  
#line 33100 "ad_aarch64.cpp"
  }
}

void vmla_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2119 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_mla(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33121 "ad_aarch64.cpp"
  }
}

void vmla_masked_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2119 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_mla(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33142 "ad_aarch64.cpp"
  }
}

void vmla_masked_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2119 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_mla(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33163 "ad_aarch64.cpp"
  }
}

void vmla_masked_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2119 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_mla(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33184 "ad_aarch64.cpp"
  }
}

void vfmlaNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2134 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fmla(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, get_arrangement(this),
              opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      BasicType bt = Matcher::vector_element_basic_type(this);
      __ sve_fmla(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                  ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    }
  
#line 33212 "ad_aarch64.cpp"
  }
}

void vfmla_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2134 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fmla(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, get_arrangement(this),
              opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      BasicType bt = Matcher::vector_element_basic_type(this);
      __ sve_fmla(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                  ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    }
  
#line 33240 "ad_aarch64.cpp"
  }
}

void vfmad_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2158 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fmad(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33262 "ad_aarch64.cpp"
  }
}

void vfmad_masked_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2158 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fmad(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33284 "ad_aarch64.cpp"
  }
}

void vmlsNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2175 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ mlsv(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, get_arrangement(this),
              opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_mls(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    }
  
#line 33311 "ad_aarch64.cpp"
  }
}

void vmls_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2175 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ mlsv(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, get_arrangement(this),
              opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_mls(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    }
  
#line 33338 "ad_aarch64.cpp"
  }
}

void vmls_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2175 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ mlsv(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, get_arrangement(this),
              opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_mls(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    }
  
#line 33365 "ad_aarch64.cpp"
  }
}

void vmlsLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2194 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_mls(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33385 "ad_aarch64.cpp"
  }
}

void vmls_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2209 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_mls(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33406 "ad_aarch64.cpp"
  }
}

void vmls_masked_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2209 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_mls(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33427 "ad_aarch64.cpp"
  }
}

void vmls_masked_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2209 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_mls(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33448 "ad_aarch64.cpp"
  }
}

void vmls_masked_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2209 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_mls(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33469 "ad_aarch64.cpp"
  }
}

void vfmlsNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2225 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fmls(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, get_arrangement(this),
              opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      BasicType bt = Matcher::vector_element_basic_type(this);
      __ sve_fmls(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                  ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    }
  
#line 33497 "ad_aarch64.cpp"
  }
}

void vfmls_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2225 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fmls(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, get_arrangement(this),
              opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    } else {
      assert(UseSVE > 0, "must be sve");
      BasicType bt = Matcher::vector_element_basic_type(this);
      __ sve_fmls(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                  ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
    }
  
#line 33525 "ad_aarch64.cpp"
  }
}

void vfmsb_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2249 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fmsb(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33547 "ad_aarch64.cpp"
  }
}

void vfmsb_masked_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2249 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fmsb(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33569 "ad_aarch64.cpp"
  }
}

void vfnmlaNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2267 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fnmla(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33590 "ad_aarch64.cpp"
  }
}

void vfnmla_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2267 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fnmla(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33611 "ad_aarch64.cpp"
  }
}

void vfnmad_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2284 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fnmad(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33633 "ad_aarch64.cpp"
  }
}

void vfnmad_masked_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2284 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fnmad(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33655 "ad_aarch64.cpp"
  }
}

void vfnmlsNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2301 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fnmls(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33676 "ad_aarch64.cpp"
  }
}

void vfnmls_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2301 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fnmls(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33697 "ad_aarch64.cpp"
  }
}

void vfnmsb_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2318 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fnmsb(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33719 "ad_aarch64.cpp"
  }
}

void vfnmsb_masked_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2318 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseFMA, "Needs FMA instructions support.");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fnmsb(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
                 opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* src3 */);
  
#line 33741 "ad_aarch64.cpp"
  }
}

void vmuladdS2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2336 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ smullv(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */, __ T4H, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    __ smullv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ T8H, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
    __ addpv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ T4S, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */);
  
#line 33762 "ad_aarch64.cpp"
  }
}

void vshiftcntLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2380 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ dup(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_Register(ra_,this,idx1)/* cnt */);
    } else {
      assert(UseSVE > 0, "must be sve");
      BasicType bt = Matcher::vector_element_basic_type(this);
      __ sve_dup(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt), opnd_array(1)->as_Register(ra_,this,idx1)/* cnt */);
    }
  
#line 33785 "ad_aarch64.cpp"
  }
}

void vshiftcntRNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2396 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    if (UseSVE == 0) {
      uint length_in_bytes = Matcher::vector_length_in_bytes(this);
      assert(length_in_bytes <= 16, "must be");
      __ negw(rscratch1, opnd_array(1)->as_Register(ra_,this,idx1)/* cnt */);
      __ dup(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), rscratch1);
    } else {
      BasicType bt = Matcher::vector_element_basic_type(this);
      __ sve_dup(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt), opnd_array(1)->as_Register(ra_,this,idx1)/* cnt */);
    }
  
#line 33809 "ad_aarch64.cpp"
  }
}

void vlsl_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2419 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sshl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 33827 "ad_aarch64.cpp"
  }
}

void vlsl_neon_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2419 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sshl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 33845 "ad_aarch64.cpp"
  }
}

void vlsl_neon_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2419 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sshl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 33863 "ad_aarch64.cpp"
  }
}

void vlsl_neon_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2419 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sshl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 33881 "ad_aarch64.cpp"
  }
}

void vlsl_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2433 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsl(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 33901 "ad_aarch64.cpp"
  }
}

void vlsl_sve_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2433 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsl(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 33921 "ad_aarch64.cpp"
  }
}

void vlsl_sve_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2433 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsl(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 33941 "ad_aarch64.cpp"
  }
}

void vlsl_sve_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2433 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsl(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 33961 "ad_aarch64.cpp"
  }
}

void vasr_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2451 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sshl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 33979 "ad_aarch64.cpp"
  }
}

void vasr_neon_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2451 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sshl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 33997 "ad_aarch64.cpp"
  }
}

void vasr_neon_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2451 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sshl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 34015 "ad_aarch64.cpp"
  }
}

void vasr_neon_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2451 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sshl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 34033 "ad_aarch64.cpp"
  }
}

void vasr_neon_varNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2466 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    __ negr(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
            opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
    __ sshl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */);
  
#line 34055 "ad_aarch64.cpp"
  }
}

void vasr_neon_var_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2466 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    __ negr(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
            opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
    __ sshl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */);
  
#line 34077 "ad_aarch64.cpp"
  }
}

void vasr_neon_var_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2466 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    __ negr(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
            opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
    __ sshl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */);
  
#line 34099 "ad_aarch64.cpp"
  }
}

void vasr_neon_var_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2466 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    __ negr(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
            opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
    __ sshl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */);
  
#line 34121 "ad_aarch64.cpp"
  }
}

void vasr_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2483 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_asr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 34140 "ad_aarch64.cpp"
  }
}

void vasr_sve_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2483 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_asr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 34159 "ad_aarch64.cpp"
  }
}

void vasr_sve_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2483 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_asr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 34178 "ad_aarch64.cpp"
  }
}

void vasr_sve_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2483 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_asr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 34197 "ad_aarch64.cpp"
  }
}

void vlsr_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2500 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ ushl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 34215 "ad_aarch64.cpp"
  }
}

void vlsr_neon_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2500 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ ushl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 34233 "ad_aarch64.cpp"
  }
}

void vlsr_neon_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2500 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ ushl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 34251 "ad_aarch64.cpp"
  }
}

void vlsr_neon_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2500 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ ushl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 34269 "ad_aarch64.cpp"
  }
}

void vlsr_neon_varNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2515 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    __ negr(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
            opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
    __ ushl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */);
  
#line 34291 "ad_aarch64.cpp"
  }
}

void vlsr_neon_var_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2515 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    __ negr(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
            opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
    __ ushl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */);
  
#line 34313 "ad_aarch64.cpp"
  }
}

void vlsr_neon_var_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2515 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    __ negr(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
            opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
    __ ushl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */);
  
#line 34335 "ad_aarch64.cpp"
  }
}

void vlsr_neon_var_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2515 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    __ negr(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
            opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
    __ ushl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this),
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */);
  
#line 34357 "ad_aarch64.cpp"
  }
}

void vlsr_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2532 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 34376 "ad_aarch64.cpp"
  }
}

void vlsr_sve_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2532 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 34395 "ad_aarch64.cpp"
  }
}

void vlsr_sve_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2532 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 34414 "ad_aarch64.cpp"
  }
}

void vlsr_sve_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2532 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shift */);
  
#line 34433 "ad_aarch64.cpp"
  }
}

void vlsl_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2549 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Optimize for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) {
        if (VM_Version::use_neon_for_vector(length_in_bytes)) {
          __ eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
                 opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        } else {
          assert(UseSVE > 0, "must be sve");
          __ sve_eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        }
        return;
      }
    }
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ shl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_lsl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 34472 "ad_aarch64.cpp"
  }
}

void vlsl_imm_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2549 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Optimize for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) {
        if (VM_Version::use_neon_for_vector(length_in_bytes)) {
          __ eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
                 opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        } else {
          assert(UseSVE > 0, "must be sve");
          __ sve_eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        }
        return;
      }
    }
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ shl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_lsl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 34511 "ad_aarch64.cpp"
  }
}

void vlsl_imm_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2549 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Optimize for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) {
        if (VM_Version::use_neon_for_vector(length_in_bytes)) {
          __ eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
                 opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        } else {
          assert(UseSVE > 0, "must be sve");
          __ sve_eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        }
        return;
      }
    }
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ shl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_lsl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 34550 "ad_aarch64.cpp"
  }
}

void vlsl_imm_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2549 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Optimize for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) {
        if (VM_Version::use_neon_for_vector(length_in_bytes)) {
          __ eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
                 opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        } else {
          assert(UseSVE > 0, "must be sve");
          __ sve_eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        }
        return;
      }
    }
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ shl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_lsl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 34589 "ad_aarch64.cpp"
  }
}

void vasr_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2584 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Refine con for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) con = esize_in_bits - 1;
    }
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ sshr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_asr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 34619 "ad_aarch64.cpp"
  }
}

void vasr_imm_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2584 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Refine con for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) con = esize_in_bits - 1;
    }
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ sshr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_asr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 34649 "ad_aarch64.cpp"
  }
}

void vasr_imm_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2584 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Refine con for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) con = esize_in_bits - 1;
    }
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ sshr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_asr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 34679 "ad_aarch64.cpp"
  }
}

void vasr_imm_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2584 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Refine con for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) con = esize_in_bits - 1;
    }
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ sshr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_asr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 34709 "ad_aarch64.cpp"
  }
}

void vlsr_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2610 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Optimize for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) {
        if (VM_Version::use_neon_for_vector(length_in_bytes)) {
          __ eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
                 opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        } else {
          assert(UseSVE > 0, "must be sve");
          __ sve_eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        }
        return;
      }
    }
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ ushr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_lsr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 34748 "ad_aarch64.cpp"
  }
}

void vlsr_imm_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2610 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Optimize for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) {
        if (VM_Version::use_neon_for_vector(length_in_bytes)) {
          __ eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
                 opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        } else {
          assert(UseSVE > 0, "must be sve");
          __ sve_eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        }
        return;
      }
    }
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ ushr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_lsr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 34787 "ad_aarch64.cpp"
  }
}

void vlsr_imm_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2610 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Optimize for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) {
        if (VM_Version::use_neon_for_vector(length_in_bytes)) {
          __ eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
                 opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        } else {
          assert(UseSVE > 0, "must be sve");
          __ sve_eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        }
        return;
      }
    }
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ ushr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_lsr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 34826 "ad_aarch64.cpp"
  }
}

void vlsr_imm_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2610 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Optimize for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) {
        if (VM_Version::use_neon_for_vector(length_in_bytes)) {
          __ eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
                 opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        } else {
          assert(UseSVE > 0, "must be sve");
          __ sve_eor(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        }
        return;
      }
    }
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ ushr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_lsr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 34865 "ad_aarch64.cpp"
  }
}

void vasra_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2647 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(3)->constant();
    if (is_subword_type(bt)) {
      // Refine con for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) con = esize_in_bits - 1;
    }
    __ ssra(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst */, get_arrangement(this), opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, con);
  
#line 34890 "ad_aarch64.cpp"
  }
}

void vasra_imm_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2647 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Refine con for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) con = esize_in_bits - 1;
    }
    __ ssra(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
  
#line 34915 "ad_aarch64.cpp"
  }
}

void vasra_imm_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2647 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(3)->constant();
    if (is_subword_type(bt)) {
      // Refine con for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) con = esize_in_bits - 1;
    }
    __ ssra(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst */, get_arrangement(this), opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, con);
  
#line 34940 "ad_aarch64.cpp"
  }
}

void vasra_imm_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2647 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Refine con for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) con = esize_in_bits - 1;
    }
    __ ssra(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
  
#line 34965 "ad_aarch64.cpp"
  }
}

void vasra_imm_3Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2647 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(3)->constant();
    if (is_subword_type(bt)) {
      // Refine con for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) con = esize_in_bits - 1;
    }
    __ ssra(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst */, get_arrangement(this), opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, con);
  
#line 34990 "ad_aarch64.cpp"
  }
}

void vasra_imm_4Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2647 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Refine con for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) con = esize_in_bits - 1;
    }
    __ ssra(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
  
#line 35015 "ad_aarch64.cpp"
  }
}

void vasra_imm_5Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2647 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(3)->constant();
    if (is_subword_type(bt)) {
      // Refine con for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) con = esize_in_bits - 1;
    }
    __ ssra(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst */, get_arrangement(this), opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, con);
  
#line 35040 "ad_aarch64.cpp"
  }
}

void vasra_imm_6Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2647 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) {
      // Refine con for B/S
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con >= esize_in_bits) con = esize_in_bits - 1;
    }
    __ ssra(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
  
#line 35065 "ad_aarch64.cpp"
  }
}

void vlsra_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2667 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(3)->constant();
    if (is_subword_type(bt)) { // for B/H
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con < esize_in_bits) {
        __ usra(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst */, get_arrangement(this), opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, con);
      }
    } else { // for S/D
      assert(type2aelembytes(bt) == 4 || type2aelembytes(bt) == 8, "unsupported type");
      __ usra(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst */, get_arrangement(this), opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, con);
    }
  
#line 35093 "ad_aarch64.cpp"
  }
}

void vlsra_imm_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2667 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) { // for B/H
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con < esize_in_bits) {
        __ usra(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
      }
    } else { // for S/D
      assert(type2aelembytes(bt) == 4 || type2aelembytes(bt) == 8, "unsupported type");
      __ usra(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 35121 "ad_aarch64.cpp"
  }
}

void vlsra_imm_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2667 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(3)->constant();
    if (is_subword_type(bt)) { // for B/H
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con < esize_in_bits) {
        __ usra(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst */, get_arrangement(this), opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, con);
      }
    } else { // for S/D
      assert(type2aelembytes(bt) == 4 || type2aelembytes(bt) == 8, "unsupported type");
      __ usra(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst */, get_arrangement(this), opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, con);
    }
  
#line 35149 "ad_aarch64.cpp"
  }
}

void vlsra_imm_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2667 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) { // for B/H
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con < esize_in_bits) {
        __ usra(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
      }
    } else { // for S/D
      assert(type2aelembytes(bt) == 4 || type2aelembytes(bt) == 8, "unsupported type");
      __ usra(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 35177 "ad_aarch64.cpp"
  }
}

void vlsra_imm_3Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2667 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(3)->constant();
    if (is_subword_type(bt)) { // for B/H
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con < esize_in_bits) {
        __ usra(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst */, get_arrangement(this), opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, con);
      }
    } else { // for S/D
      assert(type2aelembytes(bt) == 4 || type2aelembytes(bt) == 8, "unsupported type");
      __ usra(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst */, get_arrangement(this), opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, con);
    }
  
#line 35205 "ad_aarch64.cpp"
  }
}

void vlsra_imm_4Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2667 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) { // for B/H
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con < esize_in_bits) {
        __ usra(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
      }
    } else { // for S/D
      assert(type2aelembytes(bt) == 4 || type2aelembytes(bt) == 8, "unsupported type");
      __ usra(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 35233 "ad_aarch64.cpp"
  }
}

void vlsra_imm_5Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2667 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(3)->constant();
    if (is_subword_type(bt)) { // for B/H
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con < esize_in_bits) {
        __ usra(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst */, get_arrangement(this), opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, con);
      }
    } else { // for S/D
      assert(type2aelembytes(bt) == 4 || type2aelembytes(bt) == 8, "unsupported type");
      __ usra(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst */, get_arrangement(this), opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, con);
    }
  
#line 35261 "ad_aarch64.cpp"
  }
}

void vlsra_imm_6Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2667 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int con = (int)opnd_array(2)->constant();
    if (is_subword_type(bt)) { // for B/H
      int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
      if (con < esize_in_bits) {
        __ usra(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
      }
    } else { // for S/D
      assert(type2aelembytes(bt) == 4 || type2aelembytes(bt) == 8, "unsupported type");
      __ usra(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, con);
    }
  
#line 35289 "ad_aarch64.cpp"
  }
}

void vlsl_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2692 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsl(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 35309 "ad_aarch64.cpp"
  }
}

void vlsl_masked_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2692 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsl(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 35329 "ad_aarch64.cpp"
  }
}

void vlsl_masked_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2692 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsl(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 35349 "ad_aarch64.cpp"
  }
}

void vlsl_masked_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2692 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsl(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 35369 "ad_aarch64.cpp"
  }
}

void vasr_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2707 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_asr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 35389 "ad_aarch64.cpp"
  }
}

void vasr_masked_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2707 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_asr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 35409 "ad_aarch64.cpp"
  }
}

void vasr_masked_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2707 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_asr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 35429 "ad_aarch64.cpp"
  }
}

void vasr_masked_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2707 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_asr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 35449 "ad_aarch64.cpp"
  }
}

void vlsr_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2722 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 35469 "ad_aarch64.cpp"
  }
}

void vlsr_masked_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2722 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 35489 "ad_aarch64.cpp"
  }
}

void vlsr_masked_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2722 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 35509 "ad_aarch64.cpp"
  }
}

void vlsr_masked_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2722 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_lsr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 35529 "ad_aarch64.cpp"
  }
}

void vlsl_imm_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2739 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
    int con = (int)opnd_array(2)->constant();
    assert(con >= 0 && con < esize_in_bits, "invalid shift immediate");
    __ sve_lsl(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, con);
  
#line 35552 "ad_aarch64.cpp"
  }
}

void vlsl_imm_masked_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2739 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
    int con = (int)opnd_array(2)->constant();
    assert(con >= 0 && con < esize_in_bits, "invalid shift immediate");
    __ sve_lsl(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, con);
  
#line 35575 "ad_aarch64.cpp"
  }
}

void vlsl_imm_masked_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2739 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
    int con = (int)opnd_array(2)->constant();
    assert(con >= 0 && con < esize_in_bits, "invalid shift immediate");
    __ sve_lsl(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, con);
  
#line 35598 "ad_aarch64.cpp"
  }
}

void vlsl_imm_masked_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2739 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
    int con = (int)opnd_array(2)->constant();
    assert(con >= 0 && con < esize_in_bits, "invalid shift immediate");
    __ sve_lsl(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, con);
  
#line 35621 "ad_aarch64.cpp"
  }
}

void vasr_imm_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2757 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
    int con = (int)opnd_array(2)->constant();
    assert(con > 0 && con < esize_in_bits, "invalid shift immediate");
    __ sve_asr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, con);
  
#line 35644 "ad_aarch64.cpp"
  }
}

void vasr_imm_masked_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2757 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
    int con = (int)opnd_array(2)->constant();
    assert(con > 0 && con < esize_in_bits, "invalid shift immediate");
    __ sve_asr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, con);
  
#line 35667 "ad_aarch64.cpp"
  }
}

void vasr_imm_masked_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2757 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
    int con = (int)opnd_array(2)->constant();
    assert(con > 0 && con < esize_in_bits, "invalid shift immediate");
    __ sve_asr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, con);
  
#line 35690 "ad_aarch64.cpp"
  }
}

void vasr_imm_masked_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2757 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
    int con = (int)opnd_array(2)->constant();
    assert(con > 0 && con < esize_in_bits, "invalid shift immediate");
    __ sve_asr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, con);
  
#line 35713 "ad_aarch64.cpp"
  }
}

void vlsr_imm_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2775 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
    int con = (int)opnd_array(2)->constant();
    assert(con > 0 && con < esize_in_bits, "invalid shift immediate");
    __ sve_lsr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, con);
  
#line 35736 "ad_aarch64.cpp"
  }
}

void vlsr_imm_masked_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2775 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
    int con = (int)opnd_array(2)->constant();
    assert(con > 0 && con < esize_in_bits, "invalid shift immediate");
    __ sve_lsr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, con);
  
#line 35759 "ad_aarch64.cpp"
  }
}

void vlsr_imm_masked_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2775 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
    int con = (int)opnd_array(2)->constant();
    assert(con > 0 && con < esize_in_bits, "invalid shift immediate");
    __ sve_lsr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, con);
  
#line 35782 "ad_aarch64.cpp"
  }
}

void vlsr_imm_masked_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2775 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int esize_in_bits = type2aelembytes(bt) * BitsPerByte;
    int con = (int)opnd_array(2)->constant();
    assert(con > 0 && con < esize_in_bits, "invalid shift immediate");
    __ sve_lsr(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, con);
  
#line 35805 "ad_aarch64.cpp"
  }
}

void reduce_addI_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2795 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    __ neon_reduce_add_integral(opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                                opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                                length_in_bytes, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 35828 "ad_aarch64.cpp"
  }
}

void reduce_addI_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2810 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           ptrue, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 35853 "ad_aarch64.cpp"
  }
}

void reduce_addL_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2829 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    __ neon_reduce_add_integral(opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                                opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                                length_in_bytes, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 35876 "ad_aarch64.cpp"
  }
}

void reduce_addL_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2844 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           ptrue, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 35901 "ad_aarch64.cpp"
  }
}

void reduce_add2F_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// fsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2865 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ faddp(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, __ S);
    __ fadds(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* fsrc */);
  
#line 35920 "ad_aarch64.cpp"
  }
}

void reduce_add4F_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// fsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2877 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ faddp(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */, __ T4S, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */);
    __ faddp(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */, __ S);
    __ fadds(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* fsrc */);
  
#line 35941 "ad_aarch64.cpp"
  }
}

void reduce_addF_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2889 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_fadda(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ S, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 35960 "ad_aarch64.cpp"
  }
}

void reduce_addD_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2906 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ faddp(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, __ D);
    __ faddd(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dsrc */);
  
#line 35979 "ad_aarch64.cpp"
  }
}

void reduce_addD_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2917 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_fadda(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ D, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 35998 "ad_aarch64.cpp"
  }
}

void reduce_addI_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2932 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(4)->as_Register(ra_,this,idx4)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */);
  
#line 36021 "ad_aarch64.cpp"
  }
}

void reduce_addL_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2946 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(4)->as_Register(ra_,this,idx4)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */);
  
#line 36044 "ad_aarch64.cpp"
  }
}

void reduce_addF_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2959 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fadda(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ S,
                 opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 36063 "ad_aarch64.cpp"
  }
}

void reduce_addD_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2970 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fadda(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src1 */, __ D,
                 opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 36082 "ad_aarch64.cpp"
  }
}

void reduce_mulINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 2986 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    __ neon_reduce_mul_integral(opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt, opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */,
                                opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, length_in_bytes,
                                opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp1 */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp2 */);
  
#line 36106 "ad_aarch64.cpp"
  }
}

void reduce_mulLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3001 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ neon_reduce_mul_integral(opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, T_LONG, opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */,
                                opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, 16, fnoreg, fnoreg);
  
#line 36125 "ad_aarch64.cpp"
  }
}

void reduce_mulFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// fsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3013 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    __ neon_reduce_mul_fp(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, T_FLOAT, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* fsrc */,
                          opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, length_in_bytes, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 36146 "ad_aarch64.cpp"
  }
}

void reduce_mulDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3026 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ neon_reduce_mul_fp(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, T_DOUBLE, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dsrc */,
                          opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, 16, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 36166 "ad_aarch64.cpp"
  }
}

void reduce_andI_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3042 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    __ neon_reduce_logical(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, length_in_bytes);
  
#line 36187 "ad_aarch64.cpp"
  }
}

void reduce_andI_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3056 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           ptrue, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 36211 "ad_aarch64.cpp"
  }
}

void reduce_andL_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3074 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    __ neon_reduce_logical(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, length_in_bytes);
  
#line 36232 "ad_aarch64.cpp"
  }
}

void reduce_andL_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3088 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           ptrue, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 36256 "ad_aarch64.cpp"
  }
}

void reduce_andI_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3106 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(4)->as_Register(ra_,this,idx4)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */);
  
#line 36279 "ad_aarch64.cpp"
  }
}

void reduce_andL_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3120 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(4)->as_Register(ra_,this,idx4)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */);
  
#line 36302 "ad_aarch64.cpp"
  }
}

void reduce_orI_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3138 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    __ neon_reduce_logical(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, length_in_bytes);
  
#line 36323 "ad_aarch64.cpp"
  }
}

void reduce_orI_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3152 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           ptrue, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 36347 "ad_aarch64.cpp"
  }
}

void reduce_orL_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3170 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    __ neon_reduce_logical(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, length_in_bytes);
  
#line 36368 "ad_aarch64.cpp"
  }
}

void reduce_orL_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3184 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           ptrue, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 36392 "ad_aarch64.cpp"
  }
}

void reduce_orI_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3202 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(4)->as_Register(ra_,this,idx4)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */);
  
#line 36415 "ad_aarch64.cpp"
  }
}

void reduce_orL_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3216 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(4)->as_Register(ra_,this,idx4)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */);
  
#line 36438 "ad_aarch64.cpp"
  }
}

void reduce_xorI_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3234 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    __ neon_reduce_logical(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, length_in_bytes);
  
#line 36459 "ad_aarch64.cpp"
  }
}

void reduce_xorI_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3248 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           ptrue, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 36483 "ad_aarch64.cpp"
  }
}

void reduce_xorL_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3266 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    __ neon_reduce_logical(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, length_in_bytes);
  
#line 36504 "ad_aarch64.cpp"
  }
}

void reduce_xorL_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3280 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           ptrue, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 36528 "ad_aarch64.cpp"
  }
}

void reduce_xorI_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3298 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(4)->as_Register(ra_,this,idx4)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */);
  
#line 36551 "ad_aarch64.cpp"
  }
}

void reduce_xorL_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3312 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(4)->as_Register(ra_,this,idx4)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */);
  
#line 36574 "ad_aarch64.cpp"
  }
}

void reduce_maxI_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3334 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    __ neon_reduce_minmax_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                                   opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                                   length_in_bytes, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 36597 "ad_aarch64.cpp"
  }
}

void reduce_maxI_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3353 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           ptrue, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 36622 "ad_aarch64.cpp"
  }
}

void reduce_maxL_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3372 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ neon_reduce_minmax_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, T_LONG,
                                   opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                                   /* vector_length_in_bytes */ 16, fnoreg);
  
#line 36642 "ad_aarch64.cpp"
  }
}

void reduce_maxL_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3386 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, T_LONG,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           ptrue, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 36665 "ad_aarch64.cpp"
  }
}

void reduce_maxFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// fsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3403 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      if (length_in_bytes == 8) {
        __ fmaxp(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, __ S);
      } else {
        __ fmaxv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ T4S, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */);
      }
    } else {
      assert(UseSVE > 0, "must be sve");
      assert(length_in_bytes == MaxVectorSize, "invalid vector length");
      __ sve_fmaxv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ S, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */);
    }
    __ fmaxs(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* fsrc */);
  
#line 36695 "ad_aarch64.cpp"
  }
}

void reduce_maxDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3428 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fmaxp(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, __ D);
    } else {
      assert(UseSVE > 0, "must be sve");
      assert(length_in_bytes == MaxVectorSize, "invalid vector length");
      __ sve_fmaxv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ D, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */);
    }
    __ fmaxd(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dsrc */);
  
#line 36721 "ad_aarch64.cpp"
  }
}

void reduce_maxI_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3453 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(4)->as_Register(ra_,this,idx4)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */);
  
#line 36744 "ad_aarch64.cpp"
  }
}

void reduce_maxL_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3468 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(4)->as_Register(ra_,this,idx4)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */);
  
#line 36767 "ad_aarch64.cpp"
  }
}

void reduce_maxF_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// fsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3482 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fmaxv(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, __ S, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */);
    __ fmaxs(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* fsrc */);
  
#line 36787 "ad_aarch64.cpp"
  }
}

void reduce_maxD_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3494 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fmaxv(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, __ D, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */);
    __ fmaxd(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dsrc */);
  
#line 36807 "ad_aarch64.cpp"
  }
}

void reduce_minI_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3514 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    __ neon_reduce_minmax_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                                   opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                                   length_in_bytes, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 36830 "ad_aarch64.cpp"
  }
}

void reduce_minI_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3533 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           ptrue, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 36855 "ad_aarch64.cpp"
  }
}

void reduce_minL_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3552 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ neon_reduce_minmax_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, T_LONG,
                                   opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                                   /* vector_length_in_bytes */ 16, fnoreg);
  
#line 36875 "ad_aarch64.cpp"
  }
}

void reduce_minL_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3566 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(3)->as_Register(ra_,this,idx3)/* dst */, T_LONG,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           ptrue, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 36898 "ad_aarch64.cpp"
  }
}

void reduce_minFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// fsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3583 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      if (length_in_bytes == 8) {
        __ fminp(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, __ S);
      } else {
        __ fminv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ T4S, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */);
      }
    } else {
      assert(UseSVE > 0, "must be sve");
      assert(length_in_bytes == MaxVectorSize, "invalid vector length");
      __ sve_fminv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ S, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */);
    }
    __ fmins(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* fsrc */);
  
#line 36928 "ad_aarch64.cpp"
  }
}

void reduce_minDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3608 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ fminp(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */, __ D);
    } else {
      assert(UseSVE > 0, "must be sve");
      assert(length_in_bytes == MaxVectorSize, "invalid vector length");
      __ sve_fminv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ D, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */);
    }
    __ fmind(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dsrc */);
  
#line 36954 "ad_aarch64.cpp"
  }
}

void reduce_minI_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3633 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(4)->as_Register(ra_,this,idx4)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */);
  
#line 36977 "ad_aarch64.cpp"
  }
}

void reduce_minL_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3648 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    __ sve_reduce_integral(this->ideal_Opcode(), opnd_array(4)->as_Register(ra_,this,idx4)/* dst */, bt,
                           opnd_array(1)->as_Register(ra_,this,idx1)/* isrc */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */,
                           opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */);
  
#line 37000 "ad_aarch64.cpp"
  }
}

void reduce_minF_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// fsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3662 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fminv(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, __ S, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */);
    __ fmins(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* fsrc */);
  
#line 37020 "ad_aarch64.cpp"
  }
}

void reduce_minD_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3674 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_fminv(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, __ D, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* vsrc */);
    __ fmind(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dsrc */);
  
#line 37040 "ad_aarch64.cpp"
  }
}

void reinterpret_same_sizeNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  // User did not define which encode class to use.
}

void reinterpret_resize_le128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3698 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, opnd_array(1));
    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);
    // The higher bits in "dst" register must be cleared to zero.
    if ((length_in_bytes_src == 4 && length_in_bytes_dst == 8) ||
        (length_in_bytes_src == 8 && length_in_bytes_dst == 4)) {
      // Reinterpret between 32 bits and 64 bits
      __ dup(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else if ((length_in_bytes_src == 4 && length_in_bytes_dst == 16) ||
               (length_in_bytes_src == 16 && length_in_bytes_dst == 4)) {
      // Reinterpret between 32 bits and 128 bits
      __ dup(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else if ((length_in_bytes_src == 8 && length_in_bytes_dst == 16) ||
               (length_in_bytes_src == 16 && length_in_bytes_dst == 8)) {
      // Reinterpret between 64 bits and 128 bits
      __ orr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T8B, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(false, "invalid vector length");
      ShouldNotReachHere();
    }
  
#line 37082 "ad_aarch64.cpp"
  }
}

void reinterpret_resize_gt128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ptmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3729 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, opnd_array(1));
    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);
    uint length_in_bytes_resize = length_in_bytes_src < length_in_bytes_dst ?
                                  length_in_bytes_src : length_in_bytes_dst;
    assert(length_in_bytes_src <= MaxVectorSize && length_in_bytes_dst <= MaxVectorSize,
           "invalid vector length");
    __ sve_gen_mask_imm(opnd_array(3)->as_PRegister(ra_,this,idx3)/* ptmp */, T_BYTE, length_in_bytes_resize);
    __ sve_dup(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ B, 0);
    __ sve_sel(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ B, opnd_array(3)->as_PRegister(ra_,this,idx3)/* ptmp */,
               opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */);
  
#line 37110 "ad_aarch64.cpp"
  }
}

void vzeroExtBtoXNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3750 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    assert(bt == T_SHORT || bt == T_INT || bt == T_LONG, "must be");
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      // 4B to 4S/4I, 8B to 8S
      __ neon_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, bt, length_in_bytes,
                            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, T_BYTE, /* is_unsigned */ true);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
                           opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ B, /* is_unsigned */ true);
    }
  
#line 37137 "ad_aarch64.cpp"
  }
}

void vzeroExtStoXNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3770 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    assert(bt == T_INT || bt == T_LONG, "must be");
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      // 4S to 4I
      __ neon_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, T_INT, length_in_bytes,
                            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, T_SHORT, /* is_unsigned */ true);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
                           opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ H, /* is_unsigned */ true);
    }
  
#line 37164 "ad_aarch64.cpp"
  }
}

void vzeroExtItoXNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3790 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    assert(bt == T_LONG, "must be");
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      // 2I to 2L
      __ neon_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, T_LONG, length_in_bytes,
                            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, T_INT, /* is_unsigned */ true);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D,
                           opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ S, /* is_unsigned */ true);
    }
  
#line 37191 "ad_aarch64.cpp"
  }
}

void vcvtBtoXNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3814 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      // 4B to 4S/4I/4F, 8B to 8S
      __ neon_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, bt == T_FLOAT ? T_INT : bt,
                            length_in_bytes, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, T_BYTE);
      if (bt == T_FLOAT) {
        __ scvtfv(__ T4S, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */);
      }
    } else {
      assert(UseSVE > 0, "must be sve");
      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
      __ sve_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, size, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ B);
      if (is_floating_point_type(bt)) {
        __ sve_scvtf(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, size, ptrue, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, size);
      }
    }
  
#line 37223 "ad_aarch64.cpp"
  }
}

void vcvtStoB_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3843 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // 4S/8S to 4B/8B
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(1));
    __ neon_vector_narrow(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, T_BYTE,
                          opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, T_SHORT, length_in_bytes);
  
#line 37242 "ad_aarch64.cpp"
  }
}

void vcvtStoB_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3858 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_vector_narrow(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ B,
                         opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ H, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */);
  
#line 37261 "ad_aarch64.cpp"
  }
}

void vcvtStoX_extendNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3870 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      // 4S to 4I/4F
      __ neon_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, T_INT, length_in_bytes,
                            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, T_SHORT);
      if (bt == T_FLOAT) {
        __ scvtfv(__ T4S, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */);
      }
    } else {
      assert(UseSVE > 0, "must be sve");
      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
      __ sve_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, size, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ H);
      if (is_floating_point_type(bt)) {
        __ sve_scvtf(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, size, ptrue, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, size);
      }
    }
  
#line 37293 "ad_aarch64.cpp"
  }
}

void vcvtItoX_narrow_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3901 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // 4I to 4B/4S
    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(1));
    __ neon_vector_narrow(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, bt,
                          opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, T_INT, length_in_bytes);
  
#line 37314 "ad_aarch64.cpp"
  }
}

void vcvtItoX_narrow_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3918 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_vector_narrow(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ elemType_to_regVariant(bt),
                         opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ S, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */);
  
#line 37335 "ad_aarch64.cpp"
  }
}

void vcvtItoXNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3931 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);
    if (bt == T_FLOAT) {
      if (VM_Version::use_neon_for_vector(length_in_bytes)) {
        // 2I/4I to 2F/4F
        __ scvtfv(get_arrangement(this), opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      } else {
        assert(UseSVE > 0, "must be sve");
        __ sve_scvtf(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ S);
      }
    } else {
      assert(type2aelembytes(bt) == 8, "unsupported type");
      if (VM_Version::use_neon_for_vector(length_in_bytes)) {
        // 2I to 2L/2D
        __ neon_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, T_LONG, length_in_bytes,
                              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, T_INT);
        if (bt == T_DOUBLE) {
          __ scvtfv(__ T2D, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */);
        }
      } else {
        assert(UseSVE > 0, "must be sve");
        __ sve_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ S);
        if (bt == T_DOUBLE) {
          __ sve_scvtf(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D);
        }
      }
    }
  
#line 37377 "ad_aarch64.cpp"
  }
}

void vcvtLtoI_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3970 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // 2L to 2I
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(1));
    __ neon_vector_narrow(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, T_INT,
                          opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, T_LONG, length_in_bytes);
  
#line 37396 "ad_aarch64.cpp"
  }
}

void vcvtLtoI_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 3987 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_vector_narrow(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ elemType_to_regVariant(bt),
                         opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ D, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */);
  
#line 37417 "ad_aarch64.cpp"
  }
}

void vcvtLtoF_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4001 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // 2L to 2F
    __ umov(rscratch1, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ D, 0);
    __ scvtfs(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, rscratch1);
    __ umov(rscratch1, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ D, 1);
    __ scvtfs(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, rscratch1);
    __ ins(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ S, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, 1, 0);
  
#line 37440 "ad_aarch64.cpp"
  }
}

void vcvtLtoF_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4017 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_scvtf(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ S, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ D);
    __ sve_vector_narrow(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ S,
                         opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ D, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */);
  
#line 37460 "ad_aarch64.cpp"
  }
}

void vcvtLtoDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4029 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      // 2L to 2D
      __ scvtfv(__ T2D, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_scvtf(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ D);
    }
  
#line 37483 "ad_aarch64.cpp"
  }
}

void vcvtFtoX_narrow_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4051 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // 4F to 4B/4S
    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(1));
    __ fcvtzs(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ T4S, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    __ neon_vector_narrow(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, bt,
                          opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, T_INT, length_in_bytes);
  
#line 37505 "ad_aarch64.cpp"
  }
}

void vcvtFtoX_narrow_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4069 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fcvtzs(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ S, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ S);
    __ sve_vector_narrow(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ elemType_to_regVariant(bt),
                         opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ S, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */);
  
#line 37527 "ad_aarch64.cpp"
  }
}

void vcvtFtoXNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4083 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);
    if (bt == T_INT) {
      if (VM_Version::use_neon_for_vector(length_in_bytes)) {
        // 2F/4F to 2I/4I
        __ fcvtzs(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      } else {
        assert(UseSVE > 0, "must be sve");
        __ sve_fcvtzs(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ S);
      }
    } else if (bt == T_LONG) {
      if (UseSVE == 0) {
        // 2F to 2L
        __ fcvtl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T2D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ T2S);
        __ fcvtzs(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T2D, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */);
      } else {
        __ sve_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ S);
        __ sve_fcvtzs(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S);
      }
    } else {
      assert(bt == T_DOUBLE, "unsupported type");
      if (length_in_bytes == 16) {
        // 2F to 2D
        __ fcvtl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T2D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ T2S);
      } else {
        assert(UseSVE > 0 && length_in_bytes > 16, "must be");
        __ sve_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ S);
        __ sve_fcvt(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S);
      }
    }
  
#line 37572 "ad_aarch64.cpp"
  }
}

void vcvtDtoI_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4125 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // 2D to 2I
    __ ins(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, 0, 1);
    // We can't use fcvtzs(vector, integer) instruction here because we need
    // saturation arithmetic. See JDK-8276151.
    __ fcvtzdw(rscratch1, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    __ fcvtzdw(rscratch2, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */);
    __ fmovs(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, rscratch1);
    __ mov(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ S, 1, rscratch2);
  
#line 37596 "ad_aarch64.cpp"
  }
}

void vcvtDtoI_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4146 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_fcvtzs(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ S, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ D);
    __ sve_vector_narrow(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ elemType_to_regVariant(bt),
                         opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ D, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */);
  
#line 37617 "ad_aarch64.cpp"
  }
}

void vcvtDtoLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4159 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes =  Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      // 2D to 2L
      __ fcvtzs(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T2D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_fcvtzs(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ D);
    }
  
#line 37640 "ad_aarch64.cpp"
  }
}

void vcvtDtoF_64bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4177 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // 2D to 2F
    __ fcvtn(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T2S, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ T2D);
  
#line 37657 "ad_aarch64.cpp"
  }
}

void vcvtDtoF_gt64bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4190 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_fcvt(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ S, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ D);
    __ sve_vector_narrow(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ S,
                         opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ D, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */);
  
#line 37678 "ad_aarch64.cpp"
  }
}

void vcvtHFtoFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4204 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      // 4HF to 4F
      __ fcvtl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T4S, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ T4H);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ H);
      __ sve_fcvt(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, ptrue, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ H);
    }
  
#line 37702 "ad_aarch64.cpp"
  }
}

void vcvtFtoHF_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4224 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // 4F to 4HF
    __ fcvtn(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T4H, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ T4S);
  
#line 37719 "ad_aarch64.cpp"
  }
}

void vcvtFtoHF_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4236 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_fcvt(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ H, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ S);
    __ sve_vector_narrow(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ H,
                         opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, __ S, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */);
  
#line 37740 "ad_aarch64.cpp"
  }
}

void replicateINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4252 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ dup(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_dup(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_reg_variant(this), opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    }
  
#line 37762 "ad_aarch64.cpp"
  }
}

void replicateLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4267 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ dup(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_dup(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_reg_variant(this), opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    }
  
#line 37784 "ad_aarch64.cpp"
  }
}

void replicateFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4282 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ dup(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_cpy(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ S, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 37806 "ad_aarch64.cpp"
  }
}

void replicateDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4297 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ dup(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_cpy(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 37828 "ad_aarch64.cpp"
  }
}

void replicateI_imm_le128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4316 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    int imm = (int)opnd_array(1)->constant();
    if (type2aelembytes(bt) == 1) {
      // Refine imm for B
      imm = imm & 0xff;
    } else if (type2aelembytes(bt) == 2) {
      // Refine imm for S
      imm = imm & 0xffff;
    }
    __ mov(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), imm);
  
#line 37853 "ad_aarch64.cpp"
  }
}

void replicateB_imm8_gt128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4336 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_dup(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ B, (int)(opnd_array(1)->constant()));
  
#line 37870 "ad_aarch64.cpp"
  }
}

void replicateI_imm8_gt128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4349 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_dup(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_reg_variant(this), (int)(opnd_array(1)->constant()));
  
#line 37887 "ad_aarch64.cpp"
  }
}

void replicateL_imm_128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4360 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ mov(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T2D, (uint64_t)(opnd_array(1)->constantL()));
  
#line 37903 "ad_aarch64.cpp"
  }
}

void replicateL_imm8_gt128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4370 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_dup(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, (int)(opnd_array(1)->constantL()));
  
#line 37920 "ad_aarch64.cpp"
  }
}

void insertI_le128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4388 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (opnd_array(0)->as_FloatRegister(ra_,this)/* dst */!= opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */) {
      __ orr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
             opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
    __ mov(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
           (int)(opnd_array(3)->constant()), opnd_array(2)->as_Register(ra_,this,idx2)/* val */);
  
#line 37945 "ad_aarch64.cpp"
  }
}

void insertI_index_lt32Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// pgtmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4411 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(1));
    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
    __ sve_index(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */, size, -16, 1);
    __ sve_cmp(Assembler::EQ, opnd_array(5)->as_PRegister(ra_,this,idx5)/* pgtmp */, size, ptrue,
               opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */, (int)(opnd_array(3)->constant()) - 16);
    if (opnd_array(0)->as_FloatRegister(ra_,this)/* dst */!= opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */) {
      __ sve_orr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
    __ sve_cpy(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, size, opnd_array(5)->as_PRegister(ra_,this,idx5)/* pgtmp */, opnd_array(2)->as_Register(ra_,this,idx2)/* val */);
  
#line 37974 "ad_aarch64.cpp"
  }
}

void insertI_index_ge32Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// pgtmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4435 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(1));
    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
    __ sve_index(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp1 */, size, 0, 1);
    __ sve_dup(opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp2 */, size, (int)(opnd_array(3)->constant()));
    __ sve_cmp(Assembler::EQ, opnd_array(6)->as_PRegister(ra_,this,idx6)/* pgtmp */, size, ptrue,
               opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp1 */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp2 */);
    if (opnd_array(0)->as_FloatRegister(ra_,this)/* dst */!= opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */) {
      __ sve_orr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
    __ sve_cpy(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, size, opnd_array(6)->as_PRegister(ra_,this,idx6)/* pgtmp */, opnd_array(2)->as_Register(ra_,this,idx2)/* val */);
  
#line 38005 "ad_aarch64.cpp"
  }
}

void insertL_128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4458 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    if (opnd_array(0)->as_FloatRegister(ra_,this)/* dst */!= opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */) {
      __ orr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T16B, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
    __ mov(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, (int)(opnd_array(3)->constant()), opnd_array(2)->as_Register(ra_,this,idx2)/* val */);
  
#line 38026 "ad_aarch64.cpp"
  }
}

void insertL_gt128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// pgtmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4474 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_index(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */, __ D, -16, 1);
    __ sve_cmp(Assembler::EQ, opnd_array(5)->as_PRegister(ra_,this,idx5)/* pgtmp */, __ D, ptrue,
               opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */, (int)(opnd_array(3)->constant()) - 16);
    if (opnd_array(0)->as_FloatRegister(ra_,this)/* dst */!= opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */) {
      __ sve_orr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
    __ sve_cpy(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, opnd_array(5)->as_PRegister(ra_,this,idx5)/* pgtmp */, opnd_array(2)->as_Register(ra_,this,idx2)/* val */);
  
#line 38053 "ad_aarch64.cpp"
  }
}

void insertF_le128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4495 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */!= opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */) {
      __ orr(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
             opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
    __ ins(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, __ S, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* val */, (int)(opnd_array(3)->constant()), 0);
  
#line 38077 "ad_aarch64.cpp"
  }
}

void insertF_index_lt32Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// pgtmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4514 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_index(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, __ S, -16, 1);
    __ sve_cmp(Assembler::EQ, opnd_array(5)->as_PRegister(ra_,this,idx5)/* pgtmp */, __ S, ptrue,
               opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, (int)(opnd_array(3)->constant()) - 16);
    __ sve_orr(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    __ sve_cpy(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, __ S, opnd_array(5)->as_PRegister(ra_,this,idx5)/* pgtmp */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* val */);
  
#line 38102 "ad_aarch64.cpp"
  }
}

void insertF_index_ge32Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// pgtmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4532 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_index(opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */, __ S, 0, 1);
    __ sve_dup(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, __ S, (int)(opnd_array(3)->constant()));
    __ sve_cmp(Assembler::EQ, opnd_array(6)->as_PRegister(ra_,this,idx6)/* pgtmp */, __ S, ptrue,
               opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */);
    __ sve_orr(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    __ sve_cpy(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, __ S, opnd_array(6)->as_PRegister(ra_,this,idx6)/* pgtmp */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* val */);
  
#line 38129 "ad_aarch64.cpp"
  }
}

void insertD_128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4552 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    if (opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */!= opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */) {
      __ orr(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, __ T16B, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
    __ ins(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, __ D, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* val */, (int)(opnd_array(3)->constant()), 0);
  
#line 38151 "ad_aarch64.cpp"
  }
}

void insertD_gt128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// pgtmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4568 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_index(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, __ D, -16, 1);
    __ sve_cmp(Assembler::EQ, opnd_array(5)->as_PRegister(ra_,this,idx5)/* pgtmp */, __ D, ptrue,
               opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, (int)(opnd_array(3)->constant()) - 16);
    __ sve_orr(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    __ sve_cpy(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, __ D, opnd_array(5)->as_PRegister(ra_,this,idx5)/* pgtmp */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* val */);
  
#line 38176 "ad_aarch64.cpp"
  }
}

void extractUB_iregNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4587 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // Input "src" is a vector of boolean represented as
    // bytes with 0x00/0x01 as element values.
    // "idx" is expected to be in range.

    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(1));
    __ mov(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, __ B, 0, opnd_array(2)->as_Register(ra_,this,idx2)/* idx */);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ tbl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, length_in_bytes == 16 ? __ T16B : __ T8B,
             opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, 1, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_tbl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, __ B, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */);
    }
    __ smov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, __ B, 0);
  
#line 38207 "ad_aarch64.cpp"
  }
}

void extractUB_index_lt16Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4610 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ smov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ B, (int)(opnd_array(2)->constant()));
  
#line 38224 "ad_aarch64.cpp"
  }
}

void extractUB_index_ge16Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4621 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_extract_integral(opnd_array(0)->as_Register(ra_,this)/* dst */, T_BYTE, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                            (int)(opnd_array(2)->constant()), opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */);
  
#line 38244 "ad_aarch64.cpp"
  }
}

void extractB_index_lt16Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4635 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ smov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ B, (int)(opnd_array(2)->constant()));
  
#line 38261 "ad_aarch64.cpp"
  }
}

void extractB_index_ge16Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4646 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_extract_integral(opnd_array(0)->as_Register(ra_,this)/* dst */, T_BYTE, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                            (int)(opnd_array(2)->constant()), opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */);
  
#line 38281 "ad_aarch64.cpp"
  }
}

void extractS_index_lt8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4660 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ smov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ H, (int)(opnd_array(2)->constant()));
  
#line 38298 "ad_aarch64.cpp"
  }
}

void extractS_index_ge8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4671 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_extract_integral(opnd_array(0)->as_Register(ra_,this)/* dst */, T_SHORT, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                            (int)(opnd_array(2)->constant()), opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */);
  
#line 38318 "ad_aarch64.cpp"
  }
}

void extractI_index_lt4Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4685 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ umov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ S, (int)(opnd_array(2)->constant()));
  
#line 38335 "ad_aarch64.cpp"
  }
}

void extractI_index_ge4Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4696 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_extract_integral(opnd_array(0)->as_Register(ra_,this)/* dst */, T_INT, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                            (int)(opnd_array(2)->constant()), opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */);
  
#line 38355 "ad_aarch64.cpp"
  }
}

void extractL_index_lt2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4710 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ umov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ D, (int)(opnd_array(2)->constant()));
  
#line 38372 "ad_aarch64.cpp"
  }
}

void extractL_index_ge2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4721 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    __ sve_extract_integral(opnd_array(0)->as_Register(ra_,this)/* dst */, T_LONG, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                            (int)(opnd_array(2)->constant()), opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */);
  
#line 38392 "ad_aarch64.cpp"
  }
}

void extractFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4735 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    int index = (int)opnd_array(2)->constant();
    if (index == 0) {
      __ fmovs(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else if (index < 4) {
      __ ins(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ S, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, 0, index);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_orr(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      __ sve_ext(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, index << 2);
    }
  
#line 38419 "ad_aarch64.cpp"
  }
}

void extractDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4756 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    int index = (int)opnd_array(2)->constant();
    if (index == 0) {
      __ fmovd(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else if (index < 2) {
      __ ins(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, 0, index);
    } else {
      assert(UseSVE > 0, "must be sve");
      __ sve_orr(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      __ sve_ext(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, index << 3);
    }
  
#line 38446 "ad_aarch64.cpp"
  }
}

void vloadmask_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4781 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    if (bt == T_BYTE) {
      uint length_in_bytes = Matcher::vector_length_in_bytes(this);
      __ negr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
              opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      __ uxtl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T8H, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ T8B);
      if (type2aelembytes(bt) >= 4) {
        __ uxtl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T4S, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T4H);
      }
      if (type2aelembytes(bt) == 8) {
        __ uxtl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T2D, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T2S);
      }
      __ negr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(0)->as_FloatRegister(ra_,this)/* dst */);
    }
  
#line 38476 "ad_aarch64.cpp"
  }
}

void vloadmaskB_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4806 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_cmp(Assembler::NE, opnd_array(0)->as_PRegister(ra_,this)/* dst */, __ B,
               ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, 0);
  
#line 38493 "ad_aarch64.cpp"
  }
}

void vloadmask_extend_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4818 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
    __ sve_vector_extend(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, size, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ B);
    __ sve_cmp(Assembler::NE, opnd_array(0)->as_PRegister(ra_,this)/* dst */, size, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, 0);
  
#line 38513 "ad_aarch64.cpp"
  }
}

void vloadmaskB_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4832 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_cmp(Assembler::NE, opnd_array(0)->as_PRegister(ra_,this)/* dst */, __ B,
               opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, 0);
  
#line 38531 "ad_aarch64.cpp"
  }
}

void vloadmask_extend_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4844 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
    __ sve_vector_extend(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, size, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ B);
    __ sve_cmp(Assembler::NE, opnd_array(0)->as_PRegister(ra_,this)/* dst */, size,
               opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, 0);
  
#line 38553 "ad_aarch64.cpp"
  }
}

void vstoremaskB_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// size
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4860 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == 8 || length_in_bytes == 16, "must be");
    __ negr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
  
#line 38573 "ad_aarch64.cpp"
  }
}

void vstoremask_narrow_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// size
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4873 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    int esize = (int)opnd_array(2)->constant();
    if (esize == 2) {
      __ xtn(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T8B, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ T8H);
    } else if (esize == 4) {
      __ xtn(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T4H, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ T4S);
      __ xtn(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T8B, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T8H);
    } else {
      assert(esize == 8, "must be");
      __ xtn(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T2S, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ T2D);
      __ xtn(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T4H, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T4S);
      __ xtn(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T8B, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T8H);
    }
    __ negr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T8B, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */);
  
#line 38602 "ad_aarch64.cpp"
  }
}

void vstoremaskB_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// size
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4897 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_cpy(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ B, opnd_array(1)->as_PRegister(ra_,this,idx1)/* src */, 1, false);
  
#line 38619 "ad_aarch64.cpp"
  }
}

void vstoremask_narrow_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// size
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4908 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant((int)opnd_array(2)->constant());
    __ sve_cpy(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, size, opnd_array(1)->as_PRegister(ra_,this,idx1)/* src */, 1, false);
    __ sve_vector_narrow(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ B,
                         opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, size, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 38641 "ad_aarch64.cpp"
  }
}

void vloadmask_loadVNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4926 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // Load mask values which are boolean type, and extend them to the
    // defined vector element type. Convert the vector to predicate.
    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */,
                          ptrue, T_BOOLEAN, bt, opnd_array(1)->opcode(),
                          as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
    __ sve_cmp(Assembler::NE, opnd_array(0)->as_PRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, 0);
  
#line 38667 "ad_aarch64.cpp"
  }
}

void vloadmask_loadV_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4949 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // Load valid mask values which are boolean type, and extend them to the
    // defined vector element type. Convert the vector to predicate.
    BasicType bt = Matcher::vector_element_basic_type(this);
    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */,
                          opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, T_BOOLEAN, bt, opnd_array(1)->opcode(),
                          as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
    __ sve_cmp(Assembler::NE, opnd_array(0)->as_PRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
               opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, 0);
  
#line 38692 "ad_aarch64.cpp"
  }
}

void vloadmask_loadVMaskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4969 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // Load mask values which are boolean type, and extend them to the
    // defined vector element type. Convert the vector to predicate.
    //
    // Note that we cannot use "pg" here, since it is the predicate used
    // for the vector load with boolean type. But the predicate used in
    // the extending "sve_ld1b" is based on the final extended vector type,
    // which is the full-sized predicate (ptrue) used in VectorLoadMask.
    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */,
                          ptrue, T_BOOLEAN, bt, opnd_array(1)->opcode(),
                          as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
    __ sve_cmp(Assembler::NE, opnd_array(0)->as_PRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
               ptrue, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, 0);
  
#line 38724 "ad_aarch64.cpp"
  }
}

void vloadmask_loadVMasked_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 4997 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // Load valid mask values which are boolean type, and extend them to the
    // defined vector element type. Convert the vector to predicate.
    //
    // Note that we cannot use "pg1" here, since it is the predicate used
    // for the vector load with boolean type. But the predicate used in
    // the extending "sve_ld1b" is based on the final extended vector type,
    // which is the "pg2" used in VectorLoadMask.
    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    loadStoreA_predicated(C2_MacroAssembler(&cbuf), false, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */,
                          opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg2 */, T_BOOLEAN, bt, opnd_array(1)->opcode(),
                          as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
    __ sve_cmp(Assembler::NE, opnd_array(0)->as_PRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg2 */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */, 0);
  
#line 38757 "ad_aarch64.cpp"
  }
}

void storeV_vstoremaskNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// esize
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5026 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // Convert the valid src predicate to vector, and store the vector elements
    // as boolean values.
    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    assert(type2aelembytes(bt) == (int)opnd_array(3)->constant(), "unsupported type");
    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant(opnd_array(3)->constant());
    __ sve_cpy(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */, size, opnd_array(2)->as_PRegister(ra_,this,idx2)/* src */, 1, false);
    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */,
                          ptrue, T_BOOLEAN, bt, opnd_array(1)->opcode(),
                          as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 38784 "ad_aarch64.cpp"
  }
}

void storeV_vstoremask_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// esize
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// pgtmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5048 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // Convert the valid src predicate to vector, and store the vector elements
    // as boolean values.
    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
    __ sve_cpy(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */, size, opnd_array(2)->as_PRegister(ra_,this,idx2)/* src */, 1, false);
    __ sve_gen_mask_imm(opnd_array(5)->as_PRegister(ra_,this,idx5)/* pgtmp */, bt, Matcher::vector_length(this, opnd_array(2)));
    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */,
                          opnd_array(5)->as_PRegister(ra_,this,idx5)/* pgtmp */, T_BOOLEAN, bt, opnd_array(1)->opcode(),
                          as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 38812 "ad_aarch64.cpp"
  }
}

void storeVMasked_vstoremaskNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// esize
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5069 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // Convert the valid src predicate to vector, and store the vector elements
    // as boolean values.
    //
    // Note that we cannot use "pg" here, since it is the predicate used
    // for the vector store with boolean type. But the predicate used in
    // the narrowing "sve_st1b" is based on the "src" vector type, which
    // is the full-sized predicate (ptrue) here.
    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    assert(type2aelembytes(bt) == (int)opnd_array(3)->constant(), "unsupported type.");
    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant(opnd_array(3)->constant());
    __ sve_cpy(opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */, size, opnd_array(2)->as_PRegister(ra_,this,idx2)/* src */, 1, false);
    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */,
                          ptrue, T_BOOLEAN, bt, opnd_array(1)->opcode(),
                          as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 38845 "ad_aarch64.cpp"
  }
}

void storeVMasked_vstoremask_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// esize
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// pgtmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5096 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // Convert the valid src predicate to vector, and store the vector elements
    // as boolean values.
    //
    // Note that we cannot use "pg" here, since it is the predicate used for the
    // vector store with boolean type. But the predicate used in the narrowing
    // "sve_st1b" is based on the "src" vector type, which needed to be generated
    // here.
    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(2));
    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
    __ sve_cpy(opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */, size, opnd_array(2)->as_PRegister(ra_,this,idx2)/* src */, 1, false);
    __ sve_gen_mask_imm(opnd_array(6)->as_PRegister(ra_,this,idx6)/* pgtmp */, bt, Matcher::vector_length(this, opnd_array(2)));
    loadStoreA_predicated(C2_MacroAssembler(&cbuf), true, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */,
                          opnd_array(6)->as_PRegister(ra_,this,idx6)/* pgtmp */, T_BOOLEAN, bt, opnd_array(1)->opcode(),
                          as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
  
#line 38879 "ad_aarch64.cpp"
  }
}

void vmask_andNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// pn
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pm
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5123 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_and(opnd_array(0)->as_PRegister(ra_,this)/* pd */, ptrue, opnd_array(1)->as_PRegister(ra_,this,idx1)/* pn */, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pm */);
  
#line 38896 "ad_aarch64.cpp"
  }
}

void vmask_orNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// pn
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pm
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5133 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_orr(opnd_array(0)->as_PRegister(ra_,this)/* pd */, ptrue, opnd_array(1)->as_PRegister(ra_,this,idx1)/* pn */, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pm */);
  
#line 38913 "ad_aarch64.cpp"
  }
}

void vmask_xorNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// pn
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pm
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5143 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_eor(opnd_array(0)->as_PRegister(ra_,this)/* pd */, ptrue, opnd_array(1)->as_PRegister(ra_,this,idx1)/* pn */, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pm */);
  
#line 38930 "ad_aarch64.cpp"
  }
}

void vmask_and_notINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// pn
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pm
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5153 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_bic(opnd_array(0)->as_PRegister(ra_,this)/* pd */, ptrue, opnd_array(1)->as_PRegister(ra_,this,idx1)/* pn */, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pm */);
  
#line 38948 "ad_aarch64.cpp"
  }
}

void vmask_and_notLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// pn
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pm
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5163 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_bic(opnd_array(0)->as_PRegister(ra_,this)/* pd */, ptrue, opnd_array(1)->as_PRegister(ra_,this,idx1)/* pn */, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pm */);
  
#line 38966 "ad_aarch64.cpp"
  }
}

void vmaskcmp_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cond
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5177 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)opnd_array(3)->constant());
    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    __ neon_compare(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, bt, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */,
                    opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, condition, /* isQ */ length_in_bytes == 16);
  
#line 38988 "ad_aarch64.cpp"
  }
}

void vmaskcmp_zeroI_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cond
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5191 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)opnd_array(3)->constant());
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    __ neon_compare_zero(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, Matcher::vector_element_basic_type(this),
                         opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                         condition, /* isQ */ length_in_bytes == 16);
  
#line 39010 "ad_aarch64.cpp"
  }
}

void vmaskcmp_zeroL_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cond
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5205 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)opnd_array(3)->constant());
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    __ neon_compare_zero(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, T_LONG,
                         opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                         condition, /* isQ */ length_in_bytes == 16);
  
#line 39032 "ad_aarch64.cpp"
  }
}

void vmaskcmp_zeroF_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cond
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5219 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)opnd_array(3)->constant());
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    __ neon_compare_zero(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, T_FLOAT,
                         opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                         condition, /* isQ */ length_in_bytes == 16);
  
#line 39054 "ad_aarch64.cpp"
  }
}

void vmaskcmp_zeroD_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cond
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5233 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)opnd_array(3)->constant());
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    __ neon_compare_zero(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, T_DOUBLE,
                         opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                         condition, /* isQ */ length_in_bytes == 16);
  
#line 39076 "ad_aarch64.cpp"
  }
}

void vmaskcmp_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cond
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5248 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)opnd_array(3)->constant());
    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_compare(opnd_array(0)->as_PRegister(ra_,this)/* dst */, bt, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */,
                   opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, condition);
  
#line 39099 "ad_aarch64.cpp"
  }
}

void vmaskcmp_immI_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cond
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5264 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)opnd_array(3)->constant());
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_cmp(condition, opnd_array(0)->as_PRegister(ra_,this)/* dst */, get_reg_variant(in(operand_index(opnd_array(1)))),
               ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant());
  
#line 39121 "ad_aarch64.cpp"
  }
}

void vmaskcmpU_immI_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cond
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5279 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)opnd_array(3)->constant());
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_cmp(condition, opnd_array(0)->as_PRegister(ra_,this)/* dst */, get_reg_variant(in(operand_index(opnd_array(1)))),
               ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant());
  
#line 39143 "ad_aarch64.cpp"
  }
}

void vmaskcmp_immL_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cond
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5294 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)opnd_array(3)->constant());
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_cmp(condition, opnd_array(0)->as_PRegister(ra_,this)/* dst */, get_reg_variant(in(operand_index(opnd_array(1)))),
               ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constantL());
  
#line 39165 "ad_aarch64.cpp"
  }
}

void vmaskcmpU_immL_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cond
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5309 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)opnd_array(3)->constant());
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_cmp(condition, opnd_array(0)->as_PRegister(ra_,this)/* dst */, get_reg_variant(in(operand_index(opnd_array(1)))),
               ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constantL());
  
#line 39187 "ad_aarch64.cpp"
  }
}

void vmaskcmp_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cond
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5325 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    Assembler::Condition condition = to_assembler_cond((BoolTest::mask)opnd_array(3)->constant());
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_compare(opnd_array(0)->as_PRegister(ra_,this)/* dst */, bt, opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */,
                   opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, condition);
  
#line 39209 "ad_aarch64.cpp"
  }
}

void vmaskcast_same_esize_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  // User did not define which encode class to use.
}

void vmaskcast_extend_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5352 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType dst_bt = Matcher::vector_element_basic_type(this);
    if (is_floating_point_type(dst_bt)) {
      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;
    }
    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);
    BasicType src_bt = Matcher::vector_element_basic_type(this, opnd_array(1));
    if (is_floating_point_type(src_bt)) {
      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;
    }
    __ neon_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, dst_bt, length_in_bytes_dst,
                          opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, src_bt);
  
#line 39243 "ad_aarch64.cpp"
  }
}

void vmaskcast_narrow_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5373 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType dst_bt = Matcher::vector_element_basic_type(this);
    if (is_floating_point_type(dst_bt)) {
      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;
    }
    BasicType src_bt = Matcher::vector_element_basic_type(this, opnd_array(1));
    if (is_floating_point_type(src_bt)) {
      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;
    }
    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, opnd_array(1));
    __ neon_vector_narrow(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, dst_bt,
                          opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, src_bt, length_in_bytes_src);
  
#line 39269 "ad_aarch64.cpp"
  }
}

void vmaskcast_same_esize_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  // User did not define which encode class to use.
}

void vmaskcast_extend_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5404 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);
    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, opnd_array(1));
    assert(length_in_bytes_dst == 2 * length_in_bytes_src ||
           length_in_bytes_dst == 4 * length_in_bytes_src ||
           length_in_bytes_dst == 8 * length_in_bytes_src, "invalid vector length");
    __ sve_vmaskcast_extend(opnd_array(0)->as_PRegister(ra_,this)/* dst */, opnd_array(1)->as_PRegister(ra_,this,idx1)/* src */,
                            length_in_bytes_dst, length_in_bytes_src);
  
#line 39299 "ad_aarch64.cpp"
  }
}

void vmaskcast_narrow_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ptmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5422 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);
    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, opnd_array(1));
    assert(length_in_bytes_dst * 2 == length_in_bytes_src ||
           length_in_bytes_dst * 4 == length_in_bytes_src ||
           length_in_bytes_dst * 8 == length_in_bytes_src, "invalid vector length");
    __ sve_vmaskcast_narrow(opnd_array(2)->as_PRegister(ra_,this,idx2)/* dst */, opnd_array(1)->as_PRegister(ra_,this,idx1)/* src */, opnd_array(3)->as_PRegister(ra_,this,idx3)/* ptmp */,
                            length_in_bytes_dst, length_in_bytes_src);
  
#line 39323 "ad_aarch64.cpp"
  }
}

void vmask_reinterpret_same_esizeNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  // User did not define which encode class to use.
}

void vmask_reinterpret_diff_esizeNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5454 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType from_bt = Matcher::vector_element_basic_type(this, opnd_array(1));
    Assembler::SIMD_RegVariant from_size = __ elemType_to_regVariant(from_bt);
    BasicType to_bt = Matcher::vector_element_basic_type(this);
    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);
    __ sve_cpy(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, from_size, opnd_array(1)->as_PRegister(ra_,this,idx1)/* src */, -1, false);
    __ sve_cmp(Assembler::EQ, opnd_array(0)->as_PRegister(ra_,this)/* dst */, to_size, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, -1);
  
#line 39353 "ad_aarch64.cpp"
  }
}

void vmask_truecount_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5474 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // Input "src" is a vector of boolean represented as bytes with
    // 0x00/0x01 as element values.
    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(1));
    assert(bt == T_BOOLEAN, "unsupported type");
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(1));
    __ addv(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, length_in_bytes == 16 ? __ T16B : __ T8B,
            opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    __ umov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, __ B, 0);
  
#line 39377 "ad_aarch64.cpp"
  }
}

void vmask_truecount_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5491 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(1));
    __ sve_cntp(opnd_array(0)->as_Register(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
                ptrue, opnd_array(1)->as_PRegister(ra_,this,idx1)/* src */);
  
#line 39395 "ad_aarch64.cpp"
  }
}

void vstoremask_truecount_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// size
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// vtmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5505 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // Input "src" is a vector mask represented as lanes with
    // 0/-1 as element values.
    uint esize = (uint)opnd_array(2)->constant();
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(1));
    Assembler::SIMD_Arrangement arrangement = Assembler::esize2arrangement(esize,
                                                                           /* isQ */ length_in_bytes == 16);
    if (arrangement == __ T2D || arrangement == __ T2S) {
      __ addpv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* vtmp */, arrangement, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    } else {
      __ addv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* vtmp */, arrangement, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
    __ smov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* vtmp */, __ B, 0);
    __ neg(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */);
  
#line 39425 "ad_aarch64.cpp"
  }
}

void vmask_firsttrue_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5529 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // Returns the index of the first active lane of the
    // vector mask, or VLENGTH if no lane is active.
    //
    // Input "src" is a vector of boolean represented as
    // bytes with 0x00/0x01 as element values.
    //
    // Computed by reversing the bits and counting the leading
    // zero bytes.

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(1));
    assert(bt == T_BOOLEAN, "unsupported type");
    uint vlength = Matcher::vector_length(this, opnd_array(1));
    if (vlength <= 8) {
      __ fmovd(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      if (vlength == 2 || vlength == 4) {
        // Special handling for 2B or 4B cases:
        // Vector mask is moved to a 64-bit general register, but only the low 16/32 bits are
        // significant for 2B/4B cases. We initialize the 16th/32nd bit as bit 1, so as to generate
        // the expected result (i.e. VLENGTH) for the case that all lanes are zero.
        __ orr(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */, vlength == 2 ? 0x10000 : 0x100000000);
      }
      __ rbit(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */);
      __ clz(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */);
      __ lsrw(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */, 3);
    } else {
      assert(vlength == 16, "must be");
      Label FIRST_TRUE_INDEX;

      // Try to compute the result from lower 64 bits.
      __ fmovd(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      __ movw(rscratch1, zr);
      __ cbnz(opnd_array(0)->as_Register(ra_,this)/* dst */, FIRST_TRUE_INDEX);

      // Compute the result from the higher 64 bits.
      __ fmovhid(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      __ movw(rscratch1, 8);

      // Reverse the bits and count the leading zero bytes.
      __ bind(FIRST_TRUE_INDEX);
      __ rbit(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */);
      __ clz(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */);
      __ addw(opnd_array(0)->as_Register(ra_,this)/* dst */, rscratch1, opnd_array(0)->as_Register(ra_,this)/* dst */, Assembler::LSR, 3);
    }
  
#line 39483 "ad_aarch64.cpp"
  }
}

void vmask_firsttrue_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// ptmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5585 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(1));
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(1));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_brkb(opnd_array(2)->as_PRegister(ra_,this,idx2)/* ptmp */, ptrue, opnd_array(1)->as_PRegister(ra_,this,idx1)/* src */, false);
    __ sve_cntp(opnd_array(0)->as_Register(ra_,this)/* dst */, __ elemType_to_regVariant(bt), ptrue, opnd_array(2)->as_PRegister(ra_,this,idx2)/* ptmp */);
  
#line 39504 "ad_aarch64.cpp"
  }
}

void vmask_firsttrue_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ptmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5600 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(1));
    __ sve_brkb(opnd_array(3)->as_PRegister(ra_,this,idx3)/* ptmp */, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_PRegister(ra_,this,idx1)/* src */, false);
    __ sve_cntp(opnd_array(0)->as_Register(ra_,this)/* dst */, __ elemType_to_regVariant(bt), ptrue, opnd_array(3)->as_PRegister(ra_,this,idx3)/* ptmp */);
  
#line 39524 "ad_aarch64.cpp"
  }
}

void vmask_lasttrue_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5614 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // Returns the index of the last active lane of the
    // vector mask, or -1 if no lane is active.
    //
    // Input "src" is a vector of boolean represented as
    // bytes with 0x00/0x01 as element values.

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(1));
    assert(bt == T_BOOLEAN, "unsupported type");
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(1));
    if (length_in_bytes <= 8) {
      // Computed by counting the leading zero bytes and
      // subtracting it by 7 (VLENGTH - 1).
      __ fmovd(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      __ clz(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */);
      __ movw(rscratch1, 7);
      __ subw(opnd_array(0)->as_Register(ra_,this)/* dst */, rscratch1, opnd_array(0)->as_Register(ra_,this)/* dst */, Assembler::LSR, 3);
    } else {
      assert(length_in_bytes == 16, "must be");
      Label LAST_TRUE_INDEX;

      // Try to compute the result from higher 64 bits.
      __ fmovhid(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      __ movw(rscratch1, 16 - 1);
      __ cbnz(opnd_array(0)->as_Register(ra_,this)/* dst */, LAST_TRUE_INDEX);

      // Compute the result from the lower 64 bits.
      __ fmovd(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      __ movw(rscratch1, 8 - 1);

      // Count the leading zero bytes and subtract it by 15 (VLENGTH - 1).
      __ bind(LAST_TRUE_INDEX);
      __ clz(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */);
      __ subw(opnd_array(0)->as_Register(ra_,this)/* dst */, rscratch1, opnd_array(0)->as_Register(ra_,this)/* dst */, Assembler::LSR, 3);
    }
  
#line 39573 "ad_aarch64.cpp"
  }
}

void vmask_lasttrue_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// ptmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5658 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this, opnd_array(1));
    __ sve_vmask_lasttrue(opnd_array(0)->as_Register(ra_,this)/* dst */, bt, opnd_array(1)->as_PRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_PRegister(ra_,this,idx2)/* ptmp */);
  
#line 39591 "ad_aarch64.cpp"
  }
}

void vmask_tolong_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5671 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // Input "src" is a vector of boolean represented as
    // bytes with 0x00/0x01 as element values.

    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(1));
    if (length_in_bytes <= 8) {
      __ fmovd(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      __ bytemask_compress(opnd_array(0)->as_Register(ra_,this)/* dst */);
    } else {
      assert(length_in_bytes == 16, "must be");
      __ umov(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ D, 0);
      __ umov(rscratch1, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ D, 1);
      __ bytemask_compress(opnd_array(0)->as_Register(ra_,this)/* dst */);
      __ bytemask_compress(rscratch1);
      __ orr(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */, rscratch1, Assembler::LSL, 8);
    }
  
#line 39621 "ad_aarch64.cpp"
  }
}

void vmask_tolong_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5696 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_vmask_tolong(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_PRegister(ra_,this,idx1)/* src */,
                        Matcher::vector_element_basic_type(this, opnd_array(1)),
                        Matcher::vector_length(this, opnd_array(1)),
                        opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp1 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp2 */);
  
#line 39642 "ad_aarch64.cpp"
  }
}

void vmask_fromlongNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5711 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_vmask_fromlong(opnd_array(0)->as_PRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */,
                          Matcher::vector_element_basic_type(this),
                          Matcher::vector_length(this),
                          opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp1 */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp2 */);
  
#line 39663 "ad_aarch64.cpp"
  }
}

void vmaskAll_immINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5729 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    int con = (int)opnd_array(1)->constant();
    if (con == 0) {
      __ sve_pfalse(opnd_array(0)->as_PRegister(ra_,this)/* dst */);
    } else {
      assert(con == -1, "invalid constant value for mask");
      BasicType bt = Matcher::vector_element_basic_type(this);
      __ sve_gen_mask_imm(opnd_array(0)->as_PRegister(ra_,this)/* dst */, bt, Matcher::vector_length(this));
    }
  
#line 39686 "ad_aarch64.cpp"
  }
}

void vmaskAllINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5747 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_dup(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, size, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ sve_cmp(Assembler::NE, opnd_array(0)->as_PRegister(ra_,this)/* dst */, size, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, 0);
  
#line 39708 "ad_aarch64.cpp"
  }
}

void vmaskAllI_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5763 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
    __ sve_dup(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, size, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ sve_cmp(Assembler::NE, opnd_array(0)->as_PRegister(ra_,this)/* dst */, size,
               opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, 0);
  
#line 39730 "ad_aarch64.cpp"
  }
}

void vmaskAll_immLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5778 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    long con = (long)opnd_array(1)->constantL();
    if (con == 0) {
      __ sve_pfalse(opnd_array(0)->as_PRegister(ra_,this)/* dst */);
    } else {
      assert(con == -1, "invalid constant value for mask");
      BasicType bt = Matcher::vector_element_basic_type(this);
      __ sve_gen_mask_imm(opnd_array(0)->as_PRegister(ra_,this)/* dst */, bt, Matcher::vector_length(this));
    }
  
#line 39753 "ad_aarch64.cpp"
  }
}

void vmaskAllLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5796 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_dup(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, size, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ sve_cmp(Assembler::NE, opnd_array(0)->as_PRegister(ra_,this)/* dst */, size, ptrue, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* tmp */, 0);
  
#line 39775 "ad_aarch64.cpp"
  }
}

void vmaskAllL_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5812 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
    __ sve_dup(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, size, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ sve_cmp(Assembler::NE, opnd_array(0)->as_PRegister(ra_,this)/* dst */, size,
               opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, 0);
  
#line 39797 "ad_aarch64.cpp"
  }
}

void vmask_gen_INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5829 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_whileltw(opnd_array(0)->as_PRegister(ra_,this)/* pd */, __ elemType_to_regVariant(bt), zr, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 39814 "ad_aarch64.cpp"
  }
}

void vmask_gen_LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5841 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_whilelt(opnd_array(0)->as_PRegister(ra_,this)/* pd */, __ elemType_to_regVariant(bt), zr, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 39831 "ad_aarch64.cpp"
  }
}

void vmask_gen_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5853 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_gen_mask_imm(opnd_array(0)->as_PRegister(ra_,this)/* pd */, bt, (uint)(opnd_array(1)->constantL()));
  
#line 39848 "ad_aarch64.cpp"
  }
}

void vmask_gen_subNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5865 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_whilelt(opnd_array(0)->as_PRegister(ra_,this)/* pd */, __ elemType_to_regVariant(bt), opnd_array(2)->as_Register(ra_,this,idx2)/* src2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
  
#line 39866 "ad_aarch64.cpp"
  }
}

void vpopcountINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5879 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (bt == T_BYTE) {
      if (VM_Version::use_neon_for_vector(length_in_bytes)) {
        __ cnt(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
               opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      } else {
        assert(UseSVE > 0, "must be sve");
        __ sve_cnt(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ B, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      }
    } else {
      assert(bt == T_SHORT || bt == T_INT, "unsupported");
      if (UseSVE == 0) {
        assert(length_in_bytes == 8 || length_in_bytes == 16, "unsupported");
        __ cnt(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
               opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        __ uaddlp(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
                  opnd_array(0)->as_FloatRegister(ra_,this)/* dst */);
        if (bt == T_INT) {
          __ uaddlp(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T8H : __ T4H,
                    opnd_array(0)->as_FloatRegister(ra_,this)/* dst */);
        }
      } else {
        __ sve_cnt(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
                   ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      }
    }
  
#line 39908 "ad_aarch64.cpp"
  }
}

void vpopcountLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5916 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    if (UseSVE == 0) {
      __ cnt(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T16B, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      __ uaddlp(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T16B, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */);
      __ uaddlp(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T8H, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */);
      __ uaddlp(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T4S, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */);
    } else {
      __ sve_cnt(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
    }
  
#line 39931 "ad_aarch64.cpp"
  }
}

void vpopcountI_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5935 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_cnt(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 39950 "ad_aarch64.cpp"
  }
}

void vpopcountL_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5947 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_cnt(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ D,
               opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 39968 "ad_aarch64.cpp"
  }
}

void vblend_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5960 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == 8 || length_in_bytes == 16, "must be");
    __ bsl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
           opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */);
  
#line 39989 "ad_aarch64.cpp"
  }
}

void vblend_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5973 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_sel(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
               opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */);
  
#line 40009 "ad_aarch64.cpp"
  }
}

void vround_le128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5992 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ vector_round_neon(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                         opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp1 */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp2 */,
                         opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp3 */, get_arrangement(this));
  
#line 40031 "ad_aarch64.cpp"
  }
}

void vround_le128b_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp3
  {
    C2_MacroAssembler _masm(&cbuf);

#line 5992 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ vector_round_neon(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                         opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp1 */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp2 */,
                         opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp3 */, get_arrangement(this));
  
#line 40053 "ad_aarch64.cpp"
  }
}

void vround_gt128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// pgtmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6007 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ vector_round_sve(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                        opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp1 */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp2 */,
                        opnd_array(5)->as_PRegister(ra_,this,idx5)/* pgtmp */, __ elemType_to_regVariant(bt));
  
#line 40077 "ad_aarch64.cpp"
  }
}

void vround_gt128b_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// pgtmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6007 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ vector_round_sve(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                        opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp1 */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp2 */,
                        opnd_array(5)->as_PRegister(ra_,this,idx5)/* pgtmp */, __ elemType_to_regVariant(bt));
  
#line 40101 "ad_aarch64.cpp"
  }
}

void vroundDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rmode
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6025 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      switch (opnd_array(2)->constant()) {
        case RoundDoubleModeNode::rmode_rint:
          __ frintn(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T2D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
          break;
        case RoundDoubleModeNode::rmode_floor:
          __ frintm(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T2D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
          break;
        case RoundDoubleModeNode::rmode_ceil:
          __ frintp(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T2D, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
          break;
        default:
          assert(false, "unsupported");
          ShouldNotReachHere();
      }
    } else {
      assert(UseSVE > 0, "must be sve");
      switch (opnd_array(2)->constant()) {
        case RoundDoubleModeNode::rmode_rint:
          __ sve_frintn(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
          break;
        case RoundDoubleModeNode::rmode_floor:
          __ sve_frintm(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
          break;
        case RoundDoubleModeNode::rmode_ceil:
          __ sve_frintp(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
          break;
        default:
          assert(false, "unsupported");
          ShouldNotReachHere();
      }
    }
  
#line 40150 "ad_aarch64.cpp"
  }
}

void vtest_anytrue_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6073 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // No need to use src2.
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(1));
    assert(length_in_bytes == 8 || length_in_bytes == 16, "must be");
    __ addv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, length_in_bytes == 16 ? __ T16B : __ T8B, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */);
    __ umov(rscratch1, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, __ B, 0);
    __ cmpw(rscratch1, zr);
  
#line 40173 "ad_aarch64.cpp"
  }
}

void vtest_anytrue_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6089 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // "src2" is not used for sve.
    __ sve_ptest(ptrue, opnd_array(1)->as_PRegister(ra_,this,idx1)/* src1 */);
  
#line 40191 "ad_aarch64.cpp"
  }
}

void vtest_alltrue_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6104 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // No need to use src2.
    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(1));
    assert(length_in_bytes == 8 || length_in_bytes == 16, "must be");
    __ uminv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, length_in_bytes == 16 ? __ T16B : __ T8B, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */);
    __ umov(rscratch1, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, __ B, 0);
    __ cmpw(rscratch1, 0xff);
  
#line 40214 "ad_aarch64.cpp"
  }
}

void vtest_alltrue_sveNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ptmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6121 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_eors(opnd_array(3)->as_PRegister(ra_,this,idx3)/* ptmp */, ptrue, opnd_array(1)->as_PRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_PRegister(ra_,this,idx2)/* src2 */);
  
#line 40232 "ad_aarch64.cpp"
  }
}

void loadshuffleNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6132 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (bt == T_BYTE) {
      if (opnd_array(0)->as_FloatRegister(ra_,this)/* dst */!= opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */) {
        if (VM_Version::use_neon_for_vector(length_in_bytes)) {
          __ orr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
                 opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        } else {
          assert(UseSVE > 0, "must be sve");
          __ sve_orr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        }
      }
    } else {
      if (VM_Version::use_neon_for_vector(length_in_bytes)) {
        // 4S/8S, 4I, 4F
        __ uxtl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T8H, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ T8B);
        if (type2aelembytes(bt) == 4) {
          __ uxtl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T4S, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ T4H);
        }
      } else {
        assert(UseSVE > 0, "must be sve");
        __ sve_vector_extend(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */,  __ elemType_to_regVariant(bt),
                             opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ B);
      }
    }
  
#line 40272 "ad_aarch64.cpp"
  }
}

void rearrange_HS_neonNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shuffle
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6192 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    if (bt == T_SHORT) {
      uint length_in_bytes = Matcher::vector_length_in_bytes(this);
      assert(length_in_bytes == 8 || length_in_bytes == 16, "must be");
      Assembler::SIMD_Arrangement size1 = length_in_bytes == 16 ? __ T16B : __ T8B;
      Assembler::SIMD_Arrangement size2 = length_in_bytes == 16 ? __ T8H : __ T4H;
      __ mov(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp1 */, size1, 0x02);
      __ mov(opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp2 */, size2, 0x0100);
      __ mulv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, size2, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shuffle */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp1 */);
      __ addv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, size1, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp2 */);
      __ tbl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, size1, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, 1, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */);
    } else {
      assert(bt == T_INT || bt == T_FLOAT, "unsupported type");
      __ mov(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp1 */, __ T16B, 0x04);
      __ mov(opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp2 */, __ T4S, 0x03020100);
      __ mulv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ T4S, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shuffle */, opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp1 */);
      __ addv(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ T16B, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp2 */);
      __ tbl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, __ T16B, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, 1, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */);
    }
  
#line 40310 "ad_aarch64.cpp"
  }
}

void rearrangeNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shuffle
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6220 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt_dst = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (bt_dst == T_BYTE && VM_Version::use_neon_for_vector(length_in_bytes)) {
      __ tbl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
             opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, 1, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shuffle */);
    } else {
      assert(UseSVE > 0, "must be sve");
      BasicType bt_src = Matcher::vector_element_basic_type(this, opnd_array(1));
      __ sve_tbl(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt_src),
                 opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* shuffle */);
    }
  
#line 40337 "ad_aarch64.cpp"
  }
}

void gather_loadSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6243 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_ld1w_gather(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, ptrue,
                       as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* idx */);
 
#line 40357 "ad_aarch64.cpp"
  }
}

void gather_loadDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6258 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_uunpklo(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */, __ D, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* idx */);
    __ sve_ld1d_gather(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, ptrue, as_Register(opnd_array(1)->base(ra_,this,idx1)),
                       opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* tmp */);
  
#line 40379 "ad_aarch64.cpp"
  }
}

void gather_loadS_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6273 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_ld1w_gather(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */,
                       as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* idx */);
  
#line 40398 "ad_aarch64.cpp"
  }
}

void gather_loadD_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6286 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_uunpklo(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */, __ D, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* idx */);
    __ sve_ld1d_gather(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(3)->as_PRegister(ra_,this,idx3)/* pg */,
                       as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 40419 "ad_aarch64.cpp"
  }
}

void scatter_storeSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6301 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_st1w_scatter(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, ptrue,
                        as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* idx */);
  
#line 40440 "ad_aarch64.cpp"
  }
}

void scatter_storeDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6316 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    uint length_in_bytes = Matcher::vector_length_in_bytes(this, opnd_array(2));
    assert(length_in_bytes == MaxVectorSize, "invalid vector length");
    __ sve_uunpklo(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */, __ D, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* idx */);
    __ sve_st1d_scatter(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, ptrue,
                        as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp */);
  
#line 40463 "ad_aarch64.cpp"
  }
}

void scatter_storeS_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6331 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_st1w_scatter(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */,
                        as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* idx */);
  
#line 40483 "ad_aarch64.cpp"
  }
}

void scatter_storeD_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6344 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_uunpklo(opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */, __ D, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* idx */);
    __ sve_st1d_scatter(opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src */, opnd_array(4)->as_PRegister(ra_,this,idx4)/* pg */,
                        as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */);
  
#line 40505 "ad_aarch64.cpp"
  }
}

void vcountLeadingZerosNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6357 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (bt == T_LONG) {
      if (UseSVE == 0) {
        __ umov(rscratch1, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ D, 0);
        __ clz(rscratch1, rscratch1);
        __ mov(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, 0, rscratch1);
        __ umov(rscratch1, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, __ D, 1);
        __ clz(rscratch1, rscratch1);
        __ mov(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, 1, rscratch1);
      } else {
        __ sve_clz(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      }
    } else {
      if (VM_Version::use_neon_for_vector(length_in_bytes)) {
        __ clz(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      } else {
        assert(UseSVE > 0, "must be sve");
        __ sve_clz(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
                   ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      }
    }
  
#line 40542 "ad_aarch64.cpp"
  }
}

void vcountLeadingZeros_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6391 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_clz(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 40561 "ad_aarch64.cpp"
  }
}

void vcountTrailingZerosNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6404 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (bt == T_BYTE) {
      if (VM_Version::use_neon_for_vector(length_in_bytes)) {
        __ rbit(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
                opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        __ clz(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(0)->as_FloatRegister(ra_,this)/* dst */);
      } else {
        assert(UseSVE > 0, "must be sve");
        __ sve_rbit(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ B, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        __ sve_clz(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ B, ptrue, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */);
      }
    } else {
      assert(bt == T_SHORT || bt == T_INT || bt == T_LONG, "unsupported type");
      if (UseSVE == 0) {
        assert(length_in_bytes == 8 || length_in_bytes == 16, "unsupported");
        __ neon_reverse_bits(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                             bt, /* isQ */ length_in_bytes == 16);
        if (bt != T_LONG) {
          __ clz(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, get_arrangement(this), opnd_array(0)->as_FloatRegister(ra_,this)/* dst */);
        } else {
          __ umov(rscratch1, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, 0);
          __ clz(rscratch1, rscratch1);
          __ mov(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, 0, rscratch1);
          __ umov(rscratch1, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, 1);
          __ clz(rscratch1, rscratch1);
          __ mov(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ D, 1, rscratch1);
        }
      } else {
        Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
        __ sve_rbit(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, size, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        __ sve_clz(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, size, ptrue, opnd_array(0)->as_FloatRegister(ra_,this)/* dst */);
      }
    }
  
#line 40610 "ad_aarch64.cpp"
  }
}

void vcountTrailingZeros_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6449 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
    __ sve_rbit(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, size,
                opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
    __ sve_clz(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, size,
               opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 40632 "ad_aarch64.cpp"
  }
}

void vreverseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6465 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (bt == T_BYTE) {
      if (VM_Version::use_neon_for_vector(length_in_bytes)) {
        __ rbit(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
                opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      } else {
        assert(UseSVE > 0, "must be sve");
        __ sve_rbit(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ B, ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      }
    } else {
      assert(bt == T_SHORT || bt == T_INT || bt == T_LONG, "unsupported type");
      if (UseSVE == 0) {
        assert(length_in_bytes == 8 || length_in_bytes == 16, "unsupported");
        __ neon_reverse_bits(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                             bt, /* isQ */ length_in_bytes == 16);
      } else {
        __ sve_rbit(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
                    ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      }
    }
  
#line 40668 "ad_aarch64.cpp"
  }
}

void vreverse_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6498 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_rbit(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
               opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
  
#line 40687 "ad_aarch64.cpp"
  }
}

void vreverseBytesNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6511 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    uint length_in_bytes = Matcher::vector_length_in_bytes(this);
    if (VM_Version::use_neon_for_vector(length_in_bytes)) {
      assert(length_in_bytes == 8 || length_in_bytes == 16, "unsupported");
      if (bt == T_BYTE) {
        if (opnd_array(0)->as_FloatRegister(ra_,this)/* dst */!= opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */) {
          __ orr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, length_in_bytes == 16 ? __ T16B : __ T8B,
                 opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        }
      } else {
        __ neon_reverse_bytes(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */,
                              bt, /* isQ */ length_in_bytes == 16);
      }
    } else {
      assert(UseSVE > 0, "must be sve");
      if (bt == T_BYTE) {
        if (opnd_array(0)->as_FloatRegister(ra_,this)/* dst */!= opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */) {
          __ sve_orr(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
        }
      } else {
        __ sve_revb(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
                    ptrue, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */);
      }
    }
  
#line 40726 "ad_aarch64.cpp"
  }
}

void vreverseBytes_maskedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6546 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    if (bt == T_BYTE) {
      // do nothing
    } else {
      __ sve_revb(opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */, __ elemType_to_regVariant(bt),
                  opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* dst_src */);
    }
  
#line 40749 "ad_aarch64.cpp"
  }
}

void populateindexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6564 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_index(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
                 opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */, (int)(opnd_array(2)->constant()));
  
#line 40768 "ad_aarch64.cpp"
  }
}

void mcompressNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6579 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
    __ sve_cntp(rscratch1, size, ptrue, opnd_array(1)->as_PRegister(ra_,this,idx1)/* pg */);
    __ sve_whilelt(as_PRegister(opnd_array(0)->reg(ra_,this)/* dst */), size, zr, rscratch1);
  
#line 40787 "ad_aarch64.cpp"
  }
}

void vcompressNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6593 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    __ sve_compact(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, __ elemType_to_regVariant(bt),
                   opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */);
  
#line 40806 "ad_aarch64.cpp"
  }
}

void vcompressBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp3
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp4
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// ptmp
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// pgtmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6607 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_compress_byte(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */,
                         opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp1 */,opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp2 */,
                         opnd_array(6)->as_FloatRegister(ra_,this,idx6)/* tmp3 */,opnd_array(7)->as_FloatRegister(ra_,this,idx7)/* tmp4 */,
                         opnd_array(8)->as_PRegister(ra_,this,idx8)/* ptmp */, opnd_array(9)->as_PRegister(ra_,this,idx9)/* pgtmp */);
  
#line 40833 "ad_aarch64.cpp"
  }
}

void vcompressSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// pgtmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6622 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ sve_compress_short(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */,
                          opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* tmp1 */,opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp2 */, opnd_array(6)->as_PRegister(ra_,this,idx6)/* pgtmp */);
  
#line 40855 "ad_aarch64.cpp"
  }
}

void vexpandNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6633 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    // Example input:   src   = 1 2 3 4 5 6 7 8
    //                  pg    = 1 0 0 1 1 0 1 1
    // Expected result: dst   = 4 0 0 5 6 0 7 8

    // The basic idea is to use TBL which can shuffle the elements in the given
    // vector flexibly. HISTCNT + SUB is used to generate the second source input
    // for TBL whose value is used to select the indexed element from src vector.

    BasicType bt = Matcher::vector_element_basic_type(this);
    assert(UseSVE == 2 && !is_subword_type(bt), "unsupported");
    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
    // dst = 0 0 0 0 0 0 0 0
    __ sve_dup(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, size, 0);
    // dst = 5 0 0 4 3 0 2 1
    __ sve_histcnt(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, size, opnd_array(2)->as_PRegister(ra_,this,idx2)/* pg */,
                   opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */);
    // dst = 4 -1 -1 3 2 -1 1 0
    __ sve_sub(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, size, 1);
    // dst = 4 0 0 5 6 0 7 8
    __ sve_tbl(opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */, size, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* dst */);
  
#line 40892 "ad_aarch64.cpp"
  }
}

void vsignum_le128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// one
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6668 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ vector_signum_neon(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* zero */,
                          opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* one */, get_arrangement(this));
  
#line 40912 "ad_aarch64.cpp"
  }
}

void vsignum_le128b_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// one
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6668 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    __ vector_signum_neon(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* zero */,
                          opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* one */, get_arrangement(this));
  
#line 40932 "ad_aarch64.cpp"
  }
}

void vsignum_gt128bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// one
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// pgtmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6681 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ vector_signum_sve(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* zero */,
                         opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* one */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */, opnd_array(6)->as_PRegister(ra_,this,idx6)/* pgtmp */,
                         __ elemType_to_regVariant(bt));
  
#line 40957 "ad_aarch64.cpp"
  }
}

void vsignum_gt128b_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// one
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// pgtmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6681 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    assert(UseSVE > 0, "must be sve");
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ vector_signum_sve(opnd_array(4)->as_FloatRegister(ra_,this,idx4)/* dst */, opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* zero */,
                         opnd_array(3)->as_FloatRegister(ra_,this,idx3)/* one */, opnd_array(5)->as_FloatRegister(ra_,this,idx5)/* tmp */, opnd_array(6)->as_PRegister(ra_,this,idx6)/* pgtmp */,
                         __ elemType_to_regVariant(bt));
  
#line 40982 "ad_aarch64.cpp"
  }
}

void vcompressBitsNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6696 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
    __ sve_bext(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, size,
                opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 41002 "ad_aarch64.cpp"
  }
}

void vexpandBitsNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    C2_MacroAssembler _masm(&cbuf);

#line 6710 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64_vector.ad"

    BasicType bt = Matcher::vector_element_basic_type(this);
    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);
    __ sve_bdep(opnd_array(0)->as_FloatRegister(ra_,this)/* dst */, size,
                opnd_array(1)->as_FloatRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_FloatRegister(ra_,this,idx2)/* src2 */);
  
#line 41022 "ad_aarch64.cpp"
  }
}

void compareAndSwapP_shenandoahNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {

#line 31 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/shenandoah/shenandoah_aarch64.ad"

    MacroAssembler _masm(&cbuf);
    guarantee(opnd_array(1)->index(ra_,this,idx1) == -1 && opnd_array(1)->disp(ra_,this,idx1) == 0, "impossible encoding");
    Register tmp = opnd_array(4)->as_Register(ra_,this,idx4)/* tmp */;
    __ mov(tmp, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */); // Must not clobber oldval.
    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, tmp, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
                                                   /*acquire*/ false, /*release*/ true, /*is_cae*/ false, opnd_array(0)->as_Register(ra_,this)/* res */);
  
#line 41045 "ad_aarch64.cpp"
  }
}

void compareAndSwapN_shenandoahNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 77 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/shenandoah/shenandoah_aarch64.ad"

    Register tmp = opnd_array(4)->as_Register(ra_,this,idx4)/* tmp */;
    __ mov(tmp, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */); // Must not clobber oldval.
    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, tmp, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, /*acquire*/ false, /*release*/ true, /*is_cae*/ false, opnd_array(0)->as_Register(ra_,this)/* res */);
  
#line 41066 "ad_aarch64.cpp"
  }
}

void compareAndSwapPAcq_shenandoahNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {

#line 40 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/shenandoah/shenandoah_aarch64.ad"

    MacroAssembler _masm(&cbuf);
    guarantee(opnd_array(1)->index(ra_,this,idx1) == -1 && opnd_array(1)->disp(ra_,this,idx1) == 0, "impossible encoding");
    Register tmp = opnd_array(4)->as_Register(ra_,this,idx4)/* tmp */;
    __ mov(tmp, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */); // Must not clobber oldval.
    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, tmp, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
                                                   /*acquire*/ true, /*release*/ true, /*is_cae*/ false, opnd_array(0)->as_Register(ra_,this)/* res */);
  
#line 41089 "ad_aarch64.cpp"
  }
}

void compareAndSwapNAcq_shenandoahNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 115 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/shenandoah/shenandoah_aarch64.ad"

    Register tmp = opnd_array(4)->as_Register(ra_,this,idx4)/* tmp */;
    __ mov(tmp, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */); // Must not clobber oldval.
    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, tmp, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, /*acquire*/ true, /*release*/ true, /*is_cae*/ false, opnd_array(0)->as_Register(ra_,this)/* res */);
  
#line 41110 "ad_aarch64.cpp"
  }
}

void compareAndExchangeN_shenandoahNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 131 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/shenandoah/shenandoah_aarch64.ad"

    Register tmp = opnd_array(5)->as_Register(ra_,this,idx5)/* tmp */;
    __ mov(tmp, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */); // Must not clobber oldval.
    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, tmp, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
                                                   /*acquire*/ false, /*release*/ true, /*is_cae*/ true, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 41133 "ad_aarch64.cpp"
  }
}

void compareAndExchangeP_shenandoahNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 147 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/shenandoah/shenandoah_aarch64.ad"

    Register tmp = opnd_array(5)->as_Register(ra_,this,idx5)/* tmp */;
    __ mov(tmp, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */); // Must not clobber oldval.
    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, tmp, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
                                                   /*acquire*/ false, /*release*/ true, /*is_cae*/ true, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 41156 "ad_aarch64.cpp"
  }
}

void compareAndExchangeNAcq_shenandoahNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 164 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/shenandoah/shenandoah_aarch64.ad"

    Register tmp = opnd_array(5)->as_Register(ra_,this,idx5)/* tmp */;
    __ mov(tmp, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */); // Must not clobber oldval.
    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, tmp, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
                                                   /*acquire*/ true, /*release*/ true, /*is_cae*/ true, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 41179 "ad_aarch64.cpp"
  }
}

void compareAndExchangePAcq_shenandoahNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 181 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/shenandoah/shenandoah_aarch64.ad"

    Register tmp = opnd_array(5)->as_Register(ra_,this,idx5)/* tmp */;
    __ mov(tmp, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */); // Must not clobber oldval.
    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, tmp, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
                                                   /*acquire*/ true, /*release*/ true, /*is_cae*/ true, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 41202 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapN_shenandoahNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 198 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/shenandoah/shenandoah_aarch64.ad"

    Register tmp = opnd_array(4)->as_Register(ra_,this,idx4)/* tmp */;
    __ mov(tmp, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */); // Must not clobber oldval.
    // Weak is not currently supported by ShenandoahBarrierSet::cmpxchg_oop
    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, tmp, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
                                                   /*acquire*/ false, /*release*/ true, /*is_cae*/ false, opnd_array(0)->as_Register(ra_,this)/* res */);
  
#line 41225 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapP_shenandoahNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 215 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/shenandoah/shenandoah_aarch64.ad"

    Register tmp = opnd_array(4)->as_Register(ra_,this,idx4)/* tmp */;
    __ mov(tmp, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */); // Must not clobber oldval.
    // Weak is not currently supported by ShenandoahBarrierSet::cmpxchg_oop
    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, tmp, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
                                                   /*acquire*/ false, /*release*/ true, /*is_cae*/ false, opnd_array(0)->as_Register(ra_,this)/* res */);
  
#line 41248 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapNAcq_shenandoahNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 234 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/shenandoah/shenandoah_aarch64.ad"

    Register tmp = opnd_array(4)->as_Register(ra_,this,idx4)/* tmp */;
    __ mov(tmp, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */); // Must not clobber oldval.
    // Weak is not currently supported by ShenandoahBarrierSet::cmpxchg_oop
    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, tmp, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
                                                   /*acquire*/ true, /*release*/ true, /*is_cae*/ false, opnd_array(0)->as_Register(ra_,this)/* res */);
  
#line 41271 "ad_aarch64.cpp"
  }
}

void weakCompareAndSwapPAcq_shenandoahNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 253 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/shenandoah/shenandoah_aarch64.ad"

    Register tmp = opnd_array(4)->as_Register(ra_,this,idx4)/* tmp */;
    __ mov(tmp, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */); // Must not clobber oldval.
    // Weak is not currently supported by ShenandoahBarrierSet::cmpxchg_oop
    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, tmp, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */,
                                                   /*acquire*/ true, /*release*/ true, /*is_cae*/ false, opnd_array(0)->as_Register(ra_,this)/* res */);
  
#line 41294 "ad_aarch64.cpp"
  }
}

void xLoadPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 64 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/x/x_aarch64.ad"

    const Address ref_addr = mem2address(opnd_array(1)->opcode(), as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
    __ ldr(opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, ref_addr);
    x_load_barrier(_masm, this, ref_addr, opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, rscratch2 /* tmp */, barrier_data());
  
#line 41313 "ad_aarch64.cpp"
  }
}

void xLoadPVolatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 84 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/x/x_aarch64.ad"

    __ ldar(opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */);
    x_load_barrier(_masm, this, Address(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */), opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, rscratch2 /* tmp */, barrier_data());
  
#line 41331 "ad_aarch64.cpp"
  }
}

void xCompareAndSwapPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 103 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/x/x_aarch64.ad"

    guarantee(opnd_array(1)->index(ra_,this,idx1)== -1 && opnd_array(1)->disp(ra_,this,idx1)== 0, "impossible encoding");
    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, Assembler::xword,
               false /* acquire */, true /* release */, false /* weak */, rscratch2);
    __ cset(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, Assembler::EQ);
    if (barrier_data() != XLoadBarrierElided) {
      Label good;
      __ ldr(rscratch1, Address(rthread, XThreadLocalData::address_bad_mask_offset()));
      __ andr(rscratch1, rscratch1, rscratch2);
      __ cbz(rscratch1, good);
      x_load_barrier_slow_path(_masm, this, Address(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */), rscratch2 /* ref */, rscratch1 /* tmp */);
      __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, Assembler::xword,
                 false /* acquire */, true /* release */, false /* weak */, rscratch2);
      __ cset(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, Assembler::EQ);
      __ bind(good);
    }
  
#line 41364 "ad_aarch64.cpp"
  }
}

void xCompareAndSwapP_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 103 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/x/x_aarch64.ad"

    guarantee(opnd_array(1)->index(ra_,this,idx1)== -1 && opnd_array(1)->disp(ra_,this,idx1)== 0, "impossible encoding");
    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, Assembler::xword,
               false /* acquire */, true /* release */, false /* weak */, rscratch2);
    __ cset(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, Assembler::EQ);
    if (barrier_data() != XLoadBarrierElided) {
      Label good;
      __ ldr(rscratch1, Address(rthread, XThreadLocalData::address_bad_mask_offset()));
      __ andr(rscratch1, rscratch1, rscratch2);
      __ cbz(rscratch1, good);
      x_load_barrier_slow_path(_masm, this, Address(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */), rscratch2 /* ref */, rscratch1 /* tmp */);
      __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, Assembler::xword,
                 false /* acquire */, true /* release */, false /* weak */, rscratch2);
      __ cset(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, Assembler::EQ);
      __ bind(good);
    }
  
#line 41397 "ad_aarch64.cpp"
  }
}

void xCompareAndSwapPAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 135 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/x/x_aarch64.ad"

    guarantee(opnd_array(1)->index(ra_,this,idx1)== -1 && opnd_array(1)->disp(ra_,this,idx1)== 0, "impossible encoding");
    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, Assembler::xword,
               true /* acquire */, true /* release */, false /* weak */, rscratch2);
    __ cset(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, Assembler::EQ);
    if (barrier_data() != XLoadBarrierElided) {
      Label good;
      __ ldr(rscratch1, Address(rthread, XThreadLocalData::address_bad_mask_offset()));
      __ andr(rscratch1, rscratch1, rscratch2);
      __ cbz(rscratch1, good);
      x_load_barrier_slow_path(_masm, this, Address(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */), rscratch2 /* ref */, rscratch1 /* tmp */ );
      __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, Assembler::xword,
                 true /* acquire */, true /* release */, false /* weak */, rscratch2);
      __ cset(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, Assembler::EQ);
      __ bind(good);
    }
  
#line 41430 "ad_aarch64.cpp"
  }
}

void xCompareAndSwapPAcq_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 135 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/x/x_aarch64.ad"

    guarantee(opnd_array(1)->index(ra_,this,idx1)== -1 && opnd_array(1)->disp(ra_,this,idx1)== 0, "impossible encoding");
    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, Assembler::xword,
               true /* acquire */, true /* release */, false /* weak */, rscratch2);
    __ cset(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, Assembler::EQ);
    if (barrier_data() != XLoadBarrierElided) {
      Label good;
      __ ldr(rscratch1, Address(rthread, XThreadLocalData::address_bad_mask_offset()));
      __ andr(rscratch1, rscratch1, rscratch2);
      __ cbz(rscratch1, good);
      x_load_barrier_slow_path(_masm, this, Address(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */), rscratch2 /* ref */, rscratch1 /* tmp */ );
      __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, Assembler::xword,
                 true /* acquire */, true /* release */, false /* weak */, rscratch2);
      __ cset(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, Assembler::EQ);
      __ bind(good);
    }
  
#line 41463 "ad_aarch64.cpp"
  }
}

void xCompareAndExchangePNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 165 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/x/x_aarch64.ad"

    guarantee(opnd_array(1)->index(ra_,this,idx1)== -1 && opnd_array(1)->disp(ra_,this,idx1)== 0, "impossible encoding");
    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, Assembler::xword,
               false /* acquire */, true /* release */, false /* weak */, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
    if (barrier_data() != XLoadBarrierElided) {
      Label good;
      __ ldr(rscratch1, Address(rthread, XThreadLocalData::address_bad_mask_offset()));
      __ andr(rscratch1, rscratch1, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
      __ cbz(rscratch1, good);
      x_load_barrier_slow_path(_masm, this, Address(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */), opnd_array(4)->as_Register(ra_,this,idx4)/* res */, rscratch1 /* tmp */);
      __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, Assembler::xword,
                 false /* acquire */, true /* release */, false /* weak */, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
      __ bind(good);
    }
  
#line 41494 "ad_aarch64.cpp"
  }
}

void xCompareAndExchangePAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  {
    C2_MacroAssembler _masm(&cbuf);

#line 193 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/x/x_aarch64.ad"

    guarantee(opnd_array(1)->index(ra_,this,idx1)== -1 && opnd_array(1)->disp(ra_,this,idx1)== 0, "impossible encoding");
    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, Assembler::xword,
               true /* acquire */, true /* release */, false /* weak */, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
    if (barrier_data() != XLoadBarrierElided) {
      Label good;
      __ ldr(rscratch1, Address(rthread, XThreadLocalData::address_bad_mask_offset()));
      __ andr(rscratch1, rscratch1, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
      __ cbz(rscratch1, good);
      x_load_barrier_slow_path(_masm, this, Address(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */), opnd_array(4)->as_Register(ra_,this,idx4)/* res */, rscratch1 /* tmp */);
      __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, Assembler::xword,
                 true /* acquire */, true /* release */, false /* weak */, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
      __ bind(good);
    }
  
#line 41525 "ad_aarch64.cpp"
  }
}

void xGetAndSetPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// prev
  {
    C2_MacroAssembler _masm(&cbuf);

#line 221 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/x/x_aarch64.ad"

    __ atomic_xchg(opnd_array(3)->as_Register(ra_,this,idx3)/* prev */, opnd_array(2)->as_Register(ra_,this,idx2)/* newv */, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */);
    x_load_barrier(_masm, this, Address(noreg, 0), opnd_array(3)->as_Register(ra_,this,idx3)/* prev */, rscratch2 /* tmp */, barrier_data());
  
#line 41544 "ad_aarch64.cpp"
  }
}

void xGetAndSetPAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// prev
  {
    C2_MacroAssembler _masm(&cbuf);

#line 238 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/x/x_aarch64.ad"

    __ atomic_xchgal(opnd_array(3)->as_Register(ra_,this,idx3)/* prev */, opnd_array(2)->as_Register(ra_,this,idx2)/* newv */, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */);
    x_load_barrier(_masm, this, Address(noreg, 0), opnd_array(3)->as_Register(ra_,this,idx3)/* prev */, rscratch2 /* tmp */, barrier_data());
  
#line 41563 "ad_aarch64.cpp"
  }
}

void zLoadPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 113 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/z/z_aarch64.ad"

    const Address ref_addr = mem2address(opnd_array(1)->opcode(), as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
    __ ldr(opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, ref_addr);
    z_load_barrier(_masm, this, ref_addr, opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, rscratch1);
  
#line 41582 "ad_aarch64.cpp"
  }
}

void zLoadPVolatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {
    C2_MacroAssembler _masm(&cbuf);

#line 133 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/z/z_aarch64.ad"

    const Address ref_addr = Address(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */);
    __ ldar(opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */);
    z_load_barrier(_masm, this, ref_addr, opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, rscratch1);
  
#line 41601 "ad_aarch64.cpp"
  }
}

void zStorePNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 151 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/z/z_aarch64.ad"

    const Address ref_addr = mem2address(opnd_array(1)->opcode(), as_Register(opnd_array(1)->base(ra_,this,idx1)), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1));
    z_store_barrier(_masm, this, ref_addr, opnd_array(2)->as_Register(ra_,this,idx2)/* src */, opnd_array(3)->as_Register(ra_,this,idx3)/* tmp */, rscratch2, false /* is_atomic */);
    __ str(opnd_array(3)->as_Register(ra_,this,idx3)/* tmp */, ref_addr);
  
#line 41621 "ad_aarch64.cpp"
  }
}

void zStorePVolatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 168 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/z/z_aarch64.ad"

    const Address ref_addr = Address(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */);
    z_store_barrier(_masm, this, ref_addr, opnd_array(2)->as_Register(ra_,this,idx2)/* src */, opnd_array(3)->as_Register(ra_,this,idx3)/* tmp */, rscratch2, false /* is_atomic */);
    __ stlr(opnd_array(3)->as_Register(ra_,this,idx3)/* tmp */, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */);
  
#line 41641 "ad_aarch64.cpp"
  }
}

void zCompareAndSwapPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// oldval_tmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// newval_tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 187 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/z/z_aarch64.ad"

    guarantee(opnd_array(1)->index(ra_,this,idx1)== -1 && opnd_array(1)->disp(ra_,this,idx1)== 0, "impossible encoding");
    Address ref_addr(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */);
    z_store_barrier(_masm, this, ref_addr, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, opnd_array(6)->as_Register(ra_,this,idx6)/* newval_tmp */, rscratch2, true /* is_atomic */);
    z_color(_masm, this, opnd_array(5)->as_Register(ra_,this,idx5)/* oldval_tmp */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */);
    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(5)->as_Register(ra_,this,idx5)/* oldval_tmp */, opnd_array(6)->as_Register(ra_,this,idx6)/* newval_tmp */, Assembler::xword,
               false /* acquire */, true /* release */, false /* weak */, noreg);
    __ cset(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, Assembler::EQ);
  
#line 41668 "ad_aarch64.cpp"
  }
}

void zCompareAndSwapP_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// oldval_tmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// newval_tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 187 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/z/z_aarch64.ad"

    guarantee(opnd_array(1)->index(ra_,this,idx1)== -1 && opnd_array(1)->disp(ra_,this,idx1)== 0, "impossible encoding");
    Address ref_addr(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */);
    z_store_barrier(_masm, this, ref_addr, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, opnd_array(6)->as_Register(ra_,this,idx6)/* newval_tmp */, rscratch2, true /* is_atomic */);
    z_color(_masm, this, opnd_array(5)->as_Register(ra_,this,idx5)/* oldval_tmp */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */);
    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(5)->as_Register(ra_,this,idx5)/* oldval_tmp */, opnd_array(6)->as_Register(ra_,this,idx6)/* newval_tmp */, Assembler::xword,
               false /* acquire */, true /* release */, false /* weak */, noreg);
    __ cset(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, Assembler::EQ);
  
#line 41695 "ad_aarch64.cpp"
  }
}

void zCompareAndSwapPAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// oldval_tmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// newval_tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 211 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/z/z_aarch64.ad"

    guarantee(opnd_array(1)->index(ra_,this,idx1)== -1 && opnd_array(1)->disp(ra_,this,idx1)== 0, "impossible encoding");
    Address ref_addr(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */);
    z_store_barrier(_masm, this, ref_addr, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, opnd_array(6)->as_Register(ra_,this,idx6)/* newval_tmp */, rscratch2, true /* is_atomic */);
    z_color(_masm, this, opnd_array(5)->as_Register(ra_,this,idx5)/* oldval_tmp */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */);
    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(5)->as_Register(ra_,this,idx5)/* oldval_tmp */, opnd_array(6)->as_Register(ra_,this,idx6)/* newval_tmp */, Assembler::xword,
               true /* acquire */, true /* release */, false /* weak */, noreg);
    __ cset(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, Assembler::EQ);
  
#line 41722 "ad_aarch64.cpp"
  }
}

void zCompareAndSwapPAcq_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// oldval_tmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// newval_tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 211 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/z/z_aarch64.ad"

    guarantee(opnd_array(1)->index(ra_,this,idx1)== -1 && opnd_array(1)->disp(ra_,this,idx1)== 0, "impossible encoding");
    Address ref_addr(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */);
    z_store_barrier(_masm, this, ref_addr, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, opnd_array(6)->as_Register(ra_,this,idx6)/* newval_tmp */, rscratch2, true /* is_atomic */);
    z_color(_masm, this, opnd_array(5)->as_Register(ra_,this,idx5)/* oldval_tmp */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */);
    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(5)->as_Register(ra_,this,idx5)/* oldval_tmp */, opnd_array(6)->as_Register(ra_,this,idx6)/* newval_tmp */, Assembler::xword,
               true /* acquire */, true /* release */, false /* weak */, noreg);
    __ cset(opnd_array(4)->as_Register(ra_,this,idx4)/* res */, Assembler::EQ);
  
#line 41749 "ad_aarch64.cpp"
  }
}

void zCompareAndExchangePNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// oldval_tmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// newval_tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 235 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/z/z_aarch64.ad"

    guarantee(opnd_array(1)->index(ra_,this,idx1)== -1 && opnd_array(1)->disp(ra_,this,idx1)== 0, "impossible encoding");
    Address ref_addr(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */);
    z_store_barrier(_masm, this, ref_addr, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, opnd_array(6)->as_Register(ra_,this,idx6)/* newval_tmp */, rscratch2, true /* is_atomic */);
    z_color(_masm, this, opnd_array(5)->as_Register(ra_,this,idx5)/* oldval_tmp */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */);
    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(5)->as_Register(ra_,this,idx5)/* oldval_tmp */, opnd_array(6)->as_Register(ra_,this,idx6)/* newval_tmp */, Assembler::xword,
               false /* acquire */, true /* release */, false /* weak */, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
    z_uncolor(_masm, this, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 41776 "ad_aarch64.cpp"
  }
}

void zCompareAndExchangePAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// oldval_tmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// newval_tmp
  {
    C2_MacroAssembler _masm(&cbuf);

#line 258 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/z/z_aarch64.ad"

    guarantee(opnd_array(1)->index(ra_,this,idx1)== -1 && opnd_array(1)->disp(ra_,this,idx1)== 0, "impossible encoding");
    Address ref_addr(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */);
    z_store_barrier(_masm, this, ref_addr, opnd_array(3)->as_Register(ra_,this,idx3)/* newval */, opnd_array(6)->as_Register(ra_,this,idx6)/* newval_tmp */, rscratch2, true /* is_atomic */);
    z_color(_masm, this, opnd_array(5)->as_Register(ra_,this,idx5)/* oldval_tmp */, opnd_array(2)->as_Register(ra_,this,idx2)/* oldval */);
    __ cmpxchg(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */, opnd_array(5)->as_Register(ra_,this,idx5)/* oldval_tmp */, opnd_array(6)->as_Register(ra_,this,idx6)/* newval_tmp */, Assembler::xword,
               true /* acquire */, true /* release */, false /* weak */, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
    z_uncolor(_masm, this, opnd_array(4)->as_Register(ra_,this,idx4)/* res */);
  
#line 41803 "ad_aarch64.cpp"
  }
}

void zGetAndSetPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// prev
  {
    C2_MacroAssembler _masm(&cbuf);

#line 280 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/z/z_aarch64.ad"

    z_store_barrier(_masm, this, Address(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */), opnd_array(2)->as_Register(ra_,this,idx2)/* newv */, opnd_array(3)->as_Register(ra_,this,idx3)/* prev */, rscratch2, true /* is_atomic */);
    __ atomic_xchg(opnd_array(3)->as_Register(ra_,this,idx3)/* prev */, opnd_array(3)->as_Register(ra_,this,idx3)/* prev */, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */);
    z_uncolor(_masm, this, opnd_array(3)->as_Register(ra_,this,idx3)/* prev */);
  
#line 41823 "ad_aarch64.cpp"
  }
}

void zGetAndSetPAcqNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// prev
  {
    C2_MacroAssembler _masm(&cbuf);

#line 298 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/gc/z/z_aarch64.ad"

    z_store_barrier(_masm, this, Address(opnd_array(1)->as_Register(ra_,this,idx1)/* mem */), opnd_array(2)->as_Register(ra_,this,idx2)/* newv */, opnd_array(3)->as_Register(ra_,this,idx3)/* prev */, rscratch2, true /* is_atomic */);
    __ atomic_xchgal(opnd_array(3)->as_Register(ra_,this,idx3)/* prev */, opnd_array(3)->as_Register(ra_,this,idx3)/* prev */, opnd_array(1)->as_Register(ra_,this,idx1)/* mem */);
    z_uncolor(_masm, this, opnd_array(3)->as_Register(ra_,this,idx3)/* prev */);
  
#line 41843 "ad_aarch64.cpp"
  }
}

const MachOper* loadBNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadB2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUBNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUB2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadSNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadS2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUSNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUS2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadINode::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUI2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadLNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadRangeNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadPNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadNNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadKlassNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadNKlassNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadFNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadDNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeimmCM0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeimmCM0_orderedNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeBNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeimmB0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeCNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeimmC0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeINode::memory_operand() const { return _opnds[1]; }
const MachOper* storeimmI0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeLNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeimmL0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storePNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeimmP0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeNNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmN0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeFNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeDNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeNKlassNode::memory_operand() const { return _opnds[1]; }
const MachOper* prefetchallocNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadB_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadB2L_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUB_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUB2L_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadS_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUS_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUS2L_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadS2L_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadI_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUI2L_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadL_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadP_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadN_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadF_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadD_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeB_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeimmB0_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeC_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeimmC0_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeI_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeimmI0_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeL_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeimmL0_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeP_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeimmP0_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeN_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeimmN0_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeF_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeD_volatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* cacheWBNode::memory_operand() const { return _opnds[1]; }
const MachOper* popCountI_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* popCountL_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapBNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapSNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapINode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapLNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapPNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapNNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapBAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapSAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapIAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapLAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapPAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapNAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeBNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeSNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeINode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeLNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeNNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangePNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeBAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeSAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeIAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeLAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeNAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangePAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapBNode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapSNode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapINode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapLNode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapNNode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapPNode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapBAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapSAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapIAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapLAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapNAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapPAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_setINode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_setLNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_setNNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_setPNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_setIAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_setLAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_setNAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_setPAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addLNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addL_no_resNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addLiNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addLi_no_resNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addINode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addI_no_resNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addIiNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addIi_no_resNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addLAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addL_no_resAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addLiAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addLi_no_resAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addIAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addI_no_resAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addIiAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* get_and_addIi_no_resAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* compressBitsI_memconNode::memory_operand() const { return _opnds[1]; }
const MachOper* compressBitsL_memconNode::memory_operand() const { return _opnds[1]; }
const MachOper* expandBitsI_memconNode::memory_operand() const { return _opnds[1]; }
const MachOper* expandBitsL_memconNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadV2Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeV2Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadV4Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeV4Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadV8Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeV8Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadV16Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeV16Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadVNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeVNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadV_maskedNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeV_maskedNode::memory_operand() const { return _opnds[1]; }
const MachOper* vloadmask_loadVNode::memory_operand() const { return _opnds[1]; }
const MachOper* vloadmask_loadV_maskedNode::memory_operand() const { return _opnds[1]; }
const MachOper* vloadmask_loadVMaskedNode::memory_operand() const { return _opnds[1]; }
const MachOper* vloadmask_loadVMasked_maskedNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeV_vstoremaskNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeV_vstoremask_maskedNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeVMasked_vstoremaskNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeVMasked_vstoremask_maskedNode::memory_operand() const { return _opnds[1]; }
const MachOper* gather_loadSNode::memory_operand() const { return _opnds[1]; }
const MachOper* gather_loadDNode::memory_operand() const { return _opnds[1]; }
const MachOper* gather_loadS_maskedNode::memory_operand() const { return _opnds[1]; }
const MachOper* gather_loadD_maskedNode::memory_operand() const { return _opnds[1]; }
const MachOper* scatter_storeSNode::memory_operand() const { return _opnds[1]; }
const MachOper* scatter_storeDNode::memory_operand() const { return _opnds[1]; }
const MachOper* scatter_storeS_maskedNode::memory_operand() const { return _opnds[1]; }
const MachOper* scatter_storeD_maskedNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapP_shenandoahNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapN_shenandoahNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapPAcq_shenandoahNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapNAcq_shenandoahNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeN_shenandoahNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeP_shenandoahNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeNAcq_shenandoahNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangePAcq_shenandoahNode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapN_shenandoahNode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapP_shenandoahNode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapNAcq_shenandoahNode::memory_operand() const { return _opnds[1]; }
const MachOper* weakCompareAndSwapPAcq_shenandoahNode::memory_operand() const { return _opnds[1]; }
const MachOper* xLoadPNode::memory_operand() const { return _opnds[1]; }
const MachOper* xLoadPVolatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* xCompareAndSwapPNode::memory_operand() const { return _opnds[1]; }
const MachOper* xCompareAndSwapP_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* xCompareAndSwapPAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* xCompareAndSwapPAcq_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* xCompareAndExchangePNode::memory_operand() const { return _opnds[1]; }
const MachOper* xCompareAndExchangePAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* xGetAndSetPNode::memory_operand() const { return _opnds[1]; }
const MachOper* xGetAndSetPAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* zLoadPNode::memory_operand() const { return _opnds[1]; }
const MachOper* zLoadPVolatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* zStorePNode::memory_operand() const { return _opnds[1]; }
const MachOper* zStorePVolatileNode::memory_operand() const { return _opnds[1]; }
const MachOper* zCompareAndSwapPNode::memory_operand() const { return _opnds[1]; }
const MachOper* zCompareAndSwapP_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* zCompareAndSwapPAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* zCompareAndSwapPAcq_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* zCompareAndExchangePNode::memory_operand() const { return _opnds[1]; }
const MachOper* zCompareAndExchangePAcqNode::memory_operand() const { return _opnds[1]; }
const MachOper* zGetAndSetPNode::memory_operand() const { return _opnds[1]; }
const MachOper* zGetAndSetPAcqNode::memory_operand() const { return _opnds[1]; }


bool Matcher::has_match_rule(int opcode) {
  assert(_last_machine_leaf < opcode && opcode < _last_opcode, "opcode in range");
  return _hasMatchRule[opcode];
}

const bool Matcher::_hasMatchRule[_last_opcode] = {
    false,  // Node
    false,  // Set
    false,  // RegN
    false,  // RegI
    false,  // RegP
    false,  // RegF
    false,  // RegD
    false,  // RegL
    false,  // VecA
    false,  // VecS
    false,  // VecD
    false,  // VecX
    false,  // VecY
    false,  // VecZ
    false,  // RegVectMask
    false,  // RegFlags
    false,  // _last_machine_leaf
    true ,  // AbsD
    true ,  // AbsF
    true ,  // AbsI
    true ,  // AbsL
    true ,  // AddD
    true ,  // AddF
    true ,  // AddI
    true ,  // AddL
    true ,  // AddP
    false,  // Allocate
    false,  // AllocateArray
    true ,  // AndI
    true ,  // AndL
    false,  // ArrayCopy
    true ,  // AryEq
    false,  // AtanD
    true ,  // Binary
    false,  // Blackhole
    true ,  // Bool
    false,  // BoxLock
    true ,  // ReverseBytesI
    true ,  // ReverseBytesL
    true ,  // ReverseBytesUS
    true ,  // ReverseBytesS
    true ,  // ReverseBytesV
    false,  // CProj
    true ,  // CacheWB
    true ,  // CacheWBPreSync
    true ,  // CacheWBPostSync
    true ,  // CallDynamicJava
    false,  // CallJava
    true ,  // CallLeaf
    true ,  // CallLeafNoFP
    false,  // CallLeafVector
    true ,  // CallRuntime
    true ,  // CallStaticJava
    true ,  // CastDD
    true ,  // CastFF
    true ,  // CastII
    true ,  // CastLL
    true ,  // CastVV
    true ,  // CastX2P
    true ,  // CastP2X
    true ,  // CastPP
    false,  // Catch
    false,  // CatchProj
    true ,  // CheckCastPP
    true ,  // ClearArray
    true ,  // CompressBits
    true ,  // ExpandBits
    true ,  // CompressBitsV
    true ,  // ExpandBitsV
    false,  // ConstraintCast
    true ,  // CMoveD
    true ,  // CMoveF
    true ,  // CMoveI
    true ,  // CMoveL
    true ,  // CMoveP
    true ,  // CMoveN
    true ,  // CmpN
    true ,  // CmpD
    true ,  // CmpD3
    true ,  // CmpF
    true ,  // CmpF3
    true ,  // CmpI
    true ,  // CmpL
    true ,  // CmpL3
    true ,  // CmpLTMask
    true ,  // CmpP
    true ,  // CmpU
    true ,  // CmpU3
    true ,  // CmpUL
    true ,  // CmpUL3
    true ,  // CompareAndSwapB
    true ,  // CompareAndSwapS
    true ,  // CompareAndSwapI
    true ,  // CompareAndSwapL
    true ,  // CompareAndSwapP
    true ,  // CompareAndSwapN
    true ,  // WeakCompareAndSwapB
    true ,  // WeakCompareAndSwapS
    true ,  // WeakCompareAndSwapI
    true ,  // WeakCompareAndSwapL
    true ,  // WeakCompareAndSwapP
    true ,  // WeakCompareAndSwapN
    true ,  // CompareAndExchangeB
    true ,  // CompareAndExchangeS
    true ,  // CompareAndExchangeI
    true ,  // CompareAndExchangeL
    true ,  // CompareAndExchangeP
    true ,  // CompareAndExchangeN
    false,  // GetAndAddB
    false,  // GetAndAddS
    true ,  // GetAndAddI
    true ,  // GetAndAddL
    false,  // GetAndSetB
    false,  // GetAndSetS
    true ,  // GetAndSetI
    true ,  // GetAndSetL
    true ,  // GetAndSetP
    true ,  // GetAndSetN
    false,  // Con
    true ,  // ConN
    true ,  // ConNKlass
    true ,  // ConD
    true ,  // ConF
    true ,  // ConI
    true ,  // ConL
    true ,  // ConP
    false,  // Conv2B
    true ,  // ConvD2F
    true ,  // ConvD2I
    true ,  // ConvD2L
    true ,  // ConvF2D
    true ,  // ConvF2I
    true ,  // ConvF2L
    true ,  // ConvI2D
    true ,  // ConvI2F
    true ,  // ConvI2L
    true ,  // ConvL2D
    true ,  // ConvL2F
    true ,  // ConvL2I
    true ,  // ConvF2HF
    true ,  // ConvHF2F
    false,  // CountedLoop
    true ,  // CountedLoopEnd
    false,  // OuterStripMinedLoop
    false,  // OuterStripMinedLoopEnd
    false,  // LongCountedLoop
    false,  // LongCountedLoopEnd
    true ,  // CountLeadingZerosI
    true ,  // CountLeadingZerosL
    true ,  // CountLeadingZerosV
    true ,  // CountTrailingZerosI
    true ,  // CountTrailingZerosL
    true ,  // CountTrailingZerosV
    true ,  // CreateEx
    true ,  // DecodeN
    true ,  // DecodeNKlass
    true ,  // DivD
    true ,  // DivF
    true ,  // DivI
    true ,  // DivL
    true ,  // UDivI
    true ,  // UDivL
    false,  // DivMod
    false,  // DivModI
    false,  // DivModL
    false,  // UDivModI
    false,  // UDivModL
    true ,  // EncodeISOArray
    true ,  // EncodeP
    true ,  // EncodePKlass
    true ,  // FastLock
    true ,  // FastUnlock
    true ,  // FmaD
    true ,  // FmaF
    true ,  // Goto
    true ,  // Halt
    true ,  // CountPositives
    true ,  // If
    false,  // RangeCheck
    false,  // IfFalse
    false,  // IfTrue
    false,  // Initialize
    false,  // JProj
    false,  // Jump
    false,  // JumpProj
    true ,  // LShiftI
    true ,  // LShiftL
    true ,  // LoadB
    true ,  // LoadUB
    true ,  // LoadUS
    true ,  // LoadD
    false,  // LoadD_unaligned
    true ,  // LoadF
    true ,  // LoadI
    true ,  // LoadKlass
    true ,  // LoadNKlass
    true ,  // LoadL
    false,  // LoadL_unaligned
    true ,  // LoadP
    true ,  // LoadN
    true ,  // LoadRange
    true ,  // LoadS
    false,  // Lock
    false,  // Loop
    false,  // LoopLimit
    false,  // Mach
    false,  // MachNullCheck
    false,  // MachProj
    true ,  // MulAddS2I
    true ,  // MaxI
    false,  // MaxL
    true ,  // MaxD
    true ,  // MaxF
    true ,  // MemBarAcquire
    true ,  // LoadFence
    true ,  // MemBarAcquireLock
    false,  // MemBarCPUOrder
    true ,  // MemBarRelease
    true ,  // StoreFence
    true ,  // StoreStoreFence
    true ,  // MemBarReleaseLock
    true ,  // MemBarVolatile
    true ,  // MemBarStoreStore
    false,  // MergeMem
    true ,  // MinI
    false,  // MinL
    true ,  // MinF
    true ,  // MinD
    false,  // ModD
    false,  // ModF
    true ,  // ModI
    true ,  // ModL
    true ,  // UModI
    true ,  // UModL
    true ,  // MoveI2F
    true ,  // MoveF2I
    true ,  // MoveL2D
    true ,  // MoveD2L
    false,  // IsInfiniteF
    false,  // IsFiniteF
    false,  // IsInfiniteD
    false,  // IsFiniteD
    true ,  // MulD
    true ,  // MulF
    true ,  // MulHiL
    true ,  // UMulHiL
    true ,  // MulI
    true ,  // MulL
    false,  // Multi
    false,  // NegI
    false,  // NegL
    true ,  // NegD
    true ,  // NegF
    false,  // NeverBranch
    true ,  // OnSpinWait
    false,  // Opaque1
    false,  // OpaqueLoopInit
    false,  // OpaqueLoopStride
    false,  // OpaqueZeroTripGuard
    false,  // Opaque3
    false,  // Opaque4
    false,  // ProfileBoolean
    true ,  // OrI
    true ,  // OrL
    true ,  // OverflowAddI
    true ,  // OverflowSubI
    true ,  // OverflowMulI
    true ,  // OverflowAddL
    true ,  // OverflowSubL
    true ,  // OverflowMulL
    false,  // PCTable
    false,  // Parm
    false,  // ParsePredicate
    true ,  // PartialSubtypeCheck
    false,  // SubTypeCheck
    false,  // Phi
    true ,  // PopCountI
    true ,  // PopCountL
    true ,  // PopCountVI
    true ,  // PopCountVL
    true ,  // PopulateIndex
    true ,  // PrefetchAllocation
    false,  // Proj
    true ,  // RShiftI
    true ,  // RShiftL
    false,  // Region
    true ,  // Rethrow
    true ,  // Return
    true ,  // ReverseI
    true ,  // ReverseL
    true ,  // ReverseV
    false,  // Root
    false,  // RoundDouble
    true ,  // RoundDoubleMode
    true ,  // RoundDoubleModeV
    false,  // RoundFloat
    true ,  // RotateLeft
    false,  // RotateLeftV
    true ,  // RotateRight
    false,  // RotateRightV
    true ,  // SafePoint
    false,  // SafePointScalarObject
    false,  // SafePointScalarMerge
    true ,  // ShenandoahCompareAndExchangeP
    true ,  // ShenandoahCompareAndExchangeN
    true ,  // ShenandoahCompareAndSwapN
    true ,  // ShenandoahCompareAndSwapP
    true ,  // ShenandoahWeakCompareAndSwapN
    true ,  // ShenandoahWeakCompareAndSwapP
    false,  // ShenandoahIUBarrier
    false,  // ShenandoahLoadReferenceBarrier
    false,  // SCMemProj
    true ,  // CopySignD
    true ,  // CopySignF
    true ,  // SignumD
    true ,  // SignumF
    true ,  // SignumVF
    true ,  // SignumVD
    true ,  // SqrtD
    true ,  // SqrtF
    true ,  // RoundF
    true ,  // RoundD
    false,  // Start
    false,  // StartOSR
    true ,  // StoreB
    true ,  // StoreC
    true ,  // StoreCM
    true ,  // StoreD
    true ,  // StoreF
    true ,  // StoreI
    true ,  // StoreL
    true ,  // StoreP
    true ,  // StoreN
    true ,  // StoreNKlass
    true ,  // StrComp
    true ,  // StrCompressedCopy
    true ,  // StrEquals
    true ,  // StrIndexOf
    true ,  // StrIndexOfChar
    true ,  // StrInflatedCopy
    true ,  // SubD
    true ,  // SubF
    true ,  // SubI
    true ,  // SubL
    true ,  // TailCall
    true ,  // TailJump
    false,  // MacroLogicV
    true ,  // ThreadLocal
    false,  // Unlock
    false,  // URShiftB
    false,  // URShiftS
    true ,  // URShiftI
    true ,  // URShiftL
    true ,  // XorI
    true ,  // XorL
    false,  // Vector
    true ,  // AddVB
    true ,  // AddVS
    true ,  // AddVI
    true ,  // AddReductionVI
    true ,  // AddVL
    true ,  // AddReductionVL
    true ,  // AddVF
    true ,  // AddReductionVF
    true ,  // AddVD
    true ,  // AddReductionVD
    true ,  // SubVB
    true ,  // SubVS
    true ,  // SubVI
    true ,  // SubVL
    true ,  // SubVF
    true ,  // SubVD
    true ,  // MulVB
    true ,  // MulVS
    true ,  // MulVI
    true ,  // MulReductionVI
    true ,  // MulVL
    true ,  // MulReductionVL
    true ,  // MulVF
    true ,  // MulReductionVF
    true ,  // MulVD
    true ,  // MulReductionVD
    true ,  // MulAddVS2VI
    true ,  // FmaVD
    true ,  // FmaVF
    true ,  // DivVF
    true ,  // DivVD
    true ,  // AbsVB
    true ,  // AbsVS
    true ,  // AbsVI
    true ,  // AbsVL
    true ,  // AbsVF
    true ,  // AbsVD
    true ,  // NegVI
    true ,  // NegVL
    true ,  // NegVF
    true ,  // NegVD
    true ,  // SqrtVD
    true ,  // SqrtVF
    true ,  // LShiftCntV
    true ,  // RShiftCntV
    true ,  // LShiftVB
    true ,  // LShiftVS
    true ,  // LShiftVI
    true ,  // LShiftVL
    true ,  // RShiftVB
    true ,  // RShiftVS
    true ,  // RShiftVI
    true ,  // RShiftVL
    true ,  // URShiftVB
    true ,  // URShiftVS
    true ,  // URShiftVI
    true ,  // URShiftVL
    true ,  // AndV
    true ,  // AndReductionV
    true ,  // OrV
    true ,  // OrReductionV
    true ,  // XorV
    true ,  // XorReductionV
    true ,  // MinV
    true ,  // MaxV
    true ,  // MinReductionV
    true ,  // MaxReductionV
    true ,  // CompressV
    true ,  // CompressM
    true ,  // ExpandV
    true ,  // LoadVector
    true ,  // LoadVectorGather
    true ,  // LoadVectorGatherMasked
    true ,  // StoreVector
    true ,  // StoreVectorScatter
    true ,  // StoreVectorScatterMasked
    true ,  // LoadVectorMasked
    true ,  // StoreVectorMasked
    true ,  // VerifyVectorAlignment
    false,  // VectorCmpMasked
    true ,  // VectorMaskGen
    false,  // VectorMaskOp
    true ,  // VectorMaskTrueCount
    true ,  // VectorMaskFirstTrue
    true ,  // VectorMaskLastTrue
    true ,  // VectorMaskToLong
    true ,  // VectorLongToMask
    false,  // Pack
    false,  // PackB
    false,  // PackS
    false,  // PackI
    false,  // PackL
    false,  // PackF
    false,  // PackD
    false,  // Pack2L
    false,  // Pack2D
    true ,  // Replicate
    true ,  // RoundVF
    true ,  // RoundVD
    false,  // Extract
    true ,  // ExtractB
    true ,  // ExtractUB
    false,  // ExtractC
    true ,  // ExtractS
    true ,  // ExtractI
    true ,  // ExtractL
    true ,  // ExtractF
    true ,  // ExtractD
    false,  // Digit
    false,  // LowerCase
    false,  // UpperCase
    false,  // Whitespace
    false,  // VectorBox
    false,  // VectorBoxAllocate
    false,  // VectorUnbox
    false,  // VectorMaskWrapper
    true ,  // VectorMaskCmp
    true ,  // VectorMaskCast
    true ,  // VectorTest
    true ,  // VectorBlend
    true ,  // VectorRearrange
    true ,  // VectorLoadMask
    true ,  // VectorLoadShuffle
    true ,  // VectorLoadConst
    true ,  // VectorStoreMask
    true ,  // VectorReinterpret
    false,  // VectorCast
    true ,  // VectorCastB2X
    true ,  // VectorCastS2X
    true ,  // VectorCastI2X
    true ,  // VectorCastL2X
    true ,  // VectorCastF2X
    true ,  // VectorCastD2X
    true ,  // VectorCastF2HF
    true ,  // VectorCastHF2F
    true ,  // VectorUCastB2X
    true ,  // VectorUCastS2X
    true ,  // VectorUCastI2X
    false,  // VectorizedHashCode
    true ,  // VectorInsert
    true ,  // MaskAll
    true ,  // AndVMask
    true ,  // OrVMask
    true    // XorVMask
};


int Compile::sync_stack_slots() const { return 2; }

uint Matcher::stack_alignment_in_bytes() { return StackAlignmentInBytes; }

OptoReg::Name Matcher::return_addr() const { return OptoReg::stack2reg(- 2 +
              align_up((Compile::current()->in_preserve_stack_slots() +
                        Compile::current()->fixed_slots()),
                       stack_alignment_in_slots())); }

uint Compile::varargs_C_out_slots_killed() const { return frame::arg_reg_save_area_bytes/BytesPerInt; }

OptoRegPair Matcher::return_value(uint ideal_reg) {

#line 3909 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    // TODO do we allow ideal_reg == Op_RegN???
    assert(ideal_reg >= Op_RegI && ideal_reg <= Op_RegL,
           "only return normal values");

    static const int lo[Op_RegL + 1] = { // enum name
      0,                                 // Op_Node
      0,                                 // Op_Set
      R0_num,                            // Op_RegN
      R0_num,                            // Op_RegI
      R0_num,                            // Op_RegP
      V0_num,                            // Op_RegF
      V0_num,                            // Op_RegD
      R0_num                             // Op_RegL
    };

    static const int hi[Op_RegL + 1] = { // enum name
      0,                                 // Op_Node
      0,                                 // Op_Set
      OptoReg::Bad,                      // Op_RegN
      OptoReg::Bad,                      // Op_RegI
      R0_H_num,                          // Op_RegP
      OptoReg::Bad,                      // Op_RegF
      V0_H_num,                          // Op_RegD
      R0_H_num                           // Op_RegL
    };

    return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
  
#line 42596 "ad_aarch64.cpp"

}

OptoRegPair Matcher::c_return_value(uint ideal_reg) {

#line 3909 "/opt/priv/d038402/git/reinrich/jdk/src/hotspot/cpu/aarch64/aarch64.ad"

    // TODO do we allow ideal_reg == Op_RegN???
    assert(ideal_reg >= Op_RegI && ideal_reg <= Op_RegL,
           "only return normal values");

    static const int lo[Op_RegL + 1] = { // enum name
      0,                                 // Op_Node
      0,                                 // Op_Set
      R0_num,                            // Op_RegN
      R0_num,                            // Op_RegI
      R0_num,                            // Op_RegP
      V0_num,                            // Op_RegF
      V0_num,                            // Op_RegD
      R0_num                             // Op_RegL
    };

    static const int hi[Op_RegL + 1] = { // enum name
      0,                                 // Op_Node
      0,                                 // Op_Set
      OptoReg::Bad,                      // Op_RegN
      OptoReg::Bad,                      // Op_RegI
      R0_H_num,                          // Op_RegP
      OptoReg::Bad,                      // Op_RegF
      V0_H_num,                          // Op_RegD
      R0_H_num                           // Op_RegL
    };

    return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
  
#line 42632 "ad_aarch64.cpp"

}

OptoReg::Name Matcher::inline_cache_reg() { return OptoReg::Name(R12_num); }

int Matcher::inline_cache_reg_encode() { return _regEncode[inline_cache_reg()]; }

OptoReg::Name Matcher::interpreter_frame_pointer_reg() { return OptoReg::Name(R29_num); }

OptoReg::Name Matcher::c_frame_pointer() const { return OptoReg::Name(R31_num); }

// Number of callee-save + always-save registers
int  Matcher::number_of_saved_registers() {
  return 0;
};

bool Compile::needs_deep_clone_jvms() { return false; }

// Check consistency of C++ compilation with ADLC options:
// Check adlc -D_ALLBSD_SOURCE=1
#ifndef _ALLBSD_SOURCE
#  error "_ALLBSD_SOURCE must be defined"
#endif // _ALLBSD_SOURCE
// Check adlc -D_GNU_SOURCE=1
#ifndef _GNU_SOURCE
#  error "_GNU_SOURCE must be defined"
#endif // _GNU_SOURCE
// Check adlc -DR18_RESERVED=1
#ifndef R18_RESERVED
#  error "R18_RESERVED must be defined"
#endif // R18_RESERVED
// Check adlc -DAARCH64=1
#ifndef AARCH64
#  error "AARCH64 must be defined"
#endif // AARCH64
// Check adlc -D_LP64=1
#ifndef _LP64
#  error "_LP64 must be defined"
#endif // _LP64
// Check adlc -DASSERT=1
#ifndef ASSERT
#  error "ASSERT must be defined"
#endif // ASSERT
