#line 1 "ad_aarch64_format.cpp"
//
// Copyright (c) 2003, 2021, Oracle and/or its affiliates. All rights reserved.
// Copyright (c) 2014, 2021, Red Hat, Inc. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 only, as
// published by the Free Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// You should have received a copy of the GNU General Public License version
// 2 along with this work; if not, write to the Free Software Foundation,
// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
//
// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
// or visit www.oracle.com if you need additional information or have any
// questions.
//
//

// Machine Generated File.  Do Not Edit!

#include "precompiled.hpp"
#include "adfiles/ad_aarch64.hpp"
#include "compiler/oopMap.hpp"

#ifndef PRODUCT
void UniverseOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("$$univ");
}
void UniverseOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("$$univ");
}
#endif

#ifndef PRODUCT
void sRegIOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
}
void sRegIOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
}
#endif

#ifndef PRODUCT
void sRegPOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
}
void sRegPOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
}
#endif

#ifndef PRODUCT
void sRegFOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
}
void sRegFOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
}
#endif

#ifndef PRODUCT
void sRegDOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
}
void sRegDOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
}
#endif

#ifndef PRODUCT
void sRegLOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
}
void sRegLOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
}
#endif

#ifndef PRODUCT
void immIOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immIOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI0Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI0Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_1Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_1Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_M1Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_M1Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immIExtOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immIExtOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_gt_1Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_gt_1Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_le_4Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_le_4Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_31Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_31Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_2Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_2Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_4Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_4Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_8Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_8Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_16Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_16Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_24Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_24Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_32Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_32Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_48Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_48Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_56Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_56Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_63Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_63Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_64Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_64Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_255Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_255Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI_65535Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_65535Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immL_255Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immL_255Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immL_65535Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immL_65535Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immL_4294967295Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immL_4294967295Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immL_bitmaskOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immL_bitmaskOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immI_bitmaskOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI_bitmaskOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immL_positive_bitmaskIOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immL_positive_bitmaskIOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immIScaleOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immIScaleOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI26Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI26Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI19Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI19Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immIU12Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immIU12Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immLU12Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immLU12Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immIOffsetOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immIOffsetOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immIOffset1Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immIOffset1Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immIOffset2Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immIOffset2Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immIOffset4Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immIOffset4Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immIOffset8Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immIOffset8Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immIOffset16Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immIOffset16Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immLoffsetOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immLoffsetOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immLoffset1Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immLoffset1Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immLoffset2Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immLoffset2Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immLoffset4Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immLoffset4Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immLoffset8Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immLoffset8Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immLoffset16Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immLoffset16Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immI8Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI8Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immI8_shift8Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immI8_shift8Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immL8_shift8Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immL8_shift8Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immBAddSubVOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immBAddSubVOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immIAddSubOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immIAddSubOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immIAddSubVOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immIAddSubVOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immBLogOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immBLogOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immSLogOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immSLogOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immILogOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void immILogOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void immLOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immLOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immL0Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immL0Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immL_1Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immL_1Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immL_M1Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immL_M1Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immL_pc_offOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immL_pc_offOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immLAddSubOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immLAddSubOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immLAddSubVOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immLAddSubVOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immLLogOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immLLogOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immL_32bitsOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void immL_32bitsOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void immPOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
void immPOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
#endif

#ifndef PRODUCT
void immP0Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
void immP0Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
#endif

#ifndef PRODUCT
void immP_1Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
void immP_1Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
#endif

#ifndef PRODUCT
void immByteMapBaseOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
void immByteMapBaseOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
#endif

#ifndef PRODUCT
void immP_M1Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
void immP_M1Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
#endif

#ifndef PRODUCT
void immP_M2Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
void immP_M2Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
#endif

#ifndef PRODUCT
void immDOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%f", _c0);
}
void immDOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%f", _c0);
}
#endif

#ifndef PRODUCT
void immD0Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%f", _c0);
}
void immD0Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%f", _c0);
}
#endif

#ifndef PRODUCT
void immDPackedOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%f", _c0);
}
void immDPackedOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%f", _c0);
}
#endif

#ifndef PRODUCT
void immFOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%f", _c0);
}
void immFOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%f", _c0);
}
#endif

#ifndef PRODUCT
void immF0Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%f", _c0);
}
void immF0Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%f", _c0);
}
#endif

#ifndef PRODUCT
void immFPackedOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%f", _c0);
}
void immFPackedOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%f", _c0);
}
#endif

#ifndef PRODUCT
void immNOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
void immNOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
#endif

#ifndef PRODUCT
void immN0Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
void immN0Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
#endif

#ifndef PRODUCT
void immNKlassOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
void immNKlassOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  if (_c0) _c0->dump_on(st);
}
#endif

#ifndef PRODUCT
void iRegIOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegIOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegINoSpOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegINoSpOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegLOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegLOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegLNoSpOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegLNoSpOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegPOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegPOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegPNoSpOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegPNoSpOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegP_R0Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegP_R0Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegP_R1Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegP_R1Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegP_R2Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegP_R2Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegP_R3Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegP_R3Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegP_R4Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegP_R4Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegP_R5Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegP_R5Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegP_R10Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegP_R10Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegL_R0Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegL_R0Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegL_R2Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegL_R2Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegL_R3Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegL_R3Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegL_R11Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegL_R11Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegP_FPOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegP_FPOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegI_R0Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegI_R0Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegI_R2Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegI_R2Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegI_R3Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegI_R3Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegI_R4Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegI_R4Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegNOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegNOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegN_R0Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegN_R0Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegN_R2Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegN_R2Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegN_R3Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegN_R3Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegNNoSpOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegNNoSpOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void iRegIHeapbaseOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void iRegIHeapbaseOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegFOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegFOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegDOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegDOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vecDOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vecDOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vecXOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vecXOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V0Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V0Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V1Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V1Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V2Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V2Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V3Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V3Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V4Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V4Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V5Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V5Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V6Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V6Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V7Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V7Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V8Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V8Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V9Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V9Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V10Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V10Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V11Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V11Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V12Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V12Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V13Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V13Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V14Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V14Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V15Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V15Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V16Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V16Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V17Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V17Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V18Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V18Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V19Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V19Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V20Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V20Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V21Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V21Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V22Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V22Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V23Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V23Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V24Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V24Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V25Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V25Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V26Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V26Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V27Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V27Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V28Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V28Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V29Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V29Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V30Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V30Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void vRegD_V31Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void vRegD_V31Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void pRegOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void pRegOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void pRegGovOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void pRegGovOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void pRegGov_P0Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void pRegGov_P0Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void pRegGov_P1Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void pRegGov_P1Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void rFlagsRegOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("RFLAGS");
}
void rFlagsRegOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("RFLAGS");
}
#endif

#ifndef PRODUCT
void rFlagsRegUOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("RFLAGSU");
}
void rFlagsRegUOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("RFLAGSU");
}
#endif

#ifndef PRODUCT
void inline_cache_RegPOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void inline_cache_RegPOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void thread_RegPOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void thread_RegPOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void lr_RegPOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void lr_RegPOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void indirectOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("]");
}
void indirectOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void indIndexScaledI2LOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(" sxtw(");
  st->print("#%d", _c0);
  st->print_raw("), 0, I2L");
}
void indIndexScaledI2LOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node->in(idx+1),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(" sxtw(");
  st->print("#%d", _c0);
  st->print_raw("), 0, I2L");
}
#endif

#ifndef PRODUCT
void indIndexScaledOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(" lsl(");
  st->print("#%d", _c0);
  st->print_raw(")");
}
void indIndexScaledOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node->in(idx+1),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(" lsl(");
  st->print("#%d", _c0);
  st->print_raw(")");
}
#endif

#ifndef PRODUCT
void indIndexI2LOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", 0, I2L");
}
void indIndexI2LOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node->in(idx+1),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", 0, I2L");
}
#endif

#ifndef PRODUCT
void indIndexOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
}
void indIndexOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node->in(idx+1),reg_str);
    st->print("%s",reg_str);
  }
}
#endif

#ifndef PRODUCT
void indOffIOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]");
}
void indOffIOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void indOffI1Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]");
}
void indOffI1Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void indOffI2Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]");
}
void indOffI2Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void indOffI4Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]");
}
void indOffI4Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void indOffI8Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]");
}
void indOffI8Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void indOffI16Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]");
}
void indOffI16Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void indOffLOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
void indOffLOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void indOffL1Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
void indOffL1Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void indOffL2Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
void indOffL2Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void indOffL4Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
void indOffL4Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void indOffL8Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
void indOffL8Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void indOffL16Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
void indOffL16Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void indirectNOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("]\t# narrow");
}
void indirectNOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("]\t# narrow");
}
#endif

#ifndef PRODUCT
void indIndexScaledI2LNOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(" sxtw(");
  st->print("#%d", _c0);
  st->print_raw("), 0, I2L\t# narrow");
}
void indIndexScaledI2LNOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node->in(idx+1),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(" sxtw(");
  st->print("#%d", _c0);
  st->print_raw("), 0, I2L\t# narrow");
}
#endif

#ifndef PRODUCT
void indIndexScaledNOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(" lsl(");
  st->print("#%d", _c0);
  st->print_raw(")\t# narrow");
}
void indIndexScaledNOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node->in(idx+1),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(" lsl(");
  st->print("#%d", _c0);
  st->print_raw(")\t# narrow");
}
#endif

#ifndef PRODUCT
void indIndexI2LNOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", 0, I2L\t# narrow");
}
void indIndexI2LNOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node->in(idx+1),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", 0, I2L\t# narrow");
}
#endif

#ifndef PRODUCT
void indIndexNOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("\t# narrow");
}
void indIndexNOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  { char reg_str[128];
    ra->dump_register(node->in(idx+1),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("\t# narrow");
}
#endif

#ifndef PRODUCT
void indOffINOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]\t# narrow");
}
void indOffINOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]\t# narrow");
}
#endif

#ifndef PRODUCT
void indOffLNOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]\t# narrow");
}
void indOffLNOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]\t# narrow");
}
#endif

#ifndef PRODUCT
void thread_anchor_pcOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
void thread_anchor_pcOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void stackSlotPOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("]");
}
void stackSlotPOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void stackSlotIOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("]");
}
void stackSlotIOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void stackSlotFOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("]");
}
void stackSlotFOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void stackSlotDOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("]");
}
void stackSlotDOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void stackSlotLOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("]");
}
void stackSlotLOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void cmpOpOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("");
       if( _c0 == BoolTest::eq ) st->print_raw("eq");
  else if( _c0 == BoolTest::ne ) st->print_raw("ne");
  else if( _c0 == BoolTest::le ) st->print_raw("le");
  else if( _c0 == BoolTest::ge ) st->print_raw("ge");
  else if( _c0 == BoolTest::lt ) st->print_raw("lt");
  else if( _c0 == BoolTest::gt ) st->print_raw("gt");
  else if( _c0 == BoolTest::overflow ) st->print_raw("vs");
  else if( _c0 == BoolTest::no_overflow ) st->print_raw("vc");
}
void cmpOpOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("");
       if( _c0 == BoolTest::eq ) st->print_raw("eq");
  else if( _c0 == BoolTest::ne ) st->print_raw("ne");
  else if( _c0 == BoolTest::le ) st->print_raw("le");
  else if( _c0 == BoolTest::ge ) st->print_raw("ge");
  else if( _c0 == BoolTest::lt ) st->print_raw("lt");
  else if( _c0 == BoolTest::gt ) st->print_raw("gt");
  else if( _c0 == BoolTest::overflow ) st->print_raw("vs");
  else if( _c0 == BoolTest::no_overflow ) st->print_raw("vc");
}
#endif

#ifndef PRODUCT
void cmpOpUOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("");
       if( _c0 == BoolTest::eq ) st->print_raw("eq");
  else if( _c0 == BoolTest::ne ) st->print_raw("ne");
  else if( _c0 == BoolTest::le ) st->print_raw("ls");
  else if( _c0 == BoolTest::ge ) st->print_raw("hs");
  else if( _c0 == BoolTest::lt ) st->print_raw("lo");
  else if( _c0 == BoolTest::gt ) st->print_raw("hi");
  else if( _c0 == BoolTest::overflow ) st->print_raw("vs");
  else if( _c0 == BoolTest::no_overflow ) st->print_raw("vc");
}
void cmpOpUOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("");
       if( _c0 == BoolTest::eq ) st->print_raw("eq");
  else if( _c0 == BoolTest::ne ) st->print_raw("ne");
  else if( _c0 == BoolTest::le ) st->print_raw("ls");
  else if( _c0 == BoolTest::ge ) st->print_raw("hs");
  else if( _c0 == BoolTest::lt ) st->print_raw("lo");
  else if( _c0 == BoolTest::gt ) st->print_raw("hi");
  else if( _c0 == BoolTest::overflow ) st->print_raw("vs");
  else if( _c0 == BoolTest::no_overflow ) st->print_raw("vc");
}
#endif

#ifndef PRODUCT
void cmpOpEqNeOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("");
       if( _c0 == BoolTest::eq ) st->print_raw("eq");
  else if( _c0 == BoolTest::ne ) st->print_raw("ne");
  else if( _c0 == BoolTest::le ) st->print_raw("le");
  else if( _c0 == BoolTest::ge ) st->print_raw("ge");
  else if( _c0 == BoolTest::lt ) st->print_raw("lt");
  else if( _c0 == BoolTest::gt ) st->print_raw("gt");
  else if( _c0 == BoolTest::overflow ) st->print_raw("vs");
  else if( _c0 == BoolTest::no_overflow ) st->print_raw("vc");
}
void cmpOpEqNeOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("");
       if( _c0 == BoolTest::eq ) st->print_raw("eq");
  else if( _c0 == BoolTest::ne ) st->print_raw("ne");
  else if( _c0 == BoolTest::le ) st->print_raw("le");
  else if( _c0 == BoolTest::ge ) st->print_raw("ge");
  else if( _c0 == BoolTest::lt ) st->print_raw("lt");
  else if( _c0 == BoolTest::gt ) st->print_raw("gt");
  else if( _c0 == BoolTest::overflow ) st->print_raw("vs");
  else if( _c0 == BoolTest::no_overflow ) st->print_raw("vc");
}
#endif

#ifndef PRODUCT
void cmpOpLtGeOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("");
       if( _c0 == BoolTest::eq ) st->print_raw("eq");
  else if( _c0 == BoolTest::ne ) st->print_raw("ne");
  else if( _c0 == BoolTest::le ) st->print_raw("le");
  else if( _c0 == BoolTest::ge ) st->print_raw("ge");
  else if( _c0 == BoolTest::lt ) st->print_raw("lt");
  else if( _c0 == BoolTest::gt ) st->print_raw("gt");
  else if( _c0 == BoolTest::overflow ) st->print_raw("vs");
  else if( _c0 == BoolTest::no_overflow ) st->print_raw("vc");
}
void cmpOpLtGeOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("");
       if( _c0 == BoolTest::eq ) st->print_raw("eq");
  else if( _c0 == BoolTest::ne ) st->print_raw("ne");
  else if( _c0 == BoolTest::le ) st->print_raw("le");
  else if( _c0 == BoolTest::ge ) st->print_raw("ge");
  else if( _c0 == BoolTest::lt ) st->print_raw("lt");
  else if( _c0 == BoolTest::gt ) st->print_raw("gt");
  else if( _c0 == BoolTest::overflow ) st->print_raw("vs");
  else if( _c0 == BoolTest::no_overflow ) st->print_raw("vc");
}
#endif

#ifndef PRODUCT
void cmpOpUEqNeLtGeOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("");
       if( _c0 == BoolTest::eq ) st->print_raw("eq");
  else if( _c0 == BoolTest::ne ) st->print_raw("ne");
  else if( _c0 == BoolTest::le ) st->print_raw("le");
  else if( _c0 == BoolTest::ge ) st->print_raw("ge");
  else if( _c0 == BoolTest::lt ) st->print_raw("lt");
  else if( _c0 == BoolTest::gt ) st->print_raw("gt");
  else if( _c0 == BoolTest::overflow ) st->print_raw("vs");
  else if( _c0 == BoolTest::no_overflow ) st->print_raw("vc");
}
void cmpOpUEqNeLtGeOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("");
       if( _c0 == BoolTest::eq ) st->print_raw("eq");
  else if( _c0 == BoolTest::ne ) st->print_raw("ne");
  else if( _c0 == BoolTest::le ) st->print_raw("le");
  else if( _c0 == BoolTest::ge ) st->print_raw("ge");
  else if( _c0 == BoolTest::lt ) st->print_raw("lt");
  else if( _c0 == BoolTest::gt ) st->print_raw("gt");
  else if( _c0 == BoolTest::overflow ) st->print_raw("vs");
  else if( _c0 == BoolTest::no_overflow ) st->print_raw("vc");
}
#endif

#ifndef PRODUCT
void iRegL2IOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("l2i(");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(")");
}
void iRegL2IOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("l2i(");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(")");
}
#endif

#ifndef PRODUCT
void vmemA_immIOffset4Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#%d", _c0);
}
void vmemA_immIOffset4Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#%d", _c0);
}
#endif

#ifndef PRODUCT
void vmemA_immLOffset4Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
void vmemA_immLOffset4Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print("#" INT64_FORMAT, (int64_t)_c0);
}
#endif

#ifndef PRODUCT
void vmemA_indOffI4Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]");
}
void vmemA_indOffI4Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#%d", _c0);
  st->print_raw("]");
}
#endif

#ifndef PRODUCT
void vmemA_indOffL4Oper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node,reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
void vmemA_indOffL4Oper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {
  st->print_raw("[");
  { char reg_str[128];
    ra->dump_register(node->in(idx),reg_str);
    st->print("%s",reg_str);
  }
  st->print_raw(", ");
  st->print("#" INT64_FORMAT, (int64_t)_c0);
  st->print_raw("]");
}
#endif
#ifndef PRODUCT
void loadBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrsbw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# byte");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadB2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrsb  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# byte");
}
#endif
#ifndef PRODUCT
void loadUBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrbw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# byte");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadUB2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrb  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# byte");
}
#endif
#ifndef PRODUCT
void loadSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrshw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# short");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadS2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrsh  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# short");
}
#endif
#ifndef PRODUCT
void loadUSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrh  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# short");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadUS2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrh  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# short");
}
#endif
#ifndef PRODUCT
void loadINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# int");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadI2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrsw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void loadUI2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  st->print_raw("ldrw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void loadLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# int");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadRangeNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# range");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadPNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# ptr");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadNNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# compressed ptr");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadKlassNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# class");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadNKlassNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# compressed class ptr");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# float");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# double");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadConINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("mov ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void loadConLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("mov ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# long");
}
#endif
#ifndef PRODUCT
void loadConPNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("mov  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# ptr\n\t");
}
#endif
#ifndef PRODUCT
void loadConP0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("mov  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# NULL ptr");
}
#endif
#ifndef PRODUCT
void loadConP1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("mov  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# NULL ptr");
}
#endif
#ifndef PRODUCT
void loadByteMapBaseNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("adr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# Byte Map Base");
}
#endif
#ifndef PRODUCT
void loadConNNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("mov  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# compressed ptr");
}
#endif
#ifndef PRODUCT
void loadConN0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("mov  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# compressed NULL ptr");
}
#endif
#ifndef PRODUCT
void loadConNKlassNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("mov  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# compressed klass ptr");
}
#endif
#ifndef PRODUCT
void loadConF_packedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("fmovs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
}
#endif
#ifndef PRODUCT
void loadConFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("ldrs ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", [");
  st->print("constant table base + #%d", constant_offset_unchecked());
  st->print_raw("]\t# load from constant table: float=");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\n\t");
}
#endif
#ifndef PRODUCT
void loadConD_packedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("fmovd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
}
#endif
#ifndef PRODUCT
void loadConDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("ldrd ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", [");
  st->print("constant table base + #%d", constant_offset_unchecked());
  st->print_raw("]\t# load from constant table: float=");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\n\t");
}
#endif
#ifndef PRODUCT
void storeimmCM0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("storestore (elided)\n\t");
  st->print_raw("strb zr, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# byte");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeimmCM0_orderedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("storestore\n\t");
  st->print_raw("dmb ishst");
  st->print_raw("\n\tstrb zr, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# byte");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("strb  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# byte");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeimmB0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("strb rscractch2, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# byte");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeCNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("strh  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# short");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeimmC0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("strh  zr, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# short");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("strw  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# int");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeimmI0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("strw  zr, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# int");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("str  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# int");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeimmL0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("str  zr, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# int");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storePNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("str  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# ptr");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeimmP0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("str zr, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# ptr");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeNNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("strw  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# compressed ptr");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeImmN0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("strw  zr, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# compressed ptr");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("strs  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# float");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("strd  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# double");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeNKlassNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("strw  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# compressed klass ptr");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void prefetchallocNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// 
  st->print_raw("prfm ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", PSTL1KEEP\t# Prefetch into level 1 cache write keep");
}
#endif
#ifndef PRODUCT
void loadB_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldarsb  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# byte");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadB2L_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldarsb  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# byte");
}
#endif
#ifndef PRODUCT
void loadUB_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldarb  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# byte");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadUB2L_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldarb  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# byte");
}
#endif
#ifndef PRODUCT
void loadS_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldarshw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# short");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadUS_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldarhw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# short");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadUS2L_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldarh  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# short");
}
#endif
#ifndef PRODUCT
void loadS2L_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldarh  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# short");
}
#endif
#ifndef PRODUCT
void loadI_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldarw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# int");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadUI2L_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  st->print_raw("ldarw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void loadL_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldar  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# int");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadP_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldar  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# ptr");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadN_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldarw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# compressed ptr");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadF_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldars  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# float");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadD_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldard  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# double");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeB_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("stlrb  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# byte");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeC_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("stlrh  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# short");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeI_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("stlrw  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# int");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeL_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("stlr  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# int");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeP_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("stlr  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# ptr");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeN_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("stlrw  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# compressed ptr");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeF_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("stlrs  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# float");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeD_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("stlrd  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# double");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void cacheWBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// 
  st->print_raw("cache wb ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // addr
}
#endif
#ifndef PRODUCT
void cacheWBPreSyncNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("cache wb presync");
}
#endif
#ifndef PRODUCT
void cacheWBPostSyncNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("cache wb postsync");
}
#endif
#ifndef PRODUCT
void bytes_reverse_intNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("revw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void bytes_reverse_longNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("rev  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void bytes_reverse_unsigned_shortNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("rev16w  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void bytes_reverse_shortNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("rev16w  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("sbfmw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", #0, #15");
}
#endif
#ifndef PRODUCT
void countLeadingZerosINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("clzw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void countLeadingZerosLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("clz   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void countTrailingZerosINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("rbitw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("clzw   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
}
#endif
#ifndef PRODUCT
void countTrailingZerosLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("rbit   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("clz    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
}
#endif
#ifndef PRODUCT
void popCountINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  st->print_raw("movw   ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("mov    ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (1D)\n\t");
  st->print_raw("cnt    ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw("\t# vector (8B)\n\t");
  st->print_raw("addv   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw("\t# vector (8B)\n\t");
  st->print_raw("mov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw("\t# vector (1D)");
}
#endif
#ifndef PRODUCT
void popCountI_memNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  st->print_raw("ldrs   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\n\t");
  st->print_raw("cnt    ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw("\t# vector (8B)\n\t");
  st->print_raw("addv   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw("\t# vector (8B)\n\t");
  st->print_raw("mov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw("\t# vector (1D)");
}
#endif
#ifndef PRODUCT
void popCountLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  st->print_raw("mov    ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (1D)\n\t");
  st->print_raw("cnt    ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw("\t# vector (8B)\n\t");
  st->print_raw("addv   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw("\t# vector (8B)\n\t");
  st->print_raw("mov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw("\t# vector (1D)");
}
#endif
#ifndef PRODUCT
void popCountL_memNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  st->print_raw("ldrd   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\n\t");
  st->print_raw("cnt    ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw("\t# vector (8B)\n\t");
  st->print_raw("addv   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw("\t# vector (8B)\n\t");
  st->print_raw("mov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw("\t# vector (1D)");
}
#endif
#ifndef PRODUCT
void load_fenceNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("load_fence");
}
#endif
#ifndef PRODUCT
void unnecessary_membar_acquireNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("membar_acquire (elided)");
}
#endif
#ifndef PRODUCT
void membar_acquireNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("membar_acquire\n\t");
  st->print_raw("dmb ish");
}
#endif
#ifndef PRODUCT
void membar_acquire_lockNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("membar_acquire_lock (elided)");
}
#endif
#ifndef PRODUCT
void store_fenceNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("store_fence");
}
#endif
#ifndef PRODUCT
void unnecessary_membar_releaseNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("membar_release (elided)");
}
#endif
#ifndef PRODUCT
void membar_releaseNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("membar_release\n\t");
  st->print_raw("dmb ish");
}
#endif
#ifndef PRODUCT
void membar_storestoreNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("MEMBAR-store-store");
}
#endif
#ifndef PRODUCT
void membar_storestore_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("MEMBAR-store-store");
}
#endif
#ifndef PRODUCT
void membar_release_lockNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("membar_release_lock (elided)");
}
#endif
#ifndef PRODUCT
void unnecessary_membar_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("membar_volatile (elided)");
}
#endif
#ifndef PRODUCT
void membar_volatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("membar_volatile\n\t");
  st->print_raw("dmb ish");
}
#endif
#ifndef PRODUCT
void castX2PNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("mov ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# long -> ptr");
}
#endif
#ifndef PRODUCT
void castP2XNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("mov ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# ptr -> long");
}
#endif
#ifndef PRODUCT
void convP2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("movw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# ptr -> int");
}
#endif
#ifndef PRODUCT
void convN2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("mov dst, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# compressed ptr -> int");
}
#endif
#ifndef PRODUCT
void encodeHeapOopNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("encode_heap_oop ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void encodeHeapOop_not_nullNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("encode_heap_oop_not_null ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void decodeHeapOopNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("decode_heap_oop ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void decodeHeapOop_not_nullNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("decode_heap_oop_not_null ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void encodeKlass_not_nullNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("encode_klass_not_null ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void decodeKlass_not_nullNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("decode_klass_not_null ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void checkCastPPNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  st->print_raw("# checkcastPP of ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
}
#endif
#ifndef PRODUCT
void castPPNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  st->print_raw("# castPP of ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
}
#endif
#ifndef PRODUCT
void castIINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  st->print_raw("# castII of ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
}
#endif
#ifndef PRODUCT
void castLLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  st->print_raw("# castLL of ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
}
#endif
#ifndef PRODUCT
void castFFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  st->print_raw("# castFF of ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
}
#endif
#ifndef PRODUCT
void castDDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  st->print_raw("# castDD of ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
}
#endif
#ifndef PRODUCT
void castVVDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  st->print_raw("# castVV of ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
}
#endif
#ifndef PRODUCT
void castVVXNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  st->print_raw("# castVV of ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
}
#endif
#ifndef PRODUCT
void castVVNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  st->print_raw("# castVV of ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
}
#endif
#ifndef PRODUCT
void castVVMaskNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  st->print_raw("# castVV of ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
}
#endif
#ifndef PRODUCT
void loadPLockedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldaxr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# ptr linked acquire");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storePConditionalNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// heap_top_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("stlxr rscratch1, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // heap_top_ptr
  st->print_raw("\t# ptr cond release");
  st->print_raw("cmpw rscratch1, zr\t# EQ on successful write");
}
#endif
#ifndef PRODUCT
void storeLConditionalNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchg rscratch1, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("cmpw rscratch1, zr\t# EQ on successful write");
}
#endif
#ifndef PRODUCT
void storeIConditionalNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgw rscratch1, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("cmpw rscratch1, zr\t# EQ on successful write");
}
#endif
#ifndef PRODUCT
void compareAndSwapBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgb ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (int) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("cset ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void compareAndSwapSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgs ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (int) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("cset ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void compareAndSwapINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgw ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (int) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("cset ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void compareAndSwapLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchg ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (long) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("cset ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void compareAndSwapPNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchg ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (ptr) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("cset ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void compareAndSwapNNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgw ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (narrow oop) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("cset ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void compareAndSwapBAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgb_acq ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (int) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("cset ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void compareAndSwapSAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgs_acq ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (int) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("cset ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void compareAndSwapIAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgw_acq ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (int) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("cset ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void compareAndSwapLAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchg_acq ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (long) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("cset ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void compareAndSwapPAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchg_acq ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (ptr) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("cset ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void compareAndSwapNAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgw_acq ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (narrow oop) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("cset ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void compareAndExchangeBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchgb ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (byte, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void compareAndExchangeSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchgs ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (short, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void compareAndExchangeINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchgw ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (int, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void compareAndExchangeLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchg ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (long, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void compareAndExchangeNNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchgw ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (narrow oop, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void compareAndExchangePNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchg ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (ptr, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void compareAndExchangeBAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchgb_acq ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (byte, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void compareAndExchangeSAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchgs_acq ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (short, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void compareAndExchangeIAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchgw_acq ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (int, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void compareAndExchangeLAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchg_acq ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (long, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void compareAndExchangeNAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchgw_acq ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (narrow oop, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void compareAndExchangePAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchg_acq ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (ptr, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgb ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (byte, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgs ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (short, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (int, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchg ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (long, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapNNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (narrow oop, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapPNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchg ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (ptr, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapBAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgb_acq ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (byte, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapSAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgs_acq ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (short, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapIAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgw_acq ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (int, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapLAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchg_acq ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (long, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapNAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchgw_acq ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (narrow oop, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapPAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  st->print_raw("cmpxchg_acq ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (ptr, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void get_and_setINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  st->print_raw("atomic_xchgw  ");
  opnd_array(0)->int_format(ra, this, st); // prev
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // newv
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("]");
}
#endif
#ifndef PRODUCT
void get_and_setLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  st->print_raw("atomic_xchg  ");
  opnd_array(0)->int_format(ra, this, st); // prev
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // newv
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("]");
}
#endif
#ifndef PRODUCT
void get_and_setNNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  st->print_raw("atomic_xchgw ");
  opnd_array(0)->int_format(ra, this, st); // prev
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // newv
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("]");
}
#endif
#ifndef PRODUCT
void get_and_setPNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  st->print_raw("atomic_xchg  ");
  opnd_array(0)->int_format(ra, this, st); // prev
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // newv
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("]");
}
#endif
#ifndef PRODUCT
void get_and_setIAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  st->print_raw("atomic_xchgw_acq  ");
  opnd_array(0)->int_format(ra, this, st); // prev
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // newv
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("]");
}
#endif
#ifndef PRODUCT
void get_and_setLAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  st->print_raw("atomic_xchg_acq  ");
  opnd_array(0)->int_format(ra, this, st); // prev
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // newv
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("]");
}
#endif
#ifndef PRODUCT
void get_and_setNAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  st->print_raw("atomic_xchgw_acq ");
  opnd_array(0)->int_format(ra, this, st); // prev
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // newv
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("]");
}
#endif
#ifndef PRODUCT
void get_and_setPAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  st->print_raw("atomic_xchg_acq  ");
  opnd_array(0)->int_format(ra, this, st); // prev
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // newv
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("]");
}
#endif
#ifndef PRODUCT
void get_and_addLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addL ");
  opnd_array(0)->int_format(ra, this, st); // newval
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void get_and_addL_no_resNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addL [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void get_and_addLiNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addL ");
  opnd_array(0)->int_format(ra, this, st); // newval
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void get_and_addLi_no_resNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addL [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void get_and_addINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addI ");
  opnd_array(0)->int_format(ra, this, st); // newval
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void get_and_addI_no_resNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addI [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void get_and_addIiNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addI ");
  opnd_array(0)->int_format(ra, this, st); // newval
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void get_and_addIi_no_resNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addI [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void get_and_addLAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addL_acq ");
  opnd_array(0)->int_format(ra, this, st); // newval
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void get_and_addL_no_resAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addL_acq [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void get_and_addLiAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addL_acq ");
  opnd_array(0)->int_format(ra, this, st); // newval
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void get_and_addLi_no_resAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addL_acq [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void get_and_addIAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addI_acq ");
  opnd_array(0)->int_format(ra, this, st); // newval
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void get_and_addI_no_resAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addI_acq [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void get_and_addIiAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addI_acq ");
  opnd_array(0)->int_format(ra, this, st); // newval
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void get_and_addIi_no_resAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// incr
  st->print_raw("get_and_addI_acq [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("], ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // incr
}
#endif
#ifndef PRODUCT
void cmpL3_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("cmp ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ne");
  st->print_raw("cnegw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", lt");
}
#endif
#ifndef PRODUCT
void cmpL3_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("cmp ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ne");
  st->print_raw("cnegw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", lt");
}
#endif
#ifndef PRODUCT
void cmovI_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  st->print_raw("cselw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed, int");
}
#endif
#ifndef PRODUCT
void cmovUI_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  st->print_raw("cselw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# unsigned, int");
}
#endif
#ifndef PRODUCT
void cmovI_zero_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  st->print_raw("cselw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src
  st->print_raw(", zr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed, int");
}
#endif
#ifndef PRODUCT
void cmovUI_zero_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  st->print_raw("cselw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src
  st->print_raw(", zr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# unsigned, int");
}
#endif
#ifndef PRODUCT
void cmovI_reg_zeroNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  st->print_raw("cselw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", zr, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed, int");
}
#endif
#ifndef PRODUCT
void cmovUI_reg_zeroNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  st->print_raw("cselw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", zr, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# unsigned, int");
}
#endif
#ifndef PRODUCT
void cmovI_reg_zero_oneNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// one
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  st->print_raw("csincw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", zr, zr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed, int");
}
#endif
#ifndef PRODUCT
void cmovUI_reg_zero_oneNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// one
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  st->print_raw("csincw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", zr, zr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# unsigned, int");
}
#endif
#ifndef PRODUCT
void cmovL_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  st->print_raw("csel ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed, long");
}
#endif
#ifndef PRODUCT
void cmovUL_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  st->print_raw("csel ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# unsigned, long");
}
#endif
#ifndef PRODUCT
void cmovL_reg_zeroNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  st->print_raw("csel ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", zr, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed, long");
}
#endif
#ifndef PRODUCT
void cmovUL_reg_zeroNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  st->print_raw("csel ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", zr, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# unsigned, long");
}
#endif
#ifndef PRODUCT
void cmovL_zero_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  st->print_raw("csel ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src
  st->print_raw(", zr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed, long");
}
#endif
#ifndef PRODUCT
void cmovUL_zero_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  st->print_raw("csel ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src
  st->print_raw(", zr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# unsigned, long");
}
#endif
#ifndef PRODUCT
void cmovP_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  st->print_raw("csel ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed, ptr");
}
#endif
#ifndef PRODUCT
void cmovUP_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  st->print_raw("csel ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# unsigned, ptr");
}
#endif
#ifndef PRODUCT
void cmovP_reg_zeroNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  st->print_raw("csel ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", zr, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed, ptr");
}
#endif
#ifndef PRODUCT
void cmovUP_reg_zeroNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  st->print_raw("csel ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", zr, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# unsigned, ptr");
}
#endif
#ifndef PRODUCT
void cmovP_zero_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  st->print_raw("csel ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src
  st->print_raw(", zr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed, ptr");
}
#endif
#ifndef PRODUCT
void cmovUP_zero_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  st->print_raw("csel ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src
  st->print_raw(", zr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# unsigned, ptr");
}
#endif
#ifndef PRODUCT
void cmovN_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  st->print_raw("cselw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed, compressed ptr");
}
#endif
#ifndef PRODUCT
void cmovUN_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  st->print_raw("cselw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed, compressed ptr");
}
#endif
#ifndef PRODUCT
void cmovN_reg_zeroNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  st->print_raw("cselw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", zr, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed, compressed ptr");
}
#endif
#ifndef PRODUCT
void cmovUN_reg_zeroNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// zero
  st->print_raw("cselw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", zr, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# unsigned, compressed ptr");
}
#endif
#ifndef PRODUCT
void cmovN_zero_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  st->print_raw("cselw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src
  st->print_raw(", zr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed, compressed ptr");
}
#endif
#ifndef PRODUCT
void cmovUN_zero_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  st->print_raw("cselw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src
  st->print_raw(", zr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# unsigned, compressed ptr");
}
#endif
#ifndef PRODUCT
void cmovF_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  st->print_raw("fcsels ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed cmove float\n\t");
}
#endif
#ifndef PRODUCT
void cmovUF_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  st->print_raw("fcsels ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# unsigned cmove float\n\t");
}
#endif
#ifndef PRODUCT
void cmovD_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  st->print_raw("fcseld ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# signed cmove float\n\t");
}
#endif
#ifndef PRODUCT
void cmovUD_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  st->print_raw("fcseld ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("\t# unsigned cmove float\n\t");
}
#endif
#ifndef PRODUCT
void addI_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void addI_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("addw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void addI_reg_imm_i2lNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("addw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void addP_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("add ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# ptr");
}
#endif
#ifndef PRODUCT
void addP_reg_reg_extNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("add ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxtw\t# ptr");
}
#endif
#ifndef PRODUCT
void addP_reg_reg_lslNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// scale
  st->print_raw("add ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LShiftL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // scale
  st->print_raw("\t# ptr");
}
#endif
#ifndef PRODUCT
void addP_reg_reg_ext_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// scale
  st->print_raw("add ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", I2L ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // scale
  st->print_raw("\t# ptr");
}
#endif
#ifndef PRODUCT
void lshift_extNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// scale
  st->print_raw("sbfiz ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // scale
  st->print_raw(" & 63, -");
  opnd_array(2)->ext_format(ra, this,idx2, st); // scale
  st->print_raw(" & 63\t");
}
#endif
#ifndef PRODUCT
void addP_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("add ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# ptr");
}
#endif
#ifndef PRODUCT
void addL_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void addL_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("add ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void subI_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("subw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void subI_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("subw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void subL_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void subL_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sub");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void negI_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("negw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void negL_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("neg ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# long");
}
#endif
#ifndef PRODUCT
void mulINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("mulw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void smulINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("smull  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void smulI_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  st->print_raw("smull  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
}
#endif
#ifndef PRODUCT
void mulLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("mul  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void mulHiL_rRegNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("smulh   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", \t# mulhi");
}
#endif
#ifndef PRODUCT
void maddINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("madd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void maddI_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("madd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void msubINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("msub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void mnegINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("mneg  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
}
#endif
#ifndef PRODUCT
void mnegI_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("mneg  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
}
#endif
#ifndef PRODUCT
void maddLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("madd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void maddL_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("madd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void msubLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("msub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void mnegLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("mneg  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
}
#endif
#ifndef PRODUCT
void mnegL_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("mneg  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
}
#endif
#ifndef PRODUCT
void smaddLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("smaddl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void smaddL_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("smaddl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void smaddL_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("smaddl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void smaddL_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("smaddl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void smsubLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("smsubl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void smsubL_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("smsubl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void smnegLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("smnegl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
}
#endif
#ifndef PRODUCT
void smnegL_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("smnegl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
}
#endif
#ifndef PRODUCT
void muladdS2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("mulw  rscratch1, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\n\t");
  st->print_raw("maddw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src4
  st->print_raw(", rscratch1");
}
#endif
#ifndef PRODUCT
void divINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sdivw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void divLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sdiv   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void modINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sdivw  rscratch1, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\n\t");
  st->print_raw("msubw(");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", rscratch1, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
}
#endif
#ifndef PRODUCT
void modLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sdiv   rscratch1, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\n");
  st->print_raw("msub(");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", rscratch1, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
}
#endif
#ifndef PRODUCT
void lShiftI_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("lslvw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void lShiftI_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("lslw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", (");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(" & 0x1f)");
}
#endif
#ifndef PRODUCT
void urShiftI_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("lsrvw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void urShiftI_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("lsrw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", (");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(" & 0x1f)");
}
#endif
#ifndef PRODUCT
void rShiftI_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("asrvw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void rShiftI_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("asrw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", (");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(" & 0x1f)");
}
#endif
#ifndef PRODUCT
void lShiftL_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("lslv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void lShiftL_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("lsl ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", (");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(" & 0x3f)");
}
#endif
#ifndef PRODUCT
void urShiftL_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("lsrv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void urShiftL_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("lsr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", (");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(" & 0x3f)");
}
#endif
#ifndef PRODUCT
void urShiftP_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("lsr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", p2x(");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw("), (");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(" & 0x3f)");
}
#endif
#ifndef PRODUCT
void rShiftL_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("asrv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void rShiftL_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("asr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", (");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(" & 0x3f)");
}
#endif
#ifndef PRODUCT
void regL_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", zr");
}
#endif
#ifndef PRODUCT
void regI_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", zr");
}
#endif
#ifndef PRODUCT
void AndI_reg_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("bicw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void AndI_reg_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bicw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
}
#endif
#ifndef PRODUCT
void AndL_reg_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void AndL_reg_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
}
#endif
#ifndef PRODUCT
void OrI_reg_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("ornw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void OrI_reg_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("ornw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
}
#endif
#ifndef PRODUCT
void OrL_reg_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("orn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void OrL_reg_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("orn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
}
#endif
#ifndef PRODUCT
void XorI_reg_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void XorI_reg_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
}
#endif
#ifndef PRODUCT
void XorL_reg_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void XorL_reg_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
}
#endif
#ifndef PRODUCT
void AndI_reg_URShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("bicw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndI_reg_URShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("bicw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_URShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_URShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AndI_reg_RShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("bicw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndI_reg_RShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("bicw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ASR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_RShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_RShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ASR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AndI_reg_RotateRight_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("bicw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ROR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndI_reg_RotateRight_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("bicw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ROR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_RotateRight_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ROR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_RotateRight_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ROR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AndI_reg_LShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("bicw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndI_reg_LShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("bicw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSL ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_LShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_LShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSL ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_URShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_URShift_not_reg_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_URShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", LSR ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_URShift_not_reg_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_URShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_URShift_not_reg_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_URShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", LSR ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_URShift_not_reg_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_RShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_RShift_not_reg_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ASR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_RShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ASR ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_RShift_not_reg_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_RShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_RShift_not_reg_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ASR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_RShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ASR ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_RShift_not_reg_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_RotateRight_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ROR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_RotateRight_not_reg_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ROR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_RotateRight_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ROR ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_RotateRight_not_reg_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ROR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_RotateRight_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ROR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_RotateRight_not_reg_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ROR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_RotateRight_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ROR ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_RotateRight_not_reg_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ROR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_LShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_LShift_not_reg_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSL ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_LShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", LSL ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_LShift_not_reg_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eonw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_LShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_LShift_not_reg_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSL ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_LShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src4
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src3
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", LSL ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_LShift_not_reg_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("eon  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_URShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("ornw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_URShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("ornw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_URShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("orn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_URShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("orn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_RShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("ornw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_RShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("ornw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ASR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_RShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("orn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_RShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("orn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ASR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_RotateRight_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("ornw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ROR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_RotateRight_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("ornw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ROR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_RotateRight_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("orn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ROR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_RotateRight_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("orn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ROR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_LShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("ornw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_LShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("ornw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSL ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_LShift_not_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src4
  st->print_raw("orn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_LShift_not_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src4
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("orn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSL ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AndI_reg_URShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("andw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndI_reg_URShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("andw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_URShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("andr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_URShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("andr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AndI_reg_RShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("andw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndI_reg_RShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("andw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ASR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_RShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("andr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_RShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("andr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ASR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AndI_reg_LShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("andw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndI_reg_LShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("andw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSL ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_LShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("andr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_LShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("andr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSL ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AndI_reg_RotateRight_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("andw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ROR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndI_reg_RotateRight_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("andw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ROR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_RotateRight_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("andr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ROR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AndL_reg_RotateRight_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("andr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ROR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_URShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("eorw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_URShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("eorw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_URShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("eor  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_URShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("eor  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_RShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("eorw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_RShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("eorw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ASR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_RShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("eor  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_RShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("eor  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ASR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_LShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("eorw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_LShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("eorw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSL ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_LShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("eor  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_LShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("eor  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSL ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_RotateRight_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("eorw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ROR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorI_reg_RotateRight_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("eorw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ROR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_RotateRight_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("eor  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ROR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void XorL_reg_RotateRight_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("eor  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ROR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_URShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("orrw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_URShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("orrw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_URShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("orr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_URShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("orr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_RShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("orrw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_RShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("orrw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ASR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_RShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("orr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_RShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("orr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ASR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_LShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("orrw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_LShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("orrw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSL ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_LShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("orr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_LShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("orr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSL ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_RotateRight_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("orrw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ROR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrI_reg_RotateRight_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("orrw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ROR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_RotateRight_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("orr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ROR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void OrL_reg_RotateRight_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("orr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ROR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AddI_reg_URShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AddI_reg_URShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AddL_reg_URShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AddL_reg_URShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AddI_reg_RShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AddI_reg_RShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ASR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AddL_reg_RShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AddL_reg_RShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", ASR ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AddI_reg_LShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AddI_reg_LShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSL ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void AddL_reg_LShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void AddL_reg_LShift_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", LSL ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src3
}
#endif
#ifndef PRODUCT
void SubI_reg_URShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("subw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void SubL_reg_URShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void SubI_reg_RShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("subw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void SubL_reg_RShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ASR ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void SubI_reg_LShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("subw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void SubL_reg_LShift_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", LSL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
}
#endif
#ifndef PRODUCT
void sbfmLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift_count
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift_count
  st->print_raw("sbfm  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // rshift_count
  st->print_raw(" - ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // lshift_count
  st->print_raw(", #63 - ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // lshift_count
}
#endif
#ifndef PRODUCT
void sbfmwINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift_count
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift_count
  st->print_raw("sbfmw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // rshift_count
  st->print_raw(" - ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // lshift_count
  st->print_raw(", #31 - ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // lshift_count
}
#endif
#ifndef PRODUCT
void ubfmLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift_count
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift_count
  st->print_raw("ubfm  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // rshift_count
  st->print_raw(" - ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // lshift_count
  st->print_raw(", #63 - ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // lshift_count
}
#endif
#ifndef PRODUCT
void ubfmwINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift_count
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift_count
  st->print_raw("ubfmw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // rshift_count
  st->print_raw(" - ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // lshift_count
  st->print_raw(", #31 - ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // lshift_count
}
#endif
#ifndef PRODUCT
void ubfxwINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  st->print_raw("ubfxw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // rshift
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // mask
}
#endif
#ifndef PRODUCT
void ubfxLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  st->print_raw("ubfx ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // rshift
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // mask
}
#endif
#ifndef PRODUCT
void ubfxIConvI2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  st->print_raw("ubfx ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // rshift
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // mask
}
#endif
#ifndef PRODUCT
void ubfizwINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  st->print_raw("ubfizw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // lshift
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // mask
}
#endif
#ifndef PRODUCT
void ubfizLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  st->print_raw("ubfiz ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // lshift
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // mask
}
#endif
#ifndef PRODUCT
void ubfizwIConvI2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  st->print_raw("ubfizw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // lshift
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // mask
}
#endif
#ifndef PRODUCT
void ubfizLConvL2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  st->print_raw("ubfiz ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // lshift
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // mask
}
#endif
#ifndef PRODUCT
void ubfizIConvI2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  st->print_raw("ubfiz ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // lshift
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // mask
}
#endif
#ifndef PRODUCT
void ubfizLConvL2IxNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  st->print_raw("ubfiz ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // lshift
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // mask
}
#endif
#ifndef PRODUCT
void ubfizIConvI2LAndINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// msk
  st->print_raw("ubfiz ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", 0, exact_log2(");
  opnd_array(2)->ext_format(ra, this,idx2, st); // msk
  st->print_raw(" + 1) ");
}
#endif
#ifndef PRODUCT
void extrOrLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  st->print_raw("extr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", #");
  opnd_array(4)->ext_format(ra, this,idx4, st); // rshift
}
#endif
#ifndef PRODUCT
void extrOrL_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  st->print_raw("extr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", #");
  opnd_array(2)->ext_format(ra, this,idx2, st); // rshift
}
#endif
#ifndef PRODUCT
void extrOrINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  st->print_raw("extr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", #");
  opnd_array(4)->ext_format(ra, this,idx4, st); // rshift
}
#endif
#ifndef PRODUCT
void extrOrI_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  st->print_raw("extr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", #");
  opnd_array(2)->ext_format(ra, this,idx2, st); // rshift
}
#endif
#ifndef PRODUCT
void extrAddLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  st->print_raw("extr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", #");
  opnd_array(4)->ext_format(ra, this,idx4, st); // rshift
}
#endif
#ifndef PRODUCT
void extrAddL_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  st->print_raw("extr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", #");
  opnd_array(2)->ext_format(ra, this,idx2, st); // rshift
}
#endif
#ifndef PRODUCT
void extrAddINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  st->print_raw("extr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", #");
  opnd_array(4)->ext_format(ra, this,idx4, st); // rshift
}
#endif
#ifndef PRODUCT
void extrAddI_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  st->print_raw("extr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", #");
  opnd_array(2)->ext_format(ra, this,idx2, st); // rshift
}
#endif
#ifndef PRODUCT
void rorI_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("ror    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
}
#endif
#ifndef PRODUCT
void rorL_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("ror    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
}
#endif
#ifndef PRODUCT
void rorI_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("ror    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
}
#endif
#ifndef PRODUCT
void rorL_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("ror    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
}
#endif
#ifndef PRODUCT
void rolI_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("rol    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
}
#endif
#ifndef PRODUCT
void rolL_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("rol    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
}
#endif
#ifndef PRODUCT
void AddExtINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxtw");
}
#endif
#ifndef PRODUCT
void AddExtI_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", sxtw");
}
#endif
#ifndef PRODUCT
void SubExtINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxtw");
}
#endif
#ifndef PRODUCT
void AddExtI_sxthNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxth");
}
#endif
#ifndef PRODUCT
void AddExtI_sxth_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", sxth");
}
#endif
#ifndef PRODUCT
void AddExtI_sxtbNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxtb");
}
#endif
#ifndef PRODUCT
void AddExtI_sxtb_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", sxtb");
}
#endif
#ifndef PRODUCT
void AddExtI_uxtbNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxtb");
}
#endif
#ifndef PRODUCT
void AddExtI_uxtb_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", uxtb");
}
#endif
#ifndef PRODUCT
void AddExtL_sxthNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxth");
}
#endif
#ifndef PRODUCT
void AddExtL_sxth_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", sxth");
}
#endif
#ifndef PRODUCT
void AddExtL_sxtwNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxtw");
}
#endif
#ifndef PRODUCT
void AddExtL_sxtw_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", sxtw");
}
#endif
#ifndef PRODUCT
void AddExtL_sxtbNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxtb");
}
#endif
#ifndef PRODUCT
void AddExtL_sxtb_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", sxtb");
}
#endif
#ifndef PRODUCT
void AddExtL_uxtbNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxtb");
}
#endif
#ifndef PRODUCT
void AddExtL_uxtb_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", uxtb");
}
#endif
#ifndef PRODUCT
void AddExtI_uxtb_andNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxtb");
}
#endif
#ifndef PRODUCT
void AddExtI_uxtb_and_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", uxtb");
}
#endif
#ifndef PRODUCT
void AddExtI_uxth_andNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxth");
}
#endif
#ifndef PRODUCT
void AddExtI_uxth_and_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", uxth");
}
#endif
#ifndef PRODUCT
void AddExtL_uxtb_andNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxtb");
}
#endif
#ifndef PRODUCT
void AddExtL_uxtb_and_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", uxtb");
}
#endif
#ifndef PRODUCT
void AddExtL_uxth_andNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxth");
}
#endif
#ifndef PRODUCT
void AddExtL_uxth_and_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", uxth");
}
#endif
#ifndef PRODUCT
void AddExtL_uxtw_andNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxtw");
}
#endif
#ifndef PRODUCT
void AddExtL_uxtw_and_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", uxtw");
}
#endif
#ifndef PRODUCT
void SubExtI_uxtb_andNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  st->print_raw("subw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxtb");
}
#endif
#ifndef PRODUCT
void SubExtI_uxth_andNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  st->print_raw("subw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxth");
}
#endif
#ifndef PRODUCT
void SubExtL_uxtb_andNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  st->print_raw("sub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxtb");
}
#endif
#ifndef PRODUCT
void SubExtL_uxth_andNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  st->print_raw("sub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxth");
}
#endif
#ifndef PRODUCT
void SubExtL_uxtw_andNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  st->print_raw("sub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxtw");
}
#endif
#ifndef PRODUCT
void AddExtL_sxtb_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxtb #lshift2");
}
#endif
#ifndef PRODUCT
void AddExtL_sxtb_shift_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", sxtb #lshift2");
}
#endif
#ifndef PRODUCT
void AddExtL_sxth_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxth #lshift2");
}
#endif
#ifndef PRODUCT
void AddExtL_sxth_shift_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", sxth #lshift2");
}
#endif
#ifndef PRODUCT
void AddExtL_sxtw_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxtw #lshift2");
}
#endif
#ifndef PRODUCT
void AddExtL_sxtw_shift_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", sxtw #lshift2");
}
#endif
#ifndef PRODUCT
void SubExtL_sxtb_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  st->print_raw("sub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxtb #lshift2");
}
#endif
#ifndef PRODUCT
void SubExtL_sxth_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  st->print_raw("sub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxth #lshift2");
}
#endif
#ifndef PRODUCT
void SubExtL_sxtw_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  st->print_raw("sub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxtw #lshift2");
}
#endif
#ifndef PRODUCT
void AddExtI_sxtb_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxtb #lshift2");
}
#endif
#ifndef PRODUCT
void AddExtI_sxtb_shift_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// src1
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", sxtb #lshift2");
}
#endif
#ifndef PRODUCT
void AddExtI_sxth_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxth #lshift2");
}
#endif
#ifndef PRODUCT
void AddExtI_sxth_shift_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// rshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// src1
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", sxth #lshift2");
}
#endif
#ifndef PRODUCT
void SubExtI_sxtb_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  st->print_raw("subw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxtb #lshift2");
}
#endif
#ifndef PRODUCT
void SubExtI_sxth_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// rshift1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// lshift2
  st->print_raw("subw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxth #lshift2");
}
#endif
#ifndef PRODUCT
void AddExtI_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxtw #lshift");
}
#endif
#ifndef PRODUCT
void AddExtI_shift_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lshift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", sxtw #lshift");
}
#endif
#ifndef PRODUCT
void SubExtI_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  st->print_raw("sub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", sxtw #lshift");
}
#endif
#ifndef PRODUCT
void AddExtL_uxtb_and_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxtb #lshift");
}
#endif
#ifndef PRODUCT
void AddExtL_uxtb_and_shift_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", uxtb #lshift");
}
#endif
#ifndef PRODUCT
void AddExtL_uxth_and_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxth #lshift");
}
#endif
#ifndef PRODUCT
void AddExtL_uxth_and_shift_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", uxth #lshift");
}
#endif
#ifndef PRODUCT
void AddExtL_uxtw_and_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxtw #lshift");
}
#endif
#ifndef PRODUCT
void AddExtL_uxtw_and_shift_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("add  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", uxtw #lshift");
}
#endif
#ifndef PRODUCT
void SubExtL_uxtb_and_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  st->print_raw("sub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxtb #lshift");
}
#endif
#ifndef PRODUCT
void SubExtL_uxth_and_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  st->print_raw("sub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxth #lshift");
}
#endif
#ifndef PRODUCT
void SubExtL_uxtw_and_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  st->print_raw("sub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxtw #lshift");
}
#endif
#ifndef PRODUCT
void AddExtI_uxtb_and_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxtb #lshift");
}
#endif
#ifndef PRODUCT
void AddExtI_uxtb_and_shift_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", uxtb #lshift");
}
#endif
#ifndef PRODUCT
void AddExtI_uxth_and_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxth #lshift");
}
#endif
#ifndef PRODUCT
void AddExtI_uxth_and_shift_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// lshift
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src1
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw(", uxth #lshift");
}
#endif
#ifndef PRODUCT
void SubExtI_uxtb_and_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  st->print_raw("subw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxtb #lshift");
}
#endif
#ifndef PRODUCT
void SubExtI_uxth_and_shiftNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// mask
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// lshift
  st->print_raw("subw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", uxth #lshift");
}
#endif
#ifndef PRODUCT
void addF_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fadds   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void addD_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("faddd   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void subF_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fsubs   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void subD_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fsubd   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void mulF_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fmuls   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void mulD_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fmuld   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void maddF_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fmadds   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void maddD_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fmaddd   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void msubF_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fmsubs   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void msubF_reg_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fmsubs   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void msubD_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fmsubd   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void msubD_reg_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fmsubd   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void mnaddF_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fnmadds  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void mnaddF_reg_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fnmadds  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void mnaddD_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fnmaddd   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void mnaddD_reg_reg_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fnmaddd   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void mnsubF_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fnmsubs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void mnsubD_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src3
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fnmsubd   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src3
}
#endif
#ifndef PRODUCT
void maxF_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fmaxs   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void minF_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fmins   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void maxD_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fmaxd   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void minD_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fmind   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void divF_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fdivs   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void divD_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fdivd   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void negF_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fneg   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void negD_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fnegd   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void absI_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("cmpw  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", zr\n\t");
  st->print_raw("cnegw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", Assembler::LT\t# int abs");
}
#endif
#ifndef PRODUCT
void absL_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("cmp  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", zr\n\t");
  st->print_raw("cneg ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", Assembler::LT\t# long abs");
}
#endif
#ifndef PRODUCT
void absF_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fabss   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void absD_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fabsd   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void absdF_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fabds   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void absdD_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fabdd   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void sqrtD_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fsqrtd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void sqrtF_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fsqrts  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void roundD_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rmode
  st->print_raw("frint  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // rmode
}
#endif
#ifndef PRODUCT
void copySignD_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  st->print_raw("CopySignD  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(" ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void copySignF_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("CopySignF  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(" ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(" ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void signumD_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// one
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  st->print_raw("signumD  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void signumF_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// one
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  st->print_raw("signumF  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void onspinwaitNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("onspinwait");
}
#endif
#ifndef PRODUCT
void andI_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("andw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void andI_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("andsw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void orI_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("orrw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void orI_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("orrw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void xorI_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("eorw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void xorI_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("eorw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void andL_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("and  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void andL_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("and  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void orL_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("orr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void orL_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("orr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void xorL_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("eor  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void xorL_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("eor  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# int");
}
#endif
#ifndef PRODUCT
void convI2L_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sxtw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# i2l");
}
#endif
#ifndef PRODUCT
void convUI2L_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  st->print_raw("ubfm  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", 0, 31\t# ui2l");
}
#endif
#ifndef PRODUCT
void convL2I_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("movw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(" \t// l2i");
}
#endif
#ifndef PRODUCT
void convI2BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("cmpw ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", zr\n\t");
  st->print_raw("cset ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ne");
}
#endif
#ifndef PRODUCT
void convP2BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("cmp  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", zr\n\t");
  st->print_raw("cset ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ne");
}
#endif
#ifndef PRODUCT
void convD2F_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fcvtd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(" \t// d2f");
}
#endif
#ifndef PRODUCT
void convF2D_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fcvts  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(" \t// f2d");
}
#endif
#ifndef PRODUCT
void convF2I_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fcvtzsw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(" \t// f2i");
}
#endif
#ifndef PRODUCT
void convF2L_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fcvtzs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(" \t// f2l");
}
#endif
#ifndef PRODUCT
void convI2F_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("scvtfws  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(" \t// i2f");
}
#endif
#ifndef PRODUCT
void convL2F_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("scvtfs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(" \t// l2f");
}
#endif
#ifndef PRODUCT
void convD2I_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fcvtzdw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(" \t// d2i");
}
#endif
#ifndef PRODUCT
void convD2L_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fcvtzd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(" \t// d2l");
}
#endif
#ifndef PRODUCT
void convI2D_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("scvtfwd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(" \t// i2d");
}
#endif
#ifndef PRODUCT
void convL2D_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("scvtfd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(" \t// l2d");
}
#endif
#ifndef PRODUCT
void MoveF2I_stack_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("ldrw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# MoveF2I_stack_reg");
}
#endif
#ifndef PRODUCT
void MoveI2F_stack_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("ldrs ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# MoveI2F_stack_reg");
}
#endif
#ifndef PRODUCT
void MoveD2L_stack_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("ldr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# MoveD2L_stack_reg");
}
#endif
#ifndef PRODUCT
void MoveL2D_stack_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("ldrd ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# MoveL2D_stack_reg");
}
#endif
#ifndef PRODUCT
void MoveF2I_reg_stackNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("strs ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# MoveF2I_reg_stack");
}
#endif
#ifndef PRODUCT
void MoveI2F_reg_stackNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("strw ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# MoveI2F_reg_stack");
}
#endif
#ifndef PRODUCT
void MoveD2L_reg_stackNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("strd ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# MoveD2L_reg_stack");
}
#endif
#ifndef PRODUCT
void MoveL2D_reg_stackNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("str ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# MoveL2D_reg_stack");
}
#endif
#ifndef PRODUCT
void MoveF2I_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fmovs ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# MoveF2I_reg_reg");
}
#endif
#ifndef PRODUCT
void MoveI2F_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fmovs ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# MoveI2F_reg_reg");
}
#endif
#ifndef PRODUCT
void MoveD2L_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fmovd ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# MoveD2L_reg_reg");
}
#endif
#ifndef PRODUCT
void MoveL2D_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fmovd ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# MoveL2D_reg_reg");
}
#endif
#ifndef PRODUCT
void clearArray_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// cnt
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// base
  st->print_raw("ClearArray ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cnt
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // base
}
#endif
#ifndef PRODUCT
void clearArray_imm_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// cnt
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// base
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// temp
  st->print_raw("ClearArray ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cnt
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // base
}
#endif
#ifndef PRODUCT
void overflowAddI_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmnw  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\t# overflow check int");
}
#endif
#ifndef PRODUCT
void overflowAddI_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmnw  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\t# overflow check int");
}
#endif
#ifndef PRODUCT
void overflowAddL_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmn   ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\t# overflow check long");
}
#endif
#ifndef PRODUCT
void overflowAddL_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmn   ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\t# overflow check long");
}
#endif
#ifndef PRODUCT
void overflowSubI_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmpw  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\t# overflow check int");
}
#endif
#ifndef PRODUCT
void overflowSubI_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmpw  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\t# overflow check int");
}
#endif
#ifndef PRODUCT
void overflowSubL_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmp   ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\t# overflow check long");
}
#endif
#ifndef PRODUCT
void overflowSubL_reg_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmp   ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\t# overflow check long");
}
#endif
#ifndef PRODUCT
void overflowNegI_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op1
  st->print_raw("cmpw  zr, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw("\t# overflow check int");
}
#endif
#ifndef PRODUCT
void overflowNegL_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op1
  st->print_raw("cmp   zr, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw("\t# overflow check long");
}
#endif
#ifndef PRODUCT
void overflowMulI_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("smull rscratch1, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\t# overflow check int\n\t");
  st->print_raw("cmp   rscratch1, rscratch1, sxtw\n\t");
  st->print_raw("movw  rscratch1, #0x80000000\n\t");
  st->print_raw("cselw rscratch1, rscratch1, zr, NE\n\t");
  st->print_raw("cmpw  rscratch1, #1");
}
#endif
#ifndef PRODUCT
void overflowMulI_reg_branchNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  st->print_raw("smull rscratch1, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // op2
  st->print_raw("\t# overflow check int\n\t");
  st->print_raw("cmp   rscratch1, rscratch1, sxtw\n\t");
  st->print_raw("b");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // labl
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void overflowMulL_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("mul   rscratch1, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\t#overflow check long\n\t");
  st->print_raw("smulh rscratch2, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\n\t");
  st->print_raw("cmp   rscratch2, rscratch1, ASR #63\n\t");
  st->print_raw("movw  rscratch1, #0x80000000\n\t");
  st->print_raw("cselw rscratch1, rscratch1, zr, NE\n\t");
  st->print_raw("cmpw  rscratch1, #1");
}
#endif
#ifndef PRODUCT
void overflowMulL_reg_branchNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  st->print_raw("mul   rscratch1, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // op2
  st->print_raw("\t#overflow check long\n\t");
  st->print_raw("smulh rscratch2, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // op2
  st->print_raw("\n\t");
  st->print_raw("cmp   rscratch2, rscratch1, ASR #63\n\t");
  st->print_raw("b");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw(" ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // labl
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void compI_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmpw  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
}
#endif
#ifndef PRODUCT
void compI_reg_immI0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("cmpw ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", 0");
}
#endif
#ifndef PRODUCT
void compI_reg_immIAddSubNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmpw  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
}
#endif
#ifndef PRODUCT
void compI_reg_immINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmpw  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
}
#endif
#ifndef PRODUCT
void compU_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmpw  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\t# unsigned");
}
#endif
#ifndef PRODUCT
void compU_reg_immI0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("cmpw ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", #0\t# unsigned");
}
#endif
#ifndef PRODUCT
void compU_reg_immIAddSubNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmpw  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\t# unsigned");
}
#endif
#ifndef PRODUCT
void compU_reg_immINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmpw  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\t# unsigned");
}
#endif
#ifndef PRODUCT
void compL_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmp  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
}
#endif
#ifndef PRODUCT
void compL_reg_immL0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("tst  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
}
#endif
#ifndef PRODUCT
void compL_reg_immLAddSubNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmp  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
}
#endif
#ifndef PRODUCT
void compL_reg_immLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmp  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
}
#endif
#ifndef PRODUCT
void compUL_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmp  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
}
#endif
#ifndef PRODUCT
void compUL_reg_immL0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("tst  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
}
#endif
#ifndef PRODUCT
void compUL_reg_immLAddSubNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmp  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
}
#endif
#ifndef PRODUCT
void compUL_reg_immLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmp  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
}
#endif
#ifndef PRODUCT
void compP_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmp  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\t // ptr");
}
#endif
#ifndef PRODUCT
void compN_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  st->print_raw("cmp  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw("\t // compressed ptr");
}
#endif
#ifndef PRODUCT
void testP_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("cmp  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", 0\t // ptr");
}
#endif
#ifndef PRODUCT
void testN_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("cmp  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", 0\t // compressed ptr");
}
#endif
#ifndef PRODUCT
void compF_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fcmps ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void compF_reg_zeroNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fcmps ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", 0.0");
}
#endif
#ifndef PRODUCT
void compD_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fcmpd ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
}
#endif
#ifndef PRODUCT
void compD_reg_zeroNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fcmpd ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", 0.0");
}
#endif
#ifndef PRODUCT
void compF3_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fcmps ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\n\t");
  st->print_raw("csinvw(");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", zr, zr, eq\n\t");
  st->print_raw("csnegw(");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", lt)");
}
#endif
#ifndef PRODUCT
void compD3_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fcmpd ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\n\t");
  st->print_raw("csinvw(");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", zr, zr, eq\n\t");
  st->print_raw("csnegw(");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", lt)");
}
#endif
#ifndef PRODUCT
void compF3_reg_immF0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("fcmps ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", 0.0\n\t");
  st->print_raw("csinvw(");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", zr, zr, eq\n\t");
  st->print_raw("csnegw(");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", lt)");
}
#endif
#ifndef PRODUCT
void compD3_reg_immD0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("fcmpd ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", 0.0\n\t");
  st->print_raw("csinvw(");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", zr, zr, eq\n\t");
  st->print_raw("csnegw(");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", lt)");
}
#endif
#ifndef PRODUCT
void cmpLTMask_reg_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// p
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// q
  st->print_raw("cmpw ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // p
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // q
  st->print_raw("\t# cmpLTMask\n\t");
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", lt\n\t");
  st->print_raw("subw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", zr, ");
  opnd_array(0)->int_format(ra, this, st); // dst
}
#endif
#ifndef PRODUCT
void cmpLTMask_reg_zeroNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  st->print_raw("asrw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", #31\t# cmpLTMask0");
}
#endif
#ifndef PRODUCT
void cmovI_reg_reg_ltNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cr
  st->print_raw("cselw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(" lt\t");
}
#endif
#ifndef PRODUCT
void minI_rRegNode::format(PhaseRegAlloc *ra, outputStream *st) const {
}
#endif
#ifndef PRODUCT
void cmovI_reg_reg_gtNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cr
  st->print_raw("cselw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(" gt\t");
}
#endif
#ifndef PRODUCT
void maxI_rRegNode::format(PhaseRegAlloc *ra, outputStream *st) const {
}
#endif
#ifndef PRODUCT
void branchNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  st->print_raw("b  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // lbl
}
#endif
#ifndef PRODUCT
void branchConNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lbl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  st->print_raw("b");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // lbl
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void branchConUNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lbl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  st->print_raw("b");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // lbl
  st->print_raw("\t# unsigned");
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void cmpI_imm0_branchNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  st->print_raw("cbw");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // labl
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void cmpL_imm0_branchNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  st->print_raw("cb");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // labl
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void cmpP_imm0_branchNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  st->print_raw("cb");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // labl
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void cmpN_imm0_branchNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  st->print_raw("cbw");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // labl
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void cmpP_narrowOop_imm0_branchNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// oop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  st->print_raw("cb");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oop
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // labl
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void cmpUI_imm0_branchNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  st->print_raw("cbw");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // labl
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void cmpUL_imm0_branchNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cr
  st->print_raw("cb");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // labl
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void cmpL_branch_signNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// 
  st->print_raw("cb");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // labl
  st->print_raw(" # long");
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void cmpI_branch_signNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// 
  st->print_raw("cb");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // labl
  st->print_raw(" # int");
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void cmpL_branch_bitNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// labl
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// 
  st->print_raw("tb");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // op2
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // labl
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void cmpI_branch_bitNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// labl
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// 
  st->print_raw("tb");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // op2
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // labl
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void far_cmpL_branch_signNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// 
  st->print_raw("cb");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // labl
  st->print_raw(" # long");
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void far_cmpI_branch_signNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// labl
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// 
  st->print_raw("cb");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // labl
  st->print_raw(" # int");
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void far_cmpL_branch_bitNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// labl
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// 
  st->print_raw("tb");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // op2
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // labl
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void far_cmpI_branch_bitNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// labl
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// 
  st->print_raw("tb");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw("   ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // op2
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // labl
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void cmpL_andNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  st->print_raw("tst ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw(" # long");
}
#endif
#ifndef PRODUCT
void cmpI_andNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  st->print_raw("tst ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw(" # int");
}
#endif
#ifndef PRODUCT
void cmpL_and_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  st->print_raw("tst ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw(" # long");
}
#endif
#ifndef PRODUCT
void cmpI_and_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// op3
  st->print_raw("tstw ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // op1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // op2
  st->print_raw(" # int");
}
#endif
#ifndef PRODUCT
void branchLoopEndNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lbl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  st->print_raw("b");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw(" ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // lbl
  st->print_raw(" \t// counted loop end");
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void branchLoopEndUNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// lbl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  st->print_raw("b");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cmp
  st->print_raw(" ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // lbl
  st->print_raw(" \t// counted loop end unsigned");
  st->print("  P=%f C=%f",_prob,_fcnt);
}
#endif
#ifndef PRODUCT
void cmpFastLockNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// object
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// box
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  st->print_raw("fastlock ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // object
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // box
  st->print_raw("\t! kills ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp2
}
#endif
#ifndef PRODUCT
void cmpFastUnlockNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// object
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// box
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  st->print_raw("fastunlock ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // object
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // box
  st->print_raw("\t! kills ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp2
}
#endif
#ifndef PRODUCT
void safePointNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// cr
  st->print_raw("ldrw zr, [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // poll
  st->print_raw("]\t# Safepoint: poll for GC");
  st->print_raw("");
  if (_jvms) _jvms->format(ra, this, st); else st->print_cr("        No JVM State Info");
  st->print("        # ");
  if( _jvms && _oop_map ) _oop_map->print_on(st);
}
#endif
#ifndef PRODUCT
void CallStaticJavaDirectNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  st->print_raw("call,static ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // meth
  st->print_raw(" \t// ==> ");
  if( _method ) _method->print_short_name(st);
  else st->print(" wrapper for: %s", _name);
  if( !_method ) dump_trap_args(st);
  st->cr();
  if (_jvms) _jvms->format(ra, this, st); else st->print_cr("        No JVM State Info");
  st->print("        # ");
  if( _jvms && _oop_map ) _oop_map->print_on(st);
}
#endif
#ifndef PRODUCT
void CallDynamicJavaDirectNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  st->print_raw("CALL,dynamic ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // meth
  st->print_raw(" \t// ==> ");
  _method->print_short_name(st);
  st->cr();
  if (_jvms) _jvms->format(ra, this, st); else st->print_cr("        No JVM State Info");
  st->print("        # ");
  if( _jvms && _oop_map ) _oop_map->print_on(st);
}
#endif
#ifndef PRODUCT
void CallRuntimeDirectNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  st->print_raw("CALL, runtime ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // meth
  st->print(" %s", _name);  st->cr();
  if (_jvms) _jvms->format(ra, this, st); else st->print_cr("        No JVM State Info");
  st->print("        # ");
  if( _jvms && _oop_map ) _oop_map->print_on(st);
}
#endif
#ifndef PRODUCT
void CallLeafDirectNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  st->print_raw("CALL, runtime leaf ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // meth
  st->print(" %s", _name);  st->cr();
  if (_jvms) _jvms->format(ra, this, st); else st->print_cr("        No JVM State Info");
  st->print("        # ");
  if( _jvms && _oop_map ) _oop_map->print_on(st);
}
#endif
#ifndef PRODUCT
void CallLeafNoFPDirectNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  st->print_raw("CALL, runtime leaf nofp ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // meth
  st->print(" %s", _name);  st->cr();
  if (_jvms) _jvms->format(ra, this, st); else st->print_cr("        No JVM State Info");
  st->print("        # ");
  if( _jvms && _oop_map ) _oop_map->print_on(st);
}
#endif
#ifndef PRODUCT
void CallNativeDirectNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  st->print_raw("CALL, native ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // meth
  st->print(" %s", _name);  st->cr();
  if (_jvms) _jvms->format(ra, this, st); else st->print_cr("        No JVM State Info");
  st->print("        # ");
  if( _jvms && _oop_map ) _oop_map->print_on(st);
}
#endif
#ifndef PRODUCT
void TailCalljmpIndNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// method_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// 
  st->print_raw("br ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // jump_target
  st->print_raw("\t# ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // method_ptr
  st->print_raw(" holds method");
}
#endif
#ifndef PRODUCT
void TailjmpIndNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// ex_oop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// 
  st->print_raw("br ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // jump_target
  st->print_raw("\t# ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // ex_oop
  st->print_raw(" holds exception oop");
}
#endif
#ifndef PRODUCT
void CreateExceptionNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw(" -- \t// exception oop; no code emitted");
}
#endif
#ifndef PRODUCT
void RethrowExceptionNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("b rethrow_stub");
}
#endif
#ifndef PRODUCT
void RetNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("ret\t// return register");
}
#endif
#ifndef PRODUCT
void ShouldNotReachHereNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  st->print_raw("ShouldNotReachHere");
}
#endif
#ifndef PRODUCT
void partialSubtypeCheckNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// sub
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// super
  st->print_raw("partialSubtypeCheck ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // sub
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // super
}
#endif
#ifndef PRODUCT
void partialSubtypeCheckVsZeroNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// sub
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// super
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  st->print_raw("partialSubtypeCheck ");
      st->print_raw("R5");
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // sub
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // super
  st->print_raw(" == 0");
}
#endif
#ifndef PRODUCT
void string_compareUNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  st->print_raw("String Compare ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // str2
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // cnt2
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw("   # KILL ");
      st->print_raw("R10");
}
#endif
#ifndef PRODUCT
void string_compareLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  st->print_raw("String Compare ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // str2
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // cnt2
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw("   # KILL ");
      st->print_raw("R10");
}
#endif
#ifndef PRODUCT
void string_compareULNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  st->print_raw("String Compare ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // str2
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // cnt2
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw("   # KILL ");
      st->print_raw("R10");
  st->print_raw(", ");
      st->print_raw("R11");
  st->print_raw(", ");
      st->print_raw("V0");
  st->print_raw(", ");
      st->print_raw("V1");
  st->print_raw(", ");
      st->print_raw("V2");
}
#endif
#ifndef PRODUCT
void string_compareLUNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  st->print_raw("String Compare ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // str2
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // cnt2
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw("   # KILL ");
      st->print_raw("R10");
  st->print_raw(", ");
      st->print_raw("R11");
  st->print_raw(", ");
      st->print_raw("V0");
  st->print_raw(", ");
      st->print_raw("V1");
  st->print_raw(", ");
      st->print_raw("V2");
}
#endif
#ifndef PRODUCT
void string_indexofUUNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp3
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// tmp4
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// tmp5
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// tmp6
  st->print_raw("String IndexOf ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // str2
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // cnt2
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw(" (UU)");
}
#endif
#ifndef PRODUCT
void string_indexofLLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp3
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// tmp4
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// tmp5
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// tmp6
  st->print_raw("String IndexOf ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // str2
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // cnt2
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw(" (LL)");
}
#endif
#ifndef PRODUCT
void string_indexofULNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp3
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// tmp4
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// tmp5
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// tmp6
  st->print_raw("String IndexOf ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // str2
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // cnt2
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw(" (UL)");
}
#endif
#ifndef PRODUCT
void string_indexof_conUUNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// int_cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp3
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// tmp4
  st->print_raw("String IndexOf ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // str2
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // int_cnt2
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw(" (UU)");
}
#endif
#ifndef PRODUCT
void string_indexof_conLLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// int_cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp3
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// tmp4
  st->print_raw("String IndexOf ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // str2
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // int_cnt2
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw(" (LL)");
}
#endif
#ifndef PRODUCT
void string_indexof_conULNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// int_cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp3
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// tmp4
  st->print_raw("String IndexOf ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // str2
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // int_cnt2
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw(" (UL)");
}
#endif
#ifndef PRODUCT
void string_indexof_charNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ch
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp3
  st->print_raw("StringUTF16 IndexOf char[] ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // ch
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
}
#endif
#ifndef PRODUCT
void stringL_indexof_charNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ch
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp3
  st->print_raw("StringLatin1 IndexOf char[] ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // ch
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
}
#endif
#ifndef PRODUCT
void string_equalsLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// str2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cnt
  st->print_raw("String Equals ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // str2
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // cnt
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
}
#endif
#ifndef PRODUCT
void string_equalsUNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// str2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cnt
  st->print_raw("String Equals ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // str2
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // cnt
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
}
#endif
#ifndef PRODUCT
void array_equalsBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// ary1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// ary2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp3
  st->print_raw("Array Equals ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // ary1
  st->print_raw(",ary2 -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw("    // KILL ");
      st->print_raw("R10");
}
#endif
#ifndef PRODUCT
void array_equalsCNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// ary1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// ary2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp3
  st->print_raw("Array Equals ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // ary1
  st->print_raw(",ary2 -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw("    // KILL ");
      st->print_raw("R10");
}
#endif
#ifndef PRODUCT
void has_negativesNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// ary1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// len
  st->print_raw("has negatives byte[] ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // ary1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // len
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
}
#endif
#ifndef PRODUCT
void string_compressNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// len
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp3
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp4
  st->print_raw("String Compress ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw("    // KILL R1, R2, R3, R4");
}
#endif
#ifndef PRODUCT
void string_inflateNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// len
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp3
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp4
  st->print_raw("String Inflate ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw("    // KILL ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp1
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // tmp2
}
#endif
#ifndef PRODUCT
void encode_iso_arrayNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// len
  st->print_raw("Encode array ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // len
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
}
#endif
#ifndef PRODUCT
void tlsLoadPNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  st->print_raw(" -- \t// ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("=Thread::current(), empty");
}
#endif
#ifndef PRODUCT
void loadV2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrh   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# vector (16 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadV4Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrs   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# vector (32 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadV8Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrd   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# vector (64 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadV16Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrq   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# vector (128 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeV2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("strh   ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (16 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeV4Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("strs   ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (32 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeV8Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("strd   ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (64 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeV16Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("strq   ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (128 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void reinterpretDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  st->print_raw(" # reinterpret ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
}
#endif
#ifndef PRODUCT
void reinterpretXNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  st->print_raw(" # reinterpret ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
}
#endif
#ifndef PRODUCT
void reinterpretD2XNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw(" # reinterpret ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# D to X");
}
#endif
#ifndef PRODUCT
void reinterpretX2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw(" # reinterpret ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# X to D");
}
#endif
#ifndef PRODUCT
void reinterpretS2XNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw(" # reinterpret ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# S to X");
}
#endif
#ifndef PRODUCT
void reinterpretX2SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw(" # reinterpret ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# X to S");
}
#endif
#ifndef PRODUCT
void reinterpretS2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw(" # reinterpret ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# S to D");
}
#endif
#ifndef PRODUCT
void reinterpretD2SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw(" # reinterpret ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# D to S");
}
#endif
#ifndef PRODUCT
void vcvt8Bto8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8B\t# convert 8B to 8S vector");
}
#endif
#ifndef PRODUCT
void vcvt4Bto4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8B\t# convert 4B to 4S vector");
}
#endif
#ifndef PRODUCT
void vcvt8Sto8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("xtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8H\t# convert 8S to 8B vector");
}
#endif
#ifndef PRODUCT
void vcvt4Sto4BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("xtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8H\t# convert 4S to 4B vector");
}
#endif
#ifndef PRODUCT
void vcvt4Sto4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T4H\t# convert 4S to 4I vector");
}
#endif
#ifndef PRODUCT
void vcvt4Ito4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("xtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T4S\t# convert 4I to 4S vector");
}
#endif
#ifndef PRODUCT
void vcvt2Ito2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2D, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T2S\t# convert 2I to 2L vector");
}
#endif
#ifndef PRODUCT
void vcvt2Lto2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("xtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T2D\t# convert 2L to 2I vector");
}
#endif
#ifndef PRODUCT
void vcvt4Ito4BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("xtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T4S\n\t");
  st->print_raw("xtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H\t# convert 4I to 4B vector");
}
#endif
#ifndef PRODUCT
void vcvt4Bto4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8B\n\t");
  st->print_raw("sxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H\t# convert 4B to 4I vector");
}
#endif
#ifndef PRODUCT
void vcvt2Lto2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("scvtfv  T2D, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("fcvtn   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2S, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2D\t# convert 2L to 2F vector");
}
#endif
#ifndef PRODUCT
void vcvt2Ito2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("scvtfv  T2S, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert 2I to 2F vector");
}
#endif
#ifndef PRODUCT
void vcvt4Ito4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("scvtfv  T4S, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert 4I to 4F vector");
}
#endif
#ifndef PRODUCT
void vcvt2Lto2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("scvtfv  T2D, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert 2L to 2D vector");
}
#endif
#ifndef PRODUCT
void vcvt4Sto4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sxtl    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T4H\n\t");
  st->print_raw("scvtfv  T4S, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# convert 4S to 4F vector");
}
#endif
#ifndef PRODUCT
void vcvt2Ito2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sxtl    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2D, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T2S\n\t");
  st->print_raw("scvtfv  T2D, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# convert 2I to 2D vector");
}
#endif
#ifndef PRODUCT
void vcvt4Bto4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sxtl    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8B\n\t");
  st->print_raw("sxtl    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H\n\t");
  st->print_raw("scvtfv  T4S, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# convert 4B to 4F vector");
}
#endif
#ifndef PRODUCT
void vcvt2Fto2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fcvtl   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2D, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T2S\n\t");
  st->print_raw("fcvtzs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2D, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# convert 2F to 2L vector");
}
#endif
#ifndef PRODUCT
void vcvt2Fto2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fcvtzs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert 2F to 2I vector");
}
#endif
#ifndef PRODUCT
void vcvt4Fto4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fcvtzs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert 4F to 4I vector");
}
#endif
#ifndef PRODUCT
void vcvt2Dto2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fcvtzs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2D, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert 2D to 2L vector");
}
#endif
#ifndef PRODUCT
void vcvt4Fto4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fcvtzs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("xtn     ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S\t# convert 4F to 4S vector");
}
#endif
#ifndef PRODUCT
void vcvt2Dto2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  st->print_raw("ins      ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw(", D, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", 0, 1\n\t");
  st->print_raw("fcvtzdw  rscratch1, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("fcvtzdw  rscratch2, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw("\n\t");
  st->print_raw("fmovs    ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw(", rscratch1\n\t");
  st->print_raw("mov      ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw(", T2S, 1, rscratch2\t#convert 2D to 2I vector");
}
#endif
#ifndef PRODUCT
void vcvt4Fto4BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fcvtzs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("xtn     ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S\n\t");
  st->print_raw("xtn     ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H\t# convert 4F to 4B vector");
}
#endif
#ifndef PRODUCT
void vcvt2Fto2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fcvtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2D, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T2S\t# convert 2F to 2D vector");
}
#endif
#ifndef PRODUCT
void vcvt2Dto2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fcvtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T2D\t# convert 2D to 2F vector");
}
#endif
#ifndef PRODUCT
void reduce_add8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("addv  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T8B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("smov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", B, 0\n\t");
  st->print_raw("addw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("sxtb  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# add reduction8B");
}
#endif
#ifndef PRODUCT
void reduce_add16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("addv  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T16B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("smov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", B, 0\n\t");
  st->print_raw("addw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("sxtb  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# add reduction16B");
}
#endif
#ifndef PRODUCT
void reduce_add4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("addv  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T4H, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("smov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", H, 0\n\t");
  st->print_raw("addw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("sxth  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# add reduction4S");
}
#endif
#ifndef PRODUCT
void reduce_add8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("addv  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T8H, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("smov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", H, 0\n\t");
  st->print_raw("addw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("sxth  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# add reduction8S");
}
#endif
#ifndef PRODUCT
void reduce_add2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("addpd ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", D, 0\n\t");
  st->print_raw("add   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# add reduction2L");
}
#endif
#ifndef PRODUCT
void reduce_mul8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// itmp
  st->print_raw("ins   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw(", S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", 0, 1\n\t");
  st->print_raw("mulv  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw(", T8B, ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("ins   ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", H, ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw(", 0, 1\n\t");
  st->print_raw("mulv  ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", T8B, ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // itmp
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", B, 0\n\t");
  st->print_raw("mulw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // itmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("sxtb  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // itmp
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", B, 1\n\t");
  st->print_raw("mulw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // itmp
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxtb  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# mul reduction8B");
}
#endif
#ifndef PRODUCT
void reduce_mul16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// itmp
  st->print_raw("ins   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw(", D, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", 0, 1\n\t");
  st->print_raw("mulv  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw(", T8B, ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("ins   ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", S, ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw(", 0, 1\n\t");
  st->print_raw("mulv  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw(", T8B, ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw("\n\t");
  st->print_raw("ins   ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", H, ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw(", 0, 1\n\t");
  st->print_raw("mulv  ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", T8B, ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // itmp
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", B, 0\n\t");
  st->print_raw("mulw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // itmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("sxtb  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // itmp
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", B, 1\n\t");
  st->print_raw("mulw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // itmp
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxtb  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# mul reduction16B");
}
#endif
#ifndef PRODUCT
void reduce_mul4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// itmp
  st->print_raw("ins   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp
  st->print_raw(", S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", 0, 1\n\t");
  st->print_raw("mulv  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp
  st->print_raw(", T4H, ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // itmp
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp
  st->print_raw(", H, 0\n\t");
  st->print_raw("mulw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // itmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("sxth  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // itmp
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp
  st->print_raw(", H, 1\n\t");
  st->print_raw("mulw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // itmp
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxth  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# mul reduction4S");
}
#endif
#ifndef PRODUCT
void reduce_mul8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// itmp
  st->print_raw("ins   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw(", D, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", 0, 1\n\t");
  st->print_raw("mulv  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw(", T4H, ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("ins   ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", S, ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw(", 0, 1\n\t");
  st->print_raw("mulv  ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", T4H, ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp1
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // itmp
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", H, 0\n\t");
  st->print_raw("mulw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // itmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("sxth  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // itmp
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // vtmp2
  st->print_raw(", H, 1\n\t");
  st->print_raw("mulw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // itmp
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxth  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# mul reduction8S");
}
#endif
#ifndef PRODUCT
void reduce_mul2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 0\n\t");
  st->print_raw("mul   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 1\n\t");
  st->print_raw("mul   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\t# mul reduction2L");
}
#endif
#ifndef PRODUCT
void reduce_max8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("smaxv ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T8B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("smov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", B, 0\n\t");
  st->print_raw("cmpw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("cselw ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(" GT\t# max reduction8B");
}
#endif
#ifndef PRODUCT
void reduce_max16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("smaxv ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T16B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("smov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", B, 0\n\t");
  st->print_raw("cmpw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("cselw ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(" GT\t# max reduction16B");
}
#endif
#ifndef PRODUCT
void reduce_max4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("smaxv ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T4H, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("smov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", H, 0\n\t");
  st->print_raw("cmpw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("cselw ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(" GT\t# max reduction4S");
}
#endif
#ifndef PRODUCT
void reduce_max8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("smaxv ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T8H, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("smov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", H, 0\n\t");
  st->print_raw("cmpw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("cselw ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(" GT\t# max reduction8S");
}
#endif
#ifndef PRODUCT
void reduce_max4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("smaxv ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T4S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", S, 0\n\t");
  st->print_raw("cmpw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("cselw ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(" GT\t# max reduction4I");
}
#endif
#ifndef PRODUCT
void reduce_min8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sminv ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T8B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("smov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", B, 0\n\t");
  st->print_raw("cmpw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("cselw ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(" LT\t# min reduction8B");
}
#endif
#ifndef PRODUCT
void reduce_min16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sminv ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T16B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("smov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", B, 0\n\t");
  st->print_raw("cmpw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("cselw ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(" LT\t# min reduction16B");
}
#endif
#ifndef PRODUCT
void reduce_min4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sminv ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T4H, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("smov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", H, 0\n\t");
  st->print_raw("cmpw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("cselw ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(" LT\t# min reduction4S");
}
#endif
#ifndef PRODUCT
void reduce_min8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sminv ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T8H, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("smov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", H, 0\n\t");
  st->print_raw("cmpw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("cselw ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(" LT\t# min reduction8S");
}
#endif
#ifndef PRODUCT
void reduce_min4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sminv ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T4S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", S, 0\n\t");
  st->print_raw("cmpw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("cselw ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(" LT\t# min reduction4I");
}
#endif
#ifndef PRODUCT
void reduce_max2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("smaxp ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T2S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", S, 0\n\t");
  st->print_raw("cmpw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("cselw ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(" GT\t# max reduction2I");
}
#endif
#ifndef PRODUCT
void reduce_min2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sminp ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", T2S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", S, 0\n\t");
  st->print_raw("cmpw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("cselw ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(" LT\t# min reduction2I");
}
#endif
#ifndef PRODUCT
void reduce_max2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 0\n\t");
  st->print_raw("cmp   ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("csel  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(" GT\n\t");
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 1\n\t");
  st->print_raw("cmp   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("csel  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(" GT\t# max reduction2L");
}
#endif
#ifndef PRODUCT
void reduce_min2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 0\n\t");
  st->print_raw("cmp   ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("csel  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(" LT\n\t");
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 1\n\t");
  st->print_raw("cmp   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("csel  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(" LT\t# min reduction2L");
}
#endif
#ifndef PRODUCT
void reduce_max2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// fsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("fmaxp ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S\n\t");
  st->print_raw("fmaxs ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // fsrc
  st->print_raw("\t# max reduction2F");
}
#endif
#ifndef PRODUCT
void reduce_max4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// fsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("fmaxv ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(",  T4S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("fmaxs ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // fsrc
  st->print_raw("\t# max reduction4F");
}
#endif
#ifndef PRODUCT
void reduce_max2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("fmaxp ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D\n\t");
  st->print_raw("fmaxd ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dsrc
  st->print_raw("\t# max reduction2D");
}
#endif
#ifndef PRODUCT
void reduce_min2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// fsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("fminp ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S\n\t");
  st->print_raw("fmins ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // fsrc
  st->print_raw("\t# min reduction2F");
}
#endif
#ifndef PRODUCT
void reduce_min4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// fsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("fminv ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(",  T4S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("fmins ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // fsrc
  st->print_raw("\t# min reduction4F");
}
#endif
#ifndef PRODUCT
void reduce_min2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("fminp ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D\n\t");
  st->print_raw("fmind ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dsrc
  st->print_raw("\t# min reduction2D");
}
#endif
#ifndef PRODUCT
void reduce_and8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 1\n\t");
  st->print_raw("andw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("andw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #16\n\t");
  st->print_raw("andw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #8\n\t");
  st->print_raw("andw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxtb   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# and reduction8B");
}
#endif
#ifndef PRODUCT
void reduce_orr8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 1\n\t");
  st->print_raw("orrw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("orrw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #16\n\t");
  st->print_raw("orrw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #8\n\t");
  st->print_raw("orrw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxtb   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# orr reduction8B");
}
#endif
#ifndef PRODUCT
void reduce_eor8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 1\n\t");
  st->print_raw("eorw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("eorw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #16\n\t");
  st->print_raw("eorw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #8\n\t");
  st->print_raw("eorw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxtb   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# eor reduction8B");
}
#endif
#ifndef PRODUCT
void reduce_and16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 1\n\t");
  st->print_raw("andr   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("andr   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #32\n\t");
  st->print_raw("andw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #16\n\t");
  st->print_raw("andw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #8\n\t");
  st->print_raw("andw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxtb   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# and reduction16B");
}
#endif
#ifndef PRODUCT
void reduce_orr16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 1\n\t");
  st->print_raw("orr    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("orr    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #32\n\t");
  st->print_raw("orrw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #16\n\t");
  st->print_raw("orrw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #8\n\t");
  st->print_raw("orrw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxtb   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# orr reduction16B");
}
#endif
#ifndef PRODUCT
void reduce_eor16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 1\n\t");
  st->print_raw("eor    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("eor    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #32\n\t");
  st->print_raw("eorw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #16\n\t");
  st->print_raw("eorw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #8\n\t");
  st->print_raw("eorw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxtb   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# eor reduction16B");
}
#endif
#ifndef PRODUCT
void reduce_and4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 1\n\t");
  st->print_raw("andw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("andw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #16\n\t");
  st->print_raw("andw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxth   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# and reduction4S");
}
#endif
#ifndef PRODUCT
void reduce_orr4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 1\n\t");
  st->print_raw("orrw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("orrw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #16\n\t");
  st->print_raw("orrw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxth   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# orr reduction4S");
}
#endif
#ifndef PRODUCT
void reduce_eor4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 1\n\t");
  st->print_raw("eorw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("eorw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #16\n\t");
  st->print_raw("eorw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxth   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# eor reduction4S");
}
#endif
#ifndef PRODUCT
void reduce_and8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 1\n\t");
  st->print_raw("andr   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("andr   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #32\n\t");
  st->print_raw("andw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #16\n\t");
  st->print_raw("andw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxth   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# and reduction8S");
}
#endif
#ifndef PRODUCT
void reduce_orr8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 1\n\t");
  st->print_raw("orr    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("orr    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #32\n\t");
  st->print_raw("orrw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #16\n\t");
  st->print_raw("orrw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxth   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# orr reduction8S");
}
#endif
#ifndef PRODUCT
void reduce_eor8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 1\n\t");
  st->print_raw("eor    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("eor    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #32\n\t");
  st->print_raw("eorw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #16\n\t");
  st->print_raw("eorw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sxth   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# eor reduction8S");
}
#endif
#ifndef PRODUCT
void reduce_and2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 0\n\t");
  st->print_raw("andw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 1\n\t");
  st->print_raw("andw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# and reduction2I");
}
#endif
#ifndef PRODUCT
void reduce_orr2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 0\n\t");
  st->print_raw("orrw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 1\n\t");
  st->print_raw("orrw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# orr reduction2I");
}
#endif
#ifndef PRODUCT
void reduce_eor2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 0\n\t");
  st->print_raw("eorw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 1\n\t");
  st->print_raw("eorw  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# eor reduction2I");
}
#endif
#ifndef PRODUCT
void reduce_and4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 1\n\t");
  st->print_raw("andr   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("andr   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #32\n\t");
  st->print_raw("andw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# and reduction4I");
}
#endif
#ifndef PRODUCT
void reduce_orr4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 1\n\t");
  st->print_raw("orr    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("orr    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #32\n\t");
  st->print_raw("orrw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# orr reduction4I");
}
#endif
#ifndef PRODUCT
void reduce_eor4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 1\n\t");
  st->print_raw("eor    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("eor    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", LSR #32\n\t");
  st->print_raw("eorw   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# eor reduction4I");
}
#endif
#ifndef PRODUCT
void reduce_and2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 0\n\t");
  st->print_raw("andr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 1\n\t");
  st->print_raw("andr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\t# and reduction2L");
}
#endif
#ifndef PRODUCT
void reduce_orr2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 0\n\t");
  st->print_raw("orr   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 1\n\t");
  st->print_raw("orr   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\t# orr reduction2L");
}
#endif
#ifndef PRODUCT
void reduce_eor2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 0\n\t");
  st->print_raw("eor   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", D, 1\n\t");
  st->print_raw("eor   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\t# eor reduction2L");
}
#endif
#ifndef PRODUCT
void insert8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  st->print_raw("orr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("mov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw("\t# insert into vector(8B)");
}
#endif
#ifndef PRODUCT
void insert16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  st->print_raw("orr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("mov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw("\t# insert into vector(16B)");
}
#endif
#ifndef PRODUCT
void insert4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  st->print_raw("orr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("mov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw("\t# insert into vector(4S)");
}
#endif
#ifndef PRODUCT
void insert8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  st->print_raw("orr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("mov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw("\t# insert into vector(8S)");
}
#endif
#ifndef PRODUCT
void insert2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  st->print_raw("orr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("mov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2S, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw("\t# insert into vector(2I)");
}
#endif
#ifndef PRODUCT
void insert4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  st->print_raw("orr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("mov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw("\t# insert into vector(4I)");
}
#endif
#ifndef PRODUCT
void insert2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  st->print_raw("orr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("mov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2D, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw("\t# insert into vector(2L)");
}
#endif
#ifndef PRODUCT
void insert2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  st->print_raw("orr    ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("ins    ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", 0\t# insert into vector(2F)");
}
#endif
#ifndef PRODUCT
void insert4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  st->print_raw("orr    ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("ins    ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", 0\t# insert into vector(4F)");
}
#endif
#ifndef PRODUCT
void insert2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  st->print_raw("orr    ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("ins    ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", D, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", 0\t# insert into vector(2D)");
}
#endif
#ifndef PRODUCT
void extract8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  st->print_raw("smov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# extract from vector(8B)");
}
#endif
#ifndef PRODUCT
void extract16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  st->print_raw("smov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# extract from vector(16B)");
}
#endif
#ifndef PRODUCT
void extract4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  st->print_raw("smov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", H, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# extract from vector(4S)");
}
#endif
#ifndef PRODUCT
void extract8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  st->print_raw("smov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", H, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# extract from vector(8S)");
}
#endif
#ifndef PRODUCT
void extract2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  st->print_raw("umov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# extract from vector(2I)");
}
#endif
#ifndef PRODUCT
void extract4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  st->print_raw("umov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# extract from vector(4I)");
}
#endif
#ifndef PRODUCT
void extract2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  st->print_raw("umov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", D, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# extract from vector(2L)");
}
#endif
#ifndef PRODUCT
void extract2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  st->print_raw("ins   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", 0, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# extract from vector(2F)");
}
#endif
#ifndef PRODUCT
void extract4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  st->print_raw("ins   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", 0, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# extract from vector(4F)");
}
#endif
#ifndef PRODUCT
void extract2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  st->print_raw("ins   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", D, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", 0, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# extract from vector(2D)");
}
#endif
#ifndef PRODUCT
void vcmpDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cond
  st->print_raw("vcmpD  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector compare ");
}
#endif
#ifndef PRODUCT
void vcmpXNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cond
  st->print_raw("vcmpX  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector compare ");
}
#endif
#ifndef PRODUCT
void vmul2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", D, 0\n\t");
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp2
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", D, 0\n\t");
  st->print_raw("mul    ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp2
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp1
  st->print_raw("\n\t");
  st->print_raw("mov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",  T2D,   0, ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp2
  st->print_raw("\t# insert into vector(2L)\n\t");
  st->print_raw("umov   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", D, 1\n\t");
  st->print_raw("umov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp2
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", D, 1\n\t");
  st->print_raw("mul    ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp2
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp1
  st->print_raw("\n\t");
  st->print_raw("mov    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",  T2D,   1, ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp2
  st->print_raw("\t# insert into vector(2L)");
}
#endif
#ifndef PRODUCT
void vnot2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  st->print_raw("not  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vnot2I_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("not  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vnot2I_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  st->print_raw("not  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vnot2I_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("not  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vnot2I_3Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  st->print_raw("not  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vnot2I_4Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("not  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vnot4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  st->print_raw("not  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vnot4I_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("not  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vnot4I_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  st->print_raw("not  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vnot4I_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("not  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vnot4I_3Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  st->print_raw("not  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vnot4I_4Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("not  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vnot2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  st->print_raw("not  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vnot2L_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("not  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vand_not2I_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vand_not2I_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vand_not2I_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vand_not2I_3Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vand_not2I_5Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vand_not2I_4Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vand_not2I_6Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vand_not2I_7Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vand_not2I_9Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vand_not2I_8Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vand_not2I_10Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vand_not4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not4I_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not4I_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not4I_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not4I_3Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not4I_5Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not4I_4Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not4I_6Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not4I_7Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not4I_9Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not4I_8Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not4I_10Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not2L_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not2L_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vand_not2L_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("bic  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vmax8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("maxv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vmax16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("maxv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vmax4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("maxv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vmax8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("maxv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8S)");
}
#endif
#ifndef PRODUCT
void vmax2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("maxv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2I)");
}
#endif
#ifndef PRODUCT
void vmax4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("maxv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4I)");
}
#endif
#ifndef PRODUCT
void vmin8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("minv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vmin16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("minv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vmin4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("minv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vmin8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("minv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8S)");
}
#endif
#ifndef PRODUCT
void vmin2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("minv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2I)");
}
#endif
#ifndef PRODUCT
void vmin4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("minv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4I)");
}
#endif
#ifndef PRODUCT
void vmax2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("cmgt  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T2D, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2L)\n\t");
  st->print_raw("bsl   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vmin2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("cmgt  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T2D, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2L)\n\t");
  st->print_raw("bsl   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vbsl8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("bsl  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vbsl16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("bsl  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void loadmask8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("negr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# load mask (8B to 8B)");
}
#endif
#ifndef PRODUCT
void loadmask16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("negr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# load mask (16B to 16B)");
}
#endif
#ifndef PRODUCT
void storemask8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// size
  st->print_raw("negr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# store mask (8B to 8B)");
}
#endif
#ifndef PRODUCT
void storemask16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// size
  st->print_raw("negr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# store mask (16B to 16B)");
}
#endif
#ifndef PRODUCT
void loadmask4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("uxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8B\n\t");
  st->print_raw("negr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# load mask (4B to 4H)");
}
#endif
#ifndef PRODUCT
void loadmask8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("uxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8B\n\t");
  st->print_raw("negr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# load mask (8B to 8H)");
}
#endif
#ifndef PRODUCT
void storemask4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// size
  st->print_raw("xtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8H\n\t");
  st->print_raw("negr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# store mask (4H to 4B)");
}
#endif
#ifndef PRODUCT
void storemask8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// size
  st->print_raw("xtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8H\n\t");
  st->print_raw("negr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# store mask (8H to 8B)");
}
#endif
#ifndef PRODUCT
void loadmask2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("uxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8B\t# 2B to 2H\n\t");
  st->print_raw("uxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H\t# 2H to 2S\n\t");
  st->print_raw("negr   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# load mask (2B to 2S)");
}
#endif
#ifndef PRODUCT
void loadmask4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("uxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8B\t# 4B to 4H\n\t");
  st->print_raw("uxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H\t# 4H to 4S\n\t");
  st->print_raw("negr   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# load mask (4B to 4S)");
}
#endif
#ifndef PRODUCT
void storemask2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// size
  st->print_raw("xtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T4S\t# 2S to 2H\n\t");
  st->print_raw("xtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H\t# 2H to 2B\n\t");
  st->print_raw("negr   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# store mask (2S to 2B)");
}
#endif
#ifndef PRODUCT
void storemask4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// size
  st->print_raw("xtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T4S\t# 4S to 4H\n\t");
  st->print_raw("xtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H\t# 4H to 4B\n\t");
  st->print_raw("negr   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# store mask (4S to 4B)");
}
#endif
#ifndef PRODUCT
void loadmask2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("uxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8B\t# 2B to 2S\n\t");
  st->print_raw("uxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H\t# 2S to 2I\n\t");
  st->print_raw("uxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2D, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2S\t# 2I to 2L\n\t");
  st->print_raw("neg   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2D, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# load mask (2B to 2L)");
}
#endif
#ifndef PRODUCT
void storemask2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// size
  st->print_raw("xtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T2D\t# 2L to 2I\n\t");
  st->print_raw("xtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S\t# 2I to 2S\n\t");
  st->print_raw("xtn  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H\t# 2S to 2B\n\t");
  st->print_raw("neg  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# store mask (2L to 2B)");
}
#endif
#ifndef PRODUCT
void vmaskcastDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  st->print_raw("vmaskcast ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw("\t# empty");
}
#endif
#ifndef PRODUCT
void vmaskcastXNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  st->print_raw("vmaskcast ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw("\t# empty");
}
#endif
#ifndef PRODUCT
void loadcon8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("ldr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", CONSTANT_MEMORY\t# load iota indices");
}
#endif
#ifndef PRODUCT
void loadcon16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("ldr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", CONSTANT_MEMORY\t# load iota indices");
}
#endif
#ifndef PRODUCT
void loadshuffle8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("mov  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# get 8B shuffle");
}
#endif
#ifndef PRODUCT
void loadshuffle16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("mov  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# get 16B shuffle");
}
#endif
#ifndef PRODUCT
void loadshuffle4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("uxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8B\t# 4B to 4H");
}
#endif
#ifndef PRODUCT
void loadshuffle8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("uxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8B\t# 8B to 8H");
}
#endif
#ifndef PRODUCT
void loadshuffle4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("uxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", T8B\t# 4B to 4H \n\t");
  st->print_raw("uxtl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H\t# 4H to 4S");
}
#endif
#ifndef PRODUCT
void rearrange8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shuffle
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("tbl ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T8B, {");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("}, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shuffle
  st->print_raw("\t# rearrange 8B");
}
#endif
#ifndef PRODUCT
void rearrange16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shuffle
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("tbl ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T16B, {");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("}, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shuffle
  st->print_raw("\t# rearrange 16B");
}
#endif
#ifndef PRODUCT
void rearrange4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shuffle
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp0
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  st->print_raw("mov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp0
  st->print_raw(", T8B, CONSTANT\t# constant 0x0202020202020202\n\t");
  st->print_raw("mov   ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // tmp1
  st->print_raw(", T4H, CONSTANT\t# constant 0x0100010001000100\n\t");
  st->print_raw("mulv  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T4H, T4H, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shuffle
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp0
  st->print_raw("\n\t");
  st->print_raw("addv  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T8B, T8B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // tmp1
  st->print_raw("\n\t");
  st->print_raw("tbl   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T8B, {");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("}, 1, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# rearrange 4S");
}
#endif
#ifndef PRODUCT
void rearrange8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shuffle
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp0
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  st->print_raw("mov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp0
  st->print_raw(", T16B, CONSTANT\t# constant 0x0202020202020202\n\t");
  st->print_raw("mov   ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // tmp1
  st->print_raw(", T8H, CONSTANT\t# constant 0x0100010001000100\n\t");
  st->print_raw("mulv  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T8H, T8H, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shuffle
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp0
  st->print_raw("\n\t");
  st->print_raw("addv  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T16B, T16B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // tmp1
  st->print_raw("\n\t");
  st->print_raw("tbl   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T16B, {");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("}, 1, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# rearrange 8S");
}
#endif
#ifndef PRODUCT
void rearrange4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shuffle
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp0
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  st->print_raw("mov   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp0
  st->print_raw(", T16B, CONSTANT\t# constant 0x0404040404040404\n\t");
  st->print_raw("mov   ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // tmp1
  st->print_raw(", T4S, CONSTANT\t# constant 0x0302010003020100\n\t");
  st->print_raw("mulv  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shuffle
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp0
  st->print_raw("\n\t");
  st->print_raw("addv  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // tmp1
  st->print_raw("\n\t");
  st->print_raw("tbl   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", T16B, {");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("}, 1, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# rearrange 4I");
}
#endif
#ifndef PRODUCT
void anytrue_in_mask8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("addv  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(", B, 0\n\t");
  st->print_raw("cmp   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", 0\n\t");
  st->print_raw("cset  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# anytrue 8B");
}
#endif
#ifndef PRODUCT
void anytrue_in_mask16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("addv  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(", B, 0\n\t");
  st->print_raw("cmp   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", 0\n\t");
  st->print_raw("cset  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# anytrue 16B");
}
#endif
#ifndef PRODUCT
void alltrue_in_mask8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("uminv ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(", B, 0\n\t");
  st->print_raw("cmp   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", 0xff\n\t");
  st->print_raw("cset  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# alltrue 8B");
}
#endif
#ifndef PRODUCT
void alltrue_in_mask16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("uminv ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(", B, 0\n\t");
  st->print_raw("cmp   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", 0xff\n\t");
  st->print_raw("cset  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# alltrue 16B");
}
#endif
#ifndef PRODUCT
void vabs8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("abs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vabs16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("abs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T16B, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vabs4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("abs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vabs8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("abs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T8H, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vabs2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("abs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vabs4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("abs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vabs2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("abs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2D, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vabs2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fabs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vabs4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fabs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vabs2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fabs  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2D, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vabd2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fabd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vabd4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fabd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T4S, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vabd2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fabd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", T2D, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void replicate8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void replicate16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void replicate8B_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("movi  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void replicate16B_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("movi  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void replicate4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void replicate8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (8S)");
}
#endif
#ifndef PRODUCT
void replicate4S_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("movi  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void replicate8S_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("movi  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void replicate2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (2I)");
}
#endif
#ifndef PRODUCT
void replicate4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (4I)");
}
#endif
#ifndef PRODUCT
void replicate2I_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("movi  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# vector (2I)");
}
#endif
#ifndef PRODUCT
void replicate4I_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("movi  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# vector (4I)");
}
#endif
#ifndef PRODUCT
void replicate2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (2L)");
}
#endif
#ifndef PRODUCT
void replicate2L_zeroNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  st->print_raw("movi  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // zero
  st->print_raw("\t# vector (4I)");
}
#endif
#ifndef PRODUCT
void replicate2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (2F)");
}
#endif
#ifndef PRODUCT
void replicate4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (4F)");
}
#endif
#ifndef PRODUCT
void replicate2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void reduce_add2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// vtmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// itmp
  st->print_raw("addpv  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // vtmp
  st->print_raw(", T2S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // itmp
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // vtmp
  st->print_raw(", S, 0\n\t");
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // itmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\t# add reduction2I");
}
#endif
#ifndef PRODUCT
void reduce_add4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// vtmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// itmp
  st->print_raw("addv  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // vtmp
  st->print_raw(", T4S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // itmp
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // vtmp
  st->print_raw(", S, 0\n\t");
  st->print_raw("addw  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // itmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\t# add reduction4I");
}
#endif
#ifndef PRODUCT
void reduce_mul2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 0\n\t");
  st->print_raw("mul   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", S, 1\n\t");
  st->print_raw("mul   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# mul reduction2I");
}
#endif
#ifndef PRODUCT
void reduce_mul4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// isrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// itmp
  st->print_raw("ins   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp
  st->print_raw(", D, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", 0, 1\n\t");
  st->print_raw("mulv  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp
  st->print_raw(", T2S, ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // itmp
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp
  st->print_raw(", S, 0\n\t");
  st->print_raw("mul   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // itmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // isrc
  st->print_raw("\n\t");
  st->print_raw("umov  ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // itmp
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // vtmp
  st->print_raw(", S, 1\n\t");
  st->print_raw("mul   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // itmp
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# mul reduction4I");
}
#endif
#ifndef PRODUCT
void reduce_add2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// fsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("fadds ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // fsrc
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("ins   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", 0, 1\n\t");
  st->print_raw("fadds ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\t# add reduction2F");
}
#endif
#ifndef PRODUCT
void reduce_add4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// fsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("fadds ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // fsrc
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("ins   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", 0, 1\n\t");
  st->print_raw("fadds ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("ins   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", 0, 2\n\t");
  st->print_raw("fadds ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("ins   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", 0, 3\n\t");
  st->print_raw("fadds ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\t# add reduction4F");
}
#endif
#ifndef PRODUCT
void reduce_mul2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// fsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("fmuls ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // fsrc
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("ins   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", 0, 1\n\t");
  st->print_raw("fmuls ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\t# mul reduction2F");
}
#endif
#ifndef PRODUCT
void reduce_mul4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// fsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("fmuls ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // fsrc
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("ins   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", 0, 1\n\t");
  st->print_raw("fmuls ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("ins   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", 0, 2\n\t");
  st->print_raw("fmuls ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\n\t");
  st->print_raw("ins   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", 0, 3\n\t");
  st->print_raw("fmuls ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\t# mul reduction4F");
}
#endif
#ifndef PRODUCT
void reduce_add2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("faddd ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dsrc
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("ins   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", D, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", 0, 1\n\t");
  st->print_raw("faddd ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\t# add reduction2D");
}
#endif
#ifndef PRODUCT
void reduce_mul2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dsrc
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vsrc
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("fmuld ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dsrc
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw("\n\t");
  st->print_raw("ins   ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", D, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // vsrc
  st->print_raw(", 0, 1\n\t");
  st->print_raw("fmuld ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw("\t# mul reduction2D");
}
#endif
#ifndef PRODUCT
void vadd8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("addv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vadd16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("addv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vadd4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("addv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vadd8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("addv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vadd2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("addv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vadd4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("addv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vadd2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("addv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2L)");
}
#endif
#ifndef PRODUCT
void vadd2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fadd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vadd4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fadd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vadd2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fadd  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vsub8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("subv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vsub16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("subv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vsub4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("subv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vsub8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("subv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vsub2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("subv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vsub4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("subv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vsub2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("subv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2L)");
}
#endif
#ifndef PRODUCT
void vsub2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fsub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vsub4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fsub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vsub2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fsub  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vmul8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("mulv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vmul16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("mulv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vmul4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("mulv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vmul8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("mulv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vmul2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("mulv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vmul4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("mulv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vmul2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fmul  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vmul4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fmul  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vmul2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fmul  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vmla4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("mlav  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vmla4S_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("mlav  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vmla8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("mlav  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vmla8S_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("mlav  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vmla2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("mlav  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vmla2I_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("mlav  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vmla4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("mlav  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vmla4I_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("mlav  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vmla2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fmla  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vmla4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fmla  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vmla2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fmla  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vmls4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("mlsv  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vmls8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("mlsv  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vmls2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("mlsv  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vmls4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("mlsv  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vmls2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fmls  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vmls2F_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fmls  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vmls4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fmls  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vmls4F_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fmls  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vmls2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fmls  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vmls2D_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("fmls  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vmuladdS2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("smullv  ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4H)\n\t");
  st->print_raw("smullv  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8H)\n\t");
  st->print_raw("addpv   ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vdiv2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fdiv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vdiv4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fdiv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vdiv2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fdiv  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vsqrt2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fsqrt  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (2F)");
}
#endif
#ifndef PRODUCT
void vsqrt4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fsqrt  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (4F)");
}
#endif
#ifndef PRODUCT
void vsqrt2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fsqrt  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vneg2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fneg  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vneg4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fneg  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vneg2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("fneg  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vand8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("and  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vand16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("and  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vor8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("orr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vor16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("orr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vxor8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("xor  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vxor16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("xor  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vshiftcnt8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  st->print_raw("dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cnt
  st->print_raw("\t# shift count vector (8B)");
}
#endif
#ifndef PRODUCT
void vshiftcnt8B_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  st->print_raw("dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cnt
  st->print_raw("\t# shift count vector (8B)");
}
#endif
#ifndef PRODUCT
void vshiftcnt16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  st->print_raw("dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cnt
  st->print_raw("\t# shift count vector (16B)");
}
#endif
#ifndef PRODUCT
void vshiftcnt16B_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  st->print_raw("dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cnt
  st->print_raw("\t# shift count vector (16B)");
}
#endif
#ifndef PRODUCT
void vsll8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sshl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vsll16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sshl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vsra8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("negr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t");
  st->print_raw("sshl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vsra16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("negr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t");
  st->print_raw("sshl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vsrl8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("negr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t");
  st->print_raw("ushl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vsrl16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("negr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t");
  st->print_raw("ushl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vsll8B_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("shl    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vsll16B_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("shl    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vsra8B_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sshr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vsra16B_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sshr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vsrl8B_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("ushr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vsrl16B_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("ushr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vsll4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sshl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vsll8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sshl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vsra4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("negr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t");
  st->print_raw("sshl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vsra8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("negr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t");
  st->print_raw("sshl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vsrl4SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("negr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t");
  st->print_raw("ushl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vsrl8SNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("negr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t");
  st->print_raw("ushl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vsll4S_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("shl    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vsll8S_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("shl    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vsra4S_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sshr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vsra8S_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sshr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vsrl4S_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("ushr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vsrl8S_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("ushr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vsll2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sshl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vsll4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sshl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vsra2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("negr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t");
  st->print_raw("sshl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vsra4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("negr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t");
  st->print_raw("sshl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vsrl2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("negr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t");
  st->print_raw("ushl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vsrl4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("negr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t");
  st->print_raw("ushl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vsll2I_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("shl    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vsll4I_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("shl    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vsra2I_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sshr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vsra4I_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sshr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vsrl2I_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("ushr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vsrl4I_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("ushr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vsll2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sshl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vsra2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("negr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t");
  st->print_raw("sshl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vsrl2LNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("negr  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t");
  st->print_raw("ushl  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // tmp
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vsll2L_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("shl    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vsra2L_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sshr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vsrl2L_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("ushr    ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vsraa8B_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  st->print_raw("ssra    ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // shift
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vsraa8B_imm_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("ssra    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vsraa16B_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  st->print_raw("ssra    ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // shift
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vsraa16B_imm_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("ssra    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vsraa4S_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  st->print_raw("ssra    ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // shift
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vsraa4S_imm_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("ssra    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vsraa8S_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  st->print_raw("ssra    ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // shift
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vsraa8S_imm_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("ssra    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vsraa2I_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  st->print_raw("ssra    ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // shift
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vsraa2I_imm_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("ssra    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vsraa4I_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  st->print_raw("ssra    ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // shift
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vsraa4I_imm_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("ssra    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vsraa2L_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  st->print_raw("ssra    ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // shift
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vsraa2L_imm_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("ssra    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vsrla8B_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  st->print_raw("usra    ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // shift
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vsrla8B_imm_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("usra    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vsrla16B_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  st->print_raw("usra    ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // shift
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vsrla16B_imm_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("usra    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vsrla4S_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  st->print_raw("usra    ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // shift
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vsrla4S_imm_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("usra    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vsrla8S_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  st->print_raw("usra    ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // shift
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vsrla8S_imm_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("usra    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vsrla2I_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  st->print_raw("usra    ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // shift
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vsrla2I_imm_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("usra    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (2S)");
}
#endif
#ifndef PRODUCT
void vsrla4I_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  st->print_raw("usra    ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // shift
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vsrla4I_imm_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("usra    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vsrla2L_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// shift
  st->print_raw("usra    ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // shift
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vsrla2L_imm_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("usra    ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vmax2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fmax  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2F)");
}
#endif
#ifndef PRODUCT
void vmax4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fmax  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vmax2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fmax  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vmin2FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fmin  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2F)");
}
#endif
#ifndef PRODUCT
void vmin4FNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fmin  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (4S)");
}
#endif
#ifndef PRODUCT
void vmin2DNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("fmin  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (2D)");
}
#endif
#ifndef PRODUCT
void vround2D_regNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rmode
  st->print_raw("frint  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // rmode
}
#endif
#ifndef PRODUCT
void vpopcount4INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("cnt     ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (16B)\n\t");
  st->print_raw("uaddlp  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# vector (16B)\n\t");
  st->print_raw("uaddlp  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# vector (8H)");
}
#endif
#ifndef PRODUCT
void vpopcount2INode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("cnt     ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (8B)\n\t");
  st->print_raw("uaddlp  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# vector (8B)\n\t");
  st->print_raw("uaddlp  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# vector (4H)");
}
#endif
#ifndef PRODUCT
void vmask_truecount8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  st->print_raw("addv ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("umov ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", B, 0\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vmask_truecount16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  st->print_raw("addv ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("umov ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", B, 0\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vmask_firsttrue_LT8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("vmask_firsttrue ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (4I/4S/2I)");
}
#endif
#ifndef PRODUCT
void vmask_firsttrue8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("vmask_firsttrue ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vmask_firsttrue16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("vmask_firsttrue ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vmask_lasttrue8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("vmask_lasttrue ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (8B)");
}
#endif
#ifndef PRODUCT
void vmask_lasttrue16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("vmask_lasttrue ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (16B)");
}
#endif
#ifndef PRODUCT
void vmask_tolong8BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("vmask_tolong ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert mask to long (8B)");
}
#endif
#ifndef PRODUCT
void vmask_tolong16BNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("vmask_tolong ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert mask to long (16B)");
}
#endif
#ifndef PRODUCT
void loadVNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("sve_ldr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# vector (sve)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeVNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("sve_str ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (sve)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadV2_vregNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrh   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# vector (16 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeV2_vregNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("strh   ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (16 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadV4_vregNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrs   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# vector (32 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeV4_vregNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("strs   ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (32 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadV8_vregNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrd   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# vector (64 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeV8_vregNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("strd   ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (64 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadV16_vregNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  st->print_raw("ldrq   ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(",");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# vector (128 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeV16_vregNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("strq   ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (128 bits)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadV_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pgtmp
  st->print_raw("sve_whilelo_zr_imm ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pgtmp
  st->print_raw(", vector_length\n\t");
  st->print_raw("sve_ldr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pgtmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# load vector partial");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeV_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pgtmp
  st->print_raw("sve_whilelo_zr_imm ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pgtmp
  st->print_raw(", vector_length\n\t");
  st->print_raw("sve_str ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pgtmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# store vector partial");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadV_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  st->print_raw("sve_ldr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# load vector predicated (sve)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadV_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pgtmp
  st->print_raw("sve_ldr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# load vector predicated partial (sve)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeV_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_str ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# store vector predicated (sve)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeV_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pgtmp
  st->print_raw("sve_str ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# store vector predicated partial (sve)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void vmaskAll_immINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_ptrue/sve_pfalse ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# mask all (sve) (B/H/S)");
}
#endif
#ifndef PRODUCT
void vmaskAllINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  st->print_raw("sve_dup ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("sve_cmpne ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", 0\t# mask all (sve) (B/H/S)");
}
#endif
#ifndef PRODUCT
void vmaskAll_immLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_ptrue/sve_pfalse ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# mask all (sve) (D)");
}
#endif
#ifndef PRODUCT
void vmaskAllLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  st->print_raw("sve_dup ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("sve_cmpne ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", 0\t# mask all (sve) (D)");
}
#endif
#ifndef PRODUCT
void vmask_andNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// pn
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pm
  st->print_raw("sve_and ");
  opnd_array(0)->int_format(ra, this, st); // pd
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // pn
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pm
  st->print_raw("\t# predicate (sve)");
}
#endif
#ifndef PRODUCT
void vmask_orNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// pn
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pm
  st->print_raw("sve_orr ");
  opnd_array(0)->int_format(ra, this, st); // pd
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // pn
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pm
  st->print_raw("\t# predicate (sve)");
}
#endif
#ifndef PRODUCT
void vmask_xorNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// pn
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pm
  st->print_raw("sve_eor ");
  opnd_array(0)->int_format(ra, this, st); // pd
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // pn
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pm
  st->print_raw("\t# predicate (sve)");
}
#endif
#ifndef PRODUCT
void vmask_and_notINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// pn
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pm
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // pd
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // pn
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pm
  st->print_raw("\t# predciate (sve) (B/H/S)");
}
#endif
#ifndef PRODUCT
void vmask_and_notLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// pn
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pm
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // pd
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // pn
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pm
  st->print_raw("\t# predciate (sve) (D)");
}
#endif
#ifndef PRODUCT
void reinterpretNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  st->print_raw("# reinterpret ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw("\t# do nothing");
}
#endif
#ifndef PRODUCT
void reinterpretResizeNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pgtmp
  st->print_raw("reinterpretResize ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve)");
}
#endif
#ifndef PRODUCT
void vmask_reinterpret_same_esizeNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  st->print_raw("# vmask_reinterpret ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw("\t# do nothing");
}
#endif
#ifndef PRODUCT
void vmask_reinterpret_diff_esizeNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  st->print_raw("# vmask_reinterpret ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve)");
}
#endif
#ifndef PRODUCT
void vabsBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_abs ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vabsSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_abs ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vabsINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_abs ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vabsLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_abs ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vabsFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_fabs ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vabsDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_fabs ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vabsB_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  st->print_raw("sve_abs ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vabsS_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  st->print_raw("sve_abs ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vabsI_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  st->print_raw("sve_abs ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vabsL_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  st->print_raw("sve_abs ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vabsF_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  st->print_raw("sve_fabs ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vabsD_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  st->print_raw("sve_fabs ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vaddBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_add ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vaddSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_add ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vaddINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_add ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vaddLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_add ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vaddFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_fadd ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vaddDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_fadd ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vaddB_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_add ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vaddS_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_add ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vaddI_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_add ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vaddL_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_add ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vaddF_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_fadd ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vaddD_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_fadd ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vaddImmBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_add ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vaddImmB_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_add ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vaddImmSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_add ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vaddImmS_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_add ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vaddImmINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_add ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vaddImmI_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_add ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vaddImmLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_add ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vaddImmL_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_add ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vandBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_and ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vandB_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_and ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vandHNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_and ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vandH_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_and ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vandSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_and ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vandS_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_and ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vandDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_and ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vandD_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_and ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vorBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_orr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vorB_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_orr ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vorHNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_orr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vorH_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_orr ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vorSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_orr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vorS_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_orr ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vorDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_orr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vorD_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_orr ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vxorBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_eor ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vxorB_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_eor ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vxorHNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_eor ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vxorH_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_eor ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vxorSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_eor ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vxorS_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_eor ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vxorDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  st->print_raw("sve_eor ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // con
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vxorD_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst_src
  st->print_raw("sve_eor ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst_src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vandNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_and  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve)");
}
#endif
#ifndef PRODUCT
void vorNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_orr  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve)");
}
#endif
#ifndef PRODUCT
void vxorNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_eor  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve)");
}
#endif
#ifndef PRODUCT
void vand_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_and ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve)");
}
#endif
#ifndef PRODUCT
void vor_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_orr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve)");
}
#endif
#ifndef PRODUCT
void vxor_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_eor ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve)");
}
#endif
#ifndef PRODUCT
void vnotINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  st->print_raw("sve_not ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vnotI_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("sve_not ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vnotI_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  st->print_raw("sve_not ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vnotI_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("sve_not ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vnotI_3Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  st->print_raw("sve_not ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vnotI_4Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("sve_not ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vnotLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  st->print_raw("sve_not ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) D");
}
#endif
#ifndef PRODUCT
void vnotL_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  st->print_raw("sve_not ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector (sve) D");
}
#endif
#ifndef PRODUCT
void vand_notINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vand_notI_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vand_notI_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vand_notI_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vand_notI_3Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vand_notI_5Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vand_notI_4Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vand_notI_6Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vand_notI_7Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vand_notI_9Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vand_notI_8Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vand_notI_10Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) B/H/S");
}
#endif
#ifndef PRODUCT
void vand_notLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// m1
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) D");
}
#endif
#ifndef PRODUCT
void vand_notL_1Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src2
  st->print_raw("\t# vector (sve) D");
}
#endif
#ifndef PRODUCT
void vand_notL_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// m1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src2
  st->print_raw("\t# vector (sve) D");
}
#endif
#ifndef PRODUCT
void vand_notL_2Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// m1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  st->print_raw("sve_bic ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) D");
}
#endif
#ifndef PRODUCT
void vdivFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_fdiv  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vdivDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_fdiv  ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vfdivF_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_fdiv ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vfdivD_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_fdiv ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vminNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_min ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve)");
}
#endif
#ifndef PRODUCT
void vmaxNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_max ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve)");
}
#endif
#ifndef PRODUCT
void vmin_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_min ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve)");
}
#endif
#ifndef PRODUCT
void vmax_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_max ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve)");
}
#endif
#ifndef PRODUCT
void vfmlaFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_fmla ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vfmlaDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_fmla ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vfmlaF_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  st->print_raw("sve_fmad ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vfmlaD_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  st->print_raw("sve_fmad ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vfmlsFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_fmls ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vfmlsF_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_fmls ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vfmlsDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_fmls ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vfmlsD_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_fmls ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vfnmlaFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_fnmla ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vfnmlaF_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_fnmla ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vfnmlaDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_fnmla ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vfnmlaD_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_fnmla ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vfnmlsFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_fnmls ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vfnmlsDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_fnmls ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // src3
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vmlaBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_mla ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", src2, src3\t # vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vmlaB_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst_src1
  st->print_raw("sve_mla ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst_src1
  st->print_raw(", src2, src3\t # vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vmlaSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_mla ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", src2, src3\t # vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vmlaS_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst_src1
  st->print_raw("sve_mla ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst_src1
  st->print_raw(", src2, src3\t # vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vmlaINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_mla ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", src2, src3\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vmlaI_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst_src1
  st->print_raw("sve_mla ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst_src1
  st->print_raw(", src2, src3\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vmlaLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_mla ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", src2, src3\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vmlaL_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src3
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst_src1
  st->print_raw("sve_mla ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst_src1
  st->print_raw(", src2, src3\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vmlsBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_mls ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", src2, src3\t # vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vmlsSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_mls ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", src2, src3\t # vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vmlsINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_mls ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", src2, src3\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vmlsLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src3
  st->print_raw("sve_mls ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", src2, src3\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vmulBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_mul ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vmulSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_mul ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vmulINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_mul ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vmulLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_mul ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vmulFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_fmul ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vmulDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_fmul ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vmulB_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_mul ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vmulS_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_mul ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vmulI_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_mul ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vmulL_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_mul ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vmulF_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_fmul ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vmulD_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_fmul ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vnegFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_fneg ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vnegDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_fneg ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vnegF_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  st->print_raw("sve_fneg ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vnegD_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  st->print_raw("sve_fneg ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vpopcountINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_cnt ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (S)\n\t");
}
#endif
#ifndef PRODUCT
void vmaskcmpNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cond
  st->print_raw("sve_cmp ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector mask cmp (sve)");
}
#endif
#ifndef PRODUCT
void vmaskcmp_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cond
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  st->print_raw("sve_cmp ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector mask cmp (sve)");
}
#endif
#ifndef PRODUCT
void vblendNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_sel ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw("\t# vector blend (sve)");
}
#endif
#ifndef PRODUCT
void vloadmaskBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("vloadmaskB ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector load mask (sve) (B)");
}
#endif
#ifndef PRODUCT
void vloadmask_extendNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  st->print_raw("vloadmask ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector load mask (sve) (H/S/D)");
}
#endif
#ifndef PRODUCT
void vstoremaskBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// size
  st->print_raw("vstoremask ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector store mask (sve) (B)");
}
#endif
#ifndef PRODUCT
void vstoremask_narrowNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// size
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("vstoremask ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector store mask (sve) (H/S/D)");
}
#endif
#ifndef PRODUCT
void vloadmask_loadVNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  st->print_raw("sve_ld1b ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\n\t");
  st->print_raw("sve_cmpne ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // tmp
  st->print_raw(", 0\t# load vector mask (sve) (H/S/D)");
}
#endif
#ifndef PRODUCT
void vloadmask_loadV_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vtmp
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ptmp
  st->print_raw("vloadmask_loadV ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# load vector mask partial (sve) (H/S/D)");
}
#endif
#ifndef PRODUCT
void storeV_vstoremaskNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// esize
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sve_cpy ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", 1\n\t");
  st->print_raw("sve_st1b ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# store vector mask (sve) (H/S/D)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void storeV_vstoremask_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// esize
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("storeV_vstoremask ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t# store vector mask partial (sve) (H/S/D)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void reduce_addINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_addI ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# addI reduction (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_addLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_addL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# addL reduction (sve)");
}
#endif
#ifndef PRODUCT
void reduce_addFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1_dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_fadda ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1_dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1_dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void reduce_addDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1_dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_fadda ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1_dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1_dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void reduce_addI_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_addI ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# addI reduction partial (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_addL_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_addL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# addL reduction partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_addF_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1_dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_addF ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1_dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1_dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# addF reduction partial (sve) (S)");
}
#endif
#ifndef PRODUCT
void reduce_addD_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1_dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_addD ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1_dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1_dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# addD reduction partial (sve) (D)");
}
#endif
#ifndef PRODUCT
void reduce_addI_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_addI ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# addI reduction predicated (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_addL_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_addL ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# addL reduction predicated (sve)");
}
#endif
#ifndef PRODUCT
void reduce_addF_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1_dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_reduce_addF ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1_dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# addF reduction predicated (sve)");
}
#endif
#ifndef PRODUCT
void reduce_addD_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1_dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_reduce_addD ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1_dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# addD reduction predicated (sve)");
}
#endif
#ifndef PRODUCT
void reduce_addI_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_addI ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# addI reduction predicated partial (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_addL_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_addL ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# addL reduction predicated partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_addF_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1_dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_addF ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1_dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# addF reduction predicated partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_addD_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1_dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_addD ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1_dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# addD reduction predicated partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_andINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_andI ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# andI reduction (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_andLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_andL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# andL reduction (sve)");
}
#endif
#ifndef PRODUCT
void reduce_andI_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_andI ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# andI reduction partial (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_andL_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_andL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# andL reduction partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_andI_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_andI ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# andI reduction predicated (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_andL_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_andL ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# andL reduction predicated (sve)");
}
#endif
#ifndef PRODUCT
void reduce_andI_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_andI ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# andI reduction predicated partial (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_andL_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_andL ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# andL reduction predicated partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_orINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_orI ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# orI reduction (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_orLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_orL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# orL reduction (sve)");
}
#endif
#ifndef PRODUCT
void reduce_orI_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_orI ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# orI reduction partial (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_orL_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_orL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# orL reduction partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_orI_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_orI ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# orI reduction predicated (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_orL_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_orL ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# orL reduction predicated (sve)");
}
#endif
#ifndef PRODUCT
void reduce_orI_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_orI ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# orI reduction predicated partial (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_orL_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_orL ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# orL reduction predicated partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_eorINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_eorI ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# eorI reduction (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_eorLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_eorL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# eorL reduction (sve)");
}
#endif
#ifndef PRODUCT
void reduce_eorI_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_eorI ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# eorI reduction partial (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_eorL_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_eorL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# eorL reduction partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_eorI_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_eorI ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# eorI reduction predicated (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_eorL_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_eorL ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# eorL reduction predicated (sve)");
}
#endif
#ifndef PRODUCT
void reduce_eorI_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_eorI ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# eorI reduction predicated partial (sve) (may extend)");
}
#endif
#ifndef PRODUCT
void reduce_eorL_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_eorL ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# eorL reduction predicated partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_maxI ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxI reduction (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_maxL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxL reduction (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxI_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_maxI ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxI reduction partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxL_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_maxL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxL reduction  partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("sve_reduce_maxF ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxF reduction (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxF_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_maxF ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxF reduction partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("sve_reduce_maxD ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxD reduction (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxD_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_maxD ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxD reduction partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxI_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_maxI ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxI reduction predicated (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxL_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_maxL ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxL reduction predicated (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxI_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_maxI ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxI reduction predicated partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxL_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_maxL ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxL reduction predicated partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxF_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_reduce_maxF ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxF reduction predicated (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxD_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_reduce_maxD ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxD reduction predicated (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxF_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_maxF ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxF reduction predicated partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_maxD_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_maxD ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# maxD reduction predicated partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_minI ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minI reduction (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_minL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minL reduction (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minI_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_minI ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minI reduction partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minL_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vtmp
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_minL ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minL reduction  partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("sve_reduce_minF ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minF reduction (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minF_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_minF ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minF reduction partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  st->print_raw("sve_reduce_minD ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minD reduction (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minD_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_minD ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minD reduction partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minI_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_minI ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minI reduction predicated (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minL_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("sve_reduce_minL ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minL reduction predicated (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minI_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_minI ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minI reduction predicated partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minL_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vtmp
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_minL ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minL reduction predicated partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minF_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_reduce_minF ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minF reduction predicated (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minD_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_reduce_minD ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minD reduction predicated (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minF_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_minF ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minF reduction predicated partial (sve)");
}
#endif
#ifndef PRODUCT
void reduce_minD_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("sve_reduce_minD ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# minD reduction predicated partial (sve)");
}
#endif
#ifndef PRODUCT
void vroundDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rmode
  st->print_raw("sve_frint ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // rmode
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void replicateBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void replicateSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void replicateINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void replicateLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void replicateB_imm8Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("sve_dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void replicateS_imm8Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("sve_dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void replicateI_imm8Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("sve_dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void replicateL_imm8Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  st->print_raw("sve_dup  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // con
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void replicateFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_cpy  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void replicateDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_cpy  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vasrBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_asr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vasrSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_asr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vasrINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_asr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vasrLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_asr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vlslBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsl ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vlslSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsl ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vlslINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsl ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vlslLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsl ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vlsrBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vlsrSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vlsrINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vlsrLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vasrB_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_asr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vasrS_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_asr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vasrI_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_asr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vasrL_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_asr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vlsrB_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vlsrS_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vlsrI_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vlsrL_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsr ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vlslB_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsl ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vlslS_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsl ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vlslI_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsl ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vlslL_immNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  st->print_raw("sve_lsl ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vshiftcntBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  st->print_raw("sve_dup ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cnt
  st->print_raw("\t# vector shift count (sve) (B)");
}
#endif
#ifndef PRODUCT
void vshiftcntB_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  st->print_raw("sve_dup ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cnt
  st->print_raw("\t# vector shift count (sve) (B)");
}
#endif
#ifndef PRODUCT
void vshiftcntSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  st->print_raw("sve_dup ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cnt
  st->print_raw("\t# vector shift count (sve) (H)");
}
#endif
#ifndef PRODUCT
void vshiftcntS_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  st->print_raw("sve_dup ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cnt
  st->print_raw("\t# vector shift count (sve) (H)");
}
#endif
#ifndef PRODUCT
void vshiftcntINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  st->print_raw("sve_dup ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cnt
  st->print_raw("\t# vector shift count (sve) (S)");
}
#endif
#ifndef PRODUCT
void vshiftcntI_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  st->print_raw("sve_dup ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cnt
  st->print_raw("\t# vector shift count (sve) (S)");
}
#endif
#ifndef PRODUCT
void vshiftcntLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  st->print_raw("sve_dup ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cnt
  st->print_raw("\t# vector shift count (sve) (D)");
}
#endif
#ifndef PRODUCT
void vshiftcntL_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  st->print_raw("sve_dup ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // cnt
  st->print_raw("\t# vector shift count (sve) (D)");
}
#endif
#ifndef PRODUCT
void vasrB_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_asr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vasrS_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_asr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vasrI_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_asr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vasrL_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_asr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vlslB_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsl ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vlslS_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsl ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vlslI_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsl ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vlslL_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsl ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vlsrB_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vlsrS_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vlsrI_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vlsrL_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vasrB_imm_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_asr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vasrS_imm_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_asr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vasrI_imm_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_asr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vasrL_imm_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_asr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vlsrB_imm_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vlsrS_imm_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vlsrI_imm_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vlsrL_imm_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsr ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vlslB_imm_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsl ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vlslS_imm_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsl ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vlslI_imm_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsl ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vlslL_imm_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_lsl ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shift
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vsqrtFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_fsqrt ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vsqrtDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_fsqrt ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vsqrtF_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  st->print_raw("sve_fsqrt ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vsqrtD_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// pg
  st->print_raw("sve_fsqrt ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vsubBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_sub ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vsubSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_sub ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vsubINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_sub ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vsubLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_sub ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vsubFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_fsub ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vsubDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_fsub ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t # vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vsubB_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_sub ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (B)");
}
#endif
#ifndef PRODUCT
void vsubS_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_sub ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (H)");
}
#endif
#ifndef PRODUCT
void vsubI_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_sub ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vsubL_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_sub ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vsubF_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_fsub ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (S)");
}
#endif
#ifndef PRODUCT
void vsubD_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("sve_fsub ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# vector (sve) (D)");
}
#endif
#ifndef PRODUCT
void vmaskcastNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst_src
  st->print_raw("vmaskcast ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // dst_src
  st->print_raw("\t# empty (sve)");
}
#endif
#ifndef PRODUCT
void vmaskcast_extendNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_vmaskcast_extend  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# extend predicate ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void vmaskcast_narrowNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_vmaskcast_narrow  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# narrow predicate ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
}
#endif
#ifndef PRODUCT
void vcvtBtoX_extendNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_vectorcast_b2x  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert B to X vector (extend)");
}
#endif
#ifndef PRODUCT
void vcvtStoBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  st->print_raw("sve_vectorcast_s2b  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert H to B vector");
}
#endif
#ifndef PRODUCT
void vcvtStoX_extendNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_vectorcast_s2x  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert H to X vector (extend)");
}
#endif
#ifndef PRODUCT
void vcvtItoBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("sve_vectorcast_i2b  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert I to B vector");
}
#endif
#ifndef PRODUCT
void vcvtItoSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// tmp
  st->print_raw("sve_vectorcast_i2s ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert I to H vector");
}
#endif
#ifndef PRODUCT
void vcvtItoLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_vectorcast_i2l  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert I to L vector");
}
#endif
#ifndef PRODUCT
void vcvtItoFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_vectorcast_i2f  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert I to F vector");
}
#endif
#ifndef PRODUCT
void vcvtItoDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_vectorcast_i2d  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert I to D vector");
}
#endif
#ifndef PRODUCT
void vcvtLtoX_narrowNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("sve_vectorcast_l2x  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert L to B/H/S vector (narrow)");
}
#endif
#ifndef PRODUCT
void vcvtLtoFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("sve_vectorcast_l2f  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert L to F vector");
}
#endif
#ifndef PRODUCT
void vcvtLtoDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_vectorcast_l2d  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert L to D vector");
}
#endif
#ifndef PRODUCT
void vcvtFtoX_narrowNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("sve_vectorcast_f2x  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert F to B/H vector");
}
#endif
#ifndef PRODUCT
void vcvtFtoINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_vectorcast_f2x  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert F to I vector");
}
#endif
#ifndef PRODUCT
void vcvtFtoLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_vectorcast_f2x  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert F to L vector");
}
#endif
#ifndef PRODUCT
void vcvtFtoDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_vectorcast_f2d  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw("\t# convert F to D vector");
}
#endif
#ifndef PRODUCT
void vcvtDtoX_narrowNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("sve_vectorcast_d2x  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert D to X vector (narrow)");
}
#endif
#ifndef PRODUCT
void vcvtDtoLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_vectorcast_d2l  ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# convert D to L vector");
}
#endif
#ifndef PRODUCT
void vcvtDtoFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  st->print_raw("sve_vectorcast_d2f  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw(", S, ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw("\t# convert D to F vector");
}
#endif
#ifndef PRODUCT
void extractBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pgtmp
  st->print_raw("sve_extract ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", B, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pgtmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\n\t");
  st->print_raw("sbfmw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", 0U, 7U\t# extract from vector(B)");
}
#endif
#ifndef PRODUCT
void extractSNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pgtmp
  st->print_raw("sve_extract ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", H, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pgtmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\n\t");
  st->print_raw("sbfmw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", 0U, 15U\t# extract from vector(S)");
}
#endif
#ifndef PRODUCT
void extractINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pgtmp
  st->print_raw("sve_extract ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", S, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pgtmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# extract from vector(I)");
}
#endif
#ifndef PRODUCT
void extractLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pgtmp
  st->print_raw("sve_extract ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", D, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pgtmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# extract from vector(L)");
}
#endif
#ifndef PRODUCT
void extractFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pgtmp
  st->print_raw("sve_extract ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", S, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pgtmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# extract from vector(F)");
}
#endif
#ifndef PRODUCT
void extractDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pgtmp
  st->print_raw("sve_extract ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", D, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pgtmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# extract from vector(D)");
}
#endif
#ifndef PRODUCT
void vtest_alltrueNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ptmp
  st->print_raw("sve_eors ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // ptmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw(" is all true mask\n");
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", EQ\t# VectorTest (sve) - alltrue");
}
#endif
#ifndef PRODUCT
void vtest_anytrueNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  st->print_raw("sve_ptest ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw("\n\t");
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", NE\t# VectorTest (sve) - anytrue");
}
#endif
#ifndef PRODUCT
void vtest_alltrue_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ptmp
  st->print_raw("vtest_alltrue_partial ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# VectorTest partial (sve) - alltrue");
}
#endif
#ifndef PRODUCT
void vtest_anytrue_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ptmp
  st->print_raw("vtest_anytrue_partial ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src1
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src2
  st->print_raw("\t# VectorTest partial (sve) - anytrue");
}
#endif
#ifndef PRODUCT
void insertI_smallNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// pgtmp
  st->print_raw("sve_index ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", -16, 1\t# (B/H/S)\n\t");
  st->print_raw("sve_cmpeq ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // pgtmp
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", (");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw("-#16) # shift from [0, 31] to [-16, 15]\n\t");
  st->print_raw("sve_orr ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("sve_cpy ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // pgtmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw("\t# insert into vector (B/H/S)");
}
#endif
#ifndef PRODUCT
void insertF_smallNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// pgtmp
  st->print_raw("sve_index ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", S, -16, 1\n\t");
  st->print_raw("sve_cmpeq ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // pgtmp
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", (");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw("-#16) # shift from [0, 31] to [-16, 15]\n\t");
  st->print_raw("sve_orr ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("sve_cpy ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // pgtmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw("\t# insert into vector (F)");
}
#endif
#ifndef PRODUCT
void insertINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// pgtmp
  st->print_raw("sve_index ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // tmp1
  st->print_raw(", 0, 1\t# (B/H/S)\n\t");
  st->print_raw("sve_dup ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw("\t# (B/H/S)\n\t");
  st->print_raw("sve_cmpeq ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // pgtmp
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // tmp1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sve_orr ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("sve_cpy ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // pgtmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw("\t# insert into vector (B/H/S)");
}
#endif
#ifndef PRODUCT
void insertLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// pgtmp
  st->print_raw("sve_index ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", D, -16, 1\n\t");
  st->print_raw("sve_cmpeq ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // pgtmp
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", (");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw("-#16) # shift from [0, 31] to [-16, 15]\n\t");
  st->print_raw("sve_orr ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("sve_cpy ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // pgtmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw("\t# insert into vector (L)");
}
#endif
#ifndef PRODUCT
void insertDNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// pgtmp
  st->print_raw("sve_index ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", D, -16, 1\n\t");
  st->print_raw("sve_cmpeq ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // pgtmp
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", (");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw("-#16) # shift from [0, 31] to [-16, 15]\n\t");
  st->print_raw("sve_orr ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("sve_cpy ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // pgtmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw("\t# insert into vector (D)");
}
#endif
#ifndef PRODUCT
void insertFNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// val
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// dst
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// pgtmp
  st->print_raw("sve_index ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // tmp1
  st->print_raw(", S, 0, 1\n\t");
  st->print_raw("sve_dup ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", S, ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw("\n\t");
  st->print_raw("sve_cmpeq ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // pgtmp
  st->print_raw(", ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // tmp1
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw("\n\t");
  st->print_raw("sve_orr ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\n\t");
  st->print_raw("sve_cpy ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // dst
  st->print_raw(", ");
  opnd_array(6)->ext_format(ra, this,idx6, st); // pgtmp
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // val
  st->print_raw("\t# insert into vector (F)");
}
#endif
#ifndef PRODUCT
void loadshuffleNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_loadshuffle ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector load shuffle (B/H/S/D)");
}
#endif
#ifndef PRODUCT
void rearrangeNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shuffle
  st->print_raw("sve_tbl ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // shuffle
  st->print_raw("\t# vector rearrange");
}
#endif
#ifndef PRODUCT
void gatherINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  st->print_raw("load_vector_gather ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# vector load gather (S)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void gatherLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  st->print_raw("load_vector_gather ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# vector load gather (D)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void gatherI_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ptmp
  st->print_raw("load_vector_gather ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // ptmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# vector load gather partial (S)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void gatherL_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ptmp
  st->print_raw("load_vector_gather ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // ptmp
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# vector load gather partial (D)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void gatherI_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("load_vector_gather ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# vector load gather predicated (S)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void gatherL_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  st->print_raw("load_vector_gather ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# vector load gather predicated (D)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void gatherI_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// ptmp
  st->print_raw("load_vector_gather ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# vector load gather predicated partial (S)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void gatherL_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// idx
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// pg
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// ptmp
  st->print_raw("load_vector_gather ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // pg
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // idx
  st->print_raw("\t# vector load gather predicated partial (D)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void scatterINode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  st->print_raw("store_vector_scatter ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector store scatter (S)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void scatterLNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  st->print_raw("store_vector_scatter ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector store scatter (D)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void scatterI_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// ptmp
  st->print_raw("store_vector_scatter ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // ptmp
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector store scatter partial (S)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void scatterL_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// ptmp
  st->print_raw("store_vector_scatter ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // ptmp
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector store scatter partial (D)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void scatterI_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  st->print_raw("store_vector_scatter ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // pg
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector store scatter predicate (S)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void scatterL_maskedNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  st->print_raw("store_vector_scatter ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // pg
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector store scatter predicated (D)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void scatterI_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("store_vector_scatter ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // pg
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector store scatter predicated partial (S)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void scatterL_masked_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// idx
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pg
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ptmp
  st->print_raw("store_vector_scatter ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // pg
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // idx
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // src
  st->print_raw("\t# vector store scatter predicated partial (D)");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void loadconBNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("sve_index ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", 0, 1\t# generate iota indices");
}
#endif
#ifndef PRODUCT
void stringL_indexof_char_sveNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ch
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// ztmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ztmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// pgtmp
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// ptmp
  st->print_raw("StringLatin1 IndexOf char[] ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // ch
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw(" # use sve");
}
#endif
#ifndef PRODUCT
void stringU_indexof_char_sveNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ch
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// ztmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// ztmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// pgtmp
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// ptmp
  st->print_raw("StringUTF16 IndexOf char[] ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // ch
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw(" # use sve");
}
#endif
#ifndef PRODUCT
void string_compareLL_sveNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// vtmp1
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// vtmp2
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// pgtmp1
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// pgtmp2
  st->print_raw("String Compare ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // str2
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // cnt2
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw("   # USE sve");
}
#endif
#ifndef PRODUCT
void string_compareLU_sveNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// vtmp1
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// vtmp2
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// pgtmp1
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// pgtmp2
  st->print_raw("String Compare ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // str2
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // cnt2
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw("   # USE sve");
}
#endif
#ifndef PRODUCT
void string_compareUL_sveNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// vtmp1
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// vtmp2
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// pgtmp1
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// pgtmp2
  st->print_raw("String Compare ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // str2
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // cnt2
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw("   # USE sve");
}
#endif
#ifndef PRODUCT
void string_compareUU_sveNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp2
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// vtmp1
  unsigned idx8 = idx7 + opnd_array(7)->num_edges(); 	// vtmp2
  unsigned idx9 = idx8 + opnd_array(8)->num_edges(); 	// pgtmp1
  unsigned idx10 = idx9 + opnd_array(9)->num_edges(); 	// pgtmp2
  st->print_raw("String Compare ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // str1
  st->print_raw(",");
  opnd_array(2)->ext_format(ra, this,idx2, st); // cnt1
  st->print_raw(",");
  opnd_array(3)->ext_format(ra, this,idx3, st); // str2
  st->print_raw(",");
  opnd_array(4)->ext_format(ra, this,idx4, st); // cnt2
  st->print_raw(" -> ");
  opnd_array(0)->int_format(ra, this, st); // result
  st->print_raw("   # USE sve");
}
#endif
#ifndef PRODUCT
void vmask_truecountNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  st->print_raw("vmask_truecount ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector mask truecount (sve)");
}
#endif
#ifndef PRODUCT
void vmask_firsttrueNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// ptmp
  st->print_raw("vmask_firsttrue ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector mask firsttrue (sve)");
}
#endif
#ifndef PRODUCT
void vmask_lasttrueNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// ptmp
  st->print_raw("vmask_lasttrue ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector mask lasttrue (sve)");
}
#endif
#ifndef PRODUCT
void vmask_truecount_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// ptmp
  st->print_raw("vmask_truecount_partial ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector mask truecount partial (sve)");
}
#endif
#ifndef PRODUCT
void vmask_firsttrue_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// ptmp1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ptmp2
  st->print_raw("vmask_firsttrue_partial ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector mask firsttrue partial (sve)");
}
#endif
#ifndef PRODUCT
void vmask_lasttrue_partialNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// ptmp
  st->print_raw("vmask_lasttrue_partial ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector mask lasttrue partial (sve)");
}
#endif
#ifndef PRODUCT
void vmask_tolongNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// vtmp1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// vtmp2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// pgtmp
  st->print_raw("vmask_tolong ");
  opnd_array(0)->int_format(ra, this, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // src
  st->print_raw("\t# vector mask tolong (sve)");
}
#endif
#ifndef PRODUCT
void vmask_genNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// len
  st->print_raw("sve_whilelo ");
  opnd_array(0)->int_format(ra, this, st); // pg
  st->print_raw(", zr, ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // len
  st->print_raw("\t # sve");
}
#endif
#ifndef PRODUCT
void compareAndSwapP_shenandoahNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("cmpxchg_shenandoah ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (ptr) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw(" with temp ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
}
#endif
#ifndef PRODUCT
void compareAndSwapN_shenandoahNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("cmpxchgw_shenandoah ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (ptr) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw(" with temp ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
}
#endif
#ifndef PRODUCT
void compareAndSwapPAcq_shenandoahNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("cmpxchg_acq_shenandoah_oop ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (ptr) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw(" with temp ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
}
#endif
#ifndef PRODUCT
void compareAndSwapNAcq_shenandoahNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("cmpxchgw_acq_shenandoah_narrow_oop ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (ptr) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw(" with temp ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // tmp
}
#endif
#ifndef PRODUCT
void compareAndExchangeN_shenandoahNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("cmpxchgw_shenandoah ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (narrow oop, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void compareAndExchangeP_shenandoahNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("cmpxchg_shenandoah ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (ptr) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw(" with temp ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // tmp
}
#endif
#ifndef PRODUCT
void compareAndExchangeNAcq_shenandoahNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("cmpxchgw_acq_shenandoah ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (narrow oop, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void compareAndExchangePAcq_shenandoahNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp
  st->print_raw("cmpxchg_acq_shenandoah ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (ptr) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw(" with temp ");
  opnd_array(5)->ext_format(ra, this,idx5, st); // tmp
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapN_shenandoahNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("cmpxchgw_shenandoah ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (narrow oop, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapP_shenandoahNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("cmpxchg_shenandoah ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (ptr, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapNAcq_shenandoahNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("cmpxchgw_acq_shenandoah ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (narrow oop, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void weakCompareAndSwapPAcq_shenandoahNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp
  st->print_raw("cmpxchg_acq_shenandoah ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\t# (ptr, weak) if ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" == ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(" then ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(" <-- ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("csetw ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(", EQ\t# ");
  opnd_array(0)->int_format(ra, this, st); // res
  st->print_raw(" <-- (EQ ? 1 : 0)");
}
#endif
#ifndef PRODUCT
void zLoadPNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  st->print_raw("ldr  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void zLoadPVolatileNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  st->print_raw("ldar  ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // dst
  st->print_raw(", ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("\t");
  if (ra->C->alias_type(adr_type())->field() != NULL) {
    ciField* f = ra->C->alias_type(adr_type())->field();
    st->print(" ! Field: ");
    if (f->is_volatile())
      st->print("volatile ");
    f->holder()->name()->print_symbol_on(st);
    st->print(".");
    f->name()->print_symbol_on(st);
    if (f->is_constant())
      st->print(" (constant)");
  } else {
    if (ra->C->alias_type(adr_type())->is_volatile())
      st->print(" volatile!");
  }
}
#endif
#ifndef PRODUCT
void zCompareAndSwapPNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchg ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\n\t");
  st->print_raw("cset    ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(", EQ");
}
#endif
#ifndef PRODUCT
void zCompareAndSwapP_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchg ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\n\t");
  st->print_raw("cset    ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(", EQ");
}
#endif
#ifndef PRODUCT
void zCompareAndSwapPAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchg ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\n\t");
  st->print_raw("cset    ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(", EQ");
}
#endif
#ifndef PRODUCT
void zCompareAndSwapPAcq_0Node::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchg ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
  st->print_raw("\n\t");
  st->print_raw("cset    ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(", EQ");
}
#endif
#ifndef PRODUCT
void zCompareAndExchangePNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchg ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void zCompareAndExchangePAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// res
  st->print_raw("cmpxchg ");
  opnd_array(4)->ext_format(ra, this,idx4, st); // res
  st->print_raw(" = ");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // oldval
  st->print_raw(", ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // newval
}
#endif
#ifndef PRODUCT
void zGetAndSetPNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// prev
  st->print_raw("atomic_xchg  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // prev
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // newv
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("]");
}
#endif
#ifndef PRODUCT
void zGetAndSetPAcqNode::format(PhaseRegAlloc *ra, outputStream *st) const {
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newv
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// prev
  st->print_raw("atomic_xchg_acq  ");
  opnd_array(3)->ext_format(ra, this,idx3, st); // prev
  st->print_raw(", ");
  opnd_array(2)->ext_format(ra, this,idx2, st); // newv
  st->print_raw(", [");
  opnd_array(1)->ext_format(ra, this,idx1, st); // mem
  st->print_raw("]");
}
#endif
// Check consistency of C++ compilation with ADLC options:
// Check adlc -DLINUX=1
#ifndef LINUX
#  error "LINUX must be defined"
#endif // LINUX
// Check adlc -D_GNU_SOURCE=1
#ifndef _GNU_SOURCE
#  error "_GNU_SOURCE must be defined"
#endif // _GNU_SOURCE
// Check adlc -DAARCH64=1
#ifndef AARCH64
#  error "AARCH64 must be defined"
#endif // AARCH64
// Check adlc -D_LP64=1
#ifndef _LP64
#  error "_LP64 must be defined"
#endif // _LP64
