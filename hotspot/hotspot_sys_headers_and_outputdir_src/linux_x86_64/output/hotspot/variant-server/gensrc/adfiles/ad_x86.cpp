#line 1 "ad_x86.cpp"
//
// Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 only, as
// published by the Free Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// You should have received a copy of the GNU General Public License version
// 2 along with this work; if not, write to the Free Software Foundation,
// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
//
// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
// or visit www.oracle.com if you need additional information or have any
// questions.
//
//

// Machine Generated File.  Do Not Edit!

#include "precompiled.hpp"
#include "adfiles/adGlobals_x86.hpp"
#include "adfiles/ad_x86.hpp"
#include "memory/allocation.inline.hpp"
#include "asm/macroAssembler.inline.hpp"
#include "code/compiledIC.hpp"
#include "code/nativeInst.hpp"
#include "code/vmreg.inline.hpp"
#include "gc/shared/collectedHeap.inline.hpp"
#include "oops/compiledICHolder.hpp"
#include "oops/markOop.hpp"
#include "oops/method.hpp"
#include "oops/oop.inline.hpp"
#include "opto/cfgnode.hpp"
#include "opto/intrinsicnode.hpp"
#include "opto/locknode.hpp"
#include "opto/opcodes.hpp"
#include "opto/regalloc.hpp"
#include "opto/regmask.hpp"
#include "opto/runtime.hpp"
#include "runtime/biasedLocking.hpp"
#include "runtime/safepointMechanism.hpp"
#include "runtime/sharedRuntime.hpp"
#include "runtime/stubRoutines.hpp"
#include "utilities/growableArray.hpp"

//SourceForm

#line 550 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

#define   RELOC_IMM64    Assembler::imm_operand
#define   RELOC_DISP32   Assembler::disp32_operand

#define __ _masm.

static bool generate_vzeroupper(Compile* C) {
  return (VM_Version::supports_vzeroupper() && (C->max_vector_size() > 16 || C->clear_upper_avx() == true)) ? true: false;  // Generate vzeroupper
}

static int clear_avx_size() {
  return generate_vzeroupper(Compile::current()) ? 3: 0;  // vzeroupper
}

// !!!!! Special hack to get all types of calls to specify the byte offset
//       from the start of the call to the point where the return address
//       will point.
int MachCallStaticJavaNode::ret_addr_offset()
{
  int offset = 5; // 5 bytes from start of call to where return address points
  offset += clear_avx_size();
  return offset;
}

int MachCallDynamicJavaNode::ret_addr_offset()
{
  int offset = 15; // 15 bytes from start of call to where return address points
  offset += clear_avx_size();
  return offset;
}

int MachCallRuntimeNode::ret_addr_offset() {
  int offset = 13; // movq r10,#addr; callq (r10)
  offset += clear_avx_size();
  return offset;
}

// Indicate if the safepoint node needs the polling page as an input,
// it does if the polling page is more than disp32 away.
bool SafePointNode::needs_polling_address_input()
{
  return SafepointMechanism::uses_thread_local_poll() || Assembler::is_polling_page_far();
}

//
// Compute padding required for nodes which need alignment
//

// The address of the call instruction needs to be 4-byte aligned to
// ensure that it does not span a cache line so that it can be patched.
int CallStaticJavaDirectNode::compute_padding(int current_offset) const
{
  current_offset += clear_avx_size(); // skip vzeroupper
  current_offset += 1; // skip call opcode byte
  return align_up(current_offset, alignment_required()) - current_offset;
}

// The address of the call instruction needs to be 4-byte aligned to
// ensure that it does not span a cache line so that it can be patched.
int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
{
  current_offset += clear_avx_size(); // skip vzeroupper
  current_offset += 11; // skip movq instruction + call opcode byte
  return align_up(current_offset, alignment_required()) - current_offset;
}

// EMIT_RM()
void emit_rm(CodeBuffer &cbuf, int f1, int f2, int f3) {
  unsigned char c = (unsigned char) ((f1 << 6) | (f2 << 3) | f3);
  cbuf.insts()->emit_int8(c);
}

// EMIT_CC()
void emit_cc(CodeBuffer &cbuf, int f1, int f2) {
  unsigned char c = (unsigned char) (f1 | f2);
  cbuf.insts()->emit_int8(c);
}

// EMIT_OPCODE()
void emit_opcode(CodeBuffer &cbuf, int code) {
  cbuf.insts()->emit_int8((unsigned char) code);
}

// EMIT_OPCODE() w/ relocation information
void emit_opcode(CodeBuffer &cbuf,
                 int code, relocInfo::relocType reloc, int offset, int format)
{
  cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
  emit_opcode(cbuf, code);
}

// EMIT_D8()
void emit_d8(CodeBuffer &cbuf, int d8) {
  cbuf.insts()->emit_int8((unsigned char) d8);
}

// EMIT_D16()
void emit_d16(CodeBuffer &cbuf, int d16) {
  cbuf.insts()->emit_int16(d16);
}

// EMIT_D32()
void emit_d32(CodeBuffer &cbuf, int d32) {
  cbuf.insts()->emit_int32(d32);
}

// EMIT_D64()
void emit_d64(CodeBuffer &cbuf, int64_t d64) {
  cbuf.insts()->emit_int64(d64);
}

// emit 32 bit value and construct relocation entry from relocInfo::relocType
void emit_d32_reloc(CodeBuffer& cbuf,
                    int d32,
                    relocInfo::relocType reloc,
                    int format)
{
  assert(reloc != relocInfo::external_word_type, "use 2-arg emit_d32_reloc");
  cbuf.relocate(cbuf.insts_mark(), reloc, format);
  cbuf.insts()->emit_int32(d32);
}

// emit 32 bit value and construct relocation entry from RelocationHolder
void emit_d32_reloc(CodeBuffer& cbuf, int d32, RelocationHolder const& rspec, int format) {
#ifdef ASSERT
  if (rspec.reloc()->type() == relocInfo::oop_type &&
      d32 != 0 && d32 != (intptr_t) Universe::non_oop_word()) {
    assert(Universe::heap()->is_in_reserved((address)(intptr_t)d32), "should be real oop");
    assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)) && (ScavengeRootsInCode || !Universe::heap()->is_scavengable(cast_to_oop((intptr_t)d32))), "cannot embed scavengable oops in code");
  }
#endif
  cbuf.relocate(cbuf.insts_mark(), rspec, format);
  cbuf.insts()->emit_int32(d32);
}

void emit_d32_reloc(CodeBuffer& cbuf, address addr) {
  address next_ip = cbuf.insts_end() + 4;
  emit_d32_reloc(cbuf, (int) (addr - next_ip),
                 external_word_Relocation::spec(addr),
                 RELOC_DISP32);
}


// emit 64 bit value and construct relocation entry from relocInfo::relocType
void emit_d64_reloc(CodeBuffer& cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  cbuf.relocate(cbuf.insts_mark(), reloc, format);
  cbuf.insts()->emit_int64(d64);
}

// emit 64 bit value and construct relocation entry from RelocationHolder
void emit_d64_reloc(CodeBuffer& cbuf, int64_t d64, RelocationHolder const& rspec, int format) {
#ifdef ASSERT
  if (rspec.reloc()->type() == relocInfo::oop_type &&
      d64 != 0 && d64 != (int64_t) Universe::non_oop_word()) {
    assert(Universe::heap()->is_in_reserved((address)d64), "should be real oop");
    assert(oopDesc::is_oop(cast_to_oop(d64)) && (ScavengeRootsInCode || !Universe::heap()->is_scavengable(cast_to_oop(d64))),
           "cannot embed scavengable oops in code");
  }
#endif
  cbuf.relocate(cbuf.insts_mark(), rspec, format);
  cbuf.insts()->emit_int64(d64);
}

// Access stack slot for load or store
void store_to_stackslot(CodeBuffer &cbuf, int opcode, int rm_field, int disp)
{
  emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  if (-0x80 <= disp && disp < 0x80) {
    emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
    emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
    emit_d8(cbuf, disp);     // Displacement  // R/M byte
  } else {
    emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
    emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
    emit_d32(cbuf, disp);     // Displacement // R/M byte
  }
}

   // rRegI ereg, memory mem) %{    // emit_reg_mem
void encode_RegMem(CodeBuffer &cbuf,
                   int reg,
                   int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
{
  assert(disp_reloc == relocInfo::none, "cannot have disp");
  int regenc = reg & 7;
  int baseenc = base & 7;
  int indexenc = index & 7;

  // There is no index & no scale, use form without SIB byte
  if (index == 0x4 && scale == 0 && base != RSP_enc && base != R12_enc) {
    // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
    if (disp == 0 && base != RBP_enc && base != R13_enc) {
      emit_rm(cbuf, 0x0, regenc, baseenc); // *
    } else if (-0x80 <= disp && disp < 0x80 && disp_reloc == relocInfo::none) {
      // If 8-bit displacement, mode 0x1
      emit_rm(cbuf, 0x1, regenc, baseenc); // *
      emit_d8(cbuf, disp);
    } else {
      // If 32-bit displacement
      if (base == -1) { // Special flag for absolute address
        emit_rm(cbuf, 0x0, regenc, 0x5); // *
        if (disp_reloc != relocInfo::none) {
          emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
        } else {
          emit_d32(cbuf, disp);
        }
      } else {
        // Normal base + offset
        emit_rm(cbuf, 0x2, regenc, baseenc); // *
        if (disp_reloc != relocInfo::none) {
          emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
        } else {
          emit_d32(cbuf, disp);
        }
      }
    }
  } else {
    // Else, encode with the SIB byte
    // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
    if (disp == 0 && base != RBP_enc && base != R13_enc) {
      // If no displacement
      emit_rm(cbuf, 0x0, regenc, 0x4); // *
      emit_rm(cbuf, scale, indexenc, baseenc);
    } else {
      if (-0x80 <= disp && disp < 0x80 && disp_reloc == relocInfo::none) {
        // If 8-bit displacement, mode 0x1
        emit_rm(cbuf, 0x1, regenc, 0x4); // *
        emit_rm(cbuf, scale, indexenc, baseenc);
        emit_d8(cbuf, disp);
      } else {
        // If 32-bit displacement
        if (base == 0x04 ) {
          emit_rm(cbuf, 0x2, regenc, 0x4);
          emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
        } else {
          emit_rm(cbuf, 0x2, regenc, 0x4);
          emit_rm(cbuf, scale, indexenc, baseenc); // *
        }
        if (disp_reloc != relocInfo::none) {
          emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
        } else {
          emit_d32(cbuf, disp);
        }
      }
    }
  }
}

// This could be in MacroAssembler but it's fairly C2 specific
void emit_cmpfp_fixup(MacroAssembler& _masm) {
  Label exit;
  __ jccb(Assembler::noParity, exit);
  __ pushf();
  //
  // comiss/ucomiss instructions set ZF,PF,CF flags and
  // zero OF,AF,SF for NaN values.
  // Fixup flags by zeroing ZF,PF so that compare of NaN
  // values returns 'less than' result (CF is set).
  // Leave the rest of flags unchanged.
  //
  //    7 6 5 4 3 2 1 0
  //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  //    0 0 1 0 1 0 1 1   (0x2B)
  //
  __ andq(Address(rsp, 0), 0xffffff2b);
  __ popf();
  __ bind(exit);
}

void emit_cmpfp3(MacroAssembler& _masm, Register dst) {
  Label done;
  __ movl(dst, -1);
  __ jcc(Assembler::parity, done);
  __ jcc(Assembler::below, done);
  __ setb(Assembler::notEqual, dst);
  __ movzbl(dst, dst);
  __ bind(done);
}


//=============================================================================
const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::Empty;

int Compile::ConstantTable::calculate_table_base_offset() const {
  return 0;  // absolute addressing, no offset
}

bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
void MachConstantBaseNode::postalloc_expand(GrowableArray <Node *> *nodes, PhaseRegAlloc *ra_) {
  ShouldNotReachHere();
}

void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  // Empty encoding
}

uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  return 0;
}

#ifndef PRODUCT
void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  st->print("# MachConstantBaseNode (empty encoding)");
}
#endif


//=============================================================================
#ifndef PRODUCT
void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  Compile* C = ra_->C;

  int framesize = C->frame_size_in_bytes();
  int bangsize = C->bang_size_in_bytes();
  assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
  // Remove wordSize for return addr which is already pushed.
  framesize -= wordSize;

  if (C->need_stack_bang(bangsize)) {
    framesize -= wordSize;
    st->print("# stack bang (%d bytes)", bangsize);
    st->print("\n\t");
    st->print("pushq   rbp\t# Save rbp");
    if (PreserveFramePointer) {
        st->print("\n\t");
        st->print("movq    rbp, rsp\t# Save the caller's SP into rbp");
    }
    if (framesize) {
      st->print("\n\t");
      st->print("subq    rsp, #%d\t# Create frame",framesize);
    }
  } else {
    st->print("subq    rsp, #%d\t# Create frame",framesize);
    st->print("\n\t");
    framesize -= wordSize;
    st->print("movq    [rsp + #%d], rbp\t# Save rbp",framesize);
    if (PreserveFramePointer) {
      st->print("\n\t");
      st->print("movq    rbp, rsp\t# Save the caller's SP into rbp");
      if (framesize > 0) {
        st->print("\n\t");
        st->print("addq    rbp, #%d", framesize);
      }
    }
  }

  if (VerifyStackAtCalls) {
    st->print("\n\t");
    framesize -= wordSize;
    st->print("movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check",framesize);
#ifdef ASSERT
    st->print("\n\t");
    st->print("# stack alignment check");
#endif
  }
  st->cr();
}
#endif

void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
  Compile* C = ra_->C;
  MacroAssembler _masm(&cbuf);

  int framesize = C->frame_size_in_bytes();
  int bangsize = C->bang_size_in_bytes();

  __ verified_entry(framesize, C->need_stack_bang(bangsize)?bangsize:0, false);

  C->set_frame_complete(cbuf.insts_size());

  if (C->has_mach_constant_base_node()) {
    // NOTE: We set the table base offset here because users might be
    // emitted before MachConstantBaseNode.
    Compile::ConstantTable& constant_table = C->constant_table();
    constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  }
}

uint MachPrologNode::size(PhaseRegAlloc* ra_) const
{
  return MachNode::size(ra_); // too many variables; just compute it
                              // the hard way
}

int MachPrologNode::reloc() const
{
  return 0; // a large enough number
}

//=============================================================================
#ifndef PRODUCT
void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
{
  Compile* C = ra_->C;
  if (generate_vzeroupper(C)) {
    st->print("vzeroupper");
    st->cr(); st->print("\t");
  }

  int framesize = C->frame_size_in_bytes();
  assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
  // Remove word for return adr already pushed
  // and RBP
  framesize -= 2*wordSize;

  if (framesize) {
    st->print_cr("addq    rsp, %d\t# Destroy frame", framesize);
    st->print("\t");
  }

  st->print_cr("popq   rbp");
  if (do_polling() && C->is_method_compilation()) {
    st->print("\t");
    if (SafepointMechanism::uses_thread_local_poll()) {
      st->print_cr("movq   rscratch1, poll_offset[r15_thread] #polling_page_address\n\t"
                   "testl  rax, [rscratch1]\t"
                   "# Safepoint: poll for GC");
    } else if (Assembler::is_polling_page_far()) {
      st->print_cr("movq   rscratch1, #polling_page_address\n\t"
                   "testl  rax, [rscratch1]\t"
                   "# Safepoint: poll for GC");
    } else {
      st->print_cr("testl  rax, [rip + #offset_to_poll_page]\t"
                   "# Safepoint: poll for GC");
    }
  }
}
#endif

void MachEpilogNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const
{
  Compile* C = ra_->C;
  MacroAssembler _masm(&cbuf);

  if (generate_vzeroupper(C)) {
    // Clear upper bits of YMM registers when current compiled code uses
    // wide vectors to avoid AVX <-> SSE transition penalty during call.
    __ vzeroupper();
  }

  int framesize = C->frame_size_in_bytes();
  assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
  // Remove word for return adr already pushed
  // and RBP
  framesize -= 2*wordSize;

  // Note that VerifyStackAtCalls' Majik cookie does not change the frame size popped here

  if (framesize) {
    emit_opcode(cbuf, Assembler::REX_W);
    if (framesize < 0x80) {
      emit_opcode(cbuf, 0x83); // addq rsp, #framesize
      emit_rm(cbuf, 0x3, 0x00, RSP_enc);
      emit_d8(cbuf, framesize);
    } else {
      emit_opcode(cbuf, 0x81); // addq rsp, #framesize
      emit_rm(cbuf, 0x3, 0x00, RSP_enc);
      emit_d32(cbuf, framesize);
    }
  }

  // popq rbp
  emit_opcode(cbuf, 0x58 | RBP_enc);

  if (StackReservedPages > 0 && C->has_reserved_stack_access()) {
    __ reserved_stack_check();
  }

  if (do_polling() && C->is_method_compilation()) {
    MacroAssembler _masm(&cbuf);
    if (SafepointMechanism::uses_thread_local_poll()) {
      __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
      __ relocate(relocInfo::poll_return_type);
      __ testl(rax, Address(rscratch1, 0));
    } else {
      AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
      if (Assembler::is_polling_page_far()) {
        __ lea(rscratch1, polling_page);
        __ relocate(relocInfo::poll_return_type);
        __ testl(rax, Address(rscratch1, 0));
      } else {
        __ testl(rax, polling_page);
      }
    }
  }
}

uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
{
  return MachNode::size(ra_); // too many variables; just compute it
                              // the hard way
}

int MachEpilogNode::reloc() const
{
  return 2; // a large enough number
}

const Pipeline* MachEpilogNode::pipeline() const
{
  return MachNode::pipeline_class();
}

int MachEpilogNode::safepoint_offset() const
{
  return 0;
}

//=============================================================================

enum RC {
  rc_bad,
  rc_int,
  rc_float,
  rc_stack
};

static enum RC rc_class(OptoReg::Name reg)
{
  if( !OptoReg::is_valid(reg)  ) return rc_bad;

  if (OptoReg::is_stack(reg)) return rc_stack;

  VMReg r = OptoReg::as_VMReg(reg);

  if (r->is_Register()) return rc_int;

  assert(r->is_XMMRegister(), "must be");
  return rc_float;
}

// Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
                          int src_hi, int dst_hi, uint ireg, outputStream* st);

static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
                            int stack_offset, int reg, uint ireg, outputStream* st);

static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
                                      int dst_offset, uint ireg, outputStream* st) {
  if (cbuf) {
    MacroAssembler _masm(cbuf);
    switch (ireg) {
    case Op_VecS:
      __ movq(Address(rsp, -8), rax);
      __ movl(rax, Address(rsp, src_offset));
      __ movl(Address(rsp, dst_offset), rax);
      __ movq(rax, Address(rsp, -8));
      break;
    case Op_VecD:
      __ pushq(Address(rsp, src_offset));
      __ popq (Address(rsp, dst_offset));
      break;
    case Op_VecX:
      __ pushq(Address(rsp, src_offset));
      __ popq (Address(rsp, dst_offset));
      __ pushq(Address(rsp, src_offset+8));
      __ popq (Address(rsp, dst_offset+8));
      break;
    case Op_VecY:
      __ vmovdqu(Address(rsp, -32), xmm0);
      __ vmovdqu(xmm0, Address(rsp, src_offset));
      __ vmovdqu(Address(rsp, dst_offset), xmm0);
      __ vmovdqu(xmm0, Address(rsp, -32));
      break;
    case Op_VecZ:
      __ evmovdquq(Address(rsp, -64), xmm0, 2);
      __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
      __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
      __ evmovdquq(xmm0, Address(rsp, -64), 2);
      break;
    default:
      ShouldNotReachHere();
    }
#ifndef PRODUCT
  } else {
    switch (ireg) {
    case Op_VecS:
      st->print("movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t"
                "movl    rax, [rsp + #%d]\n\t"
                "movl    [rsp + #%d], rax\n\t"
                "movq    rax, [rsp - #8]",
                src_offset, dst_offset);
      break;
    case Op_VecD:
      st->print("pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t"
                "popq    [rsp + #%d]",
                src_offset, dst_offset);
      break;
     case Op_VecX:
      st->print("pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t"
                "popq    [rsp + #%d]\n\t"
                "pushq   [rsp + #%d]\n\t"
                "popq    [rsp + #%d]",
                src_offset, dst_offset, src_offset+8, dst_offset+8);
      break;
    case Op_VecY:
      st->print("vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t"
                "vmovdqu xmm0, [rsp + #%d]\n\t"
                "vmovdqu [rsp + #%d], xmm0\n\t"
                "vmovdqu xmm0, [rsp - #32]",
                src_offset, dst_offset);
      break;
    case Op_VecZ:
      st->print("vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t"
                "vmovdqu xmm0, [rsp + #%d]\n\t"
                "vmovdqu [rsp + #%d], xmm0\n\t"
                "vmovdqu xmm0, [rsp - #64]",
                src_offset, dst_offset);
      break;
    default:
      ShouldNotReachHere();
    }
#endif
  }
}

uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
                                       PhaseRegAlloc* ra_,
                                       bool do_size,
                                       outputStream* st) const {
  assert(cbuf != NULL || st  != NULL, "sanity");
  // Get registers to move
  OptoReg::Name src_second = ra_->get_reg_second(in(1));
  OptoReg::Name src_first = ra_->get_reg_first(in(1));
  OptoReg::Name dst_second = ra_->get_reg_second(this);
  OptoReg::Name dst_first = ra_->get_reg_first(this);

  enum RC src_second_rc = rc_class(src_second);
  enum RC src_first_rc = rc_class(src_first);
  enum RC dst_second_rc = rc_class(dst_second);
  enum RC dst_first_rc = rc_class(dst_first);

  assert(OptoReg::is_valid(src_first) && OptoReg::is_valid(dst_first),
         "must move at least 1 register" );

  if (src_first == dst_first && src_second == dst_second) {
    // Self copy, no move
    return 0;
  }
  if (bottom_type()->isa_vect() != NULL) {
    uint ireg = ideal_reg();
    assert((src_first_rc != rc_int && dst_first_rc != rc_int), "sanity");
    assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), "sanity");
    if( src_first_rc == rc_stack && dst_first_rc == rc_stack ) {
      // mem -> mem
      int src_offset = ra_->reg2offset(src_first);
      int dst_offset = ra_->reg2offset(dst_first);
      vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
    } else if (src_first_rc == rc_float && dst_first_rc == rc_float ) {
      vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
    } else if (src_first_rc == rc_float && dst_first_rc == rc_stack ) {
      int stack_offset = ra_->reg2offset(dst_first);
      vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
    } else if (src_first_rc == rc_stack && dst_first_rc == rc_float ) {
      int stack_offset = ra_->reg2offset(src_first);
      vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
    } else {
      ShouldNotReachHere();
    }
    return 0;
  }
  if (src_first_rc == rc_stack) {
    // mem ->
    if (dst_first_rc == rc_stack) {
      // mem -> mem
      assert(src_second != dst_first, "overlap");
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        int src_offset = ra_->reg2offset(src_first);
        int dst_offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ pushq(Address(rsp, src_offset));
          __ popq (Address(rsp, dst_offset));
#ifndef PRODUCT
        } else {
          st->print("pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t"
                    "popq    [rsp + #%d]",
                     src_offset, dst_offset);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        // No pushl/popl, so:
        int src_offset = ra_->reg2offset(src_first);
        int dst_offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movq(Address(rsp, -8), rax);
          __ movl(rax, Address(rsp, src_offset));
          __ movl(Address(rsp, dst_offset), rax);
          __ movq(rax, Address(rsp, -8));
#ifndef PRODUCT
        } else {
          st->print("movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t"
                    "movl    rax, [rsp + #%d]\n\t"
                    "movl    [rsp + #%d], rax\n\t"
                    "movq    rax, [rsp - #8]",
                     src_offset, dst_offset);
#endif
        }
      }
      return 0;
    } else if (dst_first_rc == rc_int) {
      // mem -> gpr
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        int offset = ra_->reg2offset(src_first);
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
#ifndef PRODUCT
        } else {
          st->print("movq    %s, [rsp + #%d]\t# spill",
                     Matcher::regName[dst_first],
                     offset);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        int offset = ra_->reg2offset(src_first);
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
#ifndef PRODUCT
        } else {
          st->print("movl    %s, [rsp + #%d]\t# spill",
                     Matcher::regName[dst_first],
                     offset);
#endif
        }
      }
      return 0;
    } else if (dst_first_rc == rc_float) {
      // mem-> xmm
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        int offset = ra_->reg2offset(src_first);
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
#ifndef PRODUCT
        } else {
          st->print("%s  %s, [rsp + #%d]\t# spill",
                     UseXmmLoadAndClearUpper ? "movsd " : "movlpd",
                     Matcher::regName[dst_first],
                     offset);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        int offset = ra_->reg2offset(src_first);
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
#ifndef PRODUCT
        } else {
          st->print("movss   %s, [rsp + #%d]\t# spill",
                     Matcher::regName[dst_first],
                     offset);
#endif
        }
      }
      return 0;
    }
  } else if (src_first_rc == rc_int) {
    // gpr ->
    if (dst_first_rc == rc_stack) {
      // gpr -> mem
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        int offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("movq    [rsp + #%d], %s\t# spill",
                     offset,
                     Matcher::regName[src_first]);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        int offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("movl    [rsp + #%d], %s\t# spill",
                     offset,
                     Matcher::regName[src_first]);
#endif
        }
      }
      return 0;
    } else if (dst_first_rc == rc_int) {
      // gpr -> gpr
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movq(as_Register(Matcher::_regEncode[dst_first]),
                  as_Register(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("movq    %s, %s\t# spill",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
        return 0;
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movl(as_Register(Matcher::_regEncode[dst_first]),
                  as_Register(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("movl    %s, %s\t# spill",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
        return 0;
      }
    } else if (dst_first_rc == rc_float) {
      // gpr -> xmm
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("movdq   %s, %s\t# spill",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("movdl   %s, %s\t# spill",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
      }
      return 0;
    }
  } else if (src_first_rc == rc_float) {
    // xmm ->
    if (dst_first_rc == rc_stack) {
      // xmm -> mem
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        int offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("movsd   [rsp + #%d], %s\t# spill",
                     offset,
                     Matcher::regName[src_first]);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        int offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("movss   [rsp + #%d], %s\t# spill",
                     offset,
                     Matcher::regName[src_first]);
#endif
        }
      }
      return 0;
    } else if (dst_first_rc == rc_int) {
      // xmm -> gpr
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("movdq   %s, %s\t# spill",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("movdl   %s, %s\t# spill",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
      }
      return 0;
    } else if (dst_first_rc == rc_float) {
      // xmm -> xmm
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("%s  %s, %s\t# spill",
                     UseXmmRegToRegMoveAll ? "movapd" : "movsd ",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        if (cbuf) {
          MacroAssembler _masm(cbuf);
          __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("%s  %s, %s\t# spill",
                     UseXmmRegToRegMoveAll ? "movaps" : "movss ",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
      }
      return 0;
    }
  }

  assert(0," foo ");
  Unimplemented();
  return 0;
}

#ifndef PRODUCT
void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
  implementation(NULL, ra_, false, st);
}
#endif

void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
  implementation(&cbuf, ra_, false, NULL);
}

uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
  return MachNode::size(ra_);
}

//=============================================================================
#ifndef PRODUCT
void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
{
  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());
  int reg = ra_->get_reg_first(this);
  st->print("leaq    %s, [rsp + #%d]\t# box lock",
            Matcher::regName[reg], offset);
}
#endif

void BoxLockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const
{
  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());
  int reg = ra_->get_encode(this);
  if (offset >= 0x80) {
    emit_opcode(cbuf, reg < 8 ? Assembler::REX_W : Assembler::REX_WR);
    emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
    emit_rm(cbuf, 0x2, reg & 7, 0x04);
    emit_rm(cbuf, 0x0, 0x04, RSP_enc);
    emit_d32(cbuf, offset);
  } else {
    emit_opcode(cbuf, reg < 8 ? Assembler::REX_W : Assembler::REX_WR);
    emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
    emit_rm(cbuf, 0x1, reg & 7, 0x04);
    emit_rm(cbuf, 0x0, 0x04, RSP_enc);
    emit_d8(cbuf, offset);
  }
}

uint BoxLockNode::size(PhaseRegAlloc *ra_) const
{
  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());
  return (offset < 0x80) ? 5 : 8; // REX
}

//=============================================================================
#ifndef PRODUCT
void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
{
  if (UseCompressedClassPointers) {
    st->print_cr("movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass");
    st->print_cr("\tdecode_klass_not_null rscratch1, rscratch1");
    st->print_cr("\tcmpq    rax, rscratch1\t # Inline cache check");
  } else {
    st->print_cr("\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t"
                 "# Inline cache check");
  }
  st->print_cr("\tjne     SharedRuntime::_ic_miss_stub");
  st->print_cr("\tnop\t# nops to align entry point");
}
#endif

void MachUEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const
{
  MacroAssembler masm(&cbuf);
  uint insts_size = cbuf.insts_size();
  if (UseCompressedClassPointers) {
    masm.load_klass(rscratch1, j_rarg0);
    masm.cmpptr(rax, rscratch1);
  } else {
    masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
  }

  masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));

  /* WARNING these NOPs are critical so that verified entry point is properly
     4 bytes aligned for patching by NativeJump::patch_verified_entry() */
  int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) & 0x3);
  if (OptoBreakpoint) {
    // Leave space for int3
    nops_cnt -= 1;
  }
  nops_cnt &= 0x3; // Do not add nops if code is aligned.
  if (nops_cnt > 0)
    masm.nop(nops_cnt);
}

uint MachUEPNode::size(PhaseRegAlloc* ra_) const
{
  return MachNode::size(ra_); // too many variables; just compute it
                              // the hard way
}


//=============================================================================

int Matcher::regnum_to_fpu_offset(int regnum)
{
  return regnum - 32; // The FP registers are in the second chunk
}

// This is UltraSparc specific, true just means we have fast l2f conversion
const bool Matcher::convL2FSupported(void) {
  return true;
}

// Is this branch offset short enough that a short branch can be used?
//
// NOTE: If the platform does not provide any short branch variants, then
//       this method should return false for offset 0.
bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
  // The passed offset is relative to address of the branch.
  // On 86 a branch displacement is calculated relative to address
  // of a next instruction.
  offset -= br_size;

  // the short version of jmpConUCF2 contains multiple branches,
  // making the reach slightly less
  if (rule == jmpConUCF2_rule)
    return (-126 <= offset && offset <= 125);
  return (-128 <= offset && offset <= 127);
}

const bool Matcher::isSimpleConstant64(jlong value) {
  // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
  //return value == (int) value;  // Cf. storeImmL and immL32.

  // Probably always true, even if a temp register is required.
  return true;
}

// The ecx parameter to rep stosq for the ClearArray node is in words.
const bool Matcher::init_array_count_is_in_bytes = false;

// No additional cost for CMOVL.
const int Matcher::long_cmove_cost() { return 0; }

// No CMOVF/CMOVD with SSE2
const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }

// Does the CPU require late expand (see block.cpp for description of late expand)?
const bool Matcher::require_postalloc_expand = false;

// Do we need to mask the count passed to shift instructions or does
// the cpu only look at the lower 5/6 bits anyway?
const bool Matcher::need_masked_shift_count = false;

bool Matcher::narrow_oop_use_complex_address() {
  assert(UseCompressedOops, "only for compressed oops code");
  return (LogMinObjAlignmentInBytes <= 3);
}

bool Matcher::narrow_klass_use_complex_address() {
  assert(UseCompressedClassPointers, "only for compressed klass code");
  return (LogKlassAlignmentInBytes <= 3);
}

bool Matcher::const_oop_prefer_decode() {
  // Prefer ConN+DecodeN over ConP.
  return true;
}

bool Matcher::const_klass_prefer_decode() {
  // TODO: Either support matching DecodeNKlass (heap-based) in operand
  //       or condisider the following:
  // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
  //return Universe::narrow_klass_base() == NULL;
  return true;
}

// Is it better to copy float constants, or load them directly from
// memory?  Intel can load a float constant from a direct address,
// requiring no extra registers.  Most RISCs will have to materialize
// an address into a register first, so they would do better to copy
// the constant from stack.
const bool Matcher::rematerialize_float_constants = true; // XXX

// If CPU can load and store mis-aligned doubles directly then no
// fixup is needed.  Else we split the double into 2 integer pieces
// and move it piece-by-piece.  Only happens when passing doubles into
// C code as the Java calling convention forces doubles to be aligned.
const bool Matcher::misaligned_doubles_ok = true;

// No-op on amd64
void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}

// Advertise here if the CPU requires explicit rounding operations to
// implement the UseStrictFP mode.
const bool Matcher::strict_fp_requires_explicit_rounding = true;

// Are floats conerted to double when stored to stack during deoptimization?
// On x64 it is stored without convertion so we can use normal access.
bool Matcher::float_in_double() { return false; }

// Do ints take an entire long register or just half?
const bool Matcher::int_in_long = true;

// Return whether or not this register is ever used as an argument.
// This function is used on startup to build the trampoline stubs in
// generateOptoStub.  Registers not mentioned will be killed by the VM
// call in the trampoline, and arguments in those registers not be
// available to the callee.
bool Matcher::can_be_java_arg(int reg)
{
  return
    reg ==  RDI_num || reg == RDI_H_num ||
    reg ==  RSI_num || reg == RSI_H_num ||
    reg ==  RDX_num || reg == RDX_H_num ||
    reg ==  RCX_num || reg == RCX_H_num ||
    reg ==   R8_num || reg ==  R8_H_num ||
    reg ==   R9_num || reg ==  R9_H_num ||
    reg ==  R12_num || reg == R12_H_num ||
    reg == XMM0_num || reg == XMM0b_num ||
    reg == XMM1_num || reg == XMM1b_num ||
    reg == XMM2_num || reg == XMM2b_num ||
    reg == XMM3_num || reg == XMM3b_num ||
    reg == XMM4_num || reg == XMM4b_num ||
    reg == XMM5_num || reg == XMM5b_num ||
    reg == XMM6_num || reg == XMM6b_num ||
    reg == XMM7_num || reg == XMM7b_num;
}

bool Matcher::is_spillable_arg(int reg)
{
  return can_be_java_arg(reg);
}

bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
  // In 64 bit mode a code which use multiply when
  // devisor is constant is faster than hardware
  // DIV instruction (it uses MulHiL).
  return false;
}

// Register for DIVI projection of divmodI
RegMask Matcher::divI_proj_mask() {
  return INT_RAX_REG_mask();
}

// Register for MODI projection of divmodI
RegMask Matcher::modI_proj_mask() {
  return INT_RDX_REG_mask();
}

// Register for DIVL projection of divmodL
RegMask Matcher::divL_proj_mask() {
  return LONG_RAX_REG_mask();
}

// Register for MODL projection of divmodL
RegMask Matcher::modL_proj_mask() {
  return LONG_RDX_REG_mask();
}

// Register for saving SP into on method handle invokes. Not used on x86_64.
const RegMask Matcher::method_handle_invoke_SP_save_mask() {
    return NO_REG_mask();
}


#line 1305 "ad_x86.cpp"


//SourceForm

#line 1272 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"


#include "opto/addnode.hpp"

// Emit exception handler code.
// Stuff framesize into a register and call a VM stub routine.
int HandlerImpl::emit_exception_handler(CodeBuffer& cbuf) {

  // Note that the code buffer's insts_mark is always relative to insts.
  // That's why we must use the macroassembler to generate a handler.
  MacroAssembler _masm(&cbuf);
  address base = __ start_a_stub(size_exception_handler());
  if (base == NULL) {
    ciEnv::current()->record_failure("CodeCache is full");
    return 0;  // CodeBuffer::expand failed
  }
  int offset = __ offset();
  __ jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));
  assert(__ offset() - offset <= (int) size_exception_handler(), "overflow");
  __ end_a_stub();
  return offset;
}

// Emit deopt handler code.
int HandlerImpl::emit_deopt_handler(CodeBuffer& cbuf) {

  // Note that the code buffer's insts_mark is always relative to insts.
  // That's why we must use the macroassembler to generate a handler.
  MacroAssembler _masm(&cbuf);
  address base = __ start_a_stub(size_deopt_handler());
  if (base == NULL) {
    ciEnv::current()->record_failure("CodeCache is full");
    return 0;  // CodeBuffer::expand failed
  }
  int offset = __ offset();

#ifdef _LP64
  address the_pc = (address) __ pc();
  Label next;
  // push a "the_pc" on the stack without destroying any registers
  // as they all may be live.

  // push address of "next"
  __ call(next, relocInfo::none); // reloc none is fine since it is a disp32
  __ bind(next);
  // adjust it so it matches "the_pc"
  __ subptr(Address(rsp, 0), __ offset() - offset);
#else
  InternalAddress here(__ pc());
  __ pushptr(here.addr());
#endif

  __ jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));
  assert(__ offset() - offset <= (int) size_deopt_handler(), "overflow");
  __ end_a_stub();
  return offset;
}


//=============================================================================

  // Float masks come from different places depending on platform.
#ifdef _LP64
  static address float_signmask()  { return StubRoutines::x86::float_sign_mask(); }
  static address float_signflip()  { return StubRoutines::x86::float_sign_flip(); }
  static address double_signmask() { return StubRoutines::x86::double_sign_mask(); }
  static address double_signflip() { return StubRoutines::x86::double_sign_flip(); }
#else
  static address float_signmask()  { return (address)float_signmask_pool; }
  static address float_signflip()  { return (address)float_signflip_pool; }
  static address double_signmask() { return (address)double_signmask_pool; }
  static address double_signflip() { return (address)double_signflip_pool; }
#endif


const bool Matcher::match_rule_supported(int opcode) {
  if (!has_match_rule(opcode))
    return false;

  bool ret_value = true;
  switch (opcode) {
    case Op_PopCountI:
    case Op_PopCountL:
      if (!UsePopCountInstruction)
        ret_value = false;
      break;
    case Op_PopCountVI:
      if (!UsePopCountInstruction || !VM_Version::supports_vpopcntdq())
        ret_value = false;
      break;
    case Op_MulVI:
      if ((UseSSE < 4) && (UseAVX < 1)) // only with SSE4_1 or AVX
        ret_value = false;
      break;
    case Op_MulVL:
    case Op_MulReductionVL:
      if (VM_Version::supports_avx512dq() == false)
        ret_value = false;
      break;
    case Op_AddReductionVL:
      if (UseAVX < 3) // only EVEX : vector connectivity becomes an issue here
        ret_value = false;
      break;
    case Op_AddReductionVI:
      if (UseSSE < 3) // requires at least SSE3
        ret_value = false;
      break;
    case Op_MulReductionVI:
      if (UseSSE < 4) // requires at least SSE4
        ret_value = false;
      break;
    case Op_AddReductionVF:
    case Op_AddReductionVD:
    case Op_MulReductionVF:
    case Op_MulReductionVD:
      if (UseSSE < 1) // requires at least SSE
        ret_value = false;
      break;
    case Op_SqrtVD:
    case Op_SqrtVF:
      if (UseAVX < 1) // enabled for AVX only
        ret_value = false;
      break;
    case Op_CompareAndSwapL:
#ifdef _LP64
    case Op_CompareAndSwapP:
#endif
      if (!VM_Version::supports_cx8())
        ret_value = false;
      break;
    case Op_CMoveVF:
    case Op_CMoveVD:
      if (UseAVX < 1 || UseAVX > 2)
        ret_value = false;
      break;
    case Op_StrIndexOf:
      if (!UseSSE42Intrinsics)
        ret_value = false;
      break;
    case Op_StrIndexOfChar:
      if (!UseSSE42Intrinsics)
        ret_value = false;
      break;
    case Op_OnSpinWait:
      if (VM_Version::supports_on_spin_wait() == false)
        ret_value = false;
      break;
  }

  return ret_value;  // Per default match rules are supported.
}

const bool Matcher::match_rule_supported_vector(int opcode, int vlen) {
  // identify extra cases that we might want to provide match rules for
  // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
  bool ret_value = match_rule_supported(opcode);
  if (ret_value) {
    switch (opcode) {
      case Op_AddVB:
      case Op_SubVB:
        if ((vlen == 64) && (VM_Version::supports_avx512bw() == false))
          ret_value = false;
        break;
      case Op_URShiftVS:
      case Op_RShiftVS:
      case Op_LShiftVS:
      case Op_MulVS:
      case Op_AddVS:
      case Op_SubVS:
        if ((vlen == 32) && (VM_Version::supports_avx512bw() == false))
          ret_value = false;
        break;
      case Op_CMoveVF:
        if (vlen != 8)
          ret_value  = false;
      case Op_CMoveVD:
        if (vlen != 4)
          ret_value  = false;
        break;
    }
  }

  return ret_value;  // Per default match rules are supported.
}

const bool Matcher::has_predicated_vectors(void) {
  bool ret_value = false;
  if (UseAVX > 2) {
    ret_value = VM_Version::supports_avx512vl();
  }

  return ret_value;
}

const int Matcher::float_pressure(int default_pressure_threshold) {
  int float_pressure_threshold = default_pressure_threshold;
#ifdef _LP64
  if (UseAVX > 2) {
    // Increase pressure threshold on machines with AVX3 which have
    // 2x more XMM registers.
    float_pressure_threshold = default_pressure_threshold * 2;
  }
#endif
  return float_pressure_threshold;
}

// Max vector size in bytes. 0 if not supported.
const int Matcher::vector_width_in_bytes(BasicType bt) {
  assert(is_java_primitive(bt), "only primitive type vectors");
  if (UseSSE < 2) return 0;
  // SSE2 supports 128bit vectors for all types.
  // AVX2 supports 256bit vectors for all types.
  // AVX2/EVEX supports 512bit vectors for all types.
  int size = (UseAVX > 1) ? (1 << UseAVX) * 8 : 16;
  // AVX1 supports 256bit vectors only for FLOAT and DOUBLE.
  if (UseAVX > 0 && (bt == T_FLOAT || bt == T_DOUBLE))
    size = (UseAVX > 2) ? 64 : 32;
  // Use flag to limit vector size.
  size = MIN2(size,(int)MaxVectorSize);
  // Minimum 2 values in vector (or 4 for bytes).
  switch (bt) {
  case T_DOUBLE:
  case T_LONG:
    if (size < 16) return 0;
    break;
  case T_FLOAT:
  case T_INT:
    if (size < 8) return 0;
    break;
  case T_BOOLEAN:
    if (size < 4) return 0;
    break;
  case T_CHAR:
    if (size < 4) return 0;
    break;
  case T_BYTE:
    if (size < 4) return 0;
    break;
  case T_SHORT:
    if (size < 4) return 0;
    break;
  default:
    ShouldNotReachHere();
  }
  return size;
}

// Limits on vector size (number of elements) loaded into vector.
const int Matcher::max_vector_size(const BasicType bt) {
  return vector_width_in_bytes(bt)/type2aelembytes(bt);
}
const int Matcher::min_vector_size(const BasicType bt) {
  int max_size = max_vector_size(bt);
  // Min size which can be loaded into vector is 4 bytes.
  int size = (type2aelembytes(bt) == 1) ? 4 : 2;
  return MIN2(size,max_size);
}

// Vector ideal reg corresponding to specidied size in bytes
const uint Matcher::vector_ideal_reg(int size) {
  assert(MaxVectorSize >= size, "");
  switch(size) {
    case  4: return Op_VecS;
    case  8: return Op_VecD;
    case 16: return Op_VecX;
    case 32: return Op_VecY;
    case 64: return Op_VecZ;
  }
  ShouldNotReachHere();
  return 0;
}

// Only lowest bits of xmm reg are used for vector shift count.
const uint Matcher::vector_shift_count_ideal_reg(int size) {
  return Op_VecS;
}

// x86 supports misaligned vectors store/load.
const bool Matcher::misaligned_vectors_ok() {
  return !AlignVector; // can be changed by flag
}

// x86 AES instructions are compatible with SunJCE expanded
// keys, hence we do not need to pass the original key to stubs
const bool Matcher::pass_original_key_for_aes() {
  return false;
}


const bool Matcher::convi2l_type_required = true;

// Check for shift by small constant as well
static bool clone_shift(Node* shift, Matcher* matcher, Matcher::MStack& mstack, VectorSet& address_visited) {
  if (shift->Opcode() == Op_LShiftX && shift->in(2)->is_Con() &&
      shift->in(2)->get_int() <= 3 &&
      // Are there other uses besides address expressions?
      !matcher->is_visited(shift)) {
    address_visited.set(shift->_idx); // Flag as address_visited
    mstack.push(shift->in(2), Matcher::Visit);
    Node *conv = shift->in(1);
#ifdef _LP64
    // Allow Matcher to match the rule which bypass
    // ConvI2L operation for an array index on LP64
    // if the index value is positive.
    if (conv->Opcode() == Op_ConvI2L &&
        conv->as_Type()->type()->is_long()->_lo >= 0 &&
        // Are there other uses besides address expressions?
        !matcher->is_visited(conv)) {
      address_visited.set(conv->_idx); // Flag as address_visited
      mstack.push(conv->in(1), Matcher::Pre_Visit);
    } else
#endif
      mstack.push(conv, Matcher::Pre_Visit);
    return true;
  }
  return false;
}

// Should the Matcher clone shifts on addressing modes, expecting them
// to be subsumed into complex addressing expressions or compute them
// into registers?
bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack& mstack, VectorSet& address_visited) {
  Node *off = m->in(AddPNode::Offset);
  if (off->is_Con()) {
    address_visited.test_set(m->_idx); // Flag as address_visited
    Node *adr = m->in(AddPNode::Address);

    // Intel can handle 2 adds in addressing mode
    // AtomicAdd is not an addressing expression.
    // Cheap to find it by looking for screwy base.
    if (adr->is_AddP() &&
        !adr->in(AddPNode::Base)->is_top() &&
        // Are there other uses besides address expressions?
        !is_visited(adr)) {
      address_visited.set(adr->_idx); // Flag as address_visited
      Node *shift = adr->in(AddPNode::Offset);
      if (!clone_shift(shift, this, mstack, address_visited)) {
        mstack.push(shift, Pre_Visit);
      }
      mstack.push(adr->in(AddPNode::Address), Pre_Visit);
      mstack.push(adr->in(AddPNode::Base), Pre_Visit);
    } else {
      mstack.push(adr, Pre_Visit);
    }

    // Clone X+offset as it also folds into most addressing expressions
    mstack.push(off, Visit);
    mstack.push(m->in(AddPNode::Base), Pre_Visit);
    return true;
  } else if (clone_shift(off, this, mstack, address_visited)) {
    address_visited.test_set(m->_idx); // Flag as address_visited
    mstack.push(m->in(AddPNode::Address), Pre_Visit);
    mstack.push(m->in(AddPNode::Base), Pre_Visit);
    return true;
  }
  return false;
}

void Compile::reshape_address(AddPNode* addp) {
}

// Helper methods for MachSpillCopyNode::implementation().
static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
                          int src_hi, int dst_hi, uint ireg, outputStream* st) {
  // In 64-bit VM size calculation is very complex. Emitting instructions
  // into scratch buffer is used to get size in 64-bit VM.
  LP64_ONLY( assert(!do_size, "this method calculates size only for 32-bit VM"); )
  assert(ireg == Op_VecS || // 32bit vector
         (src_lo & 1) == 0 && (src_lo + 1) == src_hi &&
         (dst_lo & 1) == 0 && (dst_lo + 1) == dst_hi,
         "no non-adjacent vector moves" );
  if (cbuf) {
    MacroAssembler _masm(cbuf);
    int offset = __ offset();
    switch (ireg) {
    case Op_VecS: // copy whole register
    case Op_VecD:
    case Op_VecX:
      __ movdqu(as_XMMRegister(Matcher::_regEncode[dst_lo]), as_XMMRegister(Matcher::_regEncode[src_lo]));
      break;
    case Op_VecY:
      __ vmovdqu(as_XMMRegister(Matcher::_regEncode[dst_lo]), as_XMMRegister(Matcher::_regEncode[src_lo]));
      break;
    case Op_VecZ:
      __ evmovdquq(as_XMMRegister(Matcher::_regEncode[dst_lo]), as_XMMRegister(Matcher::_regEncode[src_lo]), 2);
      break;
    default:
      ShouldNotReachHere();
    }
    int size = __ offset() - offset;
#ifdef ASSERT
    // VEX_2bytes prefix is used if UseAVX > 0, so it takes the same 2 bytes as SIMD prefix.
    assert(!do_size || size == 4, "incorrect size calculattion");
#endif
    return size;
#ifndef PRODUCT
  } else if (!do_size) {
    switch (ireg) {
    case Op_VecS:
    case Op_VecD:
    case Op_VecX:
      st->print("movdqu  %s,%s\t# spill",Matcher::regName[dst_lo],Matcher::regName[src_lo]);
      break;
    case Op_VecY:
    case Op_VecZ:
      st->print("vmovdqu %s,%s\t# spill",Matcher::regName[dst_lo],Matcher::regName[src_lo]);
      break;
    default:
      ShouldNotReachHere();
    }
#endif
  }
  // VEX_2bytes prefix is used if UseAVX > 0, and it takes the same 2 bytes as SIMD prefix.
  return (UseAVX > 2) ? 6 : 4;
}

static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
                            int stack_offset, int reg, uint ireg, outputStream* st) {
  // In 64-bit VM size calculation is very complex. Emitting instructions
  // into scratch buffer is used to get size in 64-bit VM.
  LP64_ONLY( assert(!do_size, "this method calculates size only for 32-bit VM"); )
  if (cbuf) {
    MacroAssembler _masm(cbuf);
    int offset = __ offset();
    if (is_load) {
      switch (ireg) {
      case Op_VecS:
        __ movdl(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));
        break;
      case Op_VecD:
        __ movq(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));
        break;
      case Op_VecX:
        __ movdqu(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));
        break;
      case Op_VecY:
        __ vmovdqu(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));
        break;
      case Op_VecZ:
        __ evmovdquq(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset), 2);
        break;
      default:
        ShouldNotReachHere();
      }
    } else { // store
      switch (ireg) {
      case Op_VecS:
        __ movdl(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]));
        break;
      case Op_VecD:
        __ movq(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]));
        break;
      case Op_VecX:
        __ movdqu(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]));
        break;
      case Op_VecY:
        __ vmovdqu(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]));
        break;
      case Op_VecZ:
        __ evmovdquq(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]), 2);
        break;
      default:
        ShouldNotReachHere();
      }
    }
    int size = __ offset() - offset;
#ifdef ASSERT
    int offset_size = (stack_offset == 0) ? 0 : ((stack_offset < 0x80) ? 1 : (UseAVX > 2) ? 6 : 4);
    // VEX_2bytes prefix is used if UseAVX > 0, so it takes the same 2 bytes as SIMD prefix.
    assert(!do_size || size == (5+offset_size), "incorrect size calculattion");
#endif
    return size;
#ifndef PRODUCT
  } else if (!do_size) {
    if (is_load) {
      switch (ireg) {
      case Op_VecS:
        st->print("movd    %s,[rsp + %d]\t# spill", Matcher::regName[reg], stack_offset);
        break;
      case Op_VecD:
        st->print("movq    %s,[rsp + %d]\t# spill", Matcher::regName[reg], stack_offset);
        break;
       case Op_VecX:
        st->print("movdqu  %s,[rsp + %d]\t# spill", Matcher::regName[reg], stack_offset);
        break;
      case Op_VecY:
      case Op_VecZ:
        st->print("vmovdqu %s,[rsp + %d]\t# spill", Matcher::regName[reg], stack_offset);
        break;
      default:
        ShouldNotReachHere();
      }
    } else { // store
      switch (ireg) {
      case Op_VecS:
        st->print("movd    [rsp + %d],%s\t# spill", stack_offset, Matcher::regName[reg]);
        break;
      case Op_VecD:
        st->print("movq    [rsp + %d],%s\t# spill", stack_offset, Matcher::regName[reg]);
        break;
       case Op_VecX:
        st->print("movdqu  [rsp + %d],%s\t# spill", stack_offset, Matcher::regName[reg]);
        break;
      case Op_VecY:
      case Op_VecZ:
        st->print("vmovdqu [rsp + %d],%s\t# spill", stack_offset, Matcher::regName[reg]);
        break;
      default:
        ShouldNotReachHere();
      }
    }
#endif
  }
  bool is_single_byte = false;
  int vec_len = 0;
  if ((UseAVX > 2) && (stack_offset != 0)) {
    int tuple_type = Assembler::EVEX_FVM;
    int input_size = Assembler::EVEX_32bit;
    switch (ireg) {
    case Op_VecS:
      tuple_type = Assembler::EVEX_T1S;
      break;
    case Op_VecD:
      tuple_type = Assembler::EVEX_T1S;
      input_size = Assembler::EVEX_64bit;
      break;
    case Op_VecX:
      break;
    case Op_VecY:
      vec_len = 1;
      break;
    case Op_VecZ:
      vec_len = 2;
      break;
    }
    is_single_byte = Assembler::query_compressed_disp_byte(stack_offset, true, vec_len, tuple_type, input_size, 0);
  }
  int offset_size = 0;
  int size = 5;
  if (UseAVX > 2 ) {
    if (VM_Version::supports_avx512novl() && (vec_len == 2)) {
      offset_size = (stack_offset == 0) ? 0 : ((is_single_byte) ? 1 : 4);
      size += 2; // Need an additional two bytes for EVEX encoding
    } else if (VM_Version::supports_avx512novl() && (vec_len < 2)) {
      offset_size = (stack_offset == 0) ? 0 : ((stack_offset <= 127) ? 1 : 4);
    } else {
      offset_size = (stack_offset == 0) ? 0 : ((is_single_byte) ? 1 : 4);
      size += 2; // Need an additional two bytes for EVEX encodding
    }
  } else {
    offset_size = (stack_offset == 0) ? 0 : ((stack_offset <= 127) ? 1 : 4);
  }
  // VEX_2bytes prefix is used if UseAVX > 0, so it takes the same 2 bytes as SIMD prefix.
  return size+offset_size;
}

static inline jint replicate4_imm(int con, int width) {
  // Load a constant of "width" (in bytes) and replicate it to fill 32bit.
  assert(width == 1 || width == 2, "only byte or short types here");
  int bit_width = width * 8;
  jint val = con;
  val &= (1 << bit_width) - 1;  // mask off sign bits
  while(bit_width < 32) {
    val |= (val << bit_width);
    bit_width <<= 1;
  }
  return val;
}

static inline jlong replicate8_imm(int con, int width) {
  // Load a constant of "width" (in bytes) and replicate it to fill 64bit.
  assert(width == 1 || width == 2 || width == 4, "only byte, short or int types here");
  int bit_width = width * 8;
  jlong val = con;
  val &= (((jlong) 1) << bit_width) - 1;  // mask off sign bits
  while(bit_width < 64) {
    val |= (val << bit_width);
    bit_width <<= 1;
  }
  return val;
}

#ifndef PRODUCT
  void MachNopNode::format(PhaseRegAlloc*, outputStream* st) const {
    st->print("nop \t# %d bytes pad for loops and calls", _count);
  }
#endif

  void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc*) const {
    MacroAssembler _masm(&cbuf);
    __ nop(_count);
  }

  uint MachNopNode::size(PhaseRegAlloc*) const {
    return _count;
  }

#ifndef PRODUCT
  void MachBreakpointNode::format(PhaseRegAlloc*, outputStream* st) const {
    st->print("# breakpoint");
  }
#endif

  void MachBreakpointNode::emit(CodeBuffer &cbuf, PhaseRegAlloc* ra_) const {
    MacroAssembler _masm(&cbuf);
    __ int3();
  }

  uint MachBreakpointNode::size(PhaseRegAlloc* ra_) const {
    return MachNode::size(ra_);
  }


#line 1924 "ad_x86.cpp"


#ifndef PRODUCT
void Compile::adlc_verification() {

  // Following assertions generated from definition section
}
#endif

// Map from machine-independent register number to register_save_policy
const        char register_save_policy[] = {
  'C', // R10
  'C', // R10_H
  'C', // R11
  'C', // R11_H
  'C', // R8
  'C', // R8_H
  'C', // R9
  'C', // R9_H
  'C', // R12
  'C', // R12_H
  'C', // RCX
  'C', // RCX_H
  'C', // RBX
  'C', // RBX_H
  'C', // RDI
  'C', // RDI_H
  'C', // RDX
  'C', // RDX_H
  'C', // RSI
  'C', // RSI_H
  'C', // RAX
  'C', // RAX_H
  'N', // RBP
  'N', // RBP_H
  'C', // R13
  'C', // R13_H
  'C', // R14
  'C', // R14_H
  'C', // R15
  'C', // R15_H
  'N', // RSP
  'N', // RSP_H
  'C', // XMM0
  'C', // XMM0b
  'C', // XMM0c
  'C', // XMM0d
  'C', // XMM0e
  'C', // XMM0f
  'C', // XMM0g
  'C', // XMM0h
  'C', // XMM0i
  'C', // XMM0j
  'C', // XMM0k
  'C', // XMM0l
  'C', // XMM0m
  'C', // XMM0n
  'C', // XMM0o
  'C', // XMM0p
  'C', // XMM1
  'C', // XMM1b
  'C', // XMM1c
  'C', // XMM1d
  'C', // XMM1e
  'C', // XMM1f
  'C', // XMM1g
  'C', // XMM1h
  'C', // XMM1i
  'C', // XMM1j
  'C', // XMM1k
  'C', // XMM1l
  'C', // XMM1m
  'C', // XMM1n
  'C', // XMM1o
  'C', // XMM1p
  'C', // XMM2
  'C', // XMM2b
  'C', // XMM2c
  'C', // XMM2d
  'C', // XMM2e
  'C', // XMM2f
  'C', // XMM2g
  'C', // XMM2h
  'C', // XMM2i
  'C', // XMM2j
  'C', // XMM2k
  'C', // XMM2l
  'C', // XMM2m
  'C', // XMM2n
  'C', // XMM2o
  'C', // XMM2p
  'C', // XMM3
  'C', // XMM3b
  'C', // XMM3c
  'C', // XMM3d
  'C', // XMM3e
  'C', // XMM3f
  'C', // XMM3g
  'C', // XMM3h
  'C', // XMM3i
  'C', // XMM3j
  'C', // XMM3k
  'C', // XMM3l
  'C', // XMM3m
  'C', // XMM3n
  'C', // XMM3o
  'C', // XMM3p
  'C', // XMM4
  'C', // XMM4b
  'C', // XMM4c
  'C', // XMM4d
  'C', // XMM4e
  'C', // XMM4f
  'C', // XMM4g
  'C', // XMM4h
  'C', // XMM4i
  'C', // XMM4j
  'C', // XMM4k
  'C', // XMM4l
  'C', // XMM4m
  'C', // XMM4n
  'C', // XMM4o
  'C', // XMM4p
  'C', // XMM5
  'C', // XMM5b
  'C', // XMM5c
  'C', // XMM5d
  'C', // XMM5e
  'C', // XMM5f
  'C', // XMM5g
  'C', // XMM5h
  'C', // XMM5i
  'C', // XMM5j
  'C', // XMM5k
  'C', // XMM5l
  'C', // XMM5m
  'C', // XMM5n
  'C', // XMM5o
  'C', // XMM5p
  'C', // XMM6
  'C', // XMM6b
  'C', // XMM6c
  'C', // XMM6d
  'C', // XMM6e
  'C', // XMM6f
  'C', // XMM6g
  'C', // XMM6h
  'C', // XMM6i
  'C', // XMM6j
  'C', // XMM6k
  'C', // XMM6l
  'C', // XMM6m
  'C', // XMM6n
  'C', // XMM6o
  'C', // XMM6p
  'C', // XMM7
  'C', // XMM7b
  'C', // XMM7c
  'C', // XMM7d
  'C', // XMM7e
  'C', // XMM7f
  'C', // XMM7g
  'C', // XMM7h
  'C', // XMM7i
  'C', // XMM7j
  'C', // XMM7k
  'C', // XMM7l
  'C', // XMM7m
  'C', // XMM7n
  'C', // XMM7o
  'C', // XMM7p
  'C', // XMM8
  'C', // XMM8b
  'C', // XMM8c
  'C', // XMM8d
  'C', // XMM8e
  'C', // XMM8f
  'C', // XMM8g
  'C', // XMM8h
  'C', // XMM8i
  'C', // XMM8j
  'C', // XMM8k
  'C', // XMM8l
  'C', // XMM8m
  'C', // XMM8n
  'C', // XMM8o
  'C', // XMM8p
  'C', // XMM9
  'C', // XMM9b
  'C', // XMM9c
  'C', // XMM9d
  'C', // XMM9e
  'C', // XMM9f
  'C', // XMM9g
  'C', // XMM9h
  'C', // XMM9i
  'C', // XMM9j
  'C', // XMM9k
  'C', // XMM9l
  'C', // XMM9m
  'C', // XMM9n
  'C', // XMM9o
  'C', // XMM9p
  'C', // XMM10
  'C', // XMM10b
  'C', // XMM10c
  'C', // XMM10d
  'C', // XMM10e
  'C', // XMM10f
  'C', // XMM10g
  'C', // XMM10h
  'C', // XMM10i
  'C', // XMM10j
  'C', // XMM10k
  'C', // XMM10l
  'C', // XMM10m
  'C', // XMM10n
  'C', // XMM10o
  'C', // XMM10p
  'C', // XMM11
  'C', // XMM11b
  'C', // XMM11c
  'C', // XMM11d
  'C', // XMM11e
  'C', // XMM11f
  'C', // XMM11g
  'C', // XMM11h
  'C', // XMM11i
  'C', // XMM11j
  'C', // XMM11k
  'C', // XMM11l
  'C', // XMM11m
  'C', // XMM11n
  'C', // XMM11o
  'C', // XMM11p
  'C', // XMM12
  'C', // XMM12b
  'C', // XMM12c
  'C', // XMM12d
  'C', // XMM12e
  'C', // XMM12f
  'C', // XMM12g
  'C', // XMM12h
  'C', // XMM12i
  'C', // XMM12j
  'C', // XMM12k
  'C', // XMM12l
  'C', // XMM12m
  'C', // XMM12n
  'C', // XMM12o
  'C', // XMM12p
  'C', // XMM13
  'C', // XMM13b
  'C', // XMM13c
  'C', // XMM13d
  'C', // XMM13e
  'C', // XMM13f
  'C', // XMM13g
  'C', // XMM13h
  'C', // XMM13i
  'C', // XMM13j
  'C', // XMM13k
  'C', // XMM13l
  'C', // XMM13m
  'C', // XMM13n
  'C', // XMM13o
  'C', // XMM13p
  'C', // XMM14
  'C', // XMM14b
  'C', // XMM14c
  'C', // XMM14d
  'C', // XMM14e
  'C', // XMM14f
  'C', // XMM14g
  'C', // XMM14h
  'C', // XMM14i
  'C', // XMM14j
  'C', // XMM14k
  'C', // XMM14l
  'C', // XMM14m
  'C', // XMM14n
  'C', // XMM14o
  'C', // XMM14p
  'C', // XMM15
  'C', // XMM15b
  'C', // XMM15c
  'C', // XMM15d
  'C', // XMM15e
  'C', // XMM15f
  'C', // XMM15g
  'C', // XMM15h
  'C', // XMM15i
  'C', // XMM15j
  'C', // XMM15k
  'C', // XMM15l
  'C', // XMM15m
  'C', // XMM15n
  'C', // XMM15o
  'C', // XMM15p
  'C', // XMM16
  'C', // XMM16b
  'C', // XMM16c
  'C', // XMM16d
  'C', // XMM16e
  'C', // XMM16f
  'C', // XMM16g
  'C', // XMM16h
  'C', // XMM16i
  'C', // XMM16j
  'C', // XMM16k
  'C', // XMM16l
  'C', // XMM16m
  'C', // XMM16n
  'C', // XMM16o
  'C', // XMM16p
  'C', // XMM17
  'C', // XMM17b
  'C', // XMM17c
  'C', // XMM17d
  'C', // XMM17e
  'C', // XMM17f
  'C', // XMM17g
  'C', // XMM17h
  'C', // XMM17i
  'C', // XMM17j
  'C', // XMM17k
  'C', // XMM17l
  'C', // XMM17m
  'C', // XMM17n
  'C', // XMM17o
  'C', // XMM17p
  'C', // XMM18
  'C', // XMM18b
  'C', // XMM18c
  'C', // XMM18d
  'C', // XMM18e
  'C', // XMM18f
  'C', // XMM18g
  'C', // XMM18h
  'C', // XMM18i
  'C', // XMM18j
  'C', // XMM18k
  'C', // XMM18l
  'C', // XMM18m
  'C', // XMM18n
  'C', // XMM18o
  'C', // XMM18p
  'C', // XMM19
  'C', // XMM19b
  'C', // XMM19c
  'C', // XMM19d
  'C', // XMM19e
  'C', // XMM19f
  'C', // XMM19g
  'C', // XMM19h
  'C', // XMM19i
  'C', // XMM19j
  'C', // XMM19k
  'C', // XMM19l
  'C', // XMM19m
  'C', // XMM19n
  'C', // XMM19o
  'C', // XMM19p
  'C', // XMM20
  'C', // XMM20b
  'C', // XMM20c
  'C', // XMM20d
  'C', // XMM20e
  'C', // XMM20f
  'C', // XMM20g
  'C', // XMM20h
  'C', // XMM20i
  'C', // XMM20j
  'C', // XMM20k
  'C', // XMM20l
  'C', // XMM20m
  'C', // XMM20n
  'C', // XMM20o
  'C', // XMM20p
  'C', // XMM21
  'C', // XMM21b
  'C', // XMM21c
  'C', // XMM21d
  'C', // XMM21e
  'C', // XMM21f
  'C', // XMM21g
  'C', // XMM21h
  'C', // XMM21i
  'C', // XMM21j
  'C', // XMM21k
  'C', // XMM21l
  'C', // XMM21m
  'C', // XMM21n
  'C', // XMM21o
  'C', // XMM21p
  'C', // XMM22
  'C', // XMM22b
  'C', // XMM22c
  'C', // XMM22d
  'C', // XMM22e
  'C', // XMM22f
  'C', // XMM22g
  'C', // XMM22h
  'C', // XMM22i
  'C', // XMM22j
  'C', // XMM22k
  'C', // XMM22l
  'C', // XMM22m
  'C', // XMM22n
  'C', // XMM22o
  'C', // XMM22p
  'C', // XMM23
  'C', // XMM23b
  'C', // XMM23c
  'C', // XMM23d
  'C', // XMM23e
  'C', // XMM23f
  'C', // XMM23g
  'C', // XMM23h
  'C', // XMM23i
  'C', // XMM23j
  'C', // XMM23k
  'C', // XMM23l
  'C', // XMM23m
  'C', // XMM23n
  'C', // XMM23o
  'C', // XMM23p
  'C', // XMM24
  'C', // XMM24b
  'C', // XMM24c
  'C', // XMM24d
  'C', // XMM24e
  'C', // XMM24f
  'C', // XMM24g
  'C', // XMM24h
  'C', // XMM24i
  'C', // XMM24j
  'C', // XMM24k
  'C', // XMM24l
  'C', // XMM24m
  'C', // XMM24n
  'C', // XMM24o
  'C', // XMM24p
  'C', // XMM25
  'C', // XMM25b
  'C', // XMM25c
  'C', // XMM25d
  'C', // XMM25e
  'C', // XMM25f
  'C', // XMM25g
  'C', // XMM25h
  'C', // XMM25i
  'C', // XMM25j
  'C', // XMM25k
  'C', // XMM25l
  'C', // XMM25m
  'C', // XMM25n
  'C', // XMM25o
  'C', // XMM25p
  'C', // XMM26
  'C', // XMM26b
  'C', // XMM26c
  'C', // XMM26d
  'C', // XMM26e
  'C', // XMM26f
  'C', // XMM26g
  'C', // XMM26h
  'C', // XMM26i
  'C', // XMM26j
  'C', // XMM26k
  'C', // XMM26l
  'C', // XMM26m
  'C', // XMM26n
  'C', // XMM26o
  'C', // XMM26p
  'C', // XMM27
  'C', // XMM27b
  'C', // XMM27c
  'C', // XMM27d
  'C', // XMM27e
  'C', // XMM27f
  'C', // XMM27g
  'C', // XMM27h
  'C', // XMM27i
  'C', // XMM27j
  'C', // XMM27k
  'C', // XMM27l
  'C', // XMM27m
  'C', // XMM27n
  'C', // XMM27o
  'C', // XMM27p
  'C', // XMM28
  'C', // XMM28b
  'C', // XMM28c
  'C', // XMM28d
  'C', // XMM28e
  'C', // XMM28f
  'C', // XMM28g
  'C', // XMM28h
  'C', // XMM28i
  'C', // XMM28j
  'C', // XMM28k
  'C', // XMM28l
  'C', // XMM28m
  'C', // XMM28n
  'C', // XMM28o
  'C', // XMM28p
  'C', // XMM29
  'C', // XMM29b
  'C', // XMM29c
  'C', // XMM29d
  'C', // XMM29e
  'C', // XMM29f
  'C', // XMM29g
  'C', // XMM29h
  'C', // XMM29i
  'C', // XMM29j
  'C', // XMM29k
  'C', // XMM29l
  'C', // XMM29m
  'C', // XMM29n
  'C', // XMM29o
  'C', // XMM29p
  'C', // XMM30
  'C', // XMM30b
  'C', // XMM30c
  'C', // XMM30d
  'C', // XMM30e
  'C', // XMM30f
  'C', // XMM30g
  'C', // XMM30h
  'C', // XMM30i
  'C', // XMM30j
  'C', // XMM30k
  'C', // XMM30l
  'C', // XMM30m
  'C', // XMM30n
  'C', // XMM30o
  'C', // XMM30p
  'C', // XMM31
  'C', // XMM31b
  'C', // XMM31c
  'C', // XMM31d
  'C', // XMM31e
  'C', // XMM31f
  'C', // XMM31g
  'C', // XMM31h
  'C', // XMM31i
  'C', // XMM31j
  'C', // XMM31k
  'C', // XMM31l
  'C', // XMM31m
  'C', // XMM31n
  'C', // XMM31o
  'C', // XMM31p
  'C' // no trailing comma // RFLAGS
};

// Map from machine-independent register number to c_reg_save_policy
const        char c_reg_save_policy[] = {
  'C', // R10
  'C', // R10_H
  'C', // R11
  'C', // R11_H
  'C', // R8
  'C', // R8_H
  'C', // R9
  'C', // R9_H
  'E', // R12
  'E', // R12_H
  'C', // RCX
  'C', // RCX_H
  'E', // RBX
  'E', // RBX_H
  'C', // RDI
  'C', // RDI_H
  'C', // RDX
  'C', // RDX_H
  'C', // RSI
  'C', // RSI_H
  'C', // RAX
  'C', // RAX_H
  'E', // RBP
  'E', // RBP_H
  'E', // R13
  'E', // R13_H
  'E', // R14
  'E', // R14_H
  'E', // R15
  'E', // R15_H
  'N', // RSP
  'N', // RSP_H
  'C', // XMM0
  'C', // XMM0b
  'C', // XMM0c
  'C', // XMM0d
  'C', // XMM0e
  'C', // XMM0f
  'C', // XMM0g
  'C', // XMM0h
  'C', // XMM0i
  'C', // XMM0j
  'C', // XMM0k
  'C', // XMM0l
  'C', // XMM0m
  'C', // XMM0n
  'C', // XMM0o
  'C', // XMM0p
  'C', // XMM1
  'C', // XMM1b
  'C', // XMM1c
  'C', // XMM1d
  'C', // XMM1e
  'C', // XMM1f
  'C', // XMM1g
  'C', // XMM1h
  'C', // XMM1i
  'C', // XMM1j
  'C', // XMM1k
  'C', // XMM1l
  'C', // XMM1m
  'C', // XMM1n
  'C', // XMM1o
  'C', // XMM1p
  'C', // XMM2
  'C', // XMM2b
  'C', // XMM2c
  'C', // XMM2d
  'C', // XMM2e
  'C', // XMM2f
  'C', // XMM2g
  'C', // XMM2h
  'C', // XMM2i
  'C', // XMM2j
  'C', // XMM2k
  'C', // XMM2l
  'C', // XMM2m
  'C', // XMM2n
  'C', // XMM2o
  'C', // XMM2p
  'C', // XMM3
  'C', // XMM3b
  'C', // XMM3c
  'C', // XMM3d
  'C', // XMM3e
  'C', // XMM3f
  'C', // XMM3g
  'C', // XMM3h
  'C', // XMM3i
  'C', // XMM3j
  'C', // XMM3k
  'C', // XMM3l
  'C', // XMM3m
  'C', // XMM3n
  'C', // XMM3o
  'C', // XMM3p
  'C', // XMM4
  'C', // XMM4b
  'C', // XMM4c
  'C', // XMM4d
  'C', // XMM4e
  'C', // XMM4f
  'C', // XMM4g
  'C', // XMM4h
  'C', // XMM4i
  'C', // XMM4j
  'C', // XMM4k
  'C', // XMM4l
  'C', // XMM4m
  'C', // XMM4n
  'C', // XMM4o
  'C', // XMM4p
  'C', // XMM5
  'C', // XMM5b
  'C', // XMM5c
  'C', // XMM5d
  'C', // XMM5e
  'C', // XMM5f
  'C', // XMM5g
  'C', // XMM5h
  'C', // XMM5i
  'C', // XMM5j
  'C', // XMM5k
  'C', // XMM5l
  'C', // XMM5m
  'C', // XMM5n
  'C', // XMM5o
  'C', // XMM5p
  'C', // XMM6
  'C', // XMM6b
  'C', // XMM6c
  'C', // XMM6d
  'C', // XMM6e
  'C', // XMM6f
  'C', // XMM6g
  'C', // XMM6h
  'C', // XMM6i
  'C', // XMM6j
  'C', // XMM6k
  'C', // XMM6l
  'C', // XMM6m
  'C', // XMM6n
  'C', // XMM6o
  'C', // XMM6p
  'C', // XMM7
  'C', // XMM7b
  'C', // XMM7c
  'C', // XMM7d
  'C', // XMM7e
  'C', // XMM7f
  'C', // XMM7g
  'C', // XMM7h
  'C', // XMM7i
  'C', // XMM7j
  'C', // XMM7k
  'C', // XMM7l
  'C', // XMM7m
  'C', // XMM7n
  'C', // XMM7o
  'C', // XMM7p
  'C', // XMM8
  'C', // XMM8b
  'C', // XMM8c
  'C', // XMM8d
  'C', // XMM8e
  'C', // XMM8f
  'C', // XMM8g
  'C', // XMM8h
  'C', // XMM8i
  'C', // XMM8j
  'C', // XMM8k
  'C', // XMM8l
  'C', // XMM8m
  'C', // XMM8n
  'C', // XMM8o
  'C', // XMM8p
  'C', // XMM9
  'C', // XMM9b
  'C', // XMM9c
  'C', // XMM9d
  'C', // XMM9e
  'C', // XMM9f
  'C', // XMM9g
  'C', // XMM9h
  'C', // XMM9i
  'C', // XMM9j
  'C', // XMM9k
  'C', // XMM9l
  'C', // XMM9m
  'C', // XMM9n
  'C', // XMM9o
  'C', // XMM9p
  'C', // XMM10
  'C', // XMM10b
  'C', // XMM10c
  'C', // XMM10d
  'C', // XMM10e
  'C', // XMM10f
  'C', // XMM10g
  'C', // XMM10h
  'C', // XMM10i
  'C', // XMM10j
  'C', // XMM10k
  'C', // XMM10l
  'C', // XMM10m
  'C', // XMM10n
  'C', // XMM10o
  'C', // XMM10p
  'C', // XMM11
  'C', // XMM11b
  'C', // XMM11c
  'C', // XMM11d
  'C', // XMM11e
  'C', // XMM11f
  'C', // XMM11g
  'C', // XMM11h
  'C', // XMM11i
  'C', // XMM11j
  'C', // XMM11k
  'C', // XMM11l
  'C', // XMM11m
  'C', // XMM11n
  'C', // XMM11o
  'C', // XMM11p
  'C', // XMM12
  'C', // XMM12b
  'C', // XMM12c
  'C', // XMM12d
  'C', // XMM12e
  'C', // XMM12f
  'C', // XMM12g
  'C', // XMM12h
  'C', // XMM12i
  'C', // XMM12j
  'C', // XMM12k
  'C', // XMM12l
  'C', // XMM12m
  'C', // XMM12n
  'C', // XMM12o
  'C', // XMM12p
  'C', // XMM13
  'C', // XMM13b
  'C', // XMM13c
  'C', // XMM13d
  'C', // XMM13e
  'C', // XMM13f
  'C', // XMM13g
  'C', // XMM13h
  'C', // XMM13i
  'C', // XMM13j
  'C', // XMM13k
  'C', // XMM13l
  'C', // XMM13m
  'C', // XMM13n
  'C', // XMM13o
  'C', // XMM13p
  'C', // XMM14
  'C', // XMM14b
  'C', // XMM14c
  'C', // XMM14d
  'C', // XMM14e
  'C', // XMM14f
  'C', // XMM14g
  'C', // XMM14h
  'C', // XMM14i
  'C', // XMM14j
  'C', // XMM14k
  'C', // XMM14l
  'C', // XMM14m
  'C', // XMM14n
  'C', // XMM14o
  'C', // XMM14p
  'C', // XMM15
  'C', // XMM15b
  'C', // XMM15c
  'C', // XMM15d
  'C', // XMM15e
  'C', // XMM15f
  'C', // XMM15g
  'C', // XMM15h
  'C', // XMM15i
  'C', // XMM15j
  'C', // XMM15k
  'C', // XMM15l
  'C', // XMM15m
  'C', // XMM15n
  'C', // XMM15o
  'C', // XMM15p
  'C', // XMM16
  'C', // XMM16b
  'C', // XMM16c
  'C', // XMM16d
  'C', // XMM16e
  'C', // XMM16f
  'C', // XMM16g
  'C', // XMM16h
  'C', // XMM16i
  'C', // XMM16j
  'C', // XMM16k
  'C', // XMM16l
  'C', // XMM16m
  'C', // XMM16n
  'C', // XMM16o
  'C', // XMM16p
  'C', // XMM17
  'C', // XMM17b
  'C', // XMM17c
  'C', // XMM17d
  'C', // XMM17e
  'C', // XMM17f
  'C', // XMM17g
  'C', // XMM17h
  'C', // XMM17i
  'C', // XMM17j
  'C', // XMM17k
  'C', // XMM17l
  'C', // XMM17m
  'C', // XMM17n
  'C', // XMM17o
  'C', // XMM17p
  'C', // XMM18
  'C', // XMM18b
  'C', // XMM18c
  'C', // XMM18d
  'C', // XMM18e
  'C', // XMM18f
  'C', // XMM18g
  'C', // XMM18h
  'C', // XMM18i
  'C', // XMM18j
  'C', // XMM18k
  'C', // XMM18l
  'C', // XMM18m
  'C', // XMM18n
  'C', // XMM18o
  'C', // XMM18p
  'C', // XMM19
  'C', // XMM19b
  'C', // XMM19c
  'C', // XMM19d
  'C', // XMM19e
  'C', // XMM19f
  'C', // XMM19g
  'C', // XMM19h
  'C', // XMM19i
  'C', // XMM19j
  'C', // XMM19k
  'C', // XMM19l
  'C', // XMM19m
  'C', // XMM19n
  'C', // XMM19o
  'C', // XMM19p
  'C', // XMM20
  'C', // XMM20b
  'C', // XMM20c
  'C', // XMM20d
  'C', // XMM20e
  'C', // XMM20f
  'C', // XMM20g
  'C', // XMM20h
  'C', // XMM20i
  'C', // XMM20j
  'C', // XMM20k
  'C', // XMM20l
  'C', // XMM20m
  'C', // XMM20n
  'C', // XMM20o
  'C', // XMM20p
  'C', // XMM21
  'C', // XMM21b
  'C', // XMM21c
  'C', // XMM21d
  'C', // XMM21e
  'C', // XMM21f
  'C', // XMM21g
  'C', // XMM21h
  'C', // XMM21i
  'C', // XMM21j
  'C', // XMM21k
  'C', // XMM21l
  'C', // XMM21m
  'C', // XMM21n
  'C', // XMM21o
  'C', // XMM21p
  'C', // XMM22
  'C', // XMM22b
  'C', // XMM22c
  'C', // XMM22d
  'C', // XMM22e
  'C', // XMM22f
  'C', // XMM22g
  'C', // XMM22h
  'C', // XMM22i
  'C', // XMM22j
  'C', // XMM22k
  'C', // XMM22l
  'C', // XMM22m
  'C', // XMM22n
  'C', // XMM22o
  'C', // XMM22p
  'C', // XMM23
  'C', // XMM23b
  'C', // XMM23c
  'C', // XMM23d
  'C', // XMM23e
  'C', // XMM23f
  'C', // XMM23g
  'C', // XMM23h
  'C', // XMM23i
  'C', // XMM23j
  'C', // XMM23k
  'C', // XMM23l
  'C', // XMM23m
  'C', // XMM23n
  'C', // XMM23o
  'C', // XMM23p
  'C', // XMM24
  'C', // XMM24b
  'C', // XMM24c
  'C', // XMM24d
  'C', // XMM24e
  'C', // XMM24f
  'C', // XMM24g
  'C', // XMM24h
  'C', // XMM24i
  'C', // XMM24j
  'C', // XMM24k
  'C', // XMM24l
  'C', // XMM24m
  'C', // XMM24n
  'C', // XMM24o
  'C', // XMM24p
  'C', // XMM25
  'C', // XMM25b
  'C', // XMM25c
  'C', // XMM25d
  'C', // XMM25e
  'C', // XMM25f
  'C', // XMM25g
  'C', // XMM25h
  'C', // XMM25i
  'C', // XMM25j
  'C', // XMM25k
  'C', // XMM25l
  'C', // XMM25m
  'C', // XMM25n
  'C', // XMM25o
  'C', // XMM25p
  'C', // XMM26
  'C', // XMM26b
  'C', // XMM26c
  'C', // XMM26d
  'C', // XMM26e
  'C', // XMM26f
  'C', // XMM26g
  'C', // XMM26h
  'C', // XMM26i
  'C', // XMM26j
  'C', // XMM26k
  'C', // XMM26l
  'C', // XMM26m
  'C', // XMM26n
  'C', // XMM26o
  'C', // XMM26p
  'C', // XMM27
  'C', // XMM27b
  'C', // XMM27c
  'C', // XMM27d
  'C', // XMM27e
  'C', // XMM27f
  'C', // XMM27g
  'C', // XMM27h
  'C', // XMM27i
  'C', // XMM27j
  'C', // XMM27k
  'C', // XMM27l
  'C', // XMM27m
  'C', // XMM27n
  'C', // XMM27o
  'C', // XMM27p
  'C', // XMM28
  'C', // XMM28b
  'C', // XMM28c
  'C', // XMM28d
  'C', // XMM28e
  'C', // XMM28f
  'C', // XMM28g
  'C', // XMM28h
  'C', // XMM28i
  'C', // XMM28j
  'C', // XMM28k
  'C', // XMM28l
  'C', // XMM28m
  'C', // XMM28n
  'C', // XMM28o
  'C', // XMM28p
  'C', // XMM29
  'C', // XMM29b
  'C', // XMM29c
  'C', // XMM29d
  'C', // XMM29e
  'C', // XMM29f
  'C', // XMM29g
  'C', // XMM29h
  'C', // XMM29i
  'C', // XMM29j
  'C', // XMM29k
  'C', // XMM29l
  'C', // XMM29m
  'C', // XMM29n
  'C', // XMM29o
  'C', // XMM29p
  'C', // XMM30
  'C', // XMM30b
  'C', // XMM30c
  'C', // XMM30d
  'C', // XMM30e
  'C', // XMM30f
  'C', // XMM30g
  'C', // XMM30h
  'C', // XMM30i
  'C', // XMM30j
  'C', // XMM30k
  'C', // XMM30l
  'C', // XMM30m
  'C', // XMM30n
  'C', // XMM30o
  'C', // XMM30p
  'C', // XMM31
  'C', // XMM31b
  'C', // XMM31c
  'C', // XMM31d
  'C', // XMM31e
  'C', // XMM31f
  'C', // XMM31g
  'C', // XMM31h
  'C', // XMM31i
  'C', // XMM31j
  'C', // XMM31k
  'C', // XMM31l
  'C', // XMM31m
  'C', // XMM31n
  'C', // XMM31o
  'C', // XMM31p
  'C' // no trailing comma // RFLAGS
};

// Map from machine-independent register number to register_save_type
const        int register_save_type[] = {
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  0 // no trailing comma
};


const        int   reduceOp[] = {
  /*    0 */  0,
  /*    1 */  0,
  /*    2 */  0,
  /*    3 */  0,
  /*    4 */  0,
  /*    5 */  0,
  /*    6 */  0,
  /*    7 */  0,
  /*    8 */  immI_rule,
  /*    9 */  immI0_rule,
  /*   10 */  immI1_rule,
  /*   11 */  immI_M1_rule,
  /*   12 */  immI2_rule,
  /*   13 */  immI8_rule,
  /*   14 */  immU8_rule,
  /*   15 */  immI16_rule,
  /*   16 */  immU31_rule,
  /*   17 */  immI_32_rule,
  /*   18 */  immI_64_rule,
  /*   19 */  immP_rule,
  /*   20 */  immP0_rule,
  /*   21 */  immN_rule,
  /*   22 */  immNKlass_rule,
  /*   23 */  immN0_rule,
  /*   24 */  immP31_rule,
  /*   25 */  immL_rule,
  /*   26 */  immL8_rule,
  /*   27 */  immUL32_rule,
  /*   28 */  immL32_rule,
  /*   29 */  immL0_rule,
  /*   30 */  immL1_rule,
  /*   31 */  immL_M1_rule,
  /*   32 */  immL10_rule,
  /*   33 */  immL_127_rule,
  /*   34 */  immL_32bits_rule,
  /*   35 */  immF0_rule,
  /*   36 */  immF_rule,
  /*   37 */  immD0_rule,
  /*   38 */  immD_rule,
  /*   39 */  immI_16_rule,
  /*   40 */  immI_24_rule,
  /*   41 */  immI_255_rule,
  /*   42 */  immI_65535_rule,
  /*   43 */  immL_255_rule,
  /*   44 */  immL_65535_rule,
  /*   45 */  rRegI_rule,
  /*   46 */  rax_RegI_rule,
  /*   47 */  rbx_RegI_rule,
  /*   48 */  rcx_RegI_rule,
  /*   49 */  rdx_RegI_rule,
  /*   50 */  rdi_RegI_rule,
  /*   51 */  no_rcx_RegI_rule,
  /*   52 */  no_rax_rdx_RegI_rule,
  /*   53 */  any_RegP_rule,
  /*   54 */  rRegP_rule,
  /*   55 */  rRegN_rule,
  /*   56 */  no_rax_RegP_rule,
  /*   57 */  no_rbp_RegP_rule,
  /*   58 */  no_rax_rbx_RegP_rule,
  /*   59 */  rax_RegP_rule,
  /*   60 */  rax_RegN_rule,
  /*   61 */  rbx_RegP_rule,
  /*   62 */  rsi_RegP_rule,
  /*   63 */  rdi_RegP_rule,
  /*   64 */  r15_RegP_rule,
  /*   65 */  rex_RegP_rule,
  /*   66 */  rRegL_rule,
  /*   67 */  no_rax_rdx_RegL_rule,
  /*   68 */  no_rax_RegL_rule,
  /*   69 */  no_rcx_RegL_rule,
  /*   70 */  rax_RegL_rule,
  /*   71 */  rcx_RegL_rule,
  /*   72 */  rdx_RegL_rule,
  /*   73 */  rFlagsReg_rule,
  /*   74 */  rFlagsRegU_rule,
  /*   75 */  rFlagsRegUCF_rule,
  /*   76 */  regF_rule,
  /*   77 */  regD_rule,
  /*   78 */  vecS_rule,
  /*   79 */  vecD_rule,
  /*   80 */  vecX_rule,
  /*   81 */  vecY_rule,
  /*   82 */  indirect_rule,
  /*   83 */  indOffset8_rule,
  /*   84 */  indOffset32_rule,
  /*   85 */  indIndexOffset_rule,
  /*   86 */  indIndex_rule,
  /*   87 */  indIndexScale_rule,
  /*   88 */  indPosIndexScale_rule,
  /*   89 */  indIndexScaleOffset_rule,
  /*   90 */  indPosIndexOffset_rule,
  /*   91 */  indPosIndexScaleOffset_rule,
  /*   92 */  indCompressedOopOffset_rule,
  /*   93 */  indirectNarrow_rule,
  /*   94 */  indOffset8Narrow_rule,
  /*   95 */  indOffset32Narrow_rule,
  /*   96 */  indIndexOffsetNarrow_rule,
  /*   97 */  indIndexNarrow_rule,
  /*   98 */  indIndexScaleNarrow_rule,
  /*   99 */  indIndexScaleOffsetNarrow_rule,
  /*  100 */  indPosIndexOffsetNarrow_rule,
  /*  101 */  indPosIndexScaleOffsetNarrow_rule,
  /*  102 */  stackSlotP_rule,
  /*  103 */  stackSlotI_rule,
  /*  104 */  stackSlotF_rule,
  /*  105 */  stackSlotD_rule,
  /*  106 */  stackSlotL_rule,
  /*  107 */  cmpOp_rule,
  /*  108 */  cmpOpU_rule,
  /*  109 */  cmpOpUCF_rule,
  /*  110 */  cmpOpUCF2_rule,
  /*  111 */  rxmm0_rule,
  /*  112 */  rxmm1_rule,
  /*  113 */  rxmm2_rule,
  /*  114 */  rxmm3_rule,
  /*  115 */  rxmm4_rule,
  /*  116 */  rxmm5_rule,
  /*  117 */  rxmm6_rule,
  /*  118 */  rxmm7_rule,
  /*  119 */  rxmm8_rule,
  /*  120 */  rxmm9_rule,
  /*  121 */  rxmm10_rule,
  /*  122 */  rxmm11_rule,
  /*  123 */  rxmm12_rule,
  /*  124 */  rxmm13_rule,
  /*  125 */  rxmm14_rule,
  /*  126 */  rxmm15_rule,
  /*  127 */  rxmm16_rule,
  /*  128 */  rxmm17_rule,
  /*  129 */  rxmm18_rule,
  /*  130 */  rxmm19_rule,
  /*  131 */  rxmm20_rule,
  /*  132 */  rxmm21_rule,
  /*  133 */  rxmm22_rule,
  /*  134 */  rxmm23_rule,
  /*  135 */  rxmm24_rule,
  /*  136 */  rxmm25_rule,
  /*  137 */  rxmm26_rule,
  /*  138 */  rxmm27_rule,
  /*  139 */  rxmm28_rule,
  /*  140 */  rxmm29_rule,
  /*  141 */  rxmm30_rule,
  /*  142 */  rxmm31_rule,
  /*  143 */  vecZ_rule,
  /*  144 */  cmpOp_vcmppd_rule,
  // last operand
  /*  145 */  memory_rule,
  // last operand class
  /*  146 */  _AddP_any_RegP_rRegL_rule,
  /*  147 */  _LShiftL_rRegL_immI2_rule,
  /*  148 */  _ConvI2L_rRegI__rule,
  /*  149 */  _LShiftL__ConvI2L_rRegI__immI2_rule,
  /*  150 */  _AddP_any_RegP__LShiftL_rRegL_immI2_rule,
  /*  151 */  _AddP_any_RegP__ConvI2L_rRegI__rule,
  /*  152 */  _AddP_any_RegP__LShiftL__ConvI2L_rRegI__immI2_rule,
  /*  153 */  _DecodeN_rRegN__rule,
  /*  154 */  _AddP__DecodeN_rRegN__rRegL_rule,
  /*  155 */  _AddP__DecodeN_rRegN___LShiftL_rRegL_immI2_rule,
  /*  156 */  _AddP__DecodeN_rRegN___ConvI2L_rRegI__rule,
  /*  157 */  _AddP__DecodeN_rRegN___LShiftL__ConvI2L_rRegI__immI2_rule,
  /*  158 */  _LoadB_memory__rule,
  /*  159 */  _LoadUB_memory__rule,
  /*  160 */  _AndI__LoadUB_memory__immI_rule,
  /*  161 */  _LoadS_memory__rule,
  /*  162 */  _LShiftI__LoadS_memory__immI_24_rule,
  /*  163 */  _LoadUS_memory__rule,
  /*  164 */  _LShiftI__LoadUS_memory__immI_24_rule,
  /*  165 */  _AndI__LoadUS_memory__immI_255_rule,
  /*  166 */  _AndI__LoadUS_memory__immI_rule,
  /*  167 */  _LoadI_memory__rule,
  /*  168 */  _LShiftI__LoadI_memory__immI_24_rule,
  /*  169 */  _LShiftI__LoadI_memory__immI_16_rule,
  /*  170 */  _AndI__LoadI_memory__immI_255_rule,
  /*  171 */  _AndI__LoadI_memory__immI_65535_rule,
  /*  172 */  _AndI__LoadI_memory__immU31_rule,
  /*  173 */  _ConvI2L__LoadI_memory___rule,
  /*  174 */  _LoadL_memory__rule,
  /*  175 */  _CastP2X_rRegP__rule,
  /*  176 */  _CastP2X__DecodeN_rRegN___rule,
  /*  177 */  _AddL__LShiftL_rRegL_immI2_immL32_rule,
  /*  178 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  179 */  _Binary_rRegI_rRegI_rule,
  /*  180 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  181 */  _Binary_cmpOpUCF_rFlagsRegUCF_rule,
  /*  182 */  _Binary_rRegI__LoadI_memory__rule,
  /*  183 */  _Binary_rRegN_rRegN_rule,
  /*  184 */  _Binary_rRegP_rRegP_rule,
  /*  185 */  _Binary_rRegL_rRegL_rule,
  /*  186 */  _Binary_rRegL__LoadL_memory__rule,
  /*  187 */  _Binary_regF_regF_rule,
  /*  188 */  _Binary_regD_regD_rule,
  /*  189 */  _AddI__LoadI_memory__rRegI_rule,
  /*  190 */  _AddI_rRegI__LoadI_memory__rule,
  /*  191 */  _AddI__LoadI_memory__immI_rule,
  /*  192 */  _AddI__LoadI_memory__immI1_rule,
  /*  193 */  _AddI__LoadI_memory__immI_M1_rule,
  /*  194 */  _AddL__LoadL_memory__rRegL_rule,
  /*  195 */  _AddL_rRegL__LoadL_memory__rule,
  /*  196 */  _AddL__LoadL_memory__immL32_rule,
  /*  197 */  _AddL__LoadL_memory__immL1_rule,
  /*  198 */  _AddL__LoadL_memory__immL_M1_rule,
  /*  199 */  _Binary_rax_RegP_rRegP_rule,
  /*  200 */  _Binary_rax_RegI_rRegI_rule,
  /*  201 */  _Binary_rax_RegL_rRegL_rule,
  /*  202 */  _Binary_rax_RegN_rRegN_rule,
  /*  203 */  _SubI__LoadI_memory__rRegI_rule,
  /*  204 */  _SubI__LoadI_memory__immI_rule,
  /*  205 */  _SubL__LoadL_memory__rRegL_rule,
  /*  206 */  _SubL__LoadL_memory__immL32_rule,
  /*  207 */  _SubI_immI0_rRegI_rule,
  /*  208 */  _SubI_immI0__LoadI_memory__rule,
  /*  209 */  _SubL_immL0__LoadL_memory__rule,
  /*  210 */  _LShiftI__LoadI_memory__immI1_rule,
  /*  211 */  _LShiftI__LoadI_memory__immI8_rule,
  /*  212 */  _LShiftI__LoadI_memory__rcx_RegI_rule,
  /*  213 */  _RShiftI__LoadI_memory__immI1_rule,
  /*  214 */  _RShiftI__LoadI_memory__immI8_rule,
  /*  215 */  _RShiftI__LoadI_memory__rcx_RegI_rule,
  /*  216 */  _URShiftI__LoadI_memory__immI1_rule,
  /*  217 */  _URShiftI__LoadI_memory__immI8_rule,
  /*  218 */  _URShiftI__LoadI_memory__rcx_RegI_rule,
  /*  219 */  _LShiftL__LoadL_memory__immI1_rule,
  /*  220 */  _LShiftL__LoadL_memory__immI8_rule,
  /*  221 */  _LShiftL__LoadL_memory__rcx_RegI_rule,
  /*  222 */  _RShiftL__LoadL_memory__immI1_rule,
  /*  223 */  _RShiftL__LoadL_memory__immI8_rule,
  /*  224 */  _RShiftL__LoadL_memory__rcx_RegI_rule,
  /*  225 */  _URShiftL__LoadL_memory__immI1_rule,
  /*  226 */  _URShiftL__LoadL_memory__immI8_rule,
  /*  227 */  _URShiftL__LoadL_memory__rcx_RegI_rule,
  /*  228 */  _LShiftI_rRegI_immI_24_rule,
  /*  229 */  _LShiftI_rRegI_immI_16_rule,
  /*  230 */  _LShiftI_rRegI_immI1_rule,
  /*  231 */  _URShiftI_rRegI_immI_M1_rule,
  /*  232 */  _LShiftI_rRegI_immI8_rule,
  /*  233 */  _URShiftI_rRegI_immI8_rule,
  /*  234 */  _LShiftI_no_rcx_RegI_rcx_RegI_rule,
  /*  235 */  _SubI_immI0_rcx_RegI_rule,
  /*  236 */  _URShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI_rule,
  /*  237 */  _SubI_immI_32_rcx_RegI_rule,
  /*  238 */  _URShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI_rule,
  /*  239 */  _URShiftI_rRegI_immI1_rule,
  /*  240 */  _LShiftI_rRegI_immI_M1_rule,
  /*  241 */  _URShiftI_no_rcx_RegI_rcx_RegI_rule,
  /*  242 */  _LShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI_rule,
  /*  243 */  _LShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI_rule,
  /*  244 */  _LShiftL_rRegL_immI1_rule,
  /*  245 */  _URShiftL_rRegL_immI_M1_rule,
  /*  246 */  _LShiftL_rRegL_immI8_rule,
  /*  247 */  _URShiftL_rRegL_immI8_rule,
  /*  248 */  _LShiftL_no_rcx_RegL_rcx_RegI_rule,
  /*  249 */  _URShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI_rule,
  /*  250 */  _SubI_immI_64_rcx_RegI_rule,
  /*  251 */  _URShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI_rule,
  /*  252 */  _URShiftL_rRegL_immI1_rule,
  /*  253 */  _LShiftL_rRegL_immI_M1_rule,
  /*  254 */  _URShiftL_no_rcx_RegL_rcx_RegI_rule,
  /*  255 */  _LShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI_rule,
  /*  256 */  _LShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI_rule,
  /*  257 */  _AndI_rRegI_immI_255_rule,
  /*  258 */  _AndI_rRegI_immI_65535_rule,
  /*  259 */  _AndI__LoadI_memory__rRegI_rule,
  /*  260 */  _AndI_rRegI__LoadI_memory__rule,
  /*  261 */  _AndI__LoadI_memory__immI_rule,
  /*  262 */  _XorI_rRegI_immI_M1_rule,
  /*  263 */  _AddI_rRegI_immI_M1_rule,
  /*  264 */  _OrI__LoadI_memory__rRegI_rule,
  /*  265 */  _OrI_rRegI__LoadI_memory__rule,
  /*  266 */  _OrI__LoadI_memory__immI_rule,
  /*  267 */  _XorI__LoadI_memory__rRegI_rule,
  /*  268 */  _XorI_rRegI__LoadI_memory__rule,
  /*  269 */  _XorI__LoadI_memory__immI_rule,
  /*  270 */  _AndL__LoadL_memory__rRegL_rule,
  /*  271 */  _AndL_rRegL__LoadL_memory__rule,
  /*  272 */  _AndL__LoadL_memory__immL32_rule,
  /*  273 */  _XorL_rRegL_immL_M1_rule,
  /*  274 */  _SubL_immL0_rRegL_rule,
  /*  275 */  _AddL_rRegL_immL_M1_rule,
  /*  276 */  _CastP2X_any_RegP__rule,
  /*  277 */  _OrL__LoadL_memory__rRegL_rule,
  /*  278 */  _OrL_rRegL__LoadL_memory__rule,
  /*  279 */  _OrL__LoadL_memory__immL32_rule,
  /*  280 */  _XorL__LoadL_memory__rRegL_rule,
  /*  281 */  _XorL_rRegL__LoadL_memory__rule,
  /*  282 */  _XorL__LoadL_memory__immL32_rule,
  /*  283 */  _CmpLTMask_rRegI_rRegI_rule,
  /*  284 */  _AndI__CmpLTMask_rRegI_rRegI_rRegI_rule,
  /*  285 */  _SubI_rRegI_rRegI_rule,
  /*  286 */  _AndI_rRegI__CmpLTMask_rRegI_rRegI_rule,
  /*  287 */  _LoadF_memory__rule,
  /*  288 */  _LoadD_memory__rule,
  /*  289 */  _Binary_rdi_RegP_rcx_RegI_rule,
  /*  290 */  _Binary_rsi_RegP_rdx_RegI_rule,
  /*  291 */  _Binary_rdi_RegP_rdx_RegI_rule,
  /*  292 */  _Binary_rsi_RegP_immI_rule,
  /*  293 */  _Binary_rsi_RegP_rax_RegI_rule,
  /*  294 */  _Binary_rdi_RegP_rsi_RegP_rule,
  /*  295 */  _AndI_rRegI_immI_rule,
  /*  296 */  _LoadP_memory__rule,
  /*  297 */  _LoadN_memory__rule,
  /*  298 */  _LoadNKlass_memory__rule,
  /*  299 */  _AndL_rRegL_immL32_rule,
  /*  300 */  _AndL__CastP2X_rRegP___LoadL_memory__rule,
  /*  301 */  _AndL__LoadL_memory___CastP2X_rRegP__rule,
  /*  302 */  _AndI__LoadB_memory__immI8_rule,
  /*  303 */  _PartialSubtypeCheck_rsi_RegP_rax_RegP_rule,
  /*  304 */  _LoadVector_memory__rule,
  /*  305 */  _Binary_cmpOp_vcmppd_immI8_rule,
  /*  306 */  _Binary_vecY_vecY_rule,
  /*  307 */  _Binary_vecX_vecX_rule,
  /*  308 */  _Binary_vecX__LoadVector_memory__rule,
  /*  309 */  _Binary_vecY__LoadVector_memory__rule,
  /*  310 */  _Binary_vecZ_vecZ_rule,
  /*  311 */  _Binary_vecZ__LoadVector_memory__rule,
  // last internally defined operand
  /*  312 */  stackSlotI_rule,
  /*  313 */  stackSlotL_rule,
  /*  314 */  stackSlotP_rule,
  /*  315 */  stackSlotF_rule,
  /*  316 */  stackSlotD_rule,
  /*  317 */  rRegP_rule,
  /*  318 */  rRegP_rule,
  /*  319 */  rRegP_rule,
  /*  320 */  rRegP_rule,
  /*  321 */  rRegP_rule,
  /*  322 */  rRegP_rule,
  /*  323 */  rRegP_rule,
  /*  324 */  rRegP_rule,
  /*  325 */  rRegP_rule,
  /*  326 */  rRegP_rule,
  /*  327 */  rRegP_rule,
  /*  328 */  rRegP_rule,
  /*  329 */  rRegP_rule,
  /*  330 */  rRegP_rule,
  /*  331 */  rRegP_rule,
  /*  332 */  rRegP_rule,
  /*  333 */  rRegI_rule,
  /*  334 */  rRegI_rule,
  /*  335 */  rRegL_rule,
  /*  336 */  rRegL_rule,
  /*  337 */  rRegL_rule,
  /*  338 */  rRegL_rule,
  /*  339 */  rRegP_rule,
  /*  340 */  rRegP_rule,
  /*  341 */  rRegP_rule,
  /*  342 */  regF_rule,
  /*  343 */  rRegN_rule,
  /*  344 */  rRegN_rule,
  /*  345 */  rRegN_rule,
  /*  346 */  regF_rule,
  /*  347 */  regD_rule,
  /*  348 */  regD_rule,
  /*  349 */  rRegI_rule,
  /*  350 */  rRegL_rule,
  /*  351 */  rRegP_rule,
  /*  352 */  regF_rule,
  /*  353 */  regD_rule,
  /*  354 */  Universe_rule,
  /*  355 */  rRegP_rule,
  /*  356 */  rRegL_rule,
  /*  357 */  rRegP_rule,
  /*  358 */  rRegP_rule,
  /*  359 */  rRegI_rule,
  /*  360 */  rFlagsReg_rule,
  /*  361 */  rFlagsReg_rule,
  /*  362 */  rFlagsReg_rule,
  /*  363 */  rFlagsRegU_rule,
  /*  364 */  rFlagsRegUCF_rule,
  /*  365 */  rFlagsRegU_rule,
  /*  366 */  rFlagsRegUCF_rule,
  /*  367 */  rFlagsRegU_rule,
  /*  368 */  rFlagsRegUCF_rule,
  /*  369 */  rFlagsRegU_rule,
  /*  370 */  rFlagsRegUCF_rule,
  /*  371 */  rFlagsRegU_rule,
  /*  372 */  rFlagsRegUCF_rule,
  /*  373 */  rFlagsRegU_rule,
  /*  374 */  rFlagsRegUCF_rule,
  /*  375 */  regF_rule,
  /*  376 */  regD_rule,
  /*  377 */  rRegI_rule,
  /*  378 */  regF_rule,
  /*  379 */  rRegL_rule,
  /*  380 */  regD_rule,
  /*  381 */  regD_rule,
  /*  382 */  rRegI_rule,
  /*  383 */  rRegL_rule,
  /*  384 */  regF_rule,
  /*  385 */  regD_rule,
  /*  386 */  rFlagsReg_rule,
  /*  387 */  rFlagsReg_rule,
  /*  388 */  rFlagsReg_rule,
  /*  389 */  rFlagsReg_rule,
  /*  390 */  rFlagsReg_rule,
  /*  391 */  rFlagsReg_rule,
  /*  392 */  rFlagsReg_rule,
  /*  393 */  rFlagsReg_rule,
  /*  394 */  rFlagsReg_rule,
  /*  395 */  rFlagsReg_rule,
  /*  396 */  rFlagsReg_rule,
  /*  397 */  rFlagsReg_rule,
  /*  398 */  rFlagsReg_rule,
  /*  399 */  rFlagsReg_rule,
  /*  400 */  rFlagsReg_rule,
  /*  401 */  rFlagsReg_rule,
  /*  402 */  rFlagsReg_rule,
  /*  403 */  rFlagsReg_rule,
  /*  404 */  rFlagsReg_rule,
  /*  405 */  rFlagsReg_rule,
  /*  406 */  rFlagsReg_rule,
  /*  407 */  rFlagsRegU_rule,
  /*  408 */  rFlagsRegU_rule,
  /*  409 */  rFlagsRegU_rule,
  /*  410 */  rFlagsRegU_rule,
  /*  411 */  rFlagsRegU_rule,
  /*  412 */  rFlagsRegU_rule,
  /*  413 */  rFlagsRegU_rule,
  /*  414 */  rFlagsReg_rule,
  /*  415 */  rFlagsReg_rule,
  /*  416 */  rFlagsReg_rule,
  /*  417 */  rFlagsRegU_rule,
  /*  418 */  rFlagsRegU_rule,
  /*  419 */  rFlagsRegU_rule,
  /*  420 */  rFlagsRegU_rule,
  /*  421 */  rFlagsRegU_rule,
  /*  422 */  rFlagsRegU_rule,
  /*  423 */  rFlagsReg_rule,
  /*  424 */  rFlagsReg_rule,
  /*  425 */  rFlagsReg_rule,
  /*  426 */  rFlagsReg_rule,
  /*  427 */  rFlagsReg_rule,
  /*  428 */  rFlagsReg_rule,
  /*  429 */  rFlagsReg_rule,
  /*  430 */  rFlagsReg_rule,
  /*  431 */  rFlagsReg_rule,
  /*  432 */  rFlagsReg_rule,
  /*  433 */  rFlagsReg_rule,
  /*  434 */  rFlagsReg_rule,
  /*  435 */  rFlagsRegU_rule,
  /*  436 */  rFlagsRegU_rule,
  /*  437 */  rFlagsRegU_rule,
  /*  438 */  rFlagsRegU_rule,
  /*  439 */  rFlagsReg_rule,
  /*  440 */  rFlagsReg_rule,
  /*  441 */  rFlagsReg_rule,
  /*  442 */  rFlagsReg_rule,
  /*  443 */  rFlagsReg_rule,
  /*  444 */  rFlagsReg_rule,
  /*  445 */  Universe_rule,
  /*  446 */  r15_RegP_rule,
  /*  447 */  regF_rule,
  /*  448 */  regF_rule,
  /*  449 */  regF_rule,
  /*  450 */  regD_rule,
  /*  451 */  regD_rule,
  /*  452 */  regD_rule,
  /*  453 */  regF_rule,
  /*  454 */  regF_rule,
  /*  455 */  regD_rule,
  /*  456 */  regD_rule,
  /*  457 */  vecS_rule,
  /*  458 */  vecS_rule,
  /*  459 */  vecX_rule,
  /*  460 */  vecX_rule,
  /*  461 */  vecY_rule,
  /*  462 */  vecY_rule,
  /*  463 */  vecZ_rule,
  /*  464 */  vecZ_rule,
  /*  465 */  vecD_rule,
  /*  466 */  vecD_rule,
  /*  467 */  vecX_rule,
  /*  468 */  vecX_rule,
  /*  469 */  vecY_rule,
  /*  470 */  vecY_rule,
  /*  471 */  vecZ_rule,
  /*  472 */  vecZ_rule,
  /*  473 */  vecD_rule,
  /*  474 */  vecX_rule,
  /*  475 */  vecY_rule,
  /*  476 */  vecZ_rule,
  /*  477 */  rRegI_rule,
  /*  478 */  rRegL_rule,
  /*  479 */  rRegI_rule,
  /*  480 */  rRegL_rule,
  /*  481 */  rRegL_rule,
  /*  482 */  rRegI_rule,
  /*  483 */  rRegI_rule,
  /*  484 */  rRegL_rule,
  /*  485 */  rRegI_rule,
  /*  486 */  rRegI_rule,
  /*  487 */  rRegL_rule,
  /*  488 */  rRegL_rule,
  /*  489 */  rRegL_rule,
  /*  490 */  rRegI_rule,
  /*  491 */  rRegI_rule,
  /*  492 */  rRegI_rule,
  /*  493 */  rRegI_rule,
  /*  494 */  rRegI_rule,
  /*  495 */  rRegL_rule,
  /*  496 */  rRegL_rule,
  /*  497 */  rRegL_rule,
  /*  498 */  rRegL_rule,
  /*  499 */  rRegL_rule,
  /*  500 */  rRegL_rule,
  /*  501 */  rRegI_rule,
  /*  502 */  rRegP_rule,
  /*  503 */  rRegN_rule,
  /*  504 */  rRegP_rule,
  /*  505 */  rRegN_rule,
  /*  506 */  regF_rule,
  /*  507 */  regD_rule,
  /*  508 */  regD_rule,
  /*  509 */  Universe_rule,
  /*  510 */  Universe_rule,
  /*  511 */  Universe_rule,
  /*  512 */  Universe_rule,
  /*  513 */  Universe_rule,
  /*  514 */  Universe_rule,
  /*  515 */  Universe_rule,
  /*  516 */  Universe_rule,
  /*  517 */  Universe_rule,
  /*  518 */  Universe_rule,
  /*  519 */  Universe_rule,
  /*  520 */  Universe_rule,
  /*  521 */  Universe_rule,
  /*  522 */  Universe_rule,
  /*  523 */  Universe_rule,
  /*  524 */  Universe_rule,
  /*  525 */  Universe_rule,
  /*  526 */  Universe_rule,
  /*  527 */  Universe_rule,
  /*  528 */  Universe_rule,
  /*  529 */  Universe_rule,
  /*  530 */  Universe_rule,
  /*  531 */  Universe_rule,
  /*  532 */  Universe_rule,
  /*  533 */  Universe_rule,
  /*  534 */  Universe_rule,
  /*  535 */  Universe_rule,
  /*  536 */  Universe_rule,
  /*  537 */  Universe_rule,
  /*  538 */  Universe_rule,
  /*  539 */  Universe_rule,
  /*  540 */  Universe_rule,
  /*  541 */  rRegI_rule,
  /*  542 */  rRegL_rule,
  /*  543 */  rRegI_rule,
  /*  544 */  rRegI_rule,
  /*  545 */  rRegI_rule,
  /*  546 */  rRegI_rule,
  /*  547 */  rRegI_rule,
  /*  548 */  rRegI_rule,
  /*  549 */  rRegI_rule,
  /*  550 */  rRegI_rule,
  /*  551 */  rRegI_rule,
  /*  552 */  rRegI_rule,
  /*  553 */  rRegI_rule,
  /*  554 */  rRegI_rule,
  /*  555 */  rRegI_rule,
  /*  556 */  rRegI_rule,
  /*  557 */  Universe_rule,
  /*  558 */  Universe_rule,
  /*  559 */  Universe_rule,
  /*  560 */  Universe_rule,
  /*  561 */  Universe_rule,
  /*  562 */  Universe_rule,
  /*  563 */  Universe_rule,
  /*  564 */  Universe_rule,
  /*  565 */  rRegI_rule,
  /*  566 */  rRegI_rule,
  /*  567 */  rRegN_rule,
  /*  568 */  rRegN_rule,
  /*  569 */  rRegP_rule,
  /*  570 */  rRegP_rule,
  /*  571 */  rRegN_rule,
  /*  572 */  rRegP_rule,
  /*  573 */  Universe_rule,
  /*  574 */  Universe_rule,
  /*  575 */  Universe_rule,
  /*  576 */  rRegI_rule,
  /*  577 */  rRegI_rule,
  /*  578 */  rRegI_rule,
  /*  579 */  rRegI_rule,
  /*  580 */  rRegI_rule,
  /*  581 */  rRegI_rule,
  /*  582 */  rRegN_rule,
  /*  583 */  rRegN_rule,
  /*  584 */  rRegN_rule,
  /*  585 */  rRegP_rule,
  /*  586 */  rRegP_rule,
  /*  587 */  rRegP_rule,
  /*  588 */  rRegL_rule,
  /*  589 */  rRegL_rule,
  /*  590 */  rRegL_rule,
  /*  591 */  rRegL_rule,
  /*  592 */  rRegL_rule,
  /*  593 */  rRegL_rule,
  /*  594 */  regF_rule,
  /*  595 */  regF_rule,
  /*  596 */  regF_rule,
  /*  597 */  regD_rule,
  /*  598 */  regD_rule,
  /*  599 */  regD_rule,
  /*  600 */  rRegI_rule,
  /*  601 */  rRegI_rule,
  /*  602 */  rRegI_rule,
  /*  603 */  rRegI_rule,
  /*  604 */  Universe_rule,
  /*  605 */  Universe_rule,
  /*  606 */  Universe_rule,
  /*  607 */  rRegI_rule,
  /*  608 */  Universe_rule,
  /*  609 */  rRegI_rule,
  /*  610 */  Universe_rule,
  /*  611 */  rRegI_rule,
  /*  612 */  rRegL_rule,
  /*  613 */  rRegL_rule,
  /*  614 */  rRegL_rule,
  /*  615 */  rRegL_rule,
  /*  616 */  Universe_rule,
  /*  617 */  Universe_rule,
  /*  618 */  Universe_rule,
  /*  619 */  rRegI_rule,
  /*  620 */  Universe_rule,
  /*  621 */  rRegL_rule,
  /*  622 */  Universe_rule,
  /*  623 */  rRegL_rule,
  /*  624 */  rRegP_rule,
  /*  625 */  rRegP_rule,
  /*  626 */  rRegP_rule,
  /*  627 */  rRegP_rule,
  /*  628 */  rRegI_rule,
  /*  629 */  rRegI_rule,
  /*  630 */  rRegI_rule,
  /*  631 */  rRegI_rule,
  /*  632 */  rRegI_rule,
  /*  633 */  rRegI_rule,
  /*  634 */  rRegI_rule,
  /*  635 */  rRegI_rule,
  /*  636 */  rRegI_rule,
  /*  637 */  rRegI_rule,
  /*  638 */  rRegI_rule,
  /*  639 */  rRegI_rule,
  /*  640 */  rax_RegI_rule,
  /*  641 */  rax_RegI_rule,
  /*  642 */  rax_RegI_rule,
  /*  643 */  rax_RegL_rule,
  /*  644 */  rax_RegN_rule,
  /*  645 */  rax_RegP_rule,
  /*  646 */  Universe_rule,
  /*  647 */  rRegI_rule,
  /*  648 */  Universe_rule,
  /*  649 */  rRegI_rule,
  /*  650 */  Universe_rule,
  /*  651 */  rRegI_rule,
  /*  652 */  Universe_rule,
  /*  653 */  rRegL_rule,
  /*  654 */  rRegI_rule,
  /*  655 */  rRegI_rule,
  /*  656 */  rRegI_rule,
  /*  657 */  rRegL_rule,
  /*  658 */  rRegP_rule,
  /*  659 */  rRegN_rule,
  /*  660 */  rRegI_rule,
  /*  661 */  rRegI_rule,
  /*  662 */  rRegI_rule,
  /*  663 */  Universe_rule,
  /*  664 */  Universe_rule,
  /*  665 */  rRegL_rule,
  /*  666 */  rRegI_rule,
  /*  667 */  rRegL_rule,
  /*  668 */  Universe_rule,
  /*  669 */  Universe_rule,
  /*  670 */  rRegP_rule,
  /*  671 */  rRegI_rule,
  /*  672 */  Universe_rule,
  /*  673 */  rRegL_rule,
  /*  674 */  Universe_rule,
  /*  675 */  rRegI_rule,
  /*  676 */  rRegI_rule,
  /*  677 */  rRegI_rule,
  /*  678 */  rRegI_rule,
  /*  679 */  rRegI_rule,
  /*  680 */  rRegL_rule,
  /*  681 */  rRegL_rule,
  /*  682 */  rRegL_rule,
  /*  683 */  rRegL_rule,
  /*  684 */  rRegL_rule,
  /*  685 */  rdx_RegL_rule,
  /*  686 */  rax_RegI_rule,
  /*  687 */  rax_RegL_rule,
  /*  688 */  Universe_rule,
  /*  689 */  Universe_rule,
  /*  690 */  0,
  /*  691 */  0,
  /*  692 */  0,
  /*  693 */  0,
  /*  694 */  rdx_RegL_rule,
  /*  695 */  rdx_RegI_rule,
  /*  696 */  rdx_RegL_rule,
  /*  697 */  rRegI_rule,
  /*  698 */  Universe_rule,
  /*  699 */  rRegI_rule,
  /*  700 */  Universe_rule,
  /*  701 */  rRegI_rule,
  /*  702 */  Universe_rule,
  /*  703 */  rRegI_rule,
  /*  704 */  Universe_rule,
  /*  705 */  rRegI_rule,
  /*  706 */  Universe_rule,
  /*  707 */  rRegI_rule,
  /*  708 */  Universe_rule,
  /*  709 */  rRegI_rule,
  /*  710 */  Universe_rule,
  /*  711 */  rRegI_rule,
  /*  712 */  Universe_rule,
  /*  713 */  rRegI_rule,
  /*  714 */  Universe_rule,
  /*  715 */  rRegL_rule,
  /*  716 */  Universe_rule,
  /*  717 */  rRegL_rule,
  /*  718 */  Universe_rule,
  /*  719 */  rRegL_rule,
  /*  720 */  Universe_rule,
  /*  721 */  rRegL_rule,
  /*  722 */  Universe_rule,
  /*  723 */  rRegL_rule,
  /*  724 */  Universe_rule,
  /*  725 */  rRegL_rule,
  /*  726 */  Universe_rule,
  /*  727 */  rRegL_rule,
  /*  728 */  Universe_rule,
  /*  729 */  rRegL_rule,
  /*  730 */  Universe_rule,
  /*  731 */  rRegL_rule,
  /*  732 */  Universe_rule,
  /*  733 */  rRegI_rule,
  /*  734 */  rRegI_rule,
  /*  735 */  0,
  /*  736 */  0,
  /*  737 */  0,
  /*  738 */  rRegI_rule,
  /*  739 */  rRegI_rule,
  /*  740 */  rRegI_rule,
  /*  741 */  rRegI_rule,
  /*  742 */  no_rcx_RegI_rule,
  /*  743 */  no_rcx_RegI_rule,
  /*  744 */  no_rcx_RegI_rule,
  /*  745 */  no_rcx_RegI_rule,
  /*  746 */  0,
  /*  747 */  0,
  /*  748 */  0,
  /*  749 */  rRegI_rule,
  /*  750 */  rRegI_rule,
  /*  751 */  rRegI_rule,
  /*  752 */  rRegI_rule,
  /*  753 */  no_rcx_RegI_rule,
  /*  754 */  no_rcx_RegI_rule,
  /*  755 */  no_rcx_RegI_rule,
  /*  756 */  no_rcx_RegI_rule,
  /*  757 */  0,
  /*  758 */  0,
  /*  759 */  0,
  /*  760 */  rRegL_rule,
  /*  761 */  rRegL_rule,
  /*  762 */  rRegL_rule,
  /*  763 */  rRegL_rule,
  /*  764 */  no_rcx_RegL_rule,
  /*  765 */  no_rcx_RegL_rule,
  /*  766 */  no_rcx_RegL_rule,
  /*  767 */  no_rcx_RegL_rule,
  /*  768 */  0,
  /*  769 */  0,
  /*  770 */  0,
  /*  771 */  rRegL_rule,
  /*  772 */  rRegL_rule,
  /*  773 */  rRegL_rule,
  /*  774 */  rRegL_rule,
  /*  775 */  no_rcx_RegL_rule,
  /*  776 */  no_rcx_RegL_rule,
  /*  777 */  no_rcx_RegL_rule,
  /*  778 */  no_rcx_RegL_rule,
  /*  779 */  rRegI_rule,
  /*  780 */  rRegI_rule,
  /*  781 */  rRegL_rule,
  /*  782 */  rRegI_rule,
  /*  783 */  rRegL_rule,
  /*  784 */  rRegI_rule,
  /*  785 */  rRegI_rule,
  /*  786 */  rRegI_rule,
  /*  787 */  Universe_rule,
  /*  788 */  Universe_rule,
  /*  789 */  Universe_rule,
  /*  790 */  rRegI_rule,
  /*  791 */  rRegI_rule,
  /*  792 */  rRegI_rule,
  /*  793 */  rRegI_rule,
  /*  794 */  rRegI_rule,
  /*  795 */  rRegI_rule,
  /*  796 */  rRegI_rule,
  /*  797 */  rRegI_rule,
  /*  798 */  rRegI_rule,
  /*  799 */  rRegI_rule,
  /*  800 */  rRegI_rule,
  /*  801 */  rRegI_rule,
  /*  802 */  rRegI_rule,
  /*  803 */  rRegI_rule,
  /*  804 */  rRegI_rule,
  /*  805 */  rRegI_rule,
  /*  806 */  rRegI_rule,
  /*  807 */  rRegI_rule,
  /*  808 */  rRegI_rule,
  /*  809 */  rRegI_rule,
  /*  810 */  Universe_rule,
  /*  811 */  Universe_rule,
  /*  812 */  Universe_rule,
  /*  813 */  rRegI_rule,
  /*  814 */  rRegI_rule,
  /*  815 */  rRegI_rule,
  /*  816 */  rRegI_rule,
  /*  817 */  rRegI_rule,
  /*  818 */  Universe_rule,
  /*  819 */  Universe_rule,
  /*  820 */  Universe_rule,
  /*  821 */  rRegL_rule,
  /*  822 */  rRegL_rule,
  /*  823 */  rRegL_rule,
  /*  824 */  rRegL_rule,
  /*  825 */  rRegL_rule,
  /*  826 */  rRegL_rule,
  /*  827 */  Universe_rule,
  /*  828 */  Universe_rule,
  /*  829 */  Universe_rule,
  /*  830 */  rRegL_rule,
  /*  831 */  rRegL_rule,
  /*  832 */  rRegL_rule,
  /*  833 */  rRegL_rule,
  /*  834 */  rRegL_rule,
  /*  835 */  rRegL_rule,
  /*  836 */  rRegL_rule,
  /*  837 */  rRegL_rule,
  /*  838 */  rRegL_rule,
  /*  839 */  rRegL_rule,
  /*  840 */  rRegL_rule,
  /*  841 */  rRegL_rule,
  /*  842 */  rRegL_rule,
  /*  843 */  rRegL_rule,
  /*  844 */  rRegL_rule,
  /*  845 */  rRegL_rule,
  /*  846 */  rRegL_rule,
  /*  847 */  rRegL_rule,
  /*  848 */  rRegL_rule,
  /*  849 */  rRegL_rule,
  /*  850 */  rRegL_rule,
  /*  851 */  rRegL_rule,
  /*  852 */  Universe_rule,
  /*  853 */  Universe_rule,
  /*  854 */  Universe_rule,
  /*  855 */  rRegL_rule,
  /*  856 */  rRegL_rule,
  /*  857 */  rRegL_rule,
  /*  858 */  rRegL_rule,
  /*  859 */  rRegL_rule,
  /*  860 */  Universe_rule,
  /*  861 */  Universe_rule,
  /*  862 */  Universe_rule,
  /*  863 */  rRegI_rule,
  /*  864 */  rRegI_rule,
  /*  865 */  rRegI_rule,
  /*  866 */  rRegI_rule,
  /*  867 */  rRegI_rule,
  /*  868 */  rRegI_rule,
  /*  869 */  rRegI_rule,
  /*  870 */  rRegI_rule,
  /*  871 */  rRegI_rule,
  /*  872 */  rRegI_rule,
  /*  873 */  rRegI_rule,
  /*  874 */  rRegI_rule,
  /*  875 */  rRegI_rule,
  /*  876 */  rRegI_rule,
  /*  877 */  rRegI_rule,
  /*  878 */  rRegI_rule,
  /*  879 */  regD_rule,
  /*  880 */  regD_rule,
  /*  881 */  regF_rule,
  /*  882 */  regF_rule,
  /*  883 */  rRegI_rule,
  /*  884 */  rRegL_rule,
  /*  885 */  rRegI_rule,
  /*  886 */  rRegL_rule,
  /*  887 */  regF_rule,
  /*  888 */  regF_rule,
  /*  889 */  regD_rule,
  /*  890 */  regD_rule,
  /*  891 */  regF_rule,
  /*  892 */  regD_rule,
  /*  893 */  regF_rule,
  /*  894 */  regF_rule,
  /*  895 */  regD_rule,
  /*  896 */  regD_rule,
  /*  897 */  rRegL_rule,
  /*  898 */  rRegL_rule,
  /*  899 */  rRegL_rule,
  /*  900 */  rRegL_rule,
  /*  901 */  rRegI_rule,
  /*  902 */  stackSlotI_rule,
  /*  903 */  stackSlotF_rule,
  /*  904 */  stackSlotL_rule,
  /*  905 */  stackSlotD_rule,
  /*  906 */  Universe_rule,
  /*  907 */  Universe_rule,
  /*  908 */  rax_RegI_rule,
  /*  909 */  rax_RegI_rule,
  /*  910 */  rax_RegI_rule,
  /*  911 */  rax_RegI_rule,
  /*  912 */  rbx_RegI_rule,
  /*  913 */  rbx_RegI_rule,
  /*  914 */  rbx_RegI_rule,
  /*  915 */  rbx_RegI_rule,
  /*  916 */  rbx_RegI_rule,
  /*  917 */  rbx_RegI_rule,
  /*  918 */  rbx_RegI_rule,
  /*  919 */  rax_RegI_rule,
  /*  920 */  rax_RegI_rule,
  /*  921 */  rax_RegI_rule,
  /*  922 */  rax_RegI_rule,
  /*  923 */  rax_RegI_rule,
  /*  924 */  Universe_rule,
  /*  925 */  rax_RegI_rule,
  /*  926 */  rRegI_rule,
  /*  927 */  0,
  /*  928 */  rRegI_rule,
  /*  929 */  0,
  /*  930 */  rRegI_rule,
  /*  931 */  Universe_rule,
  /*  932 */  Universe_rule,
  /*  933 */  Universe_rule,
  /*  934 */  Universe_rule,
  /*  935 */  Universe_rule,
  /*  936 */  Universe_rule,
  /*  937 */  Universe_rule,
  /*  938 */  Universe_rule,
  /*  939 */  Universe_rule,
  /*  940 */  Universe_rule,
  /*  941 */  Universe_rule,
  /*  942 */  rdi_RegP_rule,
  /*  943 */  Universe_rule,
  /*  944 */  Universe_rule,
  /*  945 */  Universe_rule,
  /*  946 */  Universe_rule,
  /*  947 */  Universe_rule,
  /*  948 */  Universe_rule,
  /*  949 */  Universe_rule,
  /*  950 */  Universe_rule,
  /*  951 */  Universe_rule,
  /*  952 */  Universe_rule,
  /*  953 */  Universe_rule,
  /*  954 */  Universe_rule,
  /*  955 */  Universe_rule,
  /*  956 */  Universe_rule,
  /*  957 */  Universe_rule,
  /*  958 */  Universe_rule,
  /*  959 */  Universe_rule,
  /*  960 */  Universe_rule,
  /*  961 */  rax_RegP_rule,
  /*  962 */  Universe_rule,
  /*  963 */  rRegP_rule,
  /*  964 */  rRegP_rule,
  /*  965 */  rRegP_rule,
  /*  966 */  rRegP_rule,
  /*  967 */  rRegP_rule,
  /*  968 */  rRegP_rule,
  /*  969 */  Universe_rule,
  /*  970 */  rRegI_rule,
  /*  971 */  regF_rule,
  /*  972 */  regF_rule,
  /*  973 */  regF_rule,
  /*  974 */  regF_rule,
  /*  975 */  regF_rule,
  /*  976 */  regF_rule,
  /*  977 */  regF_rule,
  /*  978 */  regF_rule,
  /*  979 */  regD_rule,
  /*  980 */  regD_rule,
  /*  981 */  regD_rule,
  /*  982 */  regD_rule,
  /*  983 */  regD_rule,
  /*  984 */  regD_rule,
  /*  985 */  regD_rule,
  /*  986 */  regD_rule,
  /*  987 */  regF_rule,
  /*  988 */  regF_rule,
  /*  989 */  regF_rule,
  /*  990 */  regF_rule,
  /*  991 */  regF_rule,
  /*  992 */  regF_rule,
  /*  993 */  regD_rule,
  /*  994 */  regD_rule,
  /*  995 */  regD_rule,
  /*  996 */  regD_rule,
  /*  997 */  regD_rule,
  /*  998 */  regD_rule,
  /*  999 */  regF_rule,
  /* 1000 */  regF_rule,
  /* 1001 */  regF_rule,
  /* 1002 */  regF_rule,
  /* 1003 */  regF_rule,
  /* 1004 */  regF_rule,
  /* 1005 */  regF_rule,
  /* 1006 */  regF_rule,
  /* 1007 */  regD_rule,
  /* 1008 */  regD_rule,
  /* 1009 */  regD_rule,
  /* 1010 */  regD_rule,
  /* 1011 */  regD_rule,
  /* 1012 */  regD_rule,
  /* 1013 */  regD_rule,
  /* 1014 */  regD_rule,
  /* 1015 */  regF_rule,
  /* 1016 */  regF_rule,
  /* 1017 */  regF_rule,
  /* 1018 */  regF_rule,
  /* 1019 */  regF_rule,
  /* 1020 */  regF_rule,
  /* 1021 */  regD_rule,
  /* 1022 */  regD_rule,
  /* 1023 */  regD_rule,
  /* 1024 */  regD_rule,
  /* 1025 */  regD_rule,
  /* 1026 */  regD_rule,
  /* 1027 */  regF_rule,
  /* 1028 */  regD_rule,
  /* 1029 */  regF_rule,
  /* 1030 */  regF_rule,
  /* 1031 */  regF_rule,
  /* 1032 */  regD_rule,
  /* 1033 */  regD_rule,
  /* 1034 */  regD_rule,
  /* 1035 */  Universe_rule,
  /* 1036 */  regD_rule,
  /* 1037 */  regF_rule,
  /* 1038 */  vecS_rule,
  /* 1039 */  vecD_rule,
  /* 1040 */  vecX_rule,
  /* 1041 */  vecY_rule,
  /* 1042 */  vecZ_rule,
  /* 1043 */  vecZ_rule,
  /* 1044 */  Universe_rule,
  /* 1045 */  Universe_rule,
  /* 1046 */  Universe_rule,
  /* 1047 */  Universe_rule,
  /* 1048 */  Universe_rule,
  /* 1049 */  Universe_rule,
  /* 1050 */  vecS_rule,
  /* 1051 */  vecD_rule,
  /* 1052 */  vecX_rule,
  /* 1053 */  vecX_rule,
  /* 1054 */  vecY_rule,
  /* 1055 */  vecY_rule,
  /* 1056 */  vecX_rule,
  /* 1057 */  vecY_rule,
  /* 1058 */  vecD_rule,
  /* 1059 */  vecD_rule,
  /* 1060 */  vecX_rule,
  /* 1061 */  vecX_rule,
  /* 1062 */  vecX_rule,
  /* 1063 */  vecY_rule,
  /* 1064 */  vecY_rule,
  /* 1065 */  vecY_rule,
  /* 1066 */  vecX_rule,
  /* 1067 */  vecX_rule,
  /* 1068 */  vecY_rule,
  /* 1069 */  vecY_rule,
  /* 1070 */  vecX_rule,
  /* 1071 */  vecY_rule,
  /* 1072 */  vecX_rule,
  /* 1073 */  vecY_rule,
  /* 1074 */  vecY_rule,
  /* 1075 */  vecY_rule,
  /* 1076 */  vecD_rule,
  /* 1077 */  vecX_rule,
  /* 1078 */  vecY_rule,
  /* 1079 */  vecY_rule,
  /* 1080 */  vecD_rule,
  /* 1081 */  vecX_rule,
  /* 1082 */  vecY_rule,
  /* 1083 */  vecX_rule,
  /* 1084 */  vecY_rule,
  /* 1085 */  vecY_rule,
  /* 1086 */  vecX_rule,
  /* 1087 */  vecY_rule,
  /* 1088 */  vecS_rule,
  /* 1089 */  vecD_rule,
  /* 1090 */  vecS_rule,
  /* 1091 */  vecD_rule,
  /* 1092 */  vecS_rule,
  /* 1093 */  vecD_rule,
  /* 1094 */  vecX_rule,
  /* 1095 */  vecY_rule,
  /* 1096 */  vecS_rule,
  /* 1097 */  vecS_rule,
  /* 1098 */  vecD_rule,
  /* 1099 */  vecS_rule,
  /* 1100 */  vecD_rule,
  /* 1101 */  vecX_rule,
  /* 1102 */  vecY_rule,
  /* 1103 */  vecD_rule,
  /* 1104 */  vecD_rule,
  /* 1105 */  vecD_rule,
  /* 1106 */  vecD_rule,
  /* 1107 */  vecX_rule,
  /* 1108 */  vecY_rule,
  /* 1109 */  vecX_rule,
  /* 1110 */  vecX_rule,
  /* 1111 */  vecX_rule,
  /* 1112 */  vecY_rule,
  /* 1113 */  vecD_rule,
  /* 1114 */  vecX_rule,
  /* 1115 */  vecX_rule,
  /* 1116 */  vecS_rule,
  /* 1117 */  vecD_rule,
  /* 1118 */  vecX_rule,
  /* 1119 */  vecX_rule,
  /* 1120 */  vecY_rule,
  /* 1121 */  vecY_rule,
  /* 1122 */  vecZ_rule,
  /* 1123 */  vecZ_rule,
  /* 1124 */  vecX_rule,
  /* 1125 */  vecY_rule,
  /* 1126 */  vecZ_rule,
  /* 1127 */  vecZ_rule,
  /* 1128 */  vecD_rule,
  /* 1129 */  vecD_rule,
  /* 1130 */  vecX_rule,
  /* 1131 */  vecX_rule,
  /* 1132 */  vecY_rule,
  /* 1133 */  vecY_rule,
  /* 1134 */  vecZ_rule,
  /* 1135 */  vecZ_rule,
  /* 1136 */  vecX_rule,
  /* 1137 */  vecY_rule,
  /* 1138 */  vecZ_rule,
  /* 1139 */  vecZ_rule,
  /* 1140 */  vecX_rule,
  /* 1141 */  vecX_rule,
  /* 1142 */  vecY_rule,
  /* 1143 */  vecY_rule,
  /* 1144 */  vecZ_rule,
  /* 1145 */  vecZ_rule,
  /* 1146 */  vecX_rule,
  /* 1147 */  vecY_rule,
  /* 1148 */  vecZ_rule,
  /* 1149 */  vecZ_rule,
  /* 1150 */  vecY_rule,
  /* 1151 */  vecZ_rule,
  /* 1152 */  vecY_rule,
  /* 1153 */  vecZ_rule,
  /* 1154 */  vecX_rule,
  /* 1155 */  vecY_rule,
  /* 1156 */  vecZ_rule,
  /* 1157 */  vecZ_rule,
  /* 1158 */  vecY_rule,
  /* 1159 */  vecY_rule,
  /* 1160 */  vecZ_rule,
  /* 1161 */  vecZ_rule,
  /* 1162 */  vecD_rule,
  /* 1163 */  vecX_rule,
  /* 1164 */  vecY_rule,
  /* 1165 */  vecZ_rule,
  /* 1166 */  vecY_rule,
  /* 1167 */  vecY_rule,
  /* 1168 */  vecZ_rule,
  /* 1169 */  vecZ_rule,
  /* 1170 */  vecX_rule,
  /* 1171 */  vecY_rule,
  /* 1172 */  vecZ_rule,
  /* 1173 */  rRegI_rule,
  /* 1174 */  rRegI_rule,
  /* 1175 */  rRegI_rule,
  /* 1176 */  rRegI_rule,
  /* 1177 */  rRegI_rule,
  /* 1178 */  rRegI_rule,
  /* 1179 */  rRegI_rule,
  /* 1180 */  rRegI_rule,
  /* 1181 */  rRegI_rule,
  /* 1182 */  rRegL_rule,
  /* 1183 */  rRegL_rule,
  /* 1184 */  rRegL_rule,
  /* 1185 */  regF_rule,
  /* 1186 */  regF_rule,
  /* 1187 */  regF_rule,
  /* 1188 */  regF_rule,
  /* 1189 */  regF_rule,
  /* 1190 */  regF_rule,
  /* 1191 */  regD_rule,
  /* 1192 */  regD_rule,
  /* 1193 */  regD_rule,
  /* 1194 */  regD_rule,
  /* 1195 */  rRegI_rule,
  /* 1196 */  rRegI_rule,
  /* 1197 */  rRegI_rule,
  /* 1198 */  rRegI_rule,
  /* 1199 */  rRegI_rule,
  /* 1200 */  rRegI_rule,
  /* 1201 */  rRegL_rule,
  /* 1202 */  rRegL_rule,
  /* 1203 */  rRegL_rule,
  /* 1204 */  regF_rule,
  /* 1205 */  regF_rule,
  /* 1206 */  regF_rule,
  /* 1207 */  regF_rule,
  /* 1208 */  regF_rule,
  /* 1209 */  regF_rule,
  /* 1210 */  regD_rule,
  /* 1211 */  regD_rule,
  /* 1212 */  regD_rule,
  /* 1213 */  regD_rule,
  /* 1214 */  vecS_rule,
  /* 1215 */  vecS_rule,
  /* 1216 */  vecS_rule,
  /* 1217 */  vecS_rule,
  /* 1218 */  vecS_rule,
  /* 1219 */  vecS_rule,
  /* 1220 */  vecS_rule,
  /* 1221 */  vecS_rule,
  /* 1222 */  vecS_rule,
  /* 1223 */  vecS_rule,
  /* 1224 */  vecD_rule,
  /* 1225 */  vecD_rule,
  /* 1226 */  vecD_rule,
  /* 1227 */  vecD_rule,
  /* 1228 */  vecD_rule,
  /* 1229 */  vecD_rule,
  /* 1230 */  vecD_rule,
  /* 1231 */  vecD_rule,
  /* 1232 */  vecD_rule,
  /* 1233 */  vecD_rule,
  /* 1234 */  vecX_rule,
  /* 1235 */  vecX_rule,
  /* 1236 */  vecX_rule,
  /* 1237 */  vecX_rule,
  /* 1238 */  vecX_rule,
  /* 1239 */  vecX_rule,
  /* 1240 */  vecX_rule,
  /* 1241 */  vecX_rule,
  /* 1242 */  vecX_rule,
  /* 1243 */  vecX_rule,
  /* 1244 */  vecY_rule,
  /* 1245 */  vecY_rule,
  /* 1246 */  vecY_rule,
  /* 1247 */  vecY_rule,
  /* 1248 */  vecY_rule,
  /* 1249 */  vecY_rule,
  /* 1250 */  vecY_rule,
  /* 1251 */  vecY_rule,
  /* 1252 */  vecY_rule,
  /* 1253 */  vecZ_rule,
  /* 1254 */  vecZ_rule,
  /* 1255 */  vecZ_rule,
  /* 1256 */  vecS_rule,
  /* 1257 */  vecS_rule,
  /* 1258 */  vecS_rule,
  /* 1259 */  vecS_rule,
  /* 1260 */  vecS_rule,
  /* 1261 */  vecS_rule,
  /* 1262 */  vecS_rule,
  /* 1263 */  vecS_rule,
  /* 1264 */  vecS_rule,
  /* 1265 */  vecS_rule,
  /* 1266 */  vecD_rule,
  /* 1267 */  vecD_rule,
  /* 1268 */  vecD_rule,
  /* 1269 */  vecD_rule,
  /* 1270 */  vecD_rule,
  /* 1271 */  vecD_rule,
  /* 1272 */  vecD_rule,
  /* 1273 */  vecD_rule,
  /* 1274 */  vecD_rule,
  /* 1275 */  vecD_rule,
  /* 1276 */  vecX_rule,
  /* 1277 */  vecX_rule,
  /* 1278 */  vecX_rule,
  /* 1279 */  vecX_rule,
  /* 1280 */  vecX_rule,
  /* 1281 */  vecX_rule,
  /* 1282 */  vecX_rule,
  /* 1283 */  vecX_rule,
  /* 1284 */  vecX_rule,
  /* 1285 */  vecX_rule,
  /* 1286 */  vecY_rule,
  /* 1287 */  vecY_rule,
  /* 1288 */  vecY_rule,
  /* 1289 */  vecY_rule,
  /* 1290 */  vecY_rule,
  /* 1291 */  vecY_rule,
  /* 1292 */  vecY_rule,
  /* 1293 */  vecY_rule,
  /* 1294 */  vecY_rule,
  /* 1295 */  vecZ_rule,
  /* 1296 */  vecZ_rule,
  /* 1297 */  vecZ_rule,
  /* 1298 */  vecD_rule,
  /* 1299 */  vecD_rule,
  /* 1300 */  vecD_rule,
  /* 1301 */  vecD_rule,
  /* 1302 */  vecX_rule,
  /* 1303 */  vecX_rule,
  /* 1304 */  vecX_rule,
  /* 1305 */  vecX_rule,
  /* 1306 */  vecY_rule,
  /* 1307 */  vecY_rule,
  /* 1308 */  vecY_rule,
  /* 1309 */  vecZ_rule,
  /* 1310 */  vecZ_rule,
  /* 1311 */  vecZ_rule,
  /* 1312 */  vecX_rule,
  /* 1313 */  vecX_rule,
  /* 1314 */  vecX_rule,
  /* 1315 */  vecX_rule,
  /* 1316 */  vecY_rule,
  /* 1317 */  vecY_rule,
  /* 1318 */  vecY_rule,
  /* 1319 */  vecZ_rule,
  /* 1320 */  vecZ_rule,
  /* 1321 */  vecZ_rule,
  /* 1322 */  vecD_rule,
  /* 1323 */  vecD_rule,
  /* 1324 */  vecD_rule,
  /* 1325 */  vecD_rule,
  /* 1326 */  vecX_rule,
  /* 1327 */  vecX_rule,
  /* 1328 */  vecX_rule,
  /* 1329 */  vecX_rule,
  /* 1330 */  vecY_rule,
  /* 1331 */  vecY_rule,
  /* 1332 */  vecY_rule,
  /* 1333 */  vecZ_rule,
  /* 1334 */  vecZ_rule,
  /* 1335 */  vecZ_rule,
  /* 1336 */  vecX_rule,
  /* 1337 */  vecX_rule,
  /* 1338 */  vecX_rule,
  /* 1339 */  vecX_rule,
  /* 1340 */  vecY_rule,
  /* 1341 */  vecY_rule,
  /* 1342 */  vecY_rule,
  /* 1343 */  vecZ_rule,
  /* 1344 */  vecZ_rule,
  /* 1345 */  vecZ_rule,
  /* 1346 */  vecS_rule,
  /* 1347 */  vecS_rule,
  /* 1348 */  vecS_rule,
  /* 1349 */  vecS_rule,
  /* 1350 */  vecS_rule,
  /* 1351 */  vecS_rule,
  /* 1352 */  vecS_rule,
  /* 1353 */  vecD_rule,
  /* 1354 */  vecD_rule,
  /* 1355 */  vecD_rule,
  /* 1356 */  vecD_rule,
  /* 1357 */  vecD_rule,
  /* 1358 */  vecD_rule,
  /* 1359 */  vecD_rule,
  /* 1360 */  vecX_rule,
  /* 1361 */  vecX_rule,
  /* 1362 */  vecX_rule,
  /* 1363 */  vecX_rule,
  /* 1364 */  vecX_rule,
  /* 1365 */  vecX_rule,
  /* 1366 */  vecX_rule,
  /* 1367 */  vecY_rule,
  /* 1368 */  vecY_rule,
  /* 1369 */  vecY_rule,
  /* 1370 */  vecY_rule,
  /* 1371 */  vecY_rule,
  /* 1372 */  vecY_rule,
  /* 1373 */  vecZ_rule,
  /* 1374 */  vecZ_rule,
  /* 1375 */  vecS_rule,
  /* 1376 */  vecS_rule,
  /* 1377 */  vecS_rule,
  /* 1378 */  vecS_rule,
  /* 1379 */  vecS_rule,
  /* 1380 */  vecS_rule,
  /* 1381 */  vecS_rule,
  /* 1382 */  vecD_rule,
  /* 1383 */  vecD_rule,
  /* 1384 */  vecD_rule,
  /* 1385 */  vecD_rule,
  /* 1386 */  vecD_rule,
  /* 1387 */  vecD_rule,
  /* 1388 */  vecD_rule,
  /* 1389 */  vecX_rule,
  /* 1390 */  vecX_rule,
  /* 1391 */  vecX_rule,
  /* 1392 */  vecX_rule,
  /* 1393 */  vecX_rule,
  /* 1394 */  vecX_rule,
  /* 1395 */  vecX_rule,
  /* 1396 */  vecY_rule,
  /* 1397 */  vecY_rule,
  /* 1398 */  vecY_rule,
  /* 1399 */  vecY_rule,
  /* 1400 */  vecY_rule,
  /* 1401 */  vecY_rule,
  /* 1402 */  vecZ_rule,
  /* 1403 */  vecZ_rule,
  /* 1404 */  vecD_rule,
  /* 1405 */  vecD_rule,
  /* 1406 */  vecD_rule,
  /* 1407 */  vecX_rule,
  /* 1408 */  vecX_rule,
  /* 1409 */  vecX_rule,
  /* 1410 */  vecY_rule,
  /* 1411 */  vecY_rule,
  /* 1412 */  vecZ_rule,
  /* 1413 */  vecZ_rule,
  /* 1414 */  vecX_rule,
  /* 1415 */  vecX_rule,
  /* 1416 */  vecX_rule,
  /* 1417 */  vecY_rule,
  /* 1418 */  vecY_rule,
  /* 1419 */  vecZ_rule,
  /* 1420 */  vecZ_rule,
  /* 1421 */  vecD_rule,
  /* 1422 */  vecD_rule,
  /* 1423 */  vecD_rule,
  /* 1424 */  vecX_rule,
  /* 1425 */  vecX_rule,
  /* 1426 */  vecX_rule,
  /* 1427 */  vecY_rule,
  /* 1428 */  vecY_rule,
  /* 1429 */  vecZ_rule,
  /* 1430 */  vecZ_rule,
  /* 1431 */  vecX_rule,
  /* 1432 */  vecX_rule,
  /* 1433 */  vecX_rule,
  /* 1434 */  vecY_rule,
  /* 1435 */  vecY_rule,
  /* 1436 */  vecZ_rule,
  /* 1437 */  vecZ_rule,
  /* 1438 */  vecS_rule,
  /* 1439 */  vecS_rule,
  /* 1440 */  vecS_rule,
  /* 1441 */  vecS_rule,
  /* 1442 */  vecS_rule,
  /* 1443 */  vecS_rule,
  /* 1444 */  vecS_rule,
  /* 1445 */  vecS_rule,
  /* 1446 */  vecS_rule,
  /* 1447 */  vecS_rule,
  /* 1448 */  vecD_rule,
  /* 1449 */  vecD_rule,
  /* 1450 */  vecD_rule,
  /* 1451 */  vecD_rule,
  /* 1452 */  vecD_rule,
  /* 1453 */  vecD_rule,
  /* 1454 */  vecD_rule,
  /* 1455 */  vecD_rule,
  /* 1456 */  vecD_rule,
  /* 1457 */  vecD_rule,
  /* 1458 */  vecX_rule,
  /* 1459 */  vecX_rule,
  /* 1460 */  vecX_rule,
  /* 1461 */  vecX_rule,
  /* 1462 */  vecX_rule,
  /* 1463 */  vecX_rule,
  /* 1464 */  vecX_rule,
  /* 1465 */  vecX_rule,
  /* 1466 */  vecX_rule,
  /* 1467 */  vecX_rule,
  /* 1468 */  vecY_rule,
  /* 1469 */  vecY_rule,
  /* 1470 */  vecY_rule,
  /* 1471 */  vecY_rule,
  /* 1472 */  vecY_rule,
  /* 1473 */  vecY_rule,
  /* 1474 */  vecY_rule,
  /* 1475 */  vecY_rule,
  /* 1476 */  vecY_rule,
  /* 1477 */  vecZ_rule,
  /* 1478 */  vecZ_rule,
  /* 1479 */  vecZ_rule,
  /* 1480 */  vecD_rule,
  /* 1481 */  vecD_rule,
  /* 1482 */  vecD_rule,
  /* 1483 */  vecD_rule,
  /* 1484 */  vecX_rule,
  /* 1485 */  vecX_rule,
  /* 1486 */  vecX_rule,
  /* 1487 */  vecX_rule,
  /* 1488 */  vecX_rule,
  /* 1489 */  vecX_rule,
  /* 1490 */  vecX_rule,
  /* 1491 */  vecY_rule,
  /* 1492 */  vecY_rule,
  /* 1493 */  vecY_rule,
  /* 1494 */  vecZ_rule,
  /* 1495 */  vecZ_rule,
  /* 1496 */  vecZ_rule,
  /* 1497 */  vecY_rule,
  /* 1498 */  vecY_rule,
  /* 1499 */  vecY_rule,
  /* 1500 */  vecZ_rule,
  /* 1501 */  vecZ_rule,
  /* 1502 */  vecZ_rule,
  /* 1503 */  vecD_rule,
  /* 1504 */  vecD_rule,
  /* 1505 */  vecD_rule,
  /* 1506 */  vecD_rule,
  /* 1507 */  vecX_rule,
  /* 1508 */  vecX_rule,
  /* 1509 */  vecX_rule,
  /* 1510 */  vecX_rule,
  /* 1511 */  vecY_rule,
  /* 1512 */  vecY_rule,
  /* 1513 */  vecY_rule,
  /* 1514 */  vecZ_rule,
  /* 1515 */  vecZ_rule,
  /* 1516 */  vecZ_rule,
  /* 1517 */  vecX_rule,
  /* 1518 */  vecX_rule,
  /* 1519 */  vecX_rule,
  /* 1520 */  vecX_rule,
  /* 1521 */  vecY_rule,
  /* 1522 */  vecY_rule,
  /* 1523 */  vecY_rule,
  /* 1524 */  vecZ_rule,
  /* 1525 */  vecZ_rule,
  /* 1526 */  vecZ_rule,
  /* 1527 */  vecY_rule,
  /* 1528 */  vecY_rule,
  /* 1529 */  vecD_rule,
  /* 1530 */  vecD_rule,
  /* 1531 */  vecD_rule,
  /* 1532 */  vecX_rule,
  /* 1533 */  vecX_rule,
  /* 1534 */  vecX_rule,
  /* 1535 */  vecY_rule,
  /* 1536 */  vecY_rule,
  /* 1537 */  vecZ_rule,
  /* 1538 */  vecZ_rule,
  /* 1539 */  vecX_rule,
  /* 1540 */  vecX_rule,
  /* 1541 */  vecX_rule,
  /* 1542 */  vecY_rule,
  /* 1543 */  vecY_rule,
  /* 1544 */  vecZ_rule,
  /* 1545 */  vecZ_rule,
  /* 1546 */  vecS_rule,
  /* 1547 */  vecS_rule,
  /* 1548 */  vecS_rule,
  /* 1549 */  vecS_rule,
  /* 1550 */  vecS_rule,
  /* 1551 */  vecS_rule,
  /* 1552 */  vecS_rule,
  /* 1553 */  vecS_rule,
  /* 1554 */  vecD_rule,
  /* 1555 */  vecD_rule,
  /* 1556 */  vecD_rule,
  /* 1557 */  vecD_rule,
  /* 1558 */  vecD_rule,
  /* 1559 */  vecD_rule,
  /* 1560 */  vecD_rule,
  /* 1561 */  vecD_rule,
  /* 1562 */  vecX_rule,
  /* 1563 */  vecX_rule,
  /* 1564 */  vecX_rule,
  /* 1565 */  vecX_rule,
  /* 1566 */  vecX_rule,
  /* 1567 */  vecX_rule,
  /* 1568 */  vecX_rule,
  /* 1569 */  vecX_rule,
  /* 1570 */  vecY_rule,
  /* 1571 */  vecY_rule,
  /* 1572 */  vecY_rule,
  /* 1573 */  vecY_rule,
  /* 1574 */  vecY_rule,
  /* 1575 */  vecY_rule,
  /* 1576 */  vecZ_rule,
  /* 1577 */  vecZ_rule,
  /* 1578 */  vecD_rule,
  /* 1579 */  vecD_rule,
  /* 1580 */  vecD_rule,
  /* 1581 */  vecD_rule,
  /* 1582 */  vecX_rule,
  /* 1583 */  vecX_rule,
  /* 1584 */  vecX_rule,
  /* 1585 */  vecX_rule,
  /* 1586 */  vecY_rule,
  /* 1587 */  vecY_rule,
  /* 1588 */  vecZ_rule,
  /* 1589 */  vecZ_rule,
  /* 1590 */  vecX_rule,
  /* 1591 */  vecX_rule,
  /* 1592 */  vecX_rule,
  /* 1593 */  vecX_rule,
  /* 1594 */  vecY_rule,
  /* 1595 */  vecY_rule,
  /* 1596 */  vecZ_rule,
  /* 1597 */  vecZ_rule,
  /* 1598 */  vecS_rule,
  /* 1599 */  vecS_rule,
  /* 1600 */  vecS_rule,
  /* 1601 */  vecS_rule,
  /* 1602 */  vecS_rule,
  /* 1603 */  vecS_rule,
  /* 1604 */  vecS_rule,
  /* 1605 */  vecS_rule,
  /* 1606 */  vecD_rule,
  /* 1607 */  vecD_rule,
  /* 1608 */  vecD_rule,
  /* 1609 */  vecD_rule,
  /* 1610 */  vecD_rule,
  /* 1611 */  vecD_rule,
  /* 1612 */  vecD_rule,
  /* 1613 */  vecD_rule,
  /* 1614 */  vecX_rule,
  /* 1615 */  vecX_rule,
  /* 1616 */  vecX_rule,
  /* 1617 */  vecX_rule,
  /* 1618 */  vecX_rule,
  /* 1619 */  vecX_rule,
  /* 1620 */  vecX_rule,
  /* 1621 */  vecX_rule,
  /* 1622 */  vecY_rule,
  /* 1623 */  vecY_rule,
  /* 1624 */  vecY_rule,
  /* 1625 */  vecY_rule,
  /* 1626 */  vecY_rule,
  /* 1627 */  vecY_rule,
  /* 1628 */  vecZ_rule,
  /* 1629 */  vecZ_rule,
  /* 1630 */  vecD_rule,
  /* 1631 */  vecD_rule,
  /* 1632 */  vecD_rule,
  /* 1633 */  vecD_rule,
  /* 1634 */  vecX_rule,
  /* 1635 */  vecX_rule,
  /* 1636 */  vecX_rule,
  /* 1637 */  vecX_rule,
  /* 1638 */  vecY_rule,
  /* 1639 */  vecY_rule,
  /* 1640 */  vecZ_rule,
  /* 1641 */  vecZ_rule,
  /* 1642 */  vecX_rule,
  /* 1643 */  vecX_rule,
  /* 1644 */  vecX_rule,
  /* 1645 */  vecX_rule,
  /* 1646 */  vecY_rule,
  /* 1647 */  vecY_rule,
  /* 1648 */  vecZ_rule,
  /* 1649 */  vecZ_rule,
  /* 1650 */  vecS_rule,
  /* 1651 */  vecS_rule,
  /* 1652 */  vecS_rule,
  /* 1653 */  vecS_rule,
  /* 1654 */  vecS_rule,
  /* 1655 */  vecS_rule,
  /* 1656 */  vecS_rule,
  /* 1657 */  vecS_rule,
  /* 1658 */  vecD_rule,
  /* 1659 */  vecD_rule,
  /* 1660 */  vecD_rule,
  /* 1661 */  vecD_rule,
  /* 1662 */  vecD_rule,
  /* 1663 */  vecD_rule,
  /* 1664 */  vecD_rule,
  /* 1665 */  vecD_rule,
  /* 1666 */  vecX_rule,
  /* 1667 */  vecX_rule,
  /* 1668 */  vecX_rule,
  /* 1669 */  vecX_rule,
  /* 1670 */  vecX_rule,
  /* 1671 */  vecX_rule,
  /* 1672 */  vecX_rule,
  /* 1673 */  vecX_rule,
  /* 1674 */  vecY_rule,
  /* 1675 */  vecY_rule,
  /* 1676 */  vecY_rule,
  /* 1677 */  vecY_rule,
  /* 1678 */  vecY_rule,
  /* 1679 */  vecY_rule,
  /* 1680 */  vecZ_rule,
  /* 1681 */  vecZ_rule,
  /* 1682 */  vecD_rule,
  /* 1683 */  vecD_rule,
  /* 1684 */  vecD_rule,
  /* 1685 */  vecD_rule,
  /* 1686 */  vecX_rule,
  /* 1687 */  vecX_rule,
  /* 1688 */  vecX_rule,
  /* 1689 */  vecX_rule,
  /* 1690 */  vecY_rule,
  /* 1691 */  vecY_rule,
  /* 1692 */  vecZ_rule,
  /* 1693 */  vecZ_rule,
  /* 1694 */  vecS_rule,
  /* 1695 */  vecS_rule,
  /* 1696 */  vecS_rule,
  /* 1697 */  vecS_rule,
  /* 1698 */  vecD_rule,
  /* 1699 */  vecD_rule,
  /* 1700 */  vecD_rule,
  /* 1701 */  vecD_rule,
  /* 1702 */  vecX_rule,
  /* 1703 */  vecX_rule,
  /* 1704 */  vecX_rule,
  /* 1705 */  vecX_rule,
  /* 1706 */  vecY_rule,
  /* 1707 */  vecY_rule,
  /* 1708 */  vecY_rule,
  /* 1709 */  vecZ_rule,
  /* 1710 */  vecZ_rule,
  /* 1711 */  vecZ_rule,
  /* 1712 */  vecS_rule,
  /* 1713 */  vecS_rule,
  /* 1714 */  vecS_rule,
  /* 1715 */  vecS_rule,
  /* 1716 */  vecD_rule,
  /* 1717 */  vecD_rule,
  /* 1718 */  vecD_rule,
  /* 1719 */  vecD_rule,
  /* 1720 */  vecX_rule,
  /* 1721 */  vecX_rule,
  /* 1722 */  vecX_rule,
  /* 1723 */  vecX_rule,
  /* 1724 */  vecY_rule,
  /* 1725 */  vecY_rule,
  /* 1726 */  vecY_rule,
  /* 1727 */  vecZ_rule,
  /* 1728 */  vecZ_rule,
  /* 1729 */  vecZ_rule,
  /* 1730 */  vecS_rule,
  /* 1731 */  vecS_rule,
  /* 1732 */  vecS_rule,
  /* 1733 */  vecS_rule,
  /* 1734 */  vecD_rule,
  /* 1735 */  vecD_rule,
  /* 1736 */  vecD_rule,
  /* 1737 */  vecD_rule,
  /* 1738 */  vecX_rule,
  /* 1739 */  vecX_rule,
  /* 1740 */  vecX_rule,
  /* 1741 */  vecX_rule,
  /* 1742 */  vecY_rule,
  /* 1743 */  vecY_rule,
  /* 1744 */  vecY_rule,
  /* 1745 */  vecZ_rule,
  /* 1746 */  vecZ_rule,
  /* 1747 */  vecZ_rule,
  /* 1748 */  vecX_rule,
  /* 1749 */  vecX_rule,
  /* 1750 */  vecY_rule,
  /* 1751 */  vecY_rule,
  /* 1752 */  vecZ_rule,
  /* 1753 */  vecZ_rule,
  /* 1754 */  vecX_rule,
  /* 1755 */  vecX_rule,
  /* 1756 */  vecY_rule,
  /* 1757 */  vecY_rule,
  /* 1758 */  vecZ_rule,
  /* 1759 */  vecZ_rule,
  // last instruction
  0 // no trailing comma
};

const        int   leftOp[] = {
  /*    0 */  0,
  /*    1 */  0,
  /*    2 */  0,
  /*    3 */  0,
  /*    4 */  0,
  /*    5 */  0,
  /*    6 */  0,
  /*    7 */  0,
  /*    8 */  0,
  /*    9 */  0,
  /*   10 */  0,
  /*   11 */  0,
  /*   12 */  0,
  /*   13 */  0,
  /*   14 */  0,
  /*   15 */  0,
  /*   16 */  0,
  /*   17 */  0,
  /*   18 */  0,
  /*   19 */  0,
  /*   20 */  0,
  /*   21 */  0,
  /*   22 */  0,
  /*   23 */  0,
  /*   24 */  0,
  /*   25 */  0,
  /*   26 */  0,
  /*   27 */  0,
  /*   28 */  0,
  /*   29 */  0,
  /*   30 */  0,
  /*   31 */  0,
  /*   32 */  0,
  /*   33 */  0,
  /*   34 */  0,
  /*   35 */  0,
  /*   36 */  0,
  /*   37 */  0,
  /*   38 */  0,
  /*   39 */  0,
  /*   40 */  0,
  /*   41 */  0,
  /*   42 */  0,
  /*   43 */  0,
  /*   44 */  0,
  /*   45 */  0,
  /*   46 */  0,
  /*   47 */  0,
  /*   48 */  0,
  /*   49 */  0,
  /*   50 */  0,
  /*   51 */  0,
  /*   52 */  0,
  /*   53 */  0,
  /*   54 */  0,
  /*   55 */  0,
  /*   56 */  0,
  /*   57 */  0,
  /*   58 */  0,
  /*   59 */  0,
  /*   60 */  0,
  /*   61 */  0,
  /*   62 */  0,
  /*   63 */  0,
  /*   64 */  0,
  /*   65 */  0,
  /*   66 */  0,
  /*   67 */  0,
  /*   68 */  0,
  /*   69 */  0,
  /*   70 */  0,
  /*   71 */  0,
  /*   72 */  0,
  /*   73 */  0,
  /*   74 */  0,
  /*   75 */  0,
  /*   76 */  0,
  /*   77 */  0,
  /*   78 */  0,
  /*   79 */  0,
  /*   80 */  0,
  /*   81 */  0,
  /*   82 */  0,
  /*   83 */  any_RegP_rule,
  /*   84 */  any_RegP_rule,
  /*   85 */  _AddP_any_RegP_rRegL_rule,
  /*   86 */  any_RegP_rule,
  /*   87 */  any_RegP_rule,
  /*   88 */  any_RegP_rule,
  /*   89 */  _AddP_any_RegP__LShiftL_rRegL_immI2_rule,
  /*   90 */  _AddP_any_RegP__ConvI2L_rRegI__rule,
  /*   91 */  _AddP_any_RegP__LShiftL__ConvI2L_rRegI__immI2_rule,
  /*   92 */  _DecodeN_rRegN__rule,
  /*   93 */  rRegN_rule,
  /*   94 */  _DecodeN_rRegN__rule,
  /*   95 */  _DecodeN_rRegN__rule,
  /*   96 */  _AddP__DecodeN_rRegN__rRegL_rule,
  /*   97 */  _DecodeN_rRegN__rule,
  /*   98 */  _DecodeN_rRegN__rule,
  /*   99 */  _AddP__DecodeN_rRegN___LShiftL_rRegL_immI2_rule,
  /*  100 */  _AddP__DecodeN_rRegN___ConvI2L_rRegI__rule,
  /*  101 */  _AddP__DecodeN_rRegN___LShiftL__ConvI2L_rRegI__immI2_rule,
  /*  102 */  0,
  /*  103 */  0,
  /*  104 */  0,
  /*  105 */  0,
  /*  106 */  0,
  /*  107 */  0,
  /*  108 */  0,
  /*  109 */  0,
  /*  110 */  0,
  /*  111 */  0,
  /*  112 */  0,
  /*  113 */  0,
  /*  114 */  0,
  /*  115 */  0,
  /*  116 */  0,
  /*  117 */  0,
  /*  118 */  0,
  /*  119 */  0,
  /*  120 */  0,
  /*  121 */  0,
  /*  122 */  0,
  /*  123 */  0,
  /*  124 */  0,
  /*  125 */  0,
  /*  126 */  0,
  /*  127 */  0,
  /*  128 */  0,
  /*  129 */  0,
  /*  130 */  0,
  /*  131 */  0,
  /*  132 */  0,
  /*  133 */  0,
  /*  134 */  0,
  /*  135 */  0,
  /*  136 */  0,
  /*  137 */  0,
  /*  138 */  0,
  /*  139 */  0,
  /*  140 */  0,
  /*  141 */  0,
  /*  142 */  0,
  /*  143 */  0,
  /*  144 */  0,
  // last operand
  /*  145 */  0,
  // last operand class
  /*  146 */  any_RegP_rule,
  /*  147 */  rRegL_rule,
  /*  148 */  rRegI_rule,
  /*  149 */  _ConvI2L_rRegI__rule,
  /*  150 */  any_RegP_rule,
  /*  151 */  any_RegP_rule,
  /*  152 */  any_RegP_rule,
  /*  153 */  rRegN_rule,
  /*  154 */  _DecodeN_rRegN__rule,
  /*  155 */  _DecodeN_rRegN__rule,
  /*  156 */  _DecodeN_rRegN__rule,
  /*  157 */  _DecodeN_rRegN__rule,
  /*  158 */  memory_rule,
  /*  159 */  memory_rule,
  /*  160 */  _LoadUB_memory__rule,
  /*  161 */  memory_rule,
  /*  162 */  _LoadS_memory__rule,
  /*  163 */  memory_rule,
  /*  164 */  _LoadUS_memory__rule,
  /*  165 */  _LoadUS_memory__rule,
  /*  166 */  _LoadUS_memory__rule,
  /*  167 */  memory_rule,
  /*  168 */  _LoadI_memory__rule,
  /*  169 */  _LoadI_memory__rule,
  /*  170 */  _LoadI_memory__rule,
  /*  171 */  _LoadI_memory__rule,
  /*  172 */  _LoadI_memory__rule,
  /*  173 */  _LoadI_memory__rule,
  /*  174 */  memory_rule,
  /*  175 */  rRegP_rule,
  /*  176 */  _DecodeN_rRegN__rule,
  /*  177 */  _LShiftL_rRegL_immI2_rule,
  /*  178 */  cmpOp_rule,
  /*  179 */  rRegI_rule,
  /*  180 */  cmpOpU_rule,
  /*  181 */  cmpOpUCF_rule,
  /*  182 */  rRegI_rule,
  /*  183 */  rRegN_rule,
  /*  184 */  rRegP_rule,
  /*  185 */  rRegL_rule,
  /*  186 */  rRegL_rule,
  /*  187 */  regF_rule,
  /*  188 */  regD_rule,
  /*  189 */  _LoadI_memory__rule,
  /*  190 */  rRegI_rule,
  /*  191 */  _LoadI_memory__rule,
  /*  192 */  _LoadI_memory__rule,
  /*  193 */  _LoadI_memory__rule,
  /*  194 */  _LoadL_memory__rule,
  /*  195 */  rRegL_rule,
  /*  196 */  _LoadL_memory__rule,
  /*  197 */  _LoadL_memory__rule,
  /*  198 */  _LoadL_memory__rule,
  /*  199 */  rax_RegP_rule,
  /*  200 */  rax_RegI_rule,
  /*  201 */  rax_RegL_rule,
  /*  202 */  rax_RegN_rule,
  /*  203 */  _LoadI_memory__rule,
  /*  204 */  _LoadI_memory__rule,
  /*  205 */  _LoadL_memory__rule,
  /*  206 */  _LoadL_memory__rule,
  /*  207 */  immI0_rule,
  /*  208 */  immI0_rule,
  /*  209 */  immL0_rule,
  /*  210 */  _LoadI_memory__rule,
  /*  211 */  _LoadI_memory__rule,
  /*  212 */  _LoadI_memory__rule,
  /*  213 */  _LoadI_memory__rule,
  /*  214 */  _LoadI_memory__rule,
  /*  215 */  _LoadI_memory__rule,
  /*  216 */  _LoadI_memory__rule,
  /*  217 */  _LoadI_memory__rule,
  /*  218 */  _LoadI_memory__rule,
  /*  219 */  _LoadL_memory__rule,
  /*  220 */  _LoadL_memory__rule,
  /*  221 */  _LoadL_memory__rule,
  /*  222 */  _LoadL_memory__rule,
  /*  223 */  _LoadL_memory__rule,
  /*  224 */  _LoadL_memory__rule,
  /*  225 */  _LoadL_memory__rule,
  /*  226 */  _LoadL_memory__rule,
  /*  227 */  _LoadL_memory__rule,
  /*  228 */  rRegI_rule,
  /*  229 */  rRegI_rule,
  /*  230 */  rRegI_rule,
  /*  231 */  rRegI_rule,
  /*  232 */  rRegI_rule,
  /*  233 */  rRegI_rule,
  /*  234 */  no_rcx_RegI_rule,
  /*  235 */  immI0_rule,
  /*  236 */  no_rcx_RegI_rule,
  /*  237 */  immI_32_rule,
  /*  238 */  no_rcx_RegI_rule,
  /*  239 */  rRegI_rule,
  /*  240 */  rRegI_rule,
  /*  241 */  no_rcx_RegI_rule,
  /*  242 */  no_rcx_RegI_rule,
  /*  243 */  no_rcx_RegI_rule,
  /*  244 */  rRegL_rule,
  /*  245 */  rRegL_rule,
  /*  246 */  rRegL_rule,
  /*  247 */  rRegL_rule,
  /*  248 */  no_rcx_RegL_rule,
  /*  249 */  no_rcx_RegL_rule,
  /*  250 */  immI_64_rule,
  /*  251 */  no_rcx_RegL_rule,
  /*  252 */  rRegL_rule,
  /*  253 */  rRegL_rule,
  /*  254 */  no_rcx_RegL_rule,
  /*  255 */  no_rcx_RegL_rule,
  /*  256 */  no_rcx_RegL_rule,
  /*  257 */  rRegI_rule,
  /*  258 */  rRegI_rule,
  /*  259 */  _LoadI_memory__rule,
  /*  260 */  rRegI_rule,
  /*  261 */  _LoadI_memory__rule,
  /*  262 */  rRegI_rule,
  /*  263 */  rRegI_rule,
  /*  264 */  _LoadI_memory__rule,
  /*  265 */  rRegI_rule,
  /*  266 */  _LoadI_memory__rule,
  /*  267 */  _LoadI_memory__rule,
  /*  268 */  rRegI_rule,
  /*  269 */  _LoadI_memory__rule,
  /*  270 */  _LoadL_memory__rule,
  /*  271 */  rRegL_rule,
  /*  272 */  _LoadL_memory__rule,
  /*  273 */  rRegL_rule,
  /*  274 */  immL0_rule,
  /*  275 */  rRegL_rule,
  /*  276 */  any_RegP_rule,
  /*  277 */  _LoadL_memory__rule,
  /*  278 */  rRegL_rule,
  /*  279 */  _LoadL_memory__rule,
  /*  280 */  _LoadL_memory__rule,
  /*  281 */  rRegL_rule,
  /*  282 */  _LoadL_memory__rule,
  /*  283 */  rRegI_rule,
  /*  284 */  _CmpLTMask_rRegI_rRegI_rule,
  /*  285 */  rRegI_rule,
  /*  286 */  rRegI_rule,
  /*  287 */  memory_rule,
  /*  288 */  memory_rule,
  /*  289 */  rdi_RegP_rule,
  /*  290 */  rsi_RegP_rule,
  /*  291 */  rdi_RegP_rule,
  /*  292 */  rsi_RegP_rule,
  /*  293 */  rsi_RegP_rule,
  /*  294 */  rdi_RegP_rule,
  /*  295 */  rRegI_rule,
  /*  296 */  memory_rule,
  /*  297 */  memory_rule,
  /*  298 */  memory_rule,
  /*  299 */  rRegL_rule,
  /*  300 */  _CastP2X_rRegP__rule,
  /*  301 */  _LoadL_memory__rule,
  /*  302 */  _LoadB_memory__rule,
  /*  303 */  rsi_RegP_rule,
  /*  304 */  memory_rule,
  /*  305 */  cmpOp_vcmppd_rule,
  /*  306 */  vecY_rule,
  /*  307 */  vecX_rule,
  /*  308 */  vecX_rule,
  /*  309 */  vecY_rule,
  /*  310 */  vecZ_rule,
  /*  311 */  vecZ_rule,
  // last internally defined operand
  /*  312 */  rRegI_rule,
  /*  313 */  rRegL_rule,
  /*  314 */  rRegP_rule,
  /*  315 */  regF_rule,
  /*  316 */  regD_rule,
  /*  317 */  indOffset8_rule,
  /*  318 */  indOffset32_rule,
  /*  319 */  indIndexOffset_rule,
  /*  320 */  indIndexScale_rule,
  /*  321 */  indPosIndexScale_rule,
  /*  322 */  indIndexScaleOffset_rule,
  /*  323 */  indPosIndexOffset_rule,
  /*  324 */  indPosIndexScaleOffset_rule,
  /*  325 */  indCompressedOopOffset_rule,
  /*  326 */  indOffset8Narrow_rule,
  /*  327 */  indOffset32Narrow_rule,
  /*  328 */  indIndexOffsetNarrow_rule,
  /*  329 */  indIndexScaleNarrow_rule,
  /*  330 */  indIndexScaleOffsetNarrow_rule,
  /*  331 */  indPosIndexOffsetNarrow_rule,
  /*  332 */  indPosIndexScaleOffsetNarrow_rule,
  /*  333 */  immI_rule,
  /*  334 */  immI0_rule,
  /*  335 */  immL_rule,
  /*  336 */  immL0_rule,
  /*  337 */  immUL32_rule,
  /*  338 */  immL32_rule,
  /*  339 */  immP_rule,
  /*  340 */  immP0_rule,
  /*  341 */  immP31_rule,
  /*  342 */  immF_rule,
  /*  343 */  immN0_rule,
  /*  344 */  immN_rule,
  /*  345 */  immNKlass_rule,
  /*  346 */  immF0_rule,
  /*  347 */  immD_rule,
  /*  348 */  immD0_rule,
  /*  349 */  stackSlotI_rule,
  /*  350 */  stackSlotL_rule,
  /*  351 */  stackSlotP_rule,
  /*  352 */  stackSlotF_rule,
  /*  353 */  stackSlotD_rule,
  /*  354 */  0,
  /*  355 */  rRegL_rule,
  /*  356 */  rRegP_rule,
  /*  357 */  rRegP_rule,
  /*  358 */  rRegP_rule,
  /*  359 */  rRegI_rule,
  /*  360 */  memory_rule,
  /*  361 */  memory_rule,
  /*  362 */  memory_rule,
  /*  363 */  regF_rule,
  /*  364 */  regF_rule,
  /*  365 */  regF_rule,
  /*  366 */  regF_rule,
  /*  367 */  regF_rule,
  /*  368 */  regF_rule,
  /*  369 */  regD_rule,
  /*  370 */  regD_rule,
  /*  371 */  regD_rule,
  /*  372 */  regD_rule,
  /*  373 */  regD_rule,
  /*  374 */  regD_rule,
  /*  375 */  regF_rule,
  /*  376 */  regD_rule,
  /*  377 */  stackSlotF_rule,
  /*  378 */  stackSlotI_rule,
  /*  379 */  stackSlotD_rule,
  /*  380 */  stackSlotL_rule,
  /*  381 */  stackSlotL_rule,
  /*  382 */  regF_rule,
  /*  383 */  regD_rule,
  /*  384 */  rRegI_rule,
  /*  385 */  rRegL_rule,
  /*  386 */  rax_RegI_rule,
  /*  387 */  rax_RegI_rule,
  /*  388 */  rax_RegL_rule,
  /*  389 */  rax_RegL_rule,
  /*  390 */  rRegI_rule,
  /*  391 */  rRegI_rule,
  /*  392 */  rRegL_rule,
  /*  393 */  rRegL_rule,
  /*  394 */  immI0_rule,
  /*  395 */  immL0_rule,
  /*  396 */  rax_RegI_rule,
  /*  397 */  rRegI_rule,
  /*  398 */  rax_RegL_rule,
  /*  399 */  rRegL_rule,
  /*  400 */  rRegI_rule,
  /*  401 */  rRegI_rule,
  /*  402 */  rRegI_rule,
  /*  403 */  rRegI_rule,
  /*  404 */  _AndI_rRegI_immI_rule,
  /*  405 */  _AndI_rRegI__LoadI_memory__rule,
  /*  406 */  _AndI__LoadI_memory__rRegI_rule,
  /*  407 */  rRegI_rule,
  /*  408 */  rRegI_rule,
  /*  409 */  rRegI_rule,
  /*  410 */  rRegI_rule,
  /*  411 */  rRegP_rule,
  /*  412 */  rRegP_rule,
  /*  413 */  rRegP_rule,
  /*  414 */  rRegP_rule,
  /*  415 */  _LoadP_memory__rule,
  /*  416 */  _LoadP_memory__rule,
  /*  417 */  rRegN_rule,
  /*  418 */  rRegN_rule,
  /*  419 */  rRegN_rule,
  /*  420 */  immN_rule,
  /*  421 */  rRegN_rule,
  /*  422 */  immNKlass_rule,
  /*  423 */  rRegN_rule,
  /*  424 */  _LoadN_memory__rule,
  /*  425 */  _LoadN_memory__rule,
  /*  426 */  rRegL_rule,
  /*  427 */  rRegL_rule,
  /*  428 */  rRegL_rule,
  /*  429 */  rRegL_rule,
  /*  430 */  _AndL_rRegL_immL32_rule,
  /*  431 */  _AndL_rRegL__LoadL_memory__rule,
  /*  432 */  _AndL__LoadL_memory__rRegL_rule,
  /*  433 */  _AndL__CastP2X_rRegP___LoadL_memory__rule,
  /*  434 */  _AndL__LoadL_memory___CastP2X_rRegP__rule,
  /*  435 */  rRegL_rule,
  /*  436 */  rRegL_rule,
  /*  437 */  rRegL_rule,
  /*  438 */  rRegL_rule,
  /*  439 */  _LoadB_memory__rule,
  /*  440 */  _AndI__LoadB_memory__immI8_rule,
  /*  441 */  _PartialSubtypeCheck_rsi_RegP_rax_RegP_rule,
  /*  442 */  rRegP_rule,
  /*  443 */  rRegP_rule,
  /*  444 */  rRegP_rule,
  /*  445 */  0,
  /*  446 */  0,
  /*  447 */  regF_rule,
  /*  448 */  regF_rule,
  /*  449 */  regF_rule,
  /*  450 */  regD_rule,
  /*  451 */  regD_rule,
  /*  452 */  regD_rule,
  /*  453 */  regF_rule,
  /*  454 */  regF_rule,
  /*  455 */  regD_rule,
  /*  456 */  regD_rule,
  /*  457 */  rRegI_rule,
  /*  458 */  rRegI_rule,
  /*  459 */  vecX_rule,
  /*  460 */  _LoadVector_memory__rule,
  /*  461 */  vecY_rule,
  /*  462 */  _LoadVector_memory__rule,
  /*  463 */  vecZ_rule,
  /*  464 */  _LoadVector_memory__rule,
  /*  465 */  vecD_rule,
  /*  466 */  _LoadVector_memory__rule,
  /*  467 */  vecX_rule,
  /*  468 */  _LoadVector_memory__rule,
  /*  469 */  vecY_rule,
  /*  470 */  _LoadVector_memory__rule,
  /*  471 */  vecZ_rule,
  /*  472 */  _LoadVector_memory__rule,
  /*  473 */  vecD_rule,
  /*  474 */  vecX_rule,
  /*  475 */  vecY_rule,
  /*  476 */  vecZ_rule,
  /*  477 */  memory_rule,
  /*  478 */  _LoadB_memory__rule,
  /*  479 */  memory_rule,
  /*  480 */  _LoadUB_memory__rule,
  /*  481 */  _AndI__LoadUB_memory__immI_rule,
  /*  482 */  memory_rule,
  /*  483 */  _LShiftI__LoadS_memory__immI_24_rule,
  /*  484 */  _LoadS_memory__rule,
  /*  485 */  memory_rule,
  /*  486 */  _LShiftI__LoadUS_memory__immI_24_rule,
  /*  487 */  _LoadUS_memory__rule,
  /*  488 */  _AndI__LoadUS_memory__immI_255_rule,
  /*  489 */  _AndI__LoadUS_memory__immI_rule,
  /*  490 */  memory_rule,
  /*  491 */  _LShiftI__LoadI_memory__immI_24_rule,
  /*  492 */  _LoadI_memory__rule,
  /*  493 */  _LShiftI__LoadI_memory__immI_16_rule,
  /*  494 */  _LoadI_memory__rule,
  /*  495 */  _LoadI_memory__rule,
  /*  496 */  _AndI__LoadI_memory__immI_255_rule,
  /*  497 */  _AndI__LoadI_memory__immI_65535_rule,
  /*  498 */  _AndI__LoadI_memory__immU31_rule,
  /*  499 */  _ConvI2L__LoadI_memory___rule,
  /*  500 */  memory_rule,
  /*  501 */  memory_rule,
  /*  502 */  memory_rule,
  /*  503 */  memory_rule,
  /*  504 */  memory_rule,
  /*  505 */  memory_rule,
  /*  506 */  memory_rule,
  /*  507 */  memory_rule,
  /*  508 */  memory_rule,
  /*  509 */  memory_rule,
  /*  510 */  memory_rule,
  /*  511 */  memory_rule,
  /*  512 */  memory_rule,
  /*  513 */  memory_rule,
  /*  514 */  memory_rule,
  /*  515 */  memory_rule,
  /*  516 */  memory_rule,
  /*  517 */  memory_rule,
  /*  518 */  memory_rule,
  /*  519 */  memory_rule,
  /*  520 */  memory_rule,
  /*  521 */  memory_rule,
  /*  522 */  memory_rule,
  /*  523 */  memory_rule,
  /*  524 */  memory_rule,
  /*  525 */  memory_rule,
  /*  526 */  memory_rule,
  /*  527 */  memory_rule,
  /*  528 */  memory_rule,
  /*  529 */  memory_rule,
  /*  530 */  memory_rule,
  /*  531 */  memory_rule,
  /*  532 */  memory_rule,
  /*  533 */  memory_rule,
  /*  534 */  memory_rule,
  /*  535 */  memory_rule,
  /*  536 */  memory_rule,
  /*  537 */  memory_rule,
  /*  538 */  memory_rule,
  /*  539 */  memory_rule,
  /*  540 */  memory_rule,
  /*  541 */  rRegI_rule,
  /*  542 */  rRegL_rule,
  /*  543 */  rRegI_rule,
  /*  544 */  rRegI_rule,
  /*  545 */  rRegI_rule,
  /*  546 */  rRegI_rule,
  /*  547 */  rRegL_rule,
  /*  548 */  rRegL_rule,
  /*  549 */  rRegI_rule,
  /*  550 */  rRegI_rule,
  /*  551 */  rRegL_rule,
  /*  552 */  rRegL_rule,
  /*  553 */  rRegI_rule,
  /*  554 */  _LoadI_memory__rule,
  /*  555 */  rRegL_rule,
  /*  556 */  _LoadL_memory__rule,
  /*  557 */  0,
  /*  558 */  0,
  /*  559 */  0,
  /*  560 */  0,
  /*  561 */  0,
  /*  562 */  0,
  /*  563 */  0,
  /*  564 */  0,
  /*  565 */  _CastP2X_rRegP__rule,
  /*  566 */  _CastP2X__DecodeN_rRegN___rule,
  /*  567 */  rRegP_rule,
  /*  568 */  rRegP_rule,
  /*  569 */  rRegN_rule,
  /*  570 */  rRegN_rule,
  /*  571 */  rRegP_rule,
  /*  572 */  rRegN_rule,
  /*  573 */  _LShiftL_rRegL_immI2_rule,
  /*  574 */  _AddL__LShiftL_rRegL_immI2_immL32_rule,
  /*  575 */  rRegL_rule,
  /*  576 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  577 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  578 */  _Binary_cmpOpUCF_rFlagsRegUCF_rule,
  /*  579 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  580 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  581 */  _Binary_cmpOpUCF_rFlagsRegUCF_rule,
  /*  582 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  583 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  584 */  _Binary_cmpOpUCF_rFlagsRegUCF_rule,
  /*  585 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  586 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  587 */  _Binary_cmpOpUCF_rFlagsRegUCF_rule,
  /*  588 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  589 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  590 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  591 */  _Binary_cmpOpUCF_rFlagsRegUCF_rule,
  /*  592 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  593 */  _Binary_cmpOpUCF_rFlagsRegUCF_rule,
  /*  594 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  595 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  596 */  _Binary_cmpOpUCF_rFlagsRegUCF_rule,
  /*  597 */  _Binary_cmpOp_rFlagsReg_rule,
  /*  598 */  _Binary_cmpOpU_rFlagsRegU_rule,
  /*  599 */  _Binary_cmpOpUCF_rFlagsRegUCF_rule,
  /*  600 */  rRegI_rule,
  /*  601 */  rRegI_rule,
  /*  602 */  rRegI_rule,
  /*  603 */  _LoadI_memory__rule,
  /*  604 */  memory_rule,
  /*  605 */  memory_rule,
  /*  606 */  memory_rule,
  /*  607 */  rRegI_rule,
  /*  608 */  memory_rule,
  /*  609 */  rRegI_rule,
  /*  610 */  memory_rule,
  /*  611 */  rRegI_rule,
  /*  612 */  rRegL_rule,
  /*  613 */  rRegL_rule,
  /*  614 */  rRegL_rule,
  /*  615 */  _LoadL_memory__rule,
  /*  616 */  memory_rule,
  /*  617 */  memory_rule,
  /*  618 */  memory_rule,
  /*  619 */  rRegI_rule,
  /*  620 */  memory_rule,
  /*  621 */  rRegL_rule,
  /*  622 */  memory_rule,
  /*  623 */  rRegL_rule,
  /*  624 */  rRegP_rule,
  /*  625 */  rRegP_rule,
  /*  626 */  rRegP_rule,
  /*  627 */  memory_rule,
  /*  628 */  memory_rule,
  /*  629 */  memory_rule,
  /*  630 */  memory_rule,
  /*  631 */  memory_rule,
  /*  632 */  memory_rule,
  /*  633 */  memory_rule,
  /*  634 */  memory_rule,
  /*  635 */  memory_rule,
  /*  636 */  memory_rule,
  /*  637 */  memory_rule,
  /*  638 */  memory_rule,
  /*  639 */  memory_rule,
  /*  640 */  memory_rule,
  /*  641 */  memory_rule,
  /*  642 */  memory_rule,
  /*  643 */  memory_rule,
  /*  644 */  memory_rule,
  /*  645 */  memory_rule,
  /*  646 */  memory_rule,
  /*  647 */  memory_rule,
  /*  648 */  memory_rule,
  /*  649 */  memory_rule,
  /*  650 */  memory_rule,
  /*  651 */  memory_rule,
  /*  652 */  memory_rule,
  /*  653 */  memory_rule,
  /*  654 */  memory_rule,
  /*  655 */  memory_rule,
  /*  656 */  memory_rule,
  /*  657 */  memory_rule,
  /*  658 */  memory_rule,
  /*  659 */  memory_rule,
  /*  660 */  rRegI_rule,
  /*  661 */  rRegI_rule,
  /*  662 */  rRegI_rule,
  /*  663 */  memory_rule,
  /*  664 */  memory_rule,
  /*  665 */  rRegL_rule,
  /*  666 */  rRegI_rule,
  /*  667 */  rRegL_rule,
  /*  668 */  memory_rule,
  /*  669 */  memory_rule,
  /*  670 */  rRegP_rule,
  /*  671 */  immI0_rule,
  /*  672 */  memory_rule,
  /*  673 */  immL0_rule,
  /*  674 */  memory_rule,
  /*  675 */  rRegI_rule,
  /*  676 */  rRegI_rule,
  /*  677 */  rRegI_rule,
  /*  678 */  _LoadI_memory__rule,
  /*  679 */  _LoadI_memory__rule,
  /*  680 */  rRegL_rule,
  /*  681 */  rRegL_rule,
  /*  682 */  rRegL_rule,
  /*  683 */  _LoadL_memory__rule,
  /*  684 */  _LoadL_memory__rule,
  /*  685 */  no_rax_RegL_rule,
  /*  686 */  rax_RegI_rule,
  /*  687 */  rax_RegL_rule,
  /*  688 */  rax_RegI_rule,
  /*  689 */  rax_RegL_rule,
  /*  690 */  0,
  /*  691 */  0,
  /*  692 */  0,
  /*  693 */  0,
  /*  694 */  no_rax_RegL_rule,
  /*  695 */  rax_RegI_rule,
  /*  696 */  rax_RegL_rule,
  /*  697 */  rRegI_rule,
  /*  698 */  memory_rule,
  /*  699 */  rRegI_rule,
  /*  700 */  memory_rule,
  /*  701 */  rRegI_rule,
  /*  702 */  memory_rule,
  /*  703 */  rRegI_rule,
  /*  704 */  memory_rule,
  /*  705 */  rRegI_rule,
  /*  706 */  memory_rule,
  /*  707 */  rRegI_rule,
  /*  708 */  memory_rule,
  /*  709 */  rRegI_rule,
  /*  710 */  memory_rule,
  /*  711 */  rRegI_rule,
  /*  712 */  memory_rule,
  /*  713 */  rRegI_rule,
  /*  714 */  memory_rule,
  /*  715 */  rRegL_rule,
  /*  716 */  memory_rule,
  /*  717 */  rRegL_rule,
  /*  718 */  memory_rule,
  /*  719 */  rRegL_rule,
  /*  720 */  memory_rule,
  /*  721 */  rRegL_rule,
  /*  722 */  memory_rule,
  /*  723 */  rRegL_rule,
  /*  724 */  memory_rule,
  /*  725 */  rRegL_rule,
  /*  726 */  memory_rule,
  /*  727 */  rRegL_rule,
  /*  728 */  memory_rule,
  /*  729 */  rRegL_rule,
  /*  730 */  memory_rule,
  /*  731 */  rRegL_rule,
  /*  732 */  memory_rule,
  /*  733 */  _LShiftI_rRegI_immI_24_rule,
  /*  734 */  _LShiftI_rRegI_immI_16_rule,
  /*  735 */  0,
  /*  736 */  0,
  /*  737 */  0,
  /*  738 */  _LShiftI_rRegI_immI1_rule,
  /*  739 */  _URShiftI_rRegI_immI_M1_rule,
  /*  740 */  _LShiftI_rRegI_immI8_rule,
  /*  741 */  _URShiftI_rRegI_immI8_rule,
  /*  742 */  _LShiftI_no_rcx_RegI_rcx_RegI_rule,
  /*  743 */  _URShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI_rule,
  /*  744 */  _LShiftI_no_rcx_RegI_rcx_RegI_rule,
  /*  745 */  _URShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI_rule,
  /*  746 */  0,
  /*  747 */  0,
  /*  748 */  0,
  /*  749 */  _URShiftI_rRegI_immI1_rule,
  /*  750 */  _LShiftI_rRegI_immI_M1_rule,
  /*  751 */  _URShiftI_rRegI_immI8_rule,
  /*  752 */  _LShiftI_rRegI_immI8_rule,
  /*  753 */  _URShiftI_no_rcx_RegI_rcx_RegI_rule,
  /*  754 */  _LShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI_rule,
  /*  755 */  _URShiftI_no_rcx_RegI_rcx_RegI_rule,
  /*  756 */  _LShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI_rule,
  /*  757 */  0,
  /*  758 */  0,
  /*  759 */  0,
  /*  760 */  _LShiftL_rRegL_immI1_rule,
  /*  761 */  _URShiftL_rRegL_immI_M1_rule,
  /*  762 */  _LShiftL_rRegL_immI8_rule,
  /*  763 */  _URShiftL_rRegL_immI8_rule,
  /*  764 */  _LShiftL_no_rcx_RegL_rcx_RegI_rule,
  /*  765 */  _URShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI_rule,
  /*  766 */  _LShiftL_no_rcx_RegL_rcx_RegI_rule,
  /*  767 */  _URShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI_rule,
  /*  768 */  0,
  /*  769 */  0,
  /*  770 */  0,
  /*  771 */  _URShiftL_rRegL_immI1_rule,
  /*  772 */  _LShiftL_rRegL_immI_M1_rule,
  /*  773 */  _URShiftL_rRegL_immI8_rule,
  /*  774 */  _LShiftL_rRegL_immI8_rule,
  /*  775 */  _URShiftL_no_rcx_RegL_rcx_RegI_rule,
  /*  776 */  _LShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI_rule,
  /*  777 */  _URShiftL_no_rcx_RegL_rcx_RegI_rule,
  /*  778 */  _LShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI_rule,
  /*  779 */  rRegI_rule,
  /*  780 */  rRegI_rule,
  /*  781 */  _AndI_rRegI_immI_255_rule,
  /*  782 */  rRegI_rule,
  /*  783 */  _AndI_rRegI_immI_65535_rule,
  /*  784 */  rRegI_rule,
  /*  785 */  rRegI_rule,
  /*  786 */  _LoadI_memory__rule,
  /*  787 */  memory_rule,
  /*  788 */  memory_rule,
  /*  789 */  memory_rule,
  /*  790 */  _XorI_rRegI_immI_M1_rule,
  /*  791 */  _LoadI_memory__rule,
  /*  792 */  _XorI_rRegI_immI_M1_rule,
  /*  793 */  rRegI_rule,
  /*  794 */  _SubI_immI0_rRegI_rule,
  /*  795 */  rRegI_rule,
  /*  796 */  _SubI_immI0__LoadI_memory__rule,
  /*  797 */  _LoadI_memory__rule,
  /*  798 */  _AddI__LoadI_memory__immI_M1_rule,
  /*  799 */  _LoadI_memory__rule,
  /*  800 */  _AddI_rRegI_immI_M1_rule,
  /*  801 */  rRegI_rule,
  /*  802 */  _AddI_rRegI_immI_M1_rule,
  /*  803 */  rRegI_rule,
  /*  804 */  _AddI__LoadI_memory__immI_M1_rule,
  /*  805 */  _LoadI_memory__rule,
  /*  806 */  rRegI_rule,
  /*  807 */  rRegI_rule,
  /*  808 */  rRegI_rule,
  /*  809 */  _LoadI_memory__rule,
  /*  810 */  memory_rule,
  /*  811 */  memory_rule,
  /*  812 */  memory_rule,
  /*  813 */  rRegI_rule,
  /*  814 */  rRegI_rule,
  /*  815 */  rRegI_rule,
  /*  816 */  rRegI_rule,
  /*  817 */  _LoadI_memory__rule,
  /*  818 */  memory_rule,
  /*  819 */  memory_rule,
  /*  820 */  memory_rule,
  /*  821 */  rRegL_rule,
  /*  822 */  rRegL_rule,
  /*  823 */  rRegL_rule,
  /*  824 */  rRegL_rule,
  /*  825 */  rRegL_rule,
  /*  826 */  _LoadL_memory__rule,
  /*  827 */  memory_rule,
  /*  828 */  memory_rule,
  /*  829 */  memory_rule,
  /*  830 */  _XorL_rRegL_immL_M1_rule,
  /*  831 */  _LoadL_memory__rule,
  /*  832 */  _XorL_rRegL_immL_M1_rule,
  /*  833 */  rRegL_rule,
  /*  834 */  _SubL_immL0_rRegL_rule,
  /*  835 */  rRegL_rule,
  /*  836 */  _SubL_immL0__LoadL_memory__rule,
  /*  837 */  _LoadL_memory__rule,
  /*  838 */  _AddL__LoadL_memory__immL_M1_rule,
  /*  839 */  _LoadL_memory__rule,
  /*  840 */  _AddL_rRegL_immL_M1_rule,
  /*  841 */  rRegL_rule,
  /*  842 */  _AddL_rRegL_immL_M1_rule,
  /*  843 */  rRegL_rule,
  /*  844 */  _AddL__LoadL_memory__immL_M1_rule,
  /*  845 */  _LoadL_memory__rule,
  /*  846 */  rRegL_rule,
  /*  847 */  rRegL_rule,
  /*  848 */  _CastP2X_any_RegP__rule,
  /*  849 */  rRegL_rule,
  /*  850 */  rRegL_rule,
  /*  851 */  _LoadL_memory__rule,
  /*  852 */  memory_rule,
  /*  853 */  memory_rule,
  /*  854 */  memory_rule,
  /*  855 */  rRegL_rule,
  /*  856 */  rRegL_rule,
  /*  857 */  rRegL_rule,
  /*  858 */  rRegL_rule,
  /*  859 */  _LoadL_memory__rule,
  /*  860 */  memory_rule,
  /*  861 */  memory_rule,
  /*  862 */  memory_rule,
  /*  863 */  rRegI_rule,
  /*  864 */  rRegP_rule,
  /*  865 */  rRegI_rule,
  /*  866 */  rRegI_rule,
  /*  867 */  _AndI__CmpLTMask_rRegI_rRegI_rRegI_rule,
  /*  868 */  _SubI_rRegI_rRegI_rule,
  /*  869 */  _AndI_rRegI__CmpLTMask_rRegI_rRegI_rule,
  /*  870 */  _SubI_rRegI_rRegI_rule,
  /*  871 */  _CmpLTMask_rRegI_rRegI_rule,
  /*  872 */  rRegI_rule,
  /*  873 */  regF_rule,
  /*  874 */  regF_rule,
  /*  875 */  regF_rule,
  /*  876 */  regD_rule,
  /*  877 */  regD_rule,
  /*  878 */  regD_rule,
  /*  879 */  regF_rule,
  /*  880 */  _LoadF_memory__rule,
  /*  881 */  regD_rule,
  /*  882 */  _LoadD_memory__rule,
  /*  883 */  regF_rule,
  /*  884 */  regF_rule,
  /*  885 */  regD_rule,
  /*  886 */  regD_rule,
  /*  887 */  rRegI_rule,
  /*  888 */  _LoadI_memory__rule,
  /*  889 */  rRegI_rule,
  /*  890 */  _LoadI_memory__rule,
  /*  891 */  rRegI_rule,
  /*  892 */  rRegI_rule,
  /*  893 */  rRegL_rule,
  /*  894 */  _LoadL_memory__rule,
  /*  895 */  rRegL_rule,
  /*  896 */  _LoadL_memory__rule,
  /*  897 */  rRegI_rule,
  /*  898 */  _ConvI2L_rRegI__rule,
  /*  899 */  _ConvI2L__LoadI_memory___rule,
  /*  900 */  rRegL_rule,
  /*  901 */  rRegL_rule,
  /*  902 */  regF_rule,
  /*  903 */  rRegI_rule,
  /*  904 */  regD_rule,
  /*  905 */  rRegL_rule,
  /*  906 */  rcx_RegL_rule,
  /*  907 */  rcx_RegL_rule,
  /*  908 */  _Binary_rdi_RegP_rcx_RegI_rule,
  /*  909 */  _Binary_rdi_RegP_rcx_RegI_rule,
  /*  910 */  _Binary_rdi_RegP_rcx_RegI_rule,
  /*  911 */  _Binary_rsi_RegP_rdx_RegI_rule,
  /*  912 */  _Binary_rdi_RegP_rdx_RegI_rule,
  /*  913 */  _Binary_rdi_RegP_rdx_RegI_rule,
  /*  914 */  _Binary_rdi_RegP_rdx_RegI_rule,
  /*  915 */  _Binary_rdi_RegP_rdx_RegI_rule,
  /*  916 */  _Binary_rdi_RegP_rdx_RegI_rule,
  /*  917 */  _Binary_rdi_RegP_rdx_RegI_rule,
  /*  918 */  _Binary_rdi_RegP_rdx_RegI_rule,
  /*  919 */  _Binary_rdi_RegP_rsi_RegP_rule,
  /*  920 */  rdi_RegP_rule,
  /*  921 */  rdi_RegP_rule,
  /*  922 */  rsi_RegP_rule,
  /*  923 */  rsi_RegP_rule,
  /*  924 */  rsi_RegP_rule,
  /*  925 */  rsi_RegP_rule,
  /*  926 */  rRegL_rule,
  /*  927 */  0,
  /*  928 */  rRegI_rule,
  /*  929 */  0,
  /*  930 */  rRegI_rule,
  /*  931 */  0,
  /*  932 */  cmpOp_rule,
  /*  933 */  cmpOp_rule,
  /*  934 */  cmpOpU_rule,
  /*  935 */  cmpOpUCF_rule,
  /*  936 */  cmpOp_rule,
  /*  937 */  cmpOpU_rule,
  /*  938 */  cmpOpUCF_rule,
  /*  939 */  cmpOpU_rule,
  /*  940 */  cmpOpUCF_rule,
  /*  941 */  cmpOpUCF2_rule,
  /*  942 */  rsi_RegP_rule,
  /*  943 */  0,
  /*  944 */  cmpOp_rule,
  /*  945 */  cmpOp_rule,
  /*  946 */  cmpOpU_rule,
  /*  947 */  cmpOpUCF_rule,
  /*  948 */  cmpOpU_rule,
  /*  949 */  cmpOpUCF_rule,
  /*  950 */  cmpOpUCF2_rule,
  /*  951 */  rRegP_rule,
  /*  952 */  rex_RegP_rule,
  /*  953 */  0,
  /*  954 */  0,
  /*  955 */  0,
  /*  956 */  0,
  /*  957 */  0,
  /*  958 */  0,
  /*  959 */  no_rbp_RegP_rule,
  /*  960 */  no_rbp_RegP_rule,
  /*  961 */  0,
  /*  962 */  0,
  /*  963 */  memory_rule,
  /*  964 */  memory_rule,
  /*  965 */  memory_rule,
  /*  966 */  memory_rule,
  /*  967 */  memory_rule,
  /*  968 */  memory_rule,
  /*  969 */  0,
  /*  970 */  rRegI_rule,
  /*  971 */  regF_rule,
  /*  972 */  regF_rule,
  /*  973 */  _LoadF_memory__rule,
  /*  974 */  regF_rule,
  /*  975 */  regF_rule,
  /*  976 */  regF_rule,
  /*  977 */  _LoadF_memory__rule,
  /*  978 */  regF_rule,
  /*  979 */  regD_rule,
  /*  980 */  regD_rule,
  /*  981 */  _LoadD_memory__rule,
  /*  982 */  regD_rule,
  /*  983 */  regD_rule,
  /*  984 */  regD_rule,
  /*  985 */  _LoadD_memory__rule,
  /*  986 */  regD_rule,
  /*  987 */  regF_rule,
  /*  988 */  regF_rule,
  /*  989 */  regF_rule,
  /*  990 */  regF_rule,
  /*  991 */  regF_rule,
  /*  992 */  regF_rule,
  /*  993 */  regD_rule,
  /*  994 */  regD_rule,
  /*  995 */  regD_rule,
  /*  996 */  regD_rule,
  /*  997 */  regD_rule,
  /*  998 */  regD_rule,
  /*  999 */  regF_rule,
  /* 1000 */  regF_rule,
  /* 1001 */  _LoadF_memory__rule,
  /* 1002 */  regF_rule,
  /* 1003 */  regF_rule,
  /* 1004 */  regF_rule,
  /* 1005 */  _LoadF_memory__rule,
  /* 1006 */  regF_rule,
  /* 1007 */  regD_rule,
  /* 1008 */  regD_rule,
  /* 1009 */  _LoadD_memory__rule,
  /* 1010 */  regD_rule,
  /* 1011 */  regD_rule,
  /* 1012 */  regD_rule,
  /* 1013 */  _LoadD_memory__rule,
  /* 1014 */  regD_rule,
  /* 1015 */  regF_rule,
  /* 1016 */  regF_rule,
  /* 1017 */  regF_rule,
  /* 1018 */  regF_rule,
  /* 1019 */  regF_rule,
  /* 1020 */  regF_rule,
  /* 1021 */  regD_rule,
  /* 1022 */  regD_rule,
  /* 1023 */  regD_rule,
  /* 1024 */  regD_rule,
  /* 1025 */  regD_rule,
  /* 1026 */  regD_rule,
  /* 1027 */  regF_rule,
  /* 1028 */  regD_rule,
  /* 1029 */  regF_rule,
  /* 1030 */  _LoadF_memory__rule,
  /* 1031 */  immF_rule,
  /* 1032 */  regD_rule,
  /* 1033 */  _LoadD_memory__rule,
  /* 1034 */  immD_rule,
  /* 1035 */  0,
  /* 1036 */  regD_rule,
  /* 1037 */  regF_rule,
  /* 1038 */  memory_rule,
  /* 1039 */  memory_rule,
  /* 1040 */  memory_rule,
  /* 1041 */  memory_rule,
  /* 1042 */  memory_rule,
  /* 1043 */  memory_rule,
  /* 1044 */  memory_rule,
  /* 1045 */  memory_rule,
  /* 1046 */  memory_rule,
  /* 1047 */  memory_rule,
  /* 1048 */  memory_rule,
  /* 1049 */  memory_rule,
  /* 1050 */  _LoadB_memory__rule,
  /* 1051 */  _LoadB_memory__rule,
  /* 1052 */  rRegI_rule,
  /* 1053 */  _LoadB_memory__rule,
  /* 1054 */  rRegI_rule,
  /* 1055 */  _LoadB_memory__rule,
  /* 1056 */  immI_rule,
  /* 1057 */  immI_rule,
  /* 1058 */  rRegI_rule,
  /* 1059 */  _LoadS_memory__rule,
  /* 1060 */  rRegI_rule,
  /* 1061 */  _LoadS_memory__rule,
  /* 1062 */  immI_rule,
  /* 1063 */  rRegI_rule,
  /* 1064 */  _LoadS_memory__rule,
  /* 1065 */  immI_rule,
  /* 1066 */  rRegI_rule,
  /* 1067 */  _LoadI_memory__rule,
  /* 1068 */  rRegI_rule,
  /* 1069 */  _LoadI_memory__rule,
  /* 1070 */  immI_rule,
  /* 1071 */  immI_rule,
  /* 1072 */  _LoadL_memory__rule,
  /* 1073 */  rRegL_rule,
  /* 1074 */  immL_rule,
  /* 1075 */  _LoadL_memory__rule,
  /* 1076 */  _LoadF_memory__rule,
  /* 1077 */  _LoadF_memory__rule,
  /* 1078 */  regF_rule,
  /* 1079 */  _LoadF_memory__rule,
  /* 1080 */  immF0_rule,
  /* 1081 */  immF0_rule,
  /* 1082 */  immF0_rule,
  /* 1083 */  _LoadD_memory__rule,
  /* 1084 */  regD_rule,
  /* 1085 */  _LoadD_memory__rule,
  /* 1086 */  immD0_rule,
  /* 1087 */  immD0_rule,
  /* 1088 */  rRegI_rule,
  /* 1089 */  rRegI_rule,
  /* 1090 */  immI_rule,
  /* 1091 */  immI_rule,
  /* 1092 */  immI0_rule,
  /* 1093 */  immI0_rule,
  /* 1094 */  immI0_rule,
  /* 1095 */  immI0_rule,
  /* 1096 */  rRegI_rule,
  /* 1097 */  immI_rule,
  /* 1098 */  immI_rule,
  /* 1099 */  immI0_rule,
  /* 1100 */  immI0_rule,
  /* 1101 */  immI0_rule,
  /* 1102 */  immI0_rule,
  /* 1103 */  rRegI_rule,
  /* 1104 */  _LoadI_memory__rule,
  /* 1105 */  immI_rule,
  /* 1106 */  immI0_rule,
  /* 1107 */  immI0_rule,
  /* 1108 */  immI0_rule,
  /* 1109 */  rRegL_rule,
  /* 1110 */  immL_rule,
  /* 1111 */  immL0_rule,
  /* 1112 */  immL0_rule,
  /* 1113 */  regF_rule,
  /* 1114 */  regF_rule,
  /* 1115 */  regD_rule,
  /* 1116 */  _LoadB_memory__rule,
  /* 1117 */  _LoadB_memory__rule,
  /* 1118 */  rRegI_rule,
  /* 1119 */  _LoadB_memory__rule,
  /* 1120 */  rRegI_rule,
  /* 1121 */  _LoadB_memory__rule,
  /* 1122 */  rRegI_rule,
  /* 1123 */  _LoadB_memory__rule,
  /* 1124 */  immI_rule,
  /* 1125 */  immI_rule,
  /* 1126 */  immI_rule,
  /* 1127 */  immI0_rule,
  /* 1128 */  rRegI_rule,
  /* 1129 */  _LoadS_memory__rule,
  /* 1130 */  rRegI_rule,
  /* 1131 */  _LoadS_memory__rule,
  /* 1132 */  rRegI_rule,
  /* 1133 */  _LoadS_memory__rule,
  /* 1134 */  rRegI_rule,
  /* 1135 */  _LoadS_memory__rule,
  /* 1136 */  immI_rule,
  /* 1137 */  immI_rule,
  /* 1138 */  immI_rule,
  /* 1139 */  immI0_rule,
  /* 1140 */  rRegI_rule,
  /* 1141 */  _LoadI_memory__rule,
  /* 1142 */  rRegI_rule,
  /* 1143 */  _LoadI_memory__rule,
  /* 1144 */  rRegI_rule,
  /* 1145 */  _LoadI_memory__rule,
  /* 1146 */  immI_rule,
  /* 1147 */  immI_rule,
  /* 1148 */  immI_rule,
  /* 1149 */  immI0_rule,
  /* 1150 */  rRegL_rule,
  /* 1151 */  rRegL_rule,
  /* 1152 */  immL_rule,
  /* 1153 */  immL_rule,
  /* 1154 */  _LoadL_memory__rule,
  /* 1155 */  _LoadL_memory__rule,
  /* 1156 */  _LoadL_memory__rule,
  /* 1157 */  immL0_rule,
  /* 1158 */  regF_rule,
  /* 1159 */  _LoadF_memory__rule,
  /* 1160 */  regF_rule,
  /* 1161 */  _LoadF_memory__rule,
  /* 1162 */  immF0_rule,
  /* 1163 */  immF0_rule,
  /* 1164 */  immF0_rule,
  /* 1165 */  immF0_rule,
  /* 1166 */  regD_rule,
  /* 1167 */  _LoadD_memory__rule,
  /* 1168 */  regD_rule,
  /* 1169 */  _LoadD_memory__rule,
  /* 1170 */  immD0_rule,
  /* 1171 */  immD0_rule,
  /* 1172 */  immD0_rule,
  /* 1173 */  rRegI_rule,
  /* 1174 */  rRegI_rule,
  /* 1175 */  rRegI_rule,
  /* 1176 */  rRegI_rule,
  /* 1177 */  rRegI_rule,
  /* 1178 */  rRegI_rule,
  /* 1179 */  rRegI_rule,
  /* 1180 */  rRegI_rule,
  /* 1181 */  rRegI_rule,
  /* 1182 */  rRegL_rule,
  /* 1183 */  rRegL_rule,
  /* 1184 */  rRegL_rule,
  /* 1185 */  regF_rule,
  /* 1186 */  regF_rule,
  /* 1187 */  regF_rule,
  /* 1188 */  regF_rule,
  /* 1189 */  regF_rule,
  /* 1190 */  regF_rule,
  /* 1191 */  regD_rule,
  /* 1192 */  regD_rule,
  /* 1193 */  regD_rule,
  /* 1194 */  regD_rule,
  /* 1195 */  rRegI_rule,
  /* 1196 */  rRegI_rule,
  /* 1197 */  rRegI_rule,
  /* 1198 */  rRegI_rule,
  /* 1199 */  rRegI_rule,
  /* 1200 */  rRegI_rule,
  /* 1201 */  rRegL_rule,
  /* 1202 */  rRegL_rule,
  /* 1203 */  rRegL_rule,
  /* 1204 */  regF_rule,
  /* 1205 */  regF_rule,
  /* 1206 */  regF_rule,
  /* 1207 */  regF_rule,
  /* 1208 */  regF_rule,
  /* 1209 */  regF_rule,
  /* 1210 */  regD_rule,
  /* 1211 */  regD_rule,
  /* 1212 */  regD_rule,
  /* 1213 */  regD_rule,
  /* 1214 */  vecS_rule,
  /* 1215 */  vecS_rule,
  /* 1216 */  vecS_rule,
  /* 1217 */  vecS_rule,
  /* 1218 */  vecS_rule,
  /* 1219 */  _LoadVector_memory__rule,
  /* 1220 */  vecS_rule,
  /* 1221 */  _LoadVector_memory__rule,
  /* 1222 */  vecS_rule,
  /* 1223 */  _LoadVector_memory__rule,
  /* 1224 */  vecD_rule,
  /* 1225 */  vecD_rule,
  /* 1226 */  vecD_rule,
  /* 1227 */  vecD_rule,
  /* 1228 */  vecD_rule,
  /* 1229 */  _LoadVector_memory__rule,
  /* 1230 */  vecD_rule,
  /* 1231 */  _LoadVector_memory__rule,
  /* 1232 */  vecD_rule,
  /* 1233 */  _LoadVector_memory__rule,
  /* 1234 */  vecX_rule,
  /* 1235 */  vecX_rule,
  /* 1236 */  vecX_rule,
  /* 1237 */  vecX_rule,
  /* 1238 */  vecX_rule,
  /* 1239 */  _LoadVector_memory__rule,
  /* 1240 */  vecX_rule,
  /* 1241 */  _LoadVector_memory__rule,
  /* 1242 */  vecX_rule,
  /* 1243 */  _LoadVector_memory__rule,
  /* 1244 */  vecY_rule,
  /* 1245 */  vecY_rule,
  /* 1246 */  vecY_rule,
  /* 1247 */  vecY_rule,
  /* 1248 */  _LoadVector_memory__rule,
  /* 1249 */  vecY_rule,
  /* 1250 */  _LoadVector_memory__rule,
  /* 1251 */  vecY_rule,
  /* 1252 */  _LoadVector_memory__rule,
  /* 1253 */  vecZ_rule,
  /* 1254 */  vecZ_rule,
  /* 1255 */  _LoadVector_memory__rule,
  /* 1256 */  vecS_rule,
  /* 1257 */  vecS_rule,
  /* 1258 */  vecS_rule,
  /* 1259 */  vecS_rule,
  /* 1260 */  vecS_rule,
  /* 1261 */  _LoadVector_memory__rule,
  /* 1262 */  vecS_rule,
  /* 1263 */  _LoadVector_memory__rule,
  /* 1264 */  vecS_rule,
  /* 1265 */  _LoadVector_memory__rule,
  /* 1266 */  vecD_rule,
  /* 1267 */  vecD_rule,
  /* 1268 */  vecD_rule,
  /* 1269 */  vecD_rule,
  /* 1270 */  vecD_rule,
  /* 1271 */  _LoadVector_memory__rule,
  /* 1272 */  vecD_rule,
  /* 1273 */  _LoadVector_memory__rule,
  /* 1274 */  vecD_rule,
  /* 1275 */  _LoadVector_memory__rule,
  /* 1276 */  vecX_rule,
  /* 1277 */  vecX_rule,
  /* 1278 */  vecX_rule,
  /* 1279 */  vecX_rule,
  /* 1280 */  vecX_rule,
  /* 1281 */  _LoadVector_memory__rule,
  /* 1282 */  vecX_rule,
  /* 1283 */  _LoadVector_memory__rule,
  /* 1284 */  vecX_rule,
  /* 1285 */  _LoadVector_memory__rule,
  /* 1286 */  vecY_rule,
  /* 1287 */  vecY_rule,
  /* 1288 */  vecY_rule,
  /* 1289 */  vecY_rule,
  /* 1290 */  _LoadVector_memory__rule,
  /* 1291 */  vecY_rule,
  /* 1292 */  _LoadVector_memory__rule,
  /* 1293 */  vecY_rule,
  /* 1294 */  _LoadVector_memory__rule,
  /* 1295 */  vecZ_rule,
  /* 1296 */  vecZ_rule,
  /* 1297 */  _LoadVector_memory__rule,
  /* 1298 */  vecD_rule,
  /* 1299 */  vecD_rule,
  /* 1300 */  vecD_rule,
  /* 1301 */  _LoadVector_memory__rule,
  /* 1302 */  vecX_rule,
  /* 1303 */  vecX_rule,
  /* 1304 */  vecX_rule,
  /* 1305 */  _LoadVector_memory__rule,
  /* 1306 */  vecY_rule,
  /* 1307 */  vecY_rule,
  /* 1308 */  _LoadVector_memory__rule,
  /* 1309 */  vecZ_rule,
  /* 1310 */  vecZ_rule,
  /* 1311 */  _LoadVector_memory__rule,
  /* 1312 */  vecX_rule,
  /* 1313 */  vecX_rule,
  /* 1314 */  vecX_rule,
  /* 1315 */  _LoadVector_memory__rule,
  /* 1316 */  vecY_rule,
  /* 1317 */  vecY_rule,
  /* 1318 */  _LoadVector_memory__rule,
  /* 1319 */  vecZ_rule,
  /* 1320 */  vecZ_rule,
  /* 1321 */  _LoadVector_memory__rule,
  /* 1322 */  vecD_rule,
  /* 1323 */  vecD_rule,
  /* 1324 */  vecD_rule,
  /* 1325 */  _LoadVector_memory__rule,
  /* 1326 */  vecX_rule,
  /* 1327 */  vecX_rule,
  /* 1328 */  vecX_rule,
  /* 1329 */  _LoadVector_memory__rule,
  /* 1330 */  vecY_rule,
  /* 1331 */  vecY_rule,
  /* 1332 */  _LoadVector_memory__rule,
  /* 1333 */  vecZ_rule,
  /* 1334 */  vecZ_rule,
  /* 1335 */  _LoadVector_memory__rule,
  /* 1336 */  vecX_rule,
  /* 1337 */  vecX_rule,
  /* 1338 */  vecX_rule,
  /* 1339 */  _LoadVector_memory__rule,
  /* 1340 */  vecY_rule,
  /* 1341 */  vecY_rule,
  /* 1342 */  _LoadVector_memory__rule,
  /* 1343 */  vecZ_rule,
  /* 1344 */  vecZ_rule,
  /* 1345 */  _LoadVector_memory__rule,
  /* 1346 */  vecS_rule,
  /* 1347 */  vecS_rule,
  /* 1348 */  vecS_rule,
  /* 1349 */  vecS_rule,
  /* 1350 */  vecS_rule,
  /* 1351 */  vecS_rule,
  /* 1352 */  vecS_rule,
  /* 1353 */  vecD_rule,
  /* 1354 */  vecD_rule,
  /* 1355 */  vecD_rule,
  /* 1356 */  vecD_rule,
  /* 1357 */  vecD_rule,
  /* 1358 */  vecD_rule,
  /* 1359 */  vecD_rule,
  /* 1360 */  vecX_rule,
  /* 1361 */  vecX_rule,
  /* 1362 */  vecX_rule,
  /* 1363 */  vecX_rule,
  /* 1364 */  vecX_rule,
  /* 1365 */  vecX_rule,
  /* 1366 */  vecX_rule,
  /* 1367 */  vecY_rule,
  /* 1368 */  vecY_rule,
  /* 1369 */  vecY_rule,
  /* 1370 */  vecY_rule,
  /* 1371 */  vecY_rule,
  /* 1372 */  vecY_rule,
  /* 1373 */  vecZ_rule,
  /* 1374 */  vecZ_rule,
  /* 1375 */  vecS_rule,
  /* 1376 */  vecS_rule,
  /* 1377 */  vecS_rule,
  /* 1378 */  vecS_rule,
  /* 1379 */  vecS_rule,
  /* 1380 */  vecS_rule,
  /* 1381 */  vecS_rule,
  /* 1382 */  vecD_rule,
  /* 1383 */  vecD_rule,
  /* 1384 */  vecD_rule,
  /* 1385 */  vecD_rule,
  /* 1386 */  vecD_rule,
  /* 1387 */  vecD_rule,
  /* 1388 */  vecD_rule,
  /* 1389 */  vecX_rule,
  /* 1390 */  vecX_rule,
  /* 1391 */  vecX_rule,
  /* 1392 */  vecX_rule,
  /* 1393 */  vecX_rule,
  /* 1394 */  vecX_rule,
  /* 1395 */  vecX_rule,
  /* 1396 */  vecY_rule,
  /* 1397 */  vecY_rule,
  /* 1398 */  vecY_rule,
  /* 1399 */  vecY_rule,
  /* 1400 */  vecY_rule,
  /* 1401 */  vecY_rule,
  /* 1402 */  vecZ_rule,
  /* 1403 */  vecZ_rule,
  /* 1404 */  vecD_rule,
  /* 1405 */  vecD_rule,
  /* 1406 */  vecD_rule,
  /* 1407 */  vecX_rule,
  /* 1408 */  vecX_rule,
  /* 1409 */  vecX_rule,
  /* 1410 */  vecY_rule,
  /* 1411 */  vecY_rule,
  /* 1412 */  vecZ_rule,
  /* 1413 */  vecZ_rule,
  /* 1414 */  vecX_rule,
  /* 1415 */  vecX_rule,
  /* 1416 */  vecX_rule,
  /* 1417 */  vecY_rule,
  /* 1418 */  vecY_rule,
  /* 1419 */  vecZ_rule,
  /* 1420 */  vecZ_rule,
  /* 1421 */  vecD_rule,
  /* 1422 */  vecD_rule,
  /* 1423 */  vecD_rule,
  /* 1424 */  vecX_rule,
  /* 1425 */  vecX_rule,
  /* 1426 */  vecX_rule,
  /* 1427 */  vecY_rule,
  /* 1428 */  vecY_rule,
  /* 1429 */  vecZ_rule,
  /* 1430 */  vecZ_rule,
  /* 1431 */  vecX_rule,
  /* 1432 */  vecX_rule,
  /* 1433 */  vecX_rule,
  /* 1434 */  vecY_rule,
  /* 1435 */  vecY_rule,
  /* 1436 */  vecZ_rule,
  /* 1437 */  vecZ_rule,
  /* 1438 */  vecS_rule,
  /* 1439 */  vecS_rule,
  /* 1440 */  vecS_rule,
  /* 1441 */  vecS_rule,
  /* 1442 */  vecS_rule,
  /* 1443 */  _LoadVector_memory__rule,
  /* 1444 */  vecS_rule,
  /* 1445 */  _LoadVector_memory__rule,
  /* 1446 */  vecS_rule,
  /* 1447 */  _LoadVector_memory__rule,
  /* 1448 */  vecD_rule,
  /* 1449 */  vecD_rule,
  /* 1450 */  vecD_rule,
  /* 1451 */  vecD_rule,
  /* 1452 */  vecD_rule,
  /* 1453 */  _LoadVector_memory__rule,
  /* 1454 */  vecD_rule,
  /* 1455 */  _LoadVector_memory__rule,
  /* 1456 */  vecD_rule,
  /* 1457 */  _LoadVector_memory__rule,
  /* 1458 */  vecX_rule,
  /* 1459 */  vecX_rule,
  /* 1460 */  vecX_rule,
  /* 1461 */  vecX_rule,
  /* 1462 */  vecX_rule,
  /* 1463 */  _LoadVector_memory__rule,
  /* 1464 */  vecX_rule,
  /* 1465 */  _LoadVector_memory__rule,
  /* 1466 */  vecX_rule,
  /* 1467 */  _LoadVector_memory__rule,
  /* 1468 */  vecY_rule,
  /* 1469 */  vecY_rule,
  /* 1470 */  vecY_rule,
  /* 1471 */  vecY_rule,
  /* 1472 */  _LoadVector_memory__rule,
  /* 1473 */  vecY_rule,
  /* 1474 */  _LoadVector_memory__rule,
  /* 1475 */  vecY_rule,
  /* 1476 */  _LoadVector_memory__rule,
  /* 1477 */  vecZ_rule,
  /* 1478 */  vecZ_rule,
  /* 1479 */  _LoadVector_memory__rule,
  /* 1480 */  vecD_rule,
  /* 1481 */  vecD_rule,
  /* 1482 */  vecD_rule,
  /* 1483 */  _LoadVector_memory__rule,
  /* 1484 */  vecX_rule,
  /* 1485 */  vecX_rule,
  /* 1486 */  vecX_rule,
  /* 1487 */  _LoadVector_memory__rule,
  /* 1488 */  vecX_rule,
  /* 1489 */  vecX_rule,
  /* 1490 */  _LoadVector_memory__rule,
  /* 1491 */  vecY_rule,
  /* 1492 */  vecY_rule,
  /* 1493 */  _LoadVector_memory__rule,
  /* 1494 */  vecZ_rule,
  /* 1495 */  vecZ_rule,
  /* 1496 */  _LoadVector_memory__rule,
  /* 1497 */  vecY_rule,
  /* 1498 */  vecY_rule,
  /* 1499 */  _LoadVector_memory__rule,
  /* 1500 */  vecZ_rule,
  /* 1501 */  vecZ_rule,
  /* 1502 */  _LoadVector_memory__rule,
  /* 1503 */  vecD_rule,
  /* 1504 */  vecD_rule,
  /* 1505 */  vecD_rule,
  /* 1506 */  _LoadVector_memory__rule,
  /* 1507 */  vecX_rule,
  /* 1508 */  vecX_rule,
  /* 1509 */  vecX_rule,
  /* 1510 */  _LoadVector_memory__rule,
  /* 1511 */  vecY_rule,
  /* 1512 */  vecY_rule,
  /* 1513 */  _LoadVector_memory__rule,
  /* 1514 */  vecZ_rule,
  /* 1515 */  vecZ_rule,
  /* 1516 */  _LoadVector_memory__rule,
  /* 1517 */  vecX_rule,
  /* 1518 */  vecX_rule,
  /* 1519 */  vecX_rule,
  /* 1520 */  _LoadVector_memory__rule,
  /* 1521 */  vecY_rule,
  /* 1522 */  vecY_rule,
  /* 1523 */  _LoadVector_memory__rule,
  /* 1524 */  vecZ_rule,
  /* 1525 */  vecZ_rule,
  /* 1526 */  _LoadVector_memory__rule,
  /* 1527 */  _Binary_cmpOp_vcmppd_immI8_rule,
  /* 1528 */  _Binary_cmpOp_vcmppd_immI8_rule,
  /* 1529 */  vecD_rule,
  /* 1530 */  vecD_rule,
  /* 1531 */  vecD_rule,
  /* 1532 */  vecX_rule,
  /* 1533 */  vecX_rule,
  /* 1534 */  vecX_rule,
  /* 1535 */  vecY_rule,
  /* 1536 */  vecY_rule,
  /* 1537 */  vecZ_rule,
  /* 1538 */  vecZ_rule,
  /* 1539 */  vecX_rule,
  /* 1540 */  vecX_rule,
  /* 1541 */  vecX_rule,
  /* 1542 */  vecY_rule,
  /* 1543 */  vecY_rule,
  /* 1544 */  vecZ_rule,
  /* 1545 */  vecZ_rule,
  /* 1546 */  vecS_rule,
  /* 1547 */  vecS_rule,
  /* 1548 */  vecS_rule,
  /* 1549 */  vecS_rule,
  /* 1550 */  vecS_rule,
  /* 1551 */  vecS_rule,
  /* 1552 */  vecS_rule,
  /* 1553 */  vecS_rule,
  /* 1554 */  vecD_rule,
  /* 1555 */  vecD_rule,
  /* 1556 */  vecD_rule,
  /* 1557 */  vecD_rule,
  /* 1558 */  vecD_rule,
  /* 1559 */  vecD_rule,
  /* 1560 */  vecD_rule,
  /* 1561 */  vecD_rule,
  /* 1562 */  vecX_rule,
  /* 1563 */  vecX_rule,
  /* 1564 */  vecX_rule,
  /* 1565 */  vecX_rule,
  /* 1566 */  vecX_rule,
  /* 1567 */  vecX_rule,
  /* 1568 */  vecX_rule,
  /* 1569 */  vecX_rule,
  /* 1570 */  vecY_rule,
  /* 1571 */  vecY_rule,
  /* 1572 */  vecY_rule,
  /* 1573 */  vecY_rule,
  /* 1574 */  vecY_rule,
  /* 1575 */  vecY_rule,
  /* 1576 */  vecZ_rule,
  /* 1577 */  vecZ_rule,
  /* 1578 */  vecD_rule,
  /* 1579 */  vecD_rule,
  /* 1580 */  vecD_rule,
  /* 1581 */  vecD_rule,
  /* 1582 */  vecX_rule,
  /* 1583 */  vecX_rule,
  /* 1584 */  vecX_rule,
  /* 1585 */  vecX_rule,
  /* 1586 */  vecY_rule,
  /* 1587 */  vecY_rule,
  /* 1588 */  vecZ_rule,
  /* 1589 */  vecZ_rule,
  /* 1590 */  vecX_rule,
  /* 1591 */  vecX_rule,
  /* 1592 */  vecX_rule,
  /* 1593 */  vecX_rule,
  /* 1594 */  vecY_rule,
  /* 1595 */  vecY_rule,
  /* 1596 */  vecZ_rule,
  /* 1597 */  vecZ_rule,
  /* 1598 */  vecS_rule,
  /* 1599 */  vecS_rule,
  /* 1600 */  vecS_rule,
  /* 1601 */  vecS_rule,
  /* 1602 */  vecS_rule,
  /* 1603 */  vecS_rule,
  /* 1604 */  vecS_rule,
  /* 1605 */  vecS_rule,
  /* 1606 */  vecD_rule,
  /* 1607 */  vecD_rule,
  /* 1608 */  vecD_rule,
  /* 1609 */  vecD_rule,
  /* 1610 */  vecD_rule,
  /* 1611 */  vecD_rule,
  /* 1612 */  vecD_rule,
  /* 1613 */  vecD_rule,
  /* 1614 */  vecX_rule,
  /* 1615 */  vecX_rule,
  /* 1616 */  vecX_rule,
  /* 1617 */  vecX_rule,
  /* 1618 */  vecX_rule,
  /* 1619 */  vecX_rule,
  /* 1620 */  vecX_rule,
  /* 1621 */  vecX_rule,
  /* 1622 */  vecY_rule,
  /* 1623 */  vecY_rule,
  /* 1624 */  vecY_rule,
  /* 1625 */  vecY_rule,
  /* 1626 */  vecY_rule,
  /* 1627 */  vecY_rule,
  /* 1628 */  vecZ_rule,
  /* 1629 */  vecZ_rule,
  /* 1630 */  vecD_rule,
  /* 1631 */  vecD_rule,
  /* 1632 */  vecD_rule,
  /* 1633 */  vecD_rule,
  /* 1634 */  vecX_rule,
  /* 1635 */  vecX_rule,
  /* 1636 */  vecX_rule,
  /* 1637 */  vecX_rule,
  /* 1638 */  vecY_rule,
  /* 1639 */  vecY_rule,
  /* 1640 */  vecZ_rule,
  /* 1641 */  vecZ_rule,
  /* 1642 */  vecX_rule,
  /* 1643 */  vecX_rule,
  /* 1644 */  vecX_rule,
  /* 1645 */  vecX_rule,
  /* 1646 */  vecY_rule,
  /* 1647 */  vecY_rule,
  /* 1648 */  vecZ_rule,
  /* 1649 */  vecZ_rule,
  /* 1650 */  vecS_rule,
  /* 1651 */  vecS_rule,
  /* 1652 */  vecS_rule,
  /* 1653 */  vecS_rule,
  /* 1654 */  vecS_rule,
  /* 1655 */  vecS_rule,
  /* 1656 */  vecS_rule,
  /* 1657 */  vecS_rule,
  /* 1658 */  vecD_rule,
  /* 1659 */  vecD_rule,
  /* 1660 */  vecD_rule,
  /* 1661 */  vecD_rule,
  /* 1662 */  vecD_rule,
  /* 1663 */  vecD_rule,
  /* 1664 */  vecD_rule,
  /* 1665 */  vecD_rule,
  /* 1666 */  vecX_rule,
  /* 1667 */  vecX_rule,
  /* 1668 */  vecX_rule,
  /* 1669 */  vecX_rule,
  /* 1670 */  vecX_rule,
  /* 1671 */  vecX_rule,
  /* 1672 */  vecX_rule,
  /* 1673 */  vecX_rule,
  /* 1674 */  vecY_rule,
  /* 1675 */  vecY_rule,
  /* 1676 */  vecY_rule,
  /* 1677 */  vecY_rule,
  /* 1678 */  vecY_rule,
  /* 1679 */  vecY_rule,
  /* 1680 */  vecZ_rule,
  /* 1681 */  vecZ_rule,
  /* 1682 */  vecD_rule,
  /* 1683 */  vecD_rule,
  /* 1684 */  vecD_rule,
  /* 1685 */  vecD_rule,
  /* 1686 */  vecX_rule,
  /* 1687 */  vecX_rule,
  /* 1688 */  vecX_rule,
  /* 1689 */  vecX_rule,
  /* 1690 */  vecY_rule,
  /* 1691 */  vecY_rule,
  /* 1692 */  vecZ_rule,
  /* 1693 */  vecZ_rule,
  /* 1694 */  vecS_rule,
  /* 1695 */  vecS_rule,
  /* 1696 */  vecS_rule,
  /* 1697 */  _LoadVector_memory__rule,
  /* 1698 */  vecD_rule,
  /* 1699 */  vecD_rule,
  /* 1700 */  vecD_rule,
  /* 1701 */  _LoadVector_memory__rule,
  /* 1702 */  vecX_rule,
  /* 1703 */  vecX_rule,
  /* 1704 */  vecX_rule,
  /* 1705 */  _LoadVector_memory__rule,
  /* 1706 */  vecY_rule,
  /* 1707 */  vecY_rule,
  /* 1708 */  _LoadVector_memory__rule,
  /* 1709 */  vecZ_rule,
  /* 1710 */  vecZ_rule,
  /* 1711 */  _LoadVector_memory__rule,
  /* 1712 */  vecS_rule,
  /* 1713 */  vecS_rule,
  /* 1714 */  vecS_rule,
  /* 1715 */  _LoadVector_memory__rule,
  /* 1716 */  vecD_rule,
  /* 1717 */  vecD_rule,
  /* 1718 */  vecD_rule,
  /* 1719 */  _LoadVector_memory__rule,
  /* 1720 */  vecX_rule,
  /* 1721 */  vecX_rule,
  /* 1722 */  vecX_rule,
  /* 1723 */  _LoadVector_memory__rule,
  /* 1724 */  vecY_rule,
  /* 1725 */  vecY_rule,
  /* 1726 */  _LoadVector_memory__rule,
  /* 1727 */  vecZ_rule,
  /* 1728 */  vecZ_rule,
  /* 1729 */  _LoadVector_memory__rule,
  /* 1730 */  vecS_rule,
  /* 1731 */  vecS_rule,
  /* 1732 */  vecS_rule,
  /* 1733 */  _LoadVector_memory__rule,
  /* 1734 */  vecD_rule,
  /* 1735 */  vecD_rule,
  /* 1736 */  vecD_rule,
  /* 1737 */  _LoadVector_memory__rule,
  /* 1738 */  vecX_rule,
  /* 1739 */  vecX_rule,
  /* 1740 */  vecX_rule,
  /* 1741 */  _LoadVector_memory__rule,
  /* 1742 */  vecY_rule,
  /* 1743 */  vecY_rule,
  /* 1744 */  _LoadVector_memory__rule,
  /* 1745 */  vecZ_rule,
  /* 1746 */  vecZ_rule,
  /* 1747 */  _LoadVector_memory__rule,
  /* 1748 */  vecX_rule,
  /* 1749 */  vecX_rule,
  /* 1750 */  vecY_rule,
  /* 1751 */  vecY_rule,
  /* 1752 */  vecZ_rule,
  /* 1753 */  vecZ_rule,
  /* 1754 */  vecX_rule,
  /* 1755 */  vecX_rule,
  /* 1756 */  vecY_rule,
  /* 1757 */  vecY_rule,
  /* 1758 */  vecZ_rule,
  /* 1759 */  vecZ_rule,
  // last instruction
  0 // no trailing comma
};

const        int   rightOp[] = {
  /*    0 */  0,
  /*    1 */  0,
  /*    2 */  0,
  /*    3 */  0,
  /*    4 */  0,
  /*    5 */  0,
  /*    6 */  0,
  /*    7 */  0,
  /*    8 */  0,
  /*    9 */  0,
  /*   10 */  0,
  /*   11 */  0,
  /*   12 */  0,
  /*   13 */  0,
  /*   14 */  0,
  /*   15 */  0,
  /*   16 */  0,
  /*   17 */  0,
  /*   18 */  0,
  /*   19 */  0,
  /*   20 */  0,
  /*   21 */  0,
  /*   22 */  0,
  /*   23 */  0,
  /*   24 */  0,
  /*   25 */  0,
  /*   26 */  0,
  /*   27 */  0,
  /*   28 */  0,
  /*   29 */  0,
  /*   30 */  0,
  /*   31 */  0,
  /*   32 */  0,
  /*   33 */  0,
  /*   34 */  0,
  /*   35 */  0,
  /*   36 */  0,
  /*   37 */  0,
  /*   38 */  0,
  /*   39 */  0,
  /*   40 */  0,
  /*   41 */  0,
  /*   42 */  0,
  /*   43 */  0,
  /*   44 */  0,
  /*   45 */  0,
  /*   46 */  0,
  /*   47 */  0,
  /*   48 */  0,
  /*   49 */  0,
  /*   50 */  0,
  /*   51 */  0,
  /*   52 */  0,
  /*   53 */  0,
  /*   54 */  0,
  /*   55 */  0,
  /*   56 */  0,
  /*   57 */  0,
  /*   58 */  0,
  /*   59 */  0,
  /*   60 */  0,
  /*   61 */  0,
  /*   62 */  0,
  /*   63 */  0,
  /*   64 */  0,
  /*   65 */  0,
  /*   66 */  0,
  /*   67 */  0,
  /*   68 */  0,
  /*   69 */  0,
  /*   70 */  0,
  /*   71 */  0,
  /*   72 */  0,
  /*   73 */  0,
  /*   74 */  0,
  /*   75 */  0,
  /*   76 */  0,
  /*   77 */  0,
  /*   78 */  0,
  /*   79 */  0,
  /*   80 */  0,
  /*   81 */  0,
  /*   82 */  0,
  /*   83 */  immL8_rule,
  /*   84 */  immL32_rule,
  /*   85 */  immL32_rule,
  /*   86 */  rRegL_rule,
  /*   87 */  _LShiftL_rRegL_immI2_rule,
  /*   88 */  _LShiftL__ConvI2L_rRegI__immI2_rule,
  /*   89 */  immL32_rule,
  /*   90 */  immL32_rule,
  /*   91 */  immL32_rule,
  /*   92 */  immL32_rule,
  /*   93 */  0,
  /*   94 */  immL8_rule,
  /*   95 */  immL32_rule,
  /*   96 */  immL32_rule,
  /*   97 */  rRegL_rule,
  /*   98 */  _LShiftL_rRegL_immI2_rule,
  /*   99 */  immL32_rule,
  /*  100 */  immL32_rule,
  /*  101 */  immL32_rule,
  /*  102 */  0,
  /*  103 */  0,
  /*  104 */  0,
  /*  105 */  0,
  /*  106 */  0,
  /*  107 */  0,
  /*  108 */  0,
  /*  109 */  0,
  /*  110 */  0,
  /*  111 */  0,
  /*  112 */  0,
  /*  113 */  0,
  /*  114 */  0,
  /*  115 */  0,
  /*  116 */  0,
  /*  117 */  0,
  /*  118 */  0,
  /*  119 */  0,
  /*  120 */  0,
  /*  121 */  0,
  /*  122 */  0,
  /*  123 */  0,
  /*  124 */  0,
  /*  125 */  0,
  /*  126 */  0,
  /*  127 */  0,
  /*  128 */  0,
  /*  129 */  0,
  /*  130 */  0,
  /*  131 */  0,
  /*  132 */  0,
  /*  133 */  0,
  /*  134 */  0,
  /*  135 */  0,
  /*  136 */  0,
  /*  137 */  0,
  /*  138 */  0,
  /*  139 */  0,
  /*  140 */  0,
  /*  141 */  0,
  /*  142 */  0,
  /*  143 */  0,
  /*  144 */  0,
  // last operand
  /*  145 */  0,
  // last operand class
  /*  146 */  rRegL_rule,
  /*  147 */  immI2_rule,
  /*  148 */  0,
  /*  149 */  immI2_rule,
  /*  150 */  _LShiftL_rRegL_immI2_rule,
  /*  151 */  _ConvI2L_rRegI__rule,
  /*  152 */  _LShiftL__ConvI2L_rRegI__immI2_rule,
  /*  153 */  0,
  /*  154 */  rRegL_rule,
  /*  155 */  _LShiftL_rRegL_immI2_rule,
  /*  156 */  _ConvI2L_rRegI__rule,
  /*  157 */  _LShiftL__ConvI2L_rRegI__immI2_rule,
  /*  158 */  0,
  /*  159 */  0,
  /*  160 */  immI_rule,
  /*  161 */  0,
  /*  162 */  immI_24_rule,
  /*  163 */  0,
  /*  164 */  immI_24_rule,
  /*  165 */  immI_255_rule,
  /*  166 */  immI_rule,
  /*  167 */  0,
  /*  168 */  immI_24_rule,
  /*  169 */  immI_16_rule,
  /*  170 */  immI_255_rule,
  /*  171 */  immI_65535_rule,
  /*  172 */  immU31_rule,
  /*  173 */  0,
  /*  174 */  0,
  /*  175 */  0,
  /*  176 */  0,
  /*  177 */  immL32_rule,
  /*  178 */  rFlagsReg_rule,
  /*  179 */  rRegI_rule,
  /*  180 */  rFlagsRegU_rule,
  /*  181 */  rFlagsRegUCF_rule,
  /*  182 */  _LoadI_memory__rule,
  /*  183 */  rRegN_rule,
  /*  184 */  rRegP_rule,
  /*  185 */  rRegL_rule,
  /*  186 */  _LoadL_memory__rule,
  /*  187 */  regF_rule,
  /*  188 */  regD_rule,
  /*  189 */  rRegI_rule,
  /*  190 */  _LoadI_memory__rule,
  /*  191 */  immI_rule,
  /*  192 */  immI1_rule,
  /*  193 */  immI_M1_rule,
  /*  194 */  rRegL_rule,
  /*  195 */  _LoadL_memory__rule,
  /*  196 */  immL32_rule,
  /*  197 */  immL1_rule,
  /*  198 */  immL_M1_rule,
  /*  199 */  rRegP_rule,
  /*  200 */  rRegI_rule,
  /*  201 */  rRegL_rule,
  /*  202 */  rRegN_rule,
  /*  203 */  rRegI_rule,
  /*  204 */  immI_rule,
  /*  205 */  rRegL_rule,
  /*  206 */  immL32_rule,
  /*  207 */  rRegI_rule,
  /*  208 */  _LoadI_memory__rule,
  /*  209 */  _LoadL_memory__rule,
  /*  210 */  immI1_rule,
  /*  211 */  immI8_rule,
  /*  212 */  rcx_RegI_rule,
  /*  213 */  immI1_rule,
  /*  214 */  immI8_rule,
  /*  215 */  rcx_RegI_rule,
  /*  216 */  immI1_rule,
  /*  217 */  immI8_rule,
  /*  218 */  rcx_RegI_rule,
  /*  219 */  immI1_rule,
  /*  220 */  immI8_rule,
  /*  221 */  rcx_RegI_rule,
  /*  222 */  immI1_rule,
  /*  223 */  immI8_rule,
  /*  224 */  rcx_RegI_rule,
  /*  225 */  immI1_rule,
  /*  226 */  immI8_rule,
  /*  227 */  rcx_RegI_rule,
  /*  228 */  immI_24_rule,
  /*  229 */  immI_16_rule,
  /*  230 */  immI1_rule,
  /*  231 */  immI_M1_rule,
  /*  232 */  immI8_rule,
  /*  233 */  immI8_rule,
  /*  234 */  rcx_RegI_rule,
  /*  235 */  rcx_RegI_rule,
  /*  236 */  _SubI_immI0_rcx_RegI_rule,
  /*  237 */  rcx_RegI_rule,
  /*  238 */  _SubI_immI_32_rcx_RegI_rule,
  /*  239 */  immI1_rule,
  /*  240 */  immI_M1_rule,
  /*  241 */  rcx_RegI_rule,
  /*  242 */  _SubI_immI0_rcx_RegI_rule,
  /*  243 */  _SubI_immI_32_rcx_RegI_rule,
  /*  244 */  immI1_rule,
  /*  245 */  immI_M1_rule,
  /*  246 */  immI8_rule,
  /*  247 */  immI8_rule,
  /*  248 */  rcx_RegI_rule,
  /*  249 */  _SubI_immI0_rcx_RegI_rule,
  /*  250 */  rcx_RegI_rule,
  /*  251 */  _SubI_immI_64_rcx_RegI_rule,
  /*  252 */  immI1_rule,
  /*  253 */  immI_M1_rule,
  /*  254 */  rcx_RegI_rule,
  /*  255 */  _SubI_immI0_rcx_RegI_rule,
  /*  256 */  _SubI_immI_64_rcx_RegI_rule,
  /*  257 */  immI_255_rule,
  /*  258 */  immI_65535_rule,
  /*  259 */  rRegI_rule,
  /*  260 */  _LoadI_memory__rule,
  /*  261 */  immI_rule,
  /*  262 */  immI_M1_rule,
  /*  263 */  immI_M1_rule,
  /*  264 */  rRegI_rule,
  /*  265 */  _LoadI_memory__rule,
  /*  266 */  immI_rule,
  /*  267 */  rRegI_rule,
  /*  268 */  _LoadI_memory__rule,
  /*  269 */  immI_rule,
  /*  270 */  rRegL_rule,
  /*  271 */  _LoadL_memory__rule,
  /*  272 */  immL32_rule,
  /*  273 */  immL_M1_rule,
  /*  274 */  rRegL_rule,
  /*  275 */  immL_M1_rule,
  /*  276 */  0,
  /*  277 */  rRegL_rule,
  /*  278 */  _LoadL_memory__rule,
  /*  279 */  immL32_rule,
  /*  280 */  rRegL_rule,
  /*  281 */  _LoadL_memory__rule,
  /*  282 */  immL32_rule,
  /*  283 */  rRegI_rule,
  /*  284 */  rRegI_rule,
  /*  285 */  rRegI_rule,
  /*  286 */  _CmpLTMask_rRegI_rRegI_rule,
  /*  287 */  0,
  /*  288 */  0,
  /*  289 */  rcx_RegI_rule,
  /*  290 */  rdx_RegI_rule,
  /*  291 */  rdx_RegI_rule,
  /*  292 */  immI_rule,
  /*  293 */  rax_RegI_rule,
  /*  294 */  rsi_RegP_rule,
  /*  295 */  immI_rule,
  /*  296 */  0,
  /*  297 */  0,
  /*  298 */  0,
  /*  299 */  immL32_rule,
  /*  300 */  _LoadL_memory__rule,
  /*  301 */  _CastP2X_rRegP__rule,
  /*  302 */  immI8_rule,
  /*  303 */  rax_RegP_rule,
  /*  304 */  0,
  /*  305 */  immI8_rule,
  /*  306 */  vecY_rule,
  /*  307 */  vecX_rule,
  /*  308 */  _LoadVector_memory__rule,
  /*  309 */  _LoadVector_memory__rule,
  /*  310 */  vecZ_rule,
  /*  311 */  _LoadVector_memory__rule,
  // last internally defined operand
  /*  312 */  0,
  /*  313 */  0,
  /*  314 */  0,
  /*  315 */  0,
  /*  316 */  0,
  /*  317 */  0,
  /*  318 */  0,
  /*  319 */  0,
  /*  320 */  0,
  /*  321 */  0,
  /*  322 */  0,
  /*  323 */  0,
  /*  324 */  0,
  /*  325 */  0,
  /*  326 */  0,
  /*  327 */  0,
  /*  328 */  0,
  /*  329 */  0,
  /*  330 */  0,
  /*  331 */  0,
  /*  332 */  0,
  /*  333 */  0,
  /*  334 */  0,
  /*  335 */  0,
  /*  336 */  0,
  /*  337 */  0,
  /*  338 */  0,
  /*  339 */  0,
  /*  340 */  0,
  /*  341 */  0,
  /*  342 */  0,
  /*  343 */  0,
  /*  344 */  0,
  /*  345 */  0,
  /*  346 */  0,
  /*  347 */  0,
  /*  348 */  0,
  /*  349 */  0,
  /*  350 */  0,
  /*  351 */  0,
  /*  352 */  0,
  /*  353 */  0,
  /*  354 */  0,
  /*  355 */  0,
  /*  356 */  0,
  /*  357 */  0,
  /*  358 */  0,
  /*  359 */  0,
  /*  360 */  _Binary_rax_RegP_rRegP_rule,
  /*  361 */  _Binary_rax_RegI_rRegI_rule,
  /*  362 */  _Binary_rax_RegL_rRegL_rule,
  /*  363 */  regF_rule,
  /*  364 */  regF_rule,
  /*  365 */  _LoadF_memory__rule,
  /*  366 */  _LoadF_memory__rule,
  /*  367 */  immF_rule,
  /*  368 */  immF_rule,
  /*  369 */  regD_rule,
  /*  370 */  regD_rule,
  /*  371 */  _LoadD_memory__rule,
  /*  372 */  _LoadD_memory__rule,
  /*  373 */  immD_rule,
  /*  374 */  immD_rule,
  /*  375 */  0,
  /*  376 */  0,
  /*  377 */  0,
  /*  378 */  0,
  /*  379 */  0,
  /*  380 */  0,
  /*  381 */  0,
  /*  382 */  0,
  /*  383 */  0,
  /*  384 */  0,
  /*  385 */  0,
  /*  386 */  rRegI_rule,
  /*  387 */  immI_rule,
  /*  388 */  rRegL_rule,
  /*  389 */  immL32_rule,
  /*  390 */  rRegI_rule,
  /*  391 */  immI_rule,
  /*  392 */  rRegL_rule,
  /*  393 */  immL32_rule,
  /*  394 */  rax_RegI_rule,
  /*  395 */  rax_RegL_rule,
  /*  396 */  rRegI_rule,
  /*  397 */  immI_rule,
  /*  398 */  rRegL_rule,
  /*  399 */  immL32_rule,
  /*  400 */  rRegI_rule,
  /*  401 */  immI_rule,
  /*  402 */  _LoadI_memory__rule,
  /*  403 */  immI0_rule,
  /*  404 */  immI0_rule,
  /*  405 */  immI0_rule,
  /*  406 */  immI0_rule,
  /*  407 */  rRegI_rule,
  /*  408 */  immI_rule,
  /*  409 */  _LoadI_memory__rule,
  /*  410 */  immI0_rule,
  /*  411 */  rRegP_rule,
  /*  412 */  _LoadP_memory__rule,
  /*  413 */  _LoadP_memory__rule,
  /*  414 */  immP0_rule,
  /*  415 */  immP0_rule,
  /*  416 */  immP0_rule,
  /*  417 */  rRegN_rule,
  /*  418 */  _LoadN_memory__rule,
  /*  419 */  immN_rule,
  /*  420 */  _LoadN_memory__rule,
  /*  421 */  immNKlass_rule,
  /*  422 */  _LoadNKlass_memory__rule,
  /*  423 */  immN0_rule,
  /*  424 */  immN0_rule,
  /*  425 */  immN0_rule,
  /*  426 */  rRegL_rule,
  /*  427 */  immL32_rule,
  /*  428 */  _LoadL_memory__rule,
  /*  429 */  immL0_rule,
  /*  430 */  immL0_rule,
  /*  431 */  immL0_rule,
  /*  432 */  immL0_rule,
  /*  433 */  immL0_rule,
  /*  434 */  immL0_rule,
  /*  435 */  rRegL_rule,
  /*  436 */  immL32_rule,
  /*  437 */  _LoadL_memory__rule,
  /*  438 */  immL0_rule,
  /*  439 */  immI8_rule,
  /*  440 */  immI0_rule,
  /*  441 */  immP0_rule,
  /*  442 */  rbx_RegP_rule,
  /*  443 */  rbx_RegP_rule,
  /*  444 */  rax_RegP_rule,
  /*  445 */  0,
  /*  446 */  0,
  /*  447 */  0,
  /*  448 */  0,
  /*  449 */  0,
  /*  450 */  0,
  /*  451 */  0,
  /*  452 */  0,
  /*  453 */  0,
  /*  454 */  0,
  /*  455 */  0,
  /*  456 */  0,
  /*  457 */  0,
  /*  458 */  0,
  /*  459 */  0,
  /*  460 */  0,
  /*  461 */  0,
  /*  462 */  0,
  /*  463 */  0,
  /*  464 */  0,
  /*  465 */  0,
  /*  466 */  0,
  /*  467 */  0,
  /*  468 */  0,
  /*  469 */  0,
  /*  470 */  0,
  /*  471 */  0,
  /*  472 */  0,
  /*  473 */  0,
  /*  474 */  0,
  /*  475 */  0,
  /*  476 */  0,
  /*  477 */  0,
  /*  478 */  0,
  /*  479 */  0,
  /*  480 */  0,
  /*  481 */  0,
  /*  482 */  0,
  /*  483 */  immI_24_rule,
  /*  484 */  0,
  /*  485 */  0,
  /*  486 */  immI_24_rule,
  /*  487 */  0,
  /*  488 */  0,
  /*  489 */  0,
  /*  490 */  0,
  /*  491 */  immI_24_rule,
  /*  492 */  immI_255_rule,
  /*  493 */  immI_16_rule,
  /*  494 */  immI_65535_rule,
  /*  495 */  0,
  /*  496 */  0,
  /*  497 */  0,
  /*  498 */  0,
  /*  499 */  immL_32bits_rule,
  /*  500 */  0,
  /*  501 */  0,
  /*  502 */  0,
  /*  503 */  0,
  /*  504 */  0,
  /*  505 */  0,
  /*  506 */  0,
  /*  507 */  0,
  /*  508 */  0,
  /*  509 */  0,
  /*  510 */  0,
  /*  511 */  0,
  /*  512 */  0,
  /*  513 */  rRegI_rule,
  /*  514 */  rRegI_rule,
  /*  515 */  rRegI_rule,
  /*  516 */  rRegL_rule,
  /*  517 */  any_RegP_rule,
  /*  518 */  immP0_rule,
  /*  519 */  immP31_rule,
  /*  520 */  rRegN_rule,
  /*  521 */  rRegN_rule,
  /*  522 */  immN0_rule,
  /*  523 */  immN_rule,
  /*  524 */  immNKlass_rule,
  /*  525 */  immI0_rule,
  /*  526 */  immI_rule,
  /*  527 */  immL0_rule,
  /*  528 */  immL32_rule,
  /*  529 */  immI0_rule,
  /*  530 */  immI16_rule,
  /*  531 */  immI0_rule,
  /*  532 */  immI8_rule,
  /*  533 */  immI0_rule,
  /*  534 */  immI0_rule,
  /*  535 */  regF_rule,
  /*  536 */  immF0_rule,
  /*  537 */  immF_rule,
  /*  538 */  regD_rule,
  /*  539 */  immD0_rule,
  /*  540 */  immD0_rule,
  /*  541 */  0,
  /*  542 */  0,
  /*  543 */  0,
  /*  544 */  0,
  /*  545 */  0,
  /*  546 */  0,
  /*  547 */  0,
  /*  548 */  0,
  /*  549 */  0,
  /*  550 */  0,
  /*  551 */  0,
  /*  552 */  0,
  /*  553 */  0,
  /*  554 */  0,
  /*  555 */  0,
  /*  556 */  0,
  /*  557 */  0,
  /*  558 */  0,
  /*  559 */  0,
  /*  560 */  0,
  /*  561 */  0,
  /*  562 */  0,
  /*  563 */  0,
  /*  564 */  0,
  /*  565 */  0,
  /*  566 */  0,
  /*  567 */  0,
  /*  568 */  0,
  /*  569 */  0,
  /*  570 */  0,
  /*  571 */  0,
  /*  572 */  0,
  /*  573 */  0,
  /*  574 */  0,
  /*  575 */  0,
  /*  576 */  _Binary_rRegI_rRegI_rule,
  /*  577 */  _Binary_rRegI_rRegI_rule,
  /*  578 */  _Binary_rRegI_rRegI_rule,
  /*  579 */  _Binary_rRegI__LoadI_memory__rule,
  /*  580 */  _Binary_rRegI__LoadI_memory__rule,
  /*  581 */  _Binary_rRegI__LoadI_memory__rule,
  /*  582 */  _Binary_rRegN_rRegN_rule,
  /*  583 */  _Binary_rRegN_rRegN_rule,
  /*  584 */  _Binary_rRegN_rRegN_rule,
  /*  585 */  _Binary_rRegP_rRegP_rule,
  /*  586 */  _Binary_rRegP_rRegP_rule,
  /*  587 */  _Binary_rRegP_rRegP_rule,
  /*  588 */  _Binary_rRegL_rRegL_rule,
  /*  589 */  _Binary_rRegL__LoadL_memory__rule,
  /*  590 */  _Binary_rRegL_rRegL_rule,
  /*  591 */  _Binary_rRegL_rRegL_rule,
  /*  592 */  _Binary_rRegL__LoadL_memory__rule,
  /*  593 */  _Binary_rRegL__LoadL_memory__rule,
  /*  594 */  _Binary_regF_regF_rule,
  /*  595 */  _Binary_regF_regF_rule,
  /*  596 */  _Binary_regF_regF_rule,
  /*  597 */  _Binary_regD_regD_rule,
  /*  598 */  _Binary_regD_regD_rule,
  /*  599 */  _Binary_regD_regD_rule,
  /*  600 */  rRegI_rule,
  /*  601 */  immI_rule,
  /*  602 */  _LoadI_memory__rule,
  /*  603 */  rRegI_rule,
  /*  604 */  _AddI__LoadI_memory__rRegI_rule,
  /*  605 */  _AddI_rRegI__LoadI_memory__rule,
  /*  606 */  _AddI__LoadI_memory__immI_rule,
  /*  607 */  immI1_rule,
  /*  608 */  _AddI__LoadI_memory__immI1_rule,
  /*  609 */  immI_M1_rule,
  /*  610 */  _AddI__LoadI_memory__immI_M1_rule,
  /*  611 */  immI_rule,
  /*  612 */  rRegL_rule,
  /*  613 */  immL32_rule,
  /*  614 */  _LoadL_memory__rule,
  /*  615 */  rRegL_rule,
  /*  616 */  _AddL__LoadL_memory__rRegL_rule,
  /*  617 */  _AddL_rRegL__LoadL_memory__rule,
  /*  618 */  _AddL__LoadL_memory__immL32_rule,
  /*  619 */  immL1_rule,
  /*  620 */  _AddL__LoadL_memory__immL1_rule,
  /*  621 */  immL_M1_rule,
  /*  622 */  _AddL__LoadL_memory__immL_M1_rule,
  /*  623 */  immL32_rule,
  /*  624 */  rRegL_rule,
  /*  625 */  immL32_rule,
  /*  626 */  immL32_rule,
  /*  627 */  0,
  /*  628 */  _Binary_rax_RegP_rRegP_rule,
  /*  629 */  _Binary_rax_RegP_rRegP_rule,
  /*  630 */  _Binary_rax_RegL_rRegL_rule,
  /*  631 */  _Binary_rax_RegL_rRegL_rule,
  /*  632 */  _Binary_rax_RegI_rRegI_rule,
  /*  633 */  _Binary_rax_RegI_rRegI_rule,
  /*  634 */  _Binary_rax_RegI_rRegI_rule,
  /*  635 */  _Binary_rax_RegI_rRegI_rule,
  /*  636 */  _Binary_rax_RegI_rRegI_rule,
  /*  637 */  _Binary_rax_RegI_rRegI_rule,
  /*  638 */  _Binary_rax_RegN_rRegN_rule,
  /*  639 */  _Binary_rax_RegN_rRegN_rule,
  /*  640 */  _Binary_rax_RegI_rRegI_rule,
  /*  641 */  _Binary_rax_RegI_rRegI_rule,
  /*  642 */  _Binary_rax_RegI_rRegI_rule,
  /*  643 */  _Binary_rax_RegL_rRegL_rule,
  /*  644 */  _Binary_rax_RegN_rRegN_rule,
  /*  645 */  _Binary_rax_RegP_rRegP_rule,
  /*  646 */  immI_rule,
  /*  647 */  rRegI_rule,
  /*  648 */  immI_rule,
  /*  649 */  rRegI_rule,
  /*  650 */  immI_rule,
  /*  651 */  rRegI_rule,
  /*  652 */  immL32_rule,
  /*  653 */  rRegL_rule,
  /*  654 */  rRegI_rule,
  /*  655 */  rRegI_rule,
  /*  656 */  rRegI_rule,
  /*  657 */  rRegL_rule,
  /*  658 */  rRegP_rule,
  /*  659 */  rRegN_rule,
  /*  660 */  rRegI_rule,
  /*  661 */  immI_rule,
  /*  662 */  _LoadI_memory__rule,
  /*  663 */  _SubI__LoadI_memory__rRegI_rule,
  /*  664 */  _SubI__LoadI_memory__immI_rule,
  /*  665 */  rRegL_rule,
  /*  666 */  immL32_rule,
  /*  667 */  _LoadL_memory__rule,
  /*  668 */  _SubL__LoadL_memory__rRegL_rule,
  /*  669 */  _SubL__LoadL_memory__immL32_rule,
  /*  670 */  _SubI_immI0_rRegI_rule,
  /*  671 */  rRegI_rule,
  /*  672 */  _SubI_immI0__LoadI_memory__rule,
  /*  673 */  rRegL_rule,
  /*  674 */  _SubL_immL0__LoadL_memory__rule,
  /*  675 */  rRegI_rule,
  /*  676 */  immI_rule,
  /*  677 */  _LoadI_memory__rule,
  /*  678 */  rRegI_rule,
  /*  679 */  immI_rule,
  /*  680 */  rRegL_rule,
  /*  681 */  immL32_rule,
  /*  682 */  _LoadL_memory__rule,
  /*  683 */  rRegL_rule,
  /*  684 */  immL32_rule,
  /*  685 */  rax_RegL_rule,
  /*  686 */  no_rax_rdx_RegI_rule,
  /*  687 */  no_rax_rdx_RegL_rule,
  /*  688 */  no_rax_rdx_RegI_rule,
  /*  689 */  no_rax_rdx_RegL_rule,
  /*  690 */  0,
  /*  691 */  0,
  /*  692 */  0,
  /*  693 */  0,
  /*  694 */  immL10_rule,
  /*  695 */  no_rax_rdx_RegI_rule,
  /*  696 */  no_rax_rdx_RegL_rule,
  /*  697 */  immI1_rule,
  /*  698 */  _LShiftI__LoadI_memory__immI1_rule,
  /*  699 */  immI8_rule,
  /*  700 */  _LShiftI__LoadI_memory__immI8_rule,
  /*  701 */  rcx_RegI_rule,
  /*  702 */  _LShiftI__LoadI_memory__rcx_RegI_rule,
  /*  703 */  immI1_rule,
  /*  704 */  _RShiftI__LoadI_memory__immI1_rule,
  /*  705 */  immI8_rule,
  /*  706 */  _RShiftI__LoadI_memory__immI8_rule,
  /*  707 */  rcx_RegI_rule,
  /*  708 */  _RShiftI__LoadI_memory__rcx_RegI_rule,
  /*  709 */  immI1_rule,
  /*  710 */  _URShiftI__LoadI_memory__immI1_rule,
  /*  711 */  immI8_rule,
  /*  712 */  _URShiftI__LoadI_memory__immI8_rule,
  /*  713 */  rcx_RegI_rule,
  /*  714 */  _URShiftI__LoadI_memory__rcx_RegI_rule,
  /*  715 */  immI1_rule,
  /*  716 */  _LShiftL__LoadL_memory__immI1_rule,
  /*  717 */  immI8_rule,
  /*  718 */  _LShiftL__LoadL_memory__immI8_rule,
  /*  719 */  rcx_RegI_rule,
  /*  720 */  _LShiftL__LoadL_memory__rcx_RegI_rule,
  /*  721 */  immI1_rule,
  /*  722 */  _RShiftL__LoadL_memory__immI1_rule,
  /*  723 */  immI8_rule,
  /*  724 */  _RShiftL__LoadL_memory__immI8_rule,
  /*  725 */  rcx_RegI_rule,
  /*  726 */  _RShiftL__LoadL_memory__rcx_RegI_rule,
  /*  727 */  immI1_rule,
  /*  728 */  _URShiftL__LoadL_memory__immI1_rule,
  /*  729 */  immI8_rule,
  /*  730 */  _URShiftL__LoadL_memory__immI8_rule,
  /*  731 */  rcx_RegI_rule,
  /*  732 */  _URShiftL__LoadL_memory__rcx_RegI_rule,
  /*  733 */  immI_24_rule,
  /*  734 */  immI_16_rule,
  /*  735 */  0,
  /*  736 */  0,
  /*  737 */  0,
  /*  738 */  _URShiftI_rRegI_immI_M1_rule,
  /*  739 */  _LShiftI_rRegI_immI1_rule,
  /*  740 */  _URShiftI_rRegI_immI8_rule,
  /*  741 */  _LShiftI_rRegI_immI8_rule,
  /*  742 */  _URShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI_rule,
  /*  743 */  _LShiftI_no_rcx_RegI_rcx_RegI_rule,
  /*  744 */  _URShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI_rule,
  /*  745 */  _LShiftI_no_rcx_RegI_rcx_RegI_rule,
  /*  746 */  0,
  /*  747 */  0,
  /*  748 */  0,
  /*  749 */  _LShiftI_rRegI_immI_M1_rule,
  /*  750 */  _URShiftI_rRegI_immI1_rule,
  /*  751 */  _LShiftI_rRegI_immI8_rule,
  /*  752 */  _URShiftI_rRegI_immI8_rule,
  /*  753 */  _LShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI_rule,
  /*  754 */  _URShiftI_no_rcx_RegI_rcx_RegI_rule,
  /*  755 */  _LShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI_rule,
  /*  756 */  _URShiftI_no_rcx_RegI_rcx_RegI_rule,
  /*  757 */  0,
  /*  758 */  0,
  /*  759 */  0,
  /*  760 */  _URShiftL_rRegL_immI_M1_rule,
  /*  761 */  _LShiftL_rRegL_immI1_rule,
  /*  762 */  _URShiftL_rRegL_immI8_rule,
  /*  763 */  _LShiftL_rRegL_immI8_rule,
  /*  764 */  _URShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI_rule,
  /*  765 */  _LShiftL_no_rcx_RegL_rcx_RegI_rule,
  /*  766 */  _URShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI_rule,
  /*  767 */  _LShiftL_no_rcx_RegL_rcx_RegI_rule,
  /*  768 */  0,
  /*  769 */  0,
  /*  770 */  0,
  /*  771 */  _LShiftL_rRegL_immI_M1_rule,
  /*  772 */  _URShiftL_rRegL_immI1_rule,
  /*  773 */  _LShiftL_rRegL_immI8_rule,
  /*  774 */  _URShiftL_rRegL_immI8_rule,
  /*  775 */  _LShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI_rule,
  /*  776 */  _URShiftL_no_rcx_RegL_rcx_RegI_rule,
  /*  777 */  _LShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI_rule,
  /*  778 */  _URShiftL_no_rcx_RegL_rcx_RegI_rule,
  /*  779 */  rRegI_rule,
  /*  780 */  immI_255_rule,
  /*  781 */  0,
  /*  782 */  immI_65535_rule,
  /*  783 */  0,
  /*  784 */  immI_rule,
  /*  785 */  _LoadI_memory__rule,
  /*  786 */  rRegI_rule,
  /*  787 */  _AndI__LoadI_memory__rRegI_rule,
  /*  788 */  _AndI_rRegI__LoadI_memory__rule,
  /*  789 */  _AndI__LoadI_memory__immI_rule,
  /*  790 */  _LoadI_memory__rule,
  /*  791 */  _XorI_rRegI_immI_M1_rule,
  /*  792 */  rRegI_rule,
  /*  793 */  _XorI_rRegI_immI_M1_rule,
  /*  794 */  rRegI_rule,
  /*  795 */  _SubI_immI0_rRegI_rule,
  /*  796 */  _LoadI_memory__rule,
  /*  797 */  _SubI_immI0__LoadI_memory__rule,
  /*  798 */  _LoadI_memory__rule,
  /*  799 */  _AddI__LoadI_memory__immI_M1_rule,
  /*  800 */  rRegI_rule,
  /*  801 */  _AddI_rRegI_immI_M1_rule,
  /*  802 */  rRegI_rule,
  /*  803 */  _AddI_rRegI_immI_M1_rule,
  /*  804 */  _LoadI_memory__rule,
  /*  805 */  _AddI__LoadI_memory__immI_M1_rule,
  /*  806 */  rRegI_rule,
  /*  807 */  immI_rule,
  /*  808 */  _LoadI_memory__rule,
  /*  809 */  rRegI_rule,
  /*  810 */  _OrI__LoadI_memory__rRegI_rule,
  /*  811 */  _OrI_rRegI__LoadI_memory__rule,
  /*  812 */  _OrI__LoadI_memory__immI_rule,
  /*  813 */  rRegI_rule,
  /*  814 */  immI_M1_rule,
  /*  815 */  immI_rule,
  /*  816 */  _LoadI_memory__rule,
  /*  817 */  rRegI_rule,
  /*  818 */  _XorI__LoadI_memory__rRegI_rule,
  /*  819 */  _XorI_rRegI__LoadI_memory__rule,
  /*  820 */  _XorI__LoadI_memory__immI_rule,
  /*  821 */  rRegL_rule,
  /*  822 */  immL_255_rule,
  /*  823 */  immL_65535_rule,
  /*  824 */  immL32_rule,
  /*  825 */  _LoadL_memory__rule,
  /*  826 */  rRegL_rule,
  /*  827 */  _AndL__LoadL_memory__rRegL_rule,
  /*  828 */  _AndL_rRegL__LoadL_memory__rule,
  /*  829 */  _AndL__LoadL_memory__immL32_rule,
  /*  830 */  _LoadL_memory__rule,
  /*  831 */  _XorL_rRegL_immL_M1_rule,
  /*  832 */  rRegL_rule,
  /*  833 */  _XorL_rRegL_immL_M1_rule,
  /*  834 */  rRegL_rule,
  /*  835 */  _SubL_immL0_rRegL_rule,
  /*  836 */  _LoadL_memory__rule,
  /*  837 */  _SubL_immL0__LoadL_memory__rule,
  /*  838 */  _LoadL_memory__rule,
  /*  839 */  _AddL__LoadL_memory__immL_M1_rule,
  /*  840 */  rRegL_rule,
  /*  841 */  _AddL_rRegL_immL_M1_rule,
  /*  842 */  rRegL_rule,
  /*  843 */  _AddL_rRegL_immL_M1_rule,
  /*  844 */  _LoadL_memory__rule,
  /*  845 */  _AddL__LoadL_memory__immL_M1_rule,
  /*  846 */  rRegL_rule,
  /*  847 */  _CastP2X_any_RegP__rule,
  /*  848 */  rRegL_rule,
  /*  849 */  immL32_rule,
  /*  850 */  _LoadL_memory__rule,
  /*  851 */  rRegL_rule,
  /*  852 */  _OrL__LoadL_memory__rRegL_rule,
  /*  853 */  _OrL_rRegL__LoadL_memory__rule,
  /*  854 */  _OrL__LoadL_memory__immL32_rule,
  /*  855 */  rRegL_rule,
  /*  856 */  immL_M1_rule,
  /*  857 */  immL32_rule,
  /*  858 */  _LoadL_memory__rule,
  /*  859 */  rRegL_rule,
  /*  860 */  _XorL__LoadL_memory__rRegL_rule,
  /*  861 */  _XorL_rRegL__LoadL_memory__rule,
  /*  862 */  _XorL__LoadL_memory__immL32_rule,
  /*  863 */  0,
  /*  864 */  0,
  /*  865 */  rRegI_rule,
  /*  866 */  immI0_rule,
  /*  867 */  _SubI_rRegI_rRegI_rule,
  /*  868 */  _AndI__CmpLTMask_rRegI_rRegI_rRegI_rule,
  /*  869 */  _SubI_rRegI_rRegI_rule,
  /*  870 */  _AndI_rRegI__CmpLTMask_rRegI_rRegI_rule,
  /*  871 */  rRegI_rule,
  /*  872 */  _CmpLTMask_rRegI_rRegI_rule,
  /*  873 */  regF_rule,
  /*  874 */  _LoadF_memory__rule,
  /*  875 */  immF_rule,
  /*  876 */  regD_rule,
  /*  877 */  _LoadD_memory__rule,
  /*  878 */  immD_rule,
  /*  879 */  0,
  /*  880 */  0,
  /*  881 */  0,
  /*  882 */  0,
  /*  883 */  0,
  /*  884 */  0,
  /*  885 */  0,
  /*  886 */  0,
  /*  887 */  0,
  /*  888 */  0,
  /*  889 */  0,
  /*  890 */  0,
  /*  891 */  0,
  /*  892 */  0,
  /*  893 */  0,
  /*  894 */  0,
  /*  895 */  0,
  /*  896 */  0,
  /*  897 */  0,
  /*  898 */  immL_32bits_rule,
  /*  899 */  immL_32bits_rule,
  /*  900 */  immL_32bits_rule,
  /*  901 */  0,
  /*  902 */  0,
  /*  903 */  0,
  /*  904 */  0,
  /*  905 */  0,
  /*  906 */  rdi_RegP_rule,
  /*  907 */  rdi_RegP_rule,
  /*  908 */  _Binary_rsi_RegP_rdx_RegI_rule,
  /*  909 */  _Binary_rsi_RegP_rdx_RegI_rule,
  /*  910 */  _Binary_rsi_RegP_rdx_RegI_rule,
  /*  911 */  _Binary_rdi_RegP_rcx_RegI_rule,
  /*  912 */  _Binary_rsi_RegP_immI_rule,
  /*  913 */  _Binary_rsi_RegP_immI_rule,
  /*  914 */  _Binary_rsi_RegP_immI_rule,
  /*  915 */  _Binary_rsi_RegP_rax_RegI_rule,
  /*  916 */  _Binary_rsi_RegP_rax_RegI_rule,
  /*  917 */  _Binary_rsi_RegP_rax_RegI_rule,
  /*  918 */  rax_RegI_rule,
  /*  919 */  rcx_RegI_rule,
  /*  920 */  rsi_RegP_rule,
  /*  921 */  rsi_RegP_rule,
  /*  922 */  rcx_RegI_rule,
  /*  923 */  _Binary_rdi_RegP_rdx_RegI_rule,
  /*  924 */  _Binary_rdi_RegP_rdx_RegI_rule,
  /*  925 */  _Binary_rdi_RegP_rdx_RegI_rule,
  /*  926 */  rRegL_rule,
  /*  927 */  0,
  /*  928 */  rRegI_rule,
  /*  929 */  0,
  /*  930 */  rRegI_rule,
  /*  931 */  0,
  /*  932 */  rFlagsReg_rule,
  /*  933 */  rFlagsReg_rule,
  /*  934 */  rFlagsRegU_rule,
  /*  935 */  rFlagsRegUCF_rule,
  /*  936 */  rFlagsReg_rule,
  /*  937 */  rFlagsRegU_rule,
  /*  938 */  rFlagsRegUCF_rule,
  /*  939 */  rFlagsRegU_rule,
  /*  940 */  rFlagsRegUCF_rule,
  /*  941 */  rFlagsRegUCF_rule,
  /*  942 */  rax_RegP_rule,
  /*  943 */  0,
  /*  944 */  rFlagsReg_rule,
  /*  945 */  rFlagsReg_rule,
  /*  946 */  rFlagsRegU_rule,
  /*  947 */  rFlagsRegUCF_rule,
  /*  948 */  rFlagsRegU_rule,
  /*  949 */  rFlagsRegUCF_rule,
  /*  950 */  rFlagsRegUCF_rule,
  /*  951 */  0,
  /*  952 */  0,
  /*  953 */  0,
  /*  954 */  0,
  /*  955 */  0,
  /*  956 */  0,
  /*  957 */  0,
  /*  958 */  0,
  /*  959 */  rbx_RegP_rule,
  /*  960 */  rax_RegP_rule,
  /*  961 */  0,
  /*  962 */  0,
  /*  963 */  0,
  /*  964 */  0,
  /*  965 */  0,
  /*  966 */  0,
  /*  967 */  0,
  /*  968 */  0,
  /*  969 */  0,
  /*  970 */  0,
  /*  971 */  regF_rule,
  /*  972 */  _LoadF_memory__rule,
  /*  973 */  regF_rule,
  /*  974 */  immF_rule,
  /*  975 */  regF_rule,
  /*  976 */  _LoadF_memory__rule,
  /*  977 */  regF_rule,
  /*  978 */  immF_rule,
  /*  979 */  regD_rule,
  /*  980 */  _LoadD_memory__rule,
  /*  981 */  regD_rule,
  /*  982 */  immD_rule,
  /*  983 */  regD_rule,
  /*  984 */  _LoadD_memory__rule,
  /*  985 */  regD_rule,
  /*  986 */  immD_rule,
  /*  987 */  regF_rule,
  /*  988 */  _LoadF_memory__rule,
  /*  989 */  immF_rule,
  /*  990 */  regF_rule,
  /*  991 */  _LoadF_memory__rule,
  /*  992 */  immF_rule,
  /*  993 */  regD_rule,
  /*  994 */  _LoadD_memory__rule,
  /*  995 */  immD_rule,
  /*  996 */  regD_rule,
  /*  997 */  _LoadD_memory__rule,
  /*  998 */  immD_rule,
  /*  999 */  regF_rule,
  /* 1000 */  _LoadF_memory__rule,
  /* 1001 */  regF_rule,
  /* 1002 */  immF_rule,
  /* 1003 */  regF_rule,
  /* 1004 */  _LoadF_memory__rule,
  /* 1005 */  regF_rule,
  /* 1006 */  immF_rule,
  /* 1007 */  regD_rule,
  /* 1008 */  _LoadD_memory__rule,
  /* 1009 */  regD_rule,
  /* 1010 */  immD_rule,
  /* 1011 */  regD_rule,
  /* 1012 */  _LoadD_memory__rule,
  /* 1013 */  regD_rule,
  /* 1014 */  immD_rule,
  /* 1015 */  regF_rule,
  /* 1016 */  _LoadF_memory__rule,
  /* 1017 */  immF_rule,
  /* 1018 */  regF_rule,
  /* 1019 */  _LoadF_memory__rule,
  /* 1020 */  immF_rule,
  /* 1021 */  regD_rule,
  /* 1022 */  _LoadD_memory__rule,
  /* 1023 */  immD_rule,
  /* 1024 */  regD_rule,
  /* 1025 */  _LoadD_memory__rule,
  /* 1026 */  immD_rule,
  /* 1027 */  0,
  /* 1028 */  0,
  /* 1029 */  0,
  /* 1030 */  0,
  /* 1031 */  0,
  /* 1032 */  0,
  /* 1033 */  0,
  /* 1034 */  0,
  /* 1035 */  0,
  /* 1036 */  _Binary_regD_regD_rule,
  /* 1037 */  _Binary_regF_regF_rule,
  /* 1038 */  0,
  /* 1039 */  0,
  /* 1040 */  0,
  /* 1041 */  0,
  /* 1042 */  0,
  /* 1043 */  0,
  /* 1044 */  vecS_rule,
  /* 1045 */  vecD_rule,
  /* 1046 */  vecX_rule,
  /* 1047 */  vecY_rule,
  /* 1048 */  vecZ_rule,
  /* 1049 */  vecZ_rule,
  /* 1050 */  0,
  /* 1051 */  0,
  /* 1052 */  0,
  /* 1053 */  0,
  /* 1054 */  0,
  /* 1055 */  0,
  /* 1056 */  0,
  /* 1057 */  0,
  /* 1058 */  0,
  /* 1059 */  0,
  /* 1060 */  0,
  /* 1061 */  0,
  /* 1062 */  0,
  /* 1063 */  0,
  /* 1064 */  0,
  /* 1065 */  0,
  /* 1066 */  0,
  /* 1067 */  0,
  /* 1068 */  0,
  /* 1069 */  0,
  /* 1070 */  0,
  /* 1071 */  0,
  /* 1072 */  0,
  /* 1073 */  0,
  /* 1074 */  0,
  /* 1075 */  0,
  /* 1076 */  0,
  /* 1077 */  0,
  /* 1078 */  0,
  /* 1079 */  0,
  /* 1080 */  0,
  /* 1081 */  0,
  /* 1082 */  0,
  /* 1083 */  0,
  /* 1084 */  0,
  /* 1085 */  0,
  /* 1086 */  0,
  /* 1087 */  0,
  /* 1088 */  0,
  /* 1089 */  0,
  /* 1090 */  0,
  /* 1091 */  0,
  /* 1092 */  0,
  /* 1093 */  0,
  /* 1094 */  0,
  /* 1095 */  0,
  /* 1096 */  0,
  /* 1097 */  0,
  /* 1098 */  0,
  /* 1099 */  0,
  /* 1100 */  0,
  /* 1101 */  0,
  /* 1102 */  0,
  /* 1103 */  0,
  /* 1104 */  0,
  /* 1105 */  0,
  /* 1106 */  0,
  /* 1107 */  0,
  /* 1108 */  0,
  /* 1109 */  0,
  /* 1110 */  0,
  /* 1111 */  0,
  /* 1112 */  0,
  /* 1113 */  0,
  /* 1114 */  0,
  /* 1115 */  0,
  /* 1116 */  0,
  /* 1117 */  0,
  /* 1118 */  0,
  /* 1119 */  0,
  /* 1120 */  0,
  /* 1121 */  0,
  /* 1122 */  0,
  /* 1123 */  0,
  /* 1124 */  0,
  /* 1125 */  0,
  /* 1126 */  0,
  /* 1127 */  0,
  /* 1128 */  0,
  /* 1129 */  0,
  /* 1130 */  0,
  /* 1131 */  0,
  /* 1132 */  0,
  /* 1133 */  0,
  /* 1134 */  0,
  /* 1135 */  0,
  /* 1136 */  0,
  /* 1137 */  0,
  /* 1138 */  0,
  /* 1139 */  0,
  /* 1140 */  0,
  /* 1141 */  0,
  /* 1142 */  0,
  /* 1143 */  0,
  /* 1144 */  0,
  /* 1145 */  0,
  /* 1146 */  0,
  /* 1147 */  0,
  /* 1148 */  0,
  /* 1149 */  0,
  /* 1150 */  0,
  /* 1151 */  0,
  /* 1152 */  0,
  /* 1153 */  0,
  /* 1154 */  0,
  /* 1155 */  0,
  /* 1156 */  0,
  /* 1157 */  0,
  /* 1158 */  0,
  /* 1159 */  0,
  /* 1160 */  0,
  /* 1161 */  0,
  /* 1162 */  0,
  /* 1163 */  0,
  /* 1164 */  0,
  /* 1165 */  0,
  /* 1166 */  0,
  /* 1167 */  0,
  /* 1168 */  0,
  /* 1169 */  0,
  /* 1170 */  0,
  /* 1171 */  0,
  /* 1172 */  0,
  /* 1173 */  vecD_rule,
  /* 1174 */  vecD_rule,
  /* 1175 */  vecD_rule,
  /* 1176 */  vecX_rule,
  /* 1177 */  vecX_rule,
  /* 1178 */  vecX_rule,
  /* 1179 */  vecY_rule,
  /* 1180 */  vecY_rule,
  /* 1181 */  vecZ_rule,
  /* 1182 */  vecX_rule,
  /* 1183 */  vecY_rule,
  /* 1184 */  vecZ_rule,
  /* 1185 */  vecD_rule,
  /* 1186 */  vecD_rule,
  /* 1187 */  vecX_rule,
  /* 1188 */  vecX_rule,
  /* 1189 */  vecY_rule,
  /* 1190 */  vecZ_rule,
  /* 1191 */  vecX_rule,
  /* 1192 */  vecX_rule,
  /* 1193 */  vecY_rule,
  /* 1194 */  vecZ_rule,
  /* 1195 */  vecD_rule,
  /* 1196 */  vecD_rule,
  /* 1197 */  vecX_rule,
  /* 1198 */  vecX_rule,
  /* 1199 */  vecY_rule,
  /* 1200 */  vecZ_rule,
  /* 1201 */  vecX_rule,
  /* 1202 */  vecY_rule,
  /* 1203 */  vecZ_rule,
  /* 1204 */  vecD_rule,
  /* 1205 */  vecD_rule,
  /* 1206 */  vecX_rule,
  /* 1207 */  vecX_rule,
  /* 1208 */  vecY_rule,
  /* 1209 */  vecZ_rule,
  /* 1210 */  vecX_rule,
  /* 1211 */  vecX_rule,
  /* 1212 */  vecY_rule,
  /* 1213 */  vecZ_rule,
  /* 1214 */  vecS_rule,
  /* 1215 */  vecS_rule,
  /* 1216 */  vecS_rule,
  /* 1217 */  vecS_rule,
  /* 1218 */  _LoadVector_memory__rule,
  /* 1219 */  vecS_rule,
  /* 1220 */  _LoadVector_memory__rule,
  /* 1221 */  vecS_rule,
  /* 1222 */  _LoadVector_memory__rule,
  /* 1223 */  vecS_rule,
  /* 1224 */  vecD_rule,
  /* 1225 */  vecD_rule,
  /* 1226 */  vecD_rule,
  /* 1227 */  vecD_rule,
  /* 1228 */  _LoadVector_memory__rule,
  /* 1229 */  vecD_rule,
  /* 1230 */  _LoadVector_memory__rule,
  /* 1231 */  vecD_rule,
  /* 1232 */  _LoadVector_memory__rule,
  /* 1233 */  vecD_rule,
  /* 1234 */  vecX_rule,
  /* 1235 */  vecX_rule,
  /* 1236 */  vecX_rule,
  /* 1237 */  vecX_rule,
  /* 1238 */  _LoadVector_memory__rule,
  /* 1239 */  vecX_rule,
  /* 1240 */  _LoadVector_memory__rule,
  /* 1241 */  vecX_rule,
  /* 1242 */  _LoadVector_memory__rule,
  /* 1243 */  vecX_rule,
  /* 1244 */  vecY_rule,
  /* 1245 */  vecY_rule,
  /* 1246 */  vecY_rule,
  /* 1247 */  _LoadVector_memory__rule,
  /* 1248 */  vecY_rule,
  /* 1249 */  _LoadVector_memory__rule,
  /* 1250 */  vecY_rule,
  /* 1251 */  _LoadVector_memory__rule,
  /* 1252 */  vecY_rule,
  /* 1253 */  vecZ_rule,
  /* 1254 */  _LoadVector_memory__rule,
  /* 1255 */  vecZ_rule,
  /* 1256 */  vecS_rule,
  /* 1257 */  vecS_rule,
  /* 1258 */  vecS_rule,
  /* 1259 */  vecS_rule,
  /* 1260 */  _LoadVector_memory__rule,
  /* 1261 */  vecS_rule,
  /* 1262 */  _LoadVector_memory__rule,
  /* 1263 */  vecS_rule,
  /* 1264 */  _LoadVector_memory__rule,
  /* 1265 */  vecS_rule,
  /* 1266 */  vecD_rule,
  /* 1267 */  vecD_rule,
  /* 1268 */  vecD_rule,
  /* 1269 */  vecD_rule,
  /* 1270 */  _LoadVector_memory__rule,
  /* 1271 */  vecD_rule,
  /* 1272 */  _LoadVector_memory__rule,
  /* 1273 */  vecD_rule,
  /* 1274 */  _LoadVector_memory__rule,
  /* 1275 */  vecD_rule,
  /* 1276 */  vecX_rule,
  /* 1277 */  vecX_rule,
  /* 1278 */  vecX_rule,
  /* 1279 */  vecX_rule,
  /* 1280 */  _LoadVector_memory__rule,
  /* 1281 */  vecX_rule,
  /* 1282 */  _LoadVector_memory__rule,
  /* 1283 */  vecX_rule,
  /* 1284 */  _LoadVector_memory__rule,
  /* 1285 */  vecX_rule,
  /* 1286 */  vecY_rule,
  /* 1287 */  vecY_rule,
  /* 1288 */  vecY_rule,
  /* 1289 */  _LoadVector_memory__rule,
  /* 1290 */  vecY_rule,
  /* 1291 */  _LoadVector_memory__rule,
  /* 1292 */  vecY_rule,
  /* 1293 */  _LoadVector_memory__rule,
  /* 1294 */  vecY_rule,
  /* 1295 */  vecZ_rule,
  /* 1296 */  _LoadVector_memory__rule,
  /* 1297 */  vecZ_rule,
  /* 1298 */  vecD_rule,
  /* 1299 */  vecD_rule,
  /* 1300 */  _LoadVector_memory__rule,
  /* 1301 */  vecD_rule,
  /* 1302 */  vecX_rule,
  /* 1303 */  vecX_rule,
  /* 1304 */  _LoadVector_memory__rule,
  /* 1305 */  vecX_rule,
  /* 1306 */  vecY_rule,
  /* 1307 */  _LoadVector_memory__rule,
  /* 1308 */  vecY_rule,
  /* 1309 */  vecZ_rule,
  /* 1310 */  _LoadVector_memory__rule,
  /* 1311 */  vecZ_rule,
  /* 1312 */  vecX_rule,
  /* 1313 */  vecX_rule,
  /* 1314 */  _LoadVector_memory__rule,
  /* 1315 */  vecX_rule,
  /* 1316 */  vecY_rule,
  /* 1317 */  _LoadVector_memory__rule,
  /* 1318 */  vecY_rule,
  /* 1319 */  vecZ_rule,
  /* 1320 */  _LoadVector_memory__rule,
  /* 1321 */  vecZ_rule,
  /* 1322 */  vecD_rule,
  /* 1323 */  vecD_rule,
  /* 1324 */  _LoadVector_memory__rule,
  /* 1325 */  vecD_rule,
  /* 1326 */  vecX_rule,
  /* 1327 */  vecX_rule,
  /* 1328 */  _LoadVector_memory__rule,
  /* 1329 */  vecX_rule,
  /* 1330 */  vecY_rule,
  /* 1331 */  _LoadVector_memory__rule,
  /* 1332 */  vecY_rule,
  /* 1333 */  vecZ_rule,
  /* 1334 */  _LoadVector_memory__rule,
  /* 1335 */  vecZ_rule,
  /* 1336 */  vecX_rule,
  /* 1337 */  vecX_rule,
  /* 1338 */  _LoadVector_memory__rule,
  /* 1339 */  vecX_rule,
  /* 1340 */  vecY_rule,
  /* 1341 */  _LoadVector_memory__rule,
  /* 1342 */  vecY_rule,
  /* 1343 */  vecZ_rule,
  /* 1344 */  _LoadVector_memory__rule,
  /* 1345 */  vecZ_rule,
  /* 1346 */  vecS_rule,
  /* 1347 */  vecS_rule,
  /* 1348 */  vecS_rule,
  /* 1349 */  vecS_rule,
  /* 1350 */  _LoadVector_memory__rule,
  /* 1351 */  _LoadVector_memory__rule,
  /* 1352 */  _LoadVector_memory__rule,
  /* 1353 */  vecD_rule,
  /* 1354 */  vecD_rule,
  /* 1355 */  vecD_rule,
  /* 1356 */  vecD_rule,
  /* 1357 */  _LoadVector_memory__rule,
  /* 1358 */  _LoadVector_memory__rule,
  /* 1359 */  _LoadVector_memory__rule,
  /* 1360 */  vecX_rule,
  /* 1361 */  vecX_rule,
  /* 1362 */  vecX_rule,
  /* 1363 */  vecX_rule,
  /* 1364 */  _LoadVector_memory__rule,
  /* 1365 */  _LoadVector_memory__rule,
  /* 1366 */  _LoadVector_memory__rule,
  /* 1367 */  vecY_rule,
  /* 1368 */  vecY_rule,
  /* 1369 */  vecY_rule,
  /* 1370 */  _LoadVector_memory__rule,
  /* 1371 */  _LoadVector_memory__rule,
  /* 1372 */  _LoadVector_memory__rule,
  /* 1373 */  vecZ_rule,
  /* 1374 */  _LoadVector_memory__rule,
  /* 1375 */  vecS_rule,
  /* 1376 */  vecS_rule,
  /* 1377 */  vecS_rule,
  /* 1378 */  vecS_rule,
  /* 1379 */  _LoadVector_memory__rule,
  /* 1380 */  _LoadVector_memory__rule,
  /* 1381 */  _LoadVector_memory__rule,
  /* 1382 */  vecD_rule,
  /* 1383 */  vecD_rule,
  /* 1384 */  vecD_rule,
  /* 1385 */  vecD_rule,
  /* 1386 */  _LoadVector_memory__rule,
  /* 1387 */  _LoadVector_memory__rule,
  /* 1388 */  _LoadVector_memory__rule,
  /* 1389 */  vecX_rule,
  /* 1390 */  vecX_rule,
  /* 1391 */  vecX_rule,
  /* 1392 */  vecX_rule,
  /* 1393 */  _LoadVector_memory__rule,
  /* 1394 */  _LoadVector_memory__rule,
  /* 1395 */  _LoadVector_memory__rule,
  /* 1396 */  vecY_rule,
  /* 1397 */  vecY_rule,
  /* 1398 */  vecY_rule,
  /* 1399 */  _LoadVector_memory__rule,
  /* 1400 */  _LoadVector_memory__rule,
  /* 1401 */  _LoadVector_memory__rule,
  /* 1402 */  vecZ_rule,
  /* 1403 */  _LoadVector_memory__rule,
  /* 1404 */  vecD_rule,
  /* 1405 */  vecD_rule,
  /* 1406 */  _LoadVector_memory__rule,
  /* 1407 */  vecX_rule,
  /* 1408 */  vecX_rule,
  /* 1409 */  _LoadVector_memory__rule,
  /* 1410 */  vecY_rule,
  /* 1411 */  _LoadVector_memory__rule,
  /* 1412 */  vecZ_rule,
  /* 1413 */  _LoadVector_memory__rule,
  /* 1414 */  vecX_rule,
  /* 1415 */  vecX_rule,
  /* 1416 */  _LoadVector_memory__rule,
  /* 1417 */  vecY_rule,
  /* 1418 */  _LoadVector_memory__rule,
  /* 1419 */  vecZ_rule,
  /* 1420 */  _LoadVector_memory__rule,
  /* 1421 */  vecD_rule,
  /* 1422 */  vecD_rule,
  /* 1423 */  _LoadVector_memory__rule,
  /* 1424 */  vecX_rule,
  /* 1425 */  vecX_rule,
  /* 1426 */  _LoadVector_memory__rule,
  /* 1427 */  vecY_rule,
  /* 1428 */  _LoadVector_memory__rule,
  /* 1429 */  vecZ_rule,
  /* 1430 */  _LoadVector_memory__rule,
  /* 1431 */  vecX_rule,
  /* 1432 */  vecX_rule,
  /* 1433 */  _LoadVector_memory__rule,
  /* 1434 */  vecY_rule,
  /* 1435 */  _LoadVector_memory__rule,
  /* 1436 */  vecZ_rule,
  /* 1437 */  _LoadVector_memory__rule,
  /* 1438 */  vecS_rule,
  /* 1439 */  vecS_rule,
  /* 1440 */  vecS_rule,
  /* 1441 */  vecS_rule,
  /* 1442 */  _LoadVector_memory__rule,
  /* 1443 */  vecS_rule,
  /* 1444 */  _LoadVector_memory__rule,
  /* 1445 */  vecS_rule,
  /* 1446 */  _LoadVector_memory__rule,
  /* 1447 */  vecS_rule,
  /* 1448 */  vecD_rule,
  /* 1449 */  vecD_rule,
  /* 1450 */  vecD_rule,
  /* 1451 */  vecD_rule,
  /* 1452 */  _LoadVector_memory__rule,
  /* 1453 */  vecD_rule,
  /* 1454 */  _LoadVector_memory__rule,
  /* 1455 */  vecD_rule,
  /* 1456 */  _LoadVector_memory__rule,
  /* 1457 */  vecD_rule,
  /* 1458 */  vecX_rule,
  /* 1459 */  vecX_rule,
  /* 1460 */  vecX_rule,
  /* 1461 */  vecX_rule,
  /* 1462 */  _LoadVector_memory__rule,
  /* 1463 */  vecX_rule,
  /* 1464 */  _LoadVector_memory__rule,
  /* 1465 */  vecX_rule,
  /* 1466 */  _LoadVector_memory__rule,
  /* 1467 */  vecX_rule,
  /* 1468 */  vecY_rule,
  /* 1469 */  vecY_rule,
  /* 1470 */  vecY_rule,
  /* 1471 */  _LoadVector_memory__rule,
  /* 1472 */  vecY_rule,
  /* 1473 */  _LoadVector_memory__rule,
  /* 1474 */  vecY_rule,
  /* 1475 */  _LoadVector_memory__rule,
  /* 1476 */  vecY_rule,
  /* 1477 */  vecZ_rule,
  /* 1478 */  _LoadVector_memory__rule,
  /* 1479 */  vecZ_rule,
  /* 1480 */  vecD_rule,
  /* 1481 */  vecD_rule,
  /* 1482 */  _LoadVector_memory__rule,
  /* 1483 */  vecD_rule,
  /* 1484 */  vecX_rule,
  /* 1485 */  vecX_rule,
  /* 1486 */  _LoadVector_memory__rule,
  /* 1487 */  vecX_rule,
  /* 1488 */  vecX_rule,
  /* 1489 */  _LoadVector_memory__rule,
  /* 1490 */  vecX_rule,
  /* 1491 */  vecY_rule,
  /* 1492 */  _LoadVector_memory__rule,
  /* 1493 */  vecY_rule,
  /* 1494 */  vecZ_rule,
  /* 1495 */  _LoadVector_memory__rule,
  /* 1496 */  vecZ_rule,
  /* 1497 */  vecY_rule,
  /* 1498 */  _LoadVector_memory__rule,
  /* 1499 */  vecY_rule,
  /* 1500 */  vecZ_rule,
  /* 1501 */  _LoadVector_memory__rule,
  /* 1502 */  vecZ_rule,
  /* 1503 */  vecD_rule,
  /* 1504 */  vecD_rule,
  /* 1505 */  _LoadVector_memory__rule,
  /* 1506 */  vecD_rule,
  /* 1507 */  vecX_rule,
  /* 1508 */  vecX_rule,
  /* 1509 */  _LoadVector_memory__rule,
  /* 1510 */  vecX_rule,
  /* 1511 */  vecY_rule,
  /* 1512 */  _LoadVector_memory__rule,
  /* 1513 */  vecY_rule,
  /* 1514 */  vecZ_rule,
  /* 1515 */  _LoadVector_memory__rule,
  /* 1516 */  vecZ_rule,
  /* 1517 */  vecX_rule,
  /* 1518 */  vecX_rule,
  /* 1519 */  _LoadVector_memory__rule,
  /* 1520 */  vecX_rule,
  /* 1521 */  vecY_rule,
  /* 1522 */  _LoadVector_memory__rule,
  /* 1523 */  vecY_rule,
  /* 1524 */  vecZ_rule,
  /* 1525 */  _LoadVector_memory__rule,
  /* 1526 */  vecZ_rule,
  /* 1527 */  _Binary_vecY_vecY_rule,
  /* 1528 */  _Binary_vecY_vecY_rule,
  /* 1529 */  vecD_rule,
  /* 1530 */  vecD_rule,
  /* 1531 */  _LoadVector_memory__rule,
  /* 1532 */  vecX_rule,
  /* 1533 */  vecX_rule,
  /* 1534 */  _LoadVector_memory__rule,
  /* 1535 */  vecY_rule,
  /* 1536 */  _LoadVector_memory__rule,
  /* 1537 */  vecZ_rule,
  /* 1538 */  _LoadVector_memory__rule,
  /* 1539 */  vecX_rule,
  /* 1540 */  vecX_rule,
  /* 1541 */  _LoadVector_memory__rule,
  /* 1542 */  vecY_rule,
  /* 1543 */  _LoadVector_memory__rule,
  /* 1544 */  vecZ_rule,
  /* 1545 */  _LoadVector_memory__rule,
  /* 1546 */  vecS_rule,
  /* 1547 */  immI8_rule,
  /* 1548 */  vecS_rule,
  /* 1549 */  vecS_rule,
  /* 1550 */  vecS_rule,
  /* 1551 */  immI8_rule,
  /* 1552 */  immI8_rule,
  /* 1553 */  immI8_rule,
  /* 1554 */  vecS_rule,
  /* 1555 */  immI8_rule,
  /* 1556 */  vecS_rule,
  /* 1557 */  vecS_rule,
  /* 1558 */  vecS_rule,
  /* 1559 */  immI8_rule,
  /* 1560 */  immI8_rule,
  /* 1561 */  immI8_rule,
  /* 1562 */  vecS_rule,
  /* 1563 */  immI8_rule,
  /* 1564 */  vecS_rule,
  /* 1565 */  vecS_rule,
  /* 1566 */  vecS_rule,
  /* 1567 */  immI8_rule,
  /* 1568 */  immI8_rule,
  /* 1569 */  immI8_rule,
  /* 1570 */  vecS_rule,
  /* 1571 */  vecS_rule,
  /* 1572 */  vecS_rule,
  /* 1573 */  immI8_rule,
  /* 1574 */  immI8_rule,
  /* 1575 */  immI8_rule,
  /* 1576 */  vecS_rule,
  /* 1577 */  immI8_rule,
  /* 1578 */  vecS_rule,
  /* 1579 */  immI8_rule,
  /* 1580 */  vecS_rule,
  /* 1581 */  immI8_rule,
  /* 1582 */  vecS_rule,
  /* 1583 */  immI8_rule,
  /* 1584 */  vecS_rule,
  /* 1585 */  immI8_rule,
  /* 1586 */  vecS_rule,
  /* 1587 */  immI8_rule,
  /* 1588 */  vecS_rule,
  /* 1589 */  immI8_rule,
  /* 1590 */  vecS_rule,
  /* 1591 */  immI8_rule,
  /* 1592 */  vecS_rule,
  /* 1593 */  immI8_rule,
  /* 1594 */  vecS_rule,
  /* 1595 */  immI8_rule,
  /* 1596 */  vecS_rule,
  /* 1597 */  immI8_rule,
  /* 1598 */  vecS_rule,
  /* 1599 */  immI8_rule,
  /* 1600 */  vecS_rule,
  /* 1601 */  vecS_rule,
  /* 1602 */  vecS_rule,
  /* 1603 */  immI8_rule,
  /* 1604 */  immI8_rule,
  /* 1605 */  immI8_rule,
  /* 1606 */  vecS_rule,
  /* 1607 */  immI8_rule,
  /* 1608 */  vecS_rule,
  /* 1609 */  vecS_rule,
  /* 1610 */  vecS_rule,
  /* 1611 */  immI8_rule,
  /* 1612 */  immI8_rule,
  /* 1613 */  immI8_rule,
  /* 1614 */  vecS_rule,
  /* 1615 */  immI8_rule,
  /* 1616 */  vecS_rule,
  /* 1617 */  vecS_rule,
  /* 1618 */  vecS_rule,
  /* 1619 */  immI8_rule,
  /* 1620 */  immI8_rule,
  /* 1621 */  immI8_rule,
  /* 1622 */  vecS_rule,
  /* 1623 */  vecS_rule,
  /* 1624 */  vecS_rule,
  /* 1625 */  immI8_rule,
  /* 1626 */  immI8_rule,
  /* 1627 */  immI8_rule,
  /* 1628 */  vecS_rule,
  /* 1629 */  immI8_rule,
  /* 1630 */  vecS_rule,
  /* 1631 */  immI8_rule,
  /* 1632 */  vecS_rule,
  /* 1633 */  immI8_rule,
  /* 1634 */  vecS_rule,
  /* 1635 */  immI8_rule,
  /* 1636 */  vecS_rule,
  /* 1637 */  immI8_rule,
  /* 1638 */  vecS_rule,
  /* 1639 */  immI8_rule,
  /* 1640 */  vecS_rule,
  /* 1641 */  immI8_rule,
  /* 1642 */  vecS_rule,
  /* 1643 */  immI8_rule,
  /* 1644 */  vecS_rule,
  /* 1645 */  immI8_rule,
  /* 1646 */  vecS_rule,
  /* 1647 */  immI8_rule,
  /* 1648 */  vecS_rule,
  /* 1649 */  immI8_rule,
  /* 1650 */  vecS_rule,
  /* 1651 */  immI8_rule,
  /* 1652 */  vecS_rule,
  /* 1653 */  vecS_rule,
  /* 1654 */  vecS_rule,
  /* 1655 */  immI8_rule,
  /* 1656 */  immI8_rule,
  /* 1657 */  immI8_rule,
  /* 1658 */  vecS_rule,
  /* 1659 */  immI8_rule,
  /* 1660 */  vecS_rule,
  /* 1661 */  vecS_rule,
  /* 1662 */  vecS_rule,
  /* 1663 */  immI8_rule,
  /* 1664 */  immI8_rule,
  /* 1665 */  immI8_rule,
  /* 1666 */  vecS_rule,
  /* 1667 */  immI8_rule,
  /* 1668 */  vecS_rule,
  /* 1669 */  vecS_rule,
  /* 1670 */  vecS_rule,
  /* 1671 */  immI8_rule,
  /* 1672 */  immI8_rule,
  /* 1673 */  immI8_rule,
  /* 1674 */  vecS_rule,
  /* 1675 */  vecS_rule,
  /* 1676 */  vecS_rule,
  /* 1677 */  immI8_rule,
  /* 1678 */  immI8_rule,
  /* 1679 */  immI8_rule,
  /* 1680 */  vecS_rule,
  /* 1681 */  immI8_rule,
  /* 1682 */  vecS_rule,
  /* 1683 */  immI8_rule,
  /* 1684 */  vecS_rule,
  /* 1685 */  immI8_rule,
  /* 1686 */  vecS_rule,
  /* 1687 */  immI8_rule,
  /* 1688 */  vecS_rule,
  /* 1689 */  immI8_rule,
  /* 1690 */  vecS_rule,
  /* 1691 */  immI8_rule,
  /* 1692 */  vecS_rule,
  /* 1693 */  immI8_rule,
  /* 1694 */  vecS_rule,
  /* 1695 */  vecS_rule,
  /* 1696 */  _LoadVector_memory__rule,
  /* 1697 */  vecS_rule,
  /* 1698 */  vecD_rule,
  /* 1699 */  vecD_rule,
  /* 1700 */  _LoadVector_memory__rule,
  /* 1701 */  vecD_rule,
  /* 1702 */  vecX_rule,
  /* 1703 */  vecX_rule,
  /* 1704 */  _LoadVector_memory__rule,
  /* 1705 */  vecX_rule,
  /* 1706 */  vecY_rule,
  /* 1707 */  _LoadVector_memory__rule,
  /* 1708 */  vecY_rule,
  /* 1709 */  vecZ_rule,
  /* 1710 */  _LoadVector_memory__rule,
  /* 1711 */  vecZ_rule,
  /* 1712 */  vecS_rule,
  /* 1713 */  vecS_rule,
  /* 1714 */  _LoadVector_memory__rule,
  /* 1715 */  vecS_rule,
  /* 1716 */  vecD_rule,
  /* 1717 */  vecD_rule,
  /* 1718 */  _LoadVector_memory__rule,
  /* 1719 */  vecD_rule,
  /* 1720 */  vecX_rule,
  /* 1721 */  vecX_rule,
  /* 1722 */  _LoadVector_memory__rule,
  /* 1723 */  vecX_rule,
  /* 1724 */  vecY_rule,
  /* 1725 */  _LoadVector_memory__rule,
  /* 1726 */  vecY_rule,
  /* 1727 */  vecZ_rule,
  /* 1728 */  _LoadVector_memory__rule,
  /* 1729 */  vecZ_rule,
  /* 1730 */  vecS_rule,
  /* 1731 */  vecS_rule,
  /* 1732 */  _LoadVector_memory__rule,
  /* 1733 */  vecS_rule,
  /* 1734 */  vecD_rule,
  /* 1735 */  vecD_rule,
  /* 1736 */  _LoadVector_memory__rule,
  /* 1737 */  vecD_rule,
  /* 1738 */  vecX_rule,
  /* 1739 */  vecX_rule,
  /* 1740 */  _LoadVector_memory__rule,
  /* 1741 */  vecX_rule,
  /* 1742 */  vecY_rule,
  /* 1743 */  _LoadVector_memory__rule,
  /* 1744 */  vecY_rule,
  /* 1745 */  vecZ_rule,
  /* 1746 */  _LoadVector_memory__rule,
  /* 1747 */  vecZ_rule,
  /* 1748 */  _Binary_vecX_vecX_rule,
  /* 1749 */  _Binary_vecX__LoadVector_memory__rule,
  /* 1750 */  _Binary_vecY_vecY_rule,
  /* 1751 */  _Binary_vecY__LoadVector_memory__rule,
  /* 1752 */  _Binary_vecZ_vecZ_rule,
  /* 1753 */  _Binary_vecZ__LoadVector_memory__rule,
  /* 1754 */  _Binary_vecX_vecX_rule,
  /* 1755 */  _Binary_vecX__LoadVector_memory__rule,
  /* 1756 */  _Binary_vecY_vecY_rule,
  /* 1757 */  _Binary_vecY__LoadVector_memory__rule,
  /* 1758 */  _Binary_vecZ_vecZ_rule,
  /* 1759 */  _Binary_vecZ__LoadVector_memory__rule,
  // last instruction
  0 // no trailing comma
};

const char        *ruleName[] = {
  /*    0 */  "UNIVERSE",
  /*    1 */  "LABEL",
  /*    2 */  "SREGI",
  /*    3 */  "SREGP",
  /*    4 */  "SREGF",
  /*    5 */  "SREGD",
  /*    6 */  "SREGL",
  /*    7 */  "METHOD",
  /*    8 */  "IMMI",
  /*    9 */  "IMMI0",
  /*   10 */  "IMMI1",
  /*   11 */  "IMMI_M1",
  /*   12 */  "IMMI2",
  /*   13 */  "IMMI8",
  /*   14 */  "IMMU8",
  /*   15 */  "IMMI16",
  /*   16 */  "IMMU31",
  /*   17 */  "IMMI_32",
  /*   18 */  "IMMI_64",
  /*   19 */  "IMMP",
  /*   20 */  "IMMP0",
  /*   21 */  "IMMN",
  /*   22 */  "IMMNKLASS",
  /*   23 */  "IMMN0",
  /*   24 */  "IMMP31",
  /*   25 */  "IMML",
  /*   26 */  "IMML8",
  /*   27 */  "IMMUL32",
  /*   28 */  "IMML32",
  /*   29 */  "IMML0",
  /*   30 */  "IMML1",
  /*   31 */  "IMML_M1",
  /*   32 */  "IMML10",
  /*   33 */  "IMML_127",
  /*   34 */  "IMML_32BITS",
  /*   35 */  "IMMF0",
  /*   36 */  "IMMF",
  /*   37 */  "IMMD0",
  /*   38 */  "IMMD",
  /*   39 */  "IMMI_16",
  /*   40 */  "IMMI_24",
  /*   41 */  "IMMI_255",
  /*   42 */  "IMMI_65535",
  /*   43 */  "IMML_255",
  /*   44 */  "IMML_65535",
  /*   45 */  "RREGI",
  /*   46 */  "RAX_REGI",
  /*   47 */  "RBX_REGI",
  /*   48 */  "RCX_REGI",
  /*   49 */  "RDX_REGI",
  /*   50 */  "RDI_REGI",
  /*   51 */  "NO_RCX_REGI",
  /*   52 */  "NO_RAX_RDX_REGI",
  /*   53 */  "ANY_REGP",
  /*   54 */  "RREGP",
  /*   55 */  "RREGN",
  /*   56 */  "NO_RAX_REGP",
  /*   57 */  "NO_RBP_REGP",
  /*   58 */  "NO_RAX_RBX_REGP",
  /*   59 */  "RAX_REGP",
  /*   60 */  "RAX_REGN",
  /*   61 */  "RBX_REGP",
  /*   62 */  "RSI_REGP",
  /*   63 */  "RDI_REGP",
  /*   64 */  "R15_REGP",
  /*   65 */  "REX_REGP",
  /*   66 */  "RREGL",
  /*   67 */  "NO_RAX_RDX_REGL",
  /*   68 */  "NO_RAX_REGL",
  /*   69 */  "NO_RCX_REGL",
  /*   70 */  "RAX_REGL",
  /*   71 */  "RCX_REGL",
  /*   72 */  "RDX_REGL",
  /*   73 */  "RFLAGSREG",
  /*   74 */  "RFLAGSREGU",
  /*   75 */  "RFLAGSREGUCF",
  /*   76 */  "REGF",
  /*   77 */  "REGD",
  /*   78 */  "VECS",
  /*   79 */  "VECD",
  /*   80 */  "VECX",
  /*   81 */  "VECY",
  /*   82 */  "INDIRECT",
  /*   83 */  "INDOFFSET8",
  /*   84 */  "INDOFFSET32",
  /*   85 */  "INDINDEXOFFSET",
  /*   86 */  "INDINDEX",
  /*   87 */  "INDINDEXSCALE",
  /*   88 */  "INDPOSINDEXSCALE",
  /*   89 */  "INDINDEXSCALEOFFSET",
  /*   90 */  "INDPOSINDEXOFFSET",
  /*   91 */  "INDPOSINDEXSCALEOFFSET",
  /*   92 */  "INDCOMPRESSEDOOPOFFSET",
  /*   93 */  "INDIRECTNARROW",
  /*   94 */  "INDOFFSET8NARROW",
  /*   95 */  "INDOFFSET32NARROW",
  /*   96 */  "INDINDEXOFFSETNARROW",
  /*   97 */  "INDINDEXNARROW",
  /*   98 */  "INDINDEXSCALENARROW",
  /*   99 */  "INDINDEXSCALEOFFSETNARROW",
  /*  100 */  "INDPOSINDEXOFFSETNARROW",
  /*  101 */  "INDPOSINDEXSCALEOFFSETNARROW",
  /*  102 */  "STACKSLOTP",
  /*  103 */  "STACKSLOTI",
  /*  104 */  "STACKSLOTF",
  /*  105 */  "STACKSLOTD",
  /*  106 */  "STACKSLOTL",
  /*  107 */  "CMPOP",
  /*  108 */  "CMPOPU",
  /*  109 */  "CMPOPUCF",
  /*  110 */  "CMPOPUCF2",
  /*  111 */  "RXMM0",
  /*  112 */  "RXMM1",
  /*  113 */  "RXMM2",
  /*  114 */  "RXMM3",
  /*  115 */  "RXMM4",
  /*  116 */  "RXMM5",
  /*  117 */  "RXMM6",
  /*  118 */  "RXMM7",
  /*  119 */  "RXMM8",
  /*  120 */  "RXMM9",
  /*  121 */  "RXMM10",
  /*  122 */  "RXMM11",
  /*  123 */  "RXMM12",
  /*  124 */  "RXMM13",
  /*  125 */  "RXMM14",
  /*  126 */  "RXMM15",
  /*  127 */  "RXMM16",
  /*  128 */  "RXMM17",
  /*  129 */  "RXMM18",
  /*  130 */  "RXMM19",
  /*  131 */  "RXMM20",
  /*  132 */  "RXMM21",
  /*  133 */  "RXMM22",
  /*  134 */  "RXMM23",
  /*  135 */  "RXMM24",
  /*  136 */  "RXMM25",
  /*  137 */  "RXMM26",
  /*  138 */  "RXMM27",
  /*  139 */  "RXMM28",
  /*  140 */  "RXMM29",
  /*  141 */  "RXMM30",
  /*  142 */  "RXMM31",
  /*  143 */  "VECZ",
  /*  144 */  "CMPOP_VCMPPD",
  // last operand
  /*  145 */  "MEMORY",
  // last operand class
  /*  146 */  "_AddP_any_RegP_rRegL",
  /*  147 */  "_LShiftL_rRegL_immI2",
  /*  148 */  "_ConvI2L_rRegI_",
  /*  149 */  "_LShiftL__ConvI2L_rRegI__immI2",
  /*  150 */  "_AddP_any_RegP__LShiftL_rRegL_immI2",
  /*  151 */  "_AddP_any_RegP__ConvI2L_rRegI_",
  /*  152 */  "_AddP_any_RegP__LShiftL__ConvI2L_rRegI__immI2",
  /*  153 */  "_DecodeN_rRegN_",
  /*  154 */  "_AddP__DecodeN_rRegN__rRegL",
  /*  155 */  "_AddP__DecodeN_rRegN___LShiftL_rRegL_immI2",
  /*  156 */  "_AddP__DecodeN_rRegN___ConvI2L_rRegI_",
  /*  157 */  "_AddP__DecodeN_rRegN___LShiftL__ConvI2L_rRegI__immI2",
  /*  158 */  "_LoadB_memory_",
  /*  159 */  "_LoadUB_memory_",
  /*  160 */  "_AndI__LoadUB_memory__immI",
  /*  161 */  "_LoadS_memory_",
  /*  162 */  "_LShiftI__LoadS_memory__immI_24",
  /*  163 */  "_LoadUS_memory_",
  /*  164 */  "_LShiftI__LoadUS_memory__immI_24",
  /*  165 */  "_AndI__LoadUS_memory__immI_255",
  /*  166 */  "_AndI__LoadUS_memory__immI",
  /*  167 */  "_LoadI_memory_",
  /*  168 */  "_LShiftI__LoadI_memory__immI_24",
  /*  169 */  "_LShiftI__LoadI_memory__immI_16",
  /*  170 */  "_AndI__LoadI_memory__immI_255",
  /*  171 */  "_AndI__LoadI_memory__immI_65535",
  /*  172 */  "_AndI__LoadI_memory__immU31",
  /*  173 */  "_ConvI2L__LoadI_memory__",
  /*  174 */  "_LoadL_memory_",
  /*  175 */  "_CastP2X_rRegP_",
  /*  176 */  "_CastP2X__DecodeN_rRegN__",
  /*  177 */  "_AddL__LShiftL_rRegL_immI2_immL32",
  /*  178 */  "_Binary_cmpOp_rFlagsReg",
  /*  179 */  "_Binary_rRegI_rRegI",
  /*  180 */  "_Binary_cmpOpU_rFlagsRegU",
  /*  181 */  "_Binary_cmpOpUCF_rFlagsRegUCF",
  /*  182 */  "_Binary_rRegI__LoadI_memory_",
  /*  183 */  "_Binary_rRegN_rRegN",
  /*  184 */  "_Binary_rRegP_rRegP",
  /*  185 */  "_Binary_rRegL_rRegL",
  /*  186 */  "_Binary_rRegL__LoadL_memory_",
  /*  187 */  "_Binary_regF_regF",
  /*  188 */  "_Binary_regD_regD",
  /*  189 */  "_AddI__LoadI_memory__rRegI",
  /*  190 */  "_AddI_rRegI__LoadI_memory_",
  /*  191 */  "_AddI__LoadI_memory__immI",
  /*  192 */  "_AddI__LoadI_memory__immI1",
  /*  193 */  "_AddI__LoadI_memory__immI_M1",
  /*  194 */  "_AddL__LoadL_memory__rRegL",
  /*  195 */  "_AddL_rRegL__LoadL_memory_",
  /*  196 */  "_AddL__LoadL_memory__immL32",
  /*  197 */  "_AddL__LoadL_memory__immL1",
  /*  198 */  "_AddL__LoadL_memory__immL_M1",
  /*  199 */  "_Binary_rax_RegP_rRegP",
  /*  200 */  "_Binary_rax_RegI_rRegI",
  /*  201 */  "_Binary_rax_RegL_rRegL",
  /*  202 */  "_Binary_rax_RegN_rRegN",
  /*  203 */  "_SubI__LoadI_memory__rRegI",
  /*  204 */  "_SubI__LoadI_memory__immI",
  /*  205 */  "_SubL__LoadL_memory__rRegL",
  /*  206 */  "_SubL__LoadL_memory__immL32",
  /*  207 */  "_SubI_immI0_rRegI",
  /*  208 */  "_SubI_immI0__LoadI_memory_",
  /*  209 */  "_SubL_immL0__LoadL_memory_",
  /*  210 */  "_LShiftI__LoadI_memory__immI1",
  /*  211 */  "_LShiftI__LoadI_memory__immI8",
  /*  212 */  "_LShiftI__LoadI_memory__rcx_RegI",
  /*  213 */  "_RShiftI__LoadI_memory__immI1",
  /*  214 */  "_RShiftI__LoadI_memory__immI8",
  /*  215 */  "_RShiftI__LoadI_memory__rcx_RegI",
  /*  216 */  "_URShiftI__LoadI_memory__immI1",
  /*  217 */  "_URShiftI__LoadI_memory__immI8",
  /*  218 */  "_URShiftI__LoadI_memory__rcx_RegI",
  /*  219 */  "_LShiftL__LoadL_memory__immI1",
  /*  220 */  "_LShiftL__LoadL_memory__immI8",
  /*  221 */  "_LShiftL__LoadL_memory__rcx_RegI",
  /*  222 */  "_RShiftL__LoadL_memory__immI1",
  /*  223 */  "_RShiftL__LoadL_memory__immI8",
  /*  224 */  "_RShiftL__LoadL_memory__rcx_RegI",
  /*  225 */  "_URShiftL__LoadL_memory__immI1",
  /*  226 */  "_URShiftL__LoadL_memory__immI8",
  /*  227 */  "_URShiftL__LoadL_memory__rcx_RegI",
  /*  228 */  "_LShiftI_rRegI_immI_24",
  /*  229 */  "_LShiftI_rRegI_immI_16",
  /*  230 */  "_LShiftI_rRegI_immI1",
  /*  231 */  "_URShiftI_rRegI_immI_M1",
  /*  232 */  "_LShiftI_rRegI_immI8",
  /*  233 */  "_URShiftI_rRegI_immI8",
  /*  234 */  "_LShiftI_no_rcx_RegI_rcx_RegI",
  /*  235 */  "_SubI_immI0_rcx_RegI",
  /*  236 */  "_URShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI",
  /*  237 */  "_SubI_immI_32_rcx_RegI",
  /*  238 */  "_URShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI",
  /*  239 */  "_URShiftI_rRegI_immI1",
  /*  240 */  "_LShiftI_rRegI_immI_M1",
  /*  241 */  "_URShiftI_no_rcx_RegI_rcx_RegI",
  /*  242 */  "_LShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI",
  /*  243 */  "_LShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI",
  /*  244 */  "_LShiftL_rRegL_immI1",
  /*  245 */  "_URShiftL_rRegL_immI_M1",
  /*  246 */  "_LShiftL_rRegL_immI8",
  /*  247 */  "_URShiftL_rRegL_immI8",
  /*  248 */  "_LShiftL_no_rcx_RegL_rcx_RegI",
  /*  249 */  "_URShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI",
  /*  250 */  "_SubI_immI_64_rcx_RegI",
  /*  251 */  "_URShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI",
  /*  252 */  "_URShiftL_rRegL_immI1",
  /*  253 */  "_LShiftL_rRegL_immI_M1",
  /*  254 */  "_URShiftL_no_rcx_RegL_rcx_RegI",
  /*  255 */  "_LShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI",
  /*  256 */  "_LShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI",
  /*  257 */  "_AndI_rRegI_immI_255",
  /*  258 */  "_AndI_rRegI_immI_65535",
  /*  259 */  "_AndI__LoadI_memory__rRegI",
  /*  260 */  "_AndI_rRegI__LoadI_memory_",
  /*  261 */  "_AndI__LoadI_memory__immI",
  /*  262 */  "_XorI_rRegI_immI_M1",
  /*  263 */  "_AddI_rRegI_immI_M1",
  /*  264 */  "_OrI__LoadI_memory__rRegI",
  /*  265 */  "_OrI_rRegI__LoadI_memory_",
  /*  266 */  "_OrI__LoadI_memory__immI",
  /*  267 */  "_XorI__LoadI_memory__rRegI",
  /*  268 */  "_XorI_rRegI__LoadI_memory_",
  /*  269 */  "_XorI__LoadI_memory__immI",
  /*  270 */  "_AndL__LoadL_memory__rRegL",
  /*  271 */  "_AndL_rRegL__LoadL_memory_",
  /*  272 */  "_AndL__LoadL_memory__immL32",
  /*  273 */  "_XorL_rRegL_immL_M1",
  /*  274 */  "_SubL_immL0_rRegL",
  /*  275 */  "_AddL_rRegL_immL_M1",
  /*  276 */  "_CastP2X_any_RegP_",
  /*  277 */  "_OrL__LoadL_memory__rRegL",
  /*  278 */  "_OrL_rRegL__LoadL_memory_",
  /*  279 */  "_OrL__LoadL_memory__immL32",
  /*  280 */  "_XorL__LoadL_memory__rRegL",
  /*  281 */  "_XorL_rRegL__LoadL_memory_",
  /*  282 */  "_XorL__LoadL_memory__immL32",
  /*  283 */  "_CmpLTMask_rRegI_rRegI",
  /*  284 */  "_AndI__CmpLTMask_rRegI_rRegI_rRegI",
  /*  285 */  "_SubI_rRegI_rRegI",
  /*  286 */  "_AndI_rRegI__CmpLTMask_rRegI_rRegI",
  /*  287 */  "_LoadF_memory_",
  /*  288 */  "_LoadD_memory_",
  /*  289 */  "_Binary_rdi_RegP_rcx_RegI",
  /*  290 */  "_Binary_rsi_RegP_rdx_RegI",
  /*  291 */  "_Binary_rdi_RegP_rdx_RegI",
  /*  292 */  "_Binary_rsi_RegP_immI",
  /*  293 */  "_Binary_rsi_RegP_rax_RegI",
  /*  294 */  "_Binary_rdi_RegP_rsi_RegP",
  /*  295 */  "_AndI_rRegI_immI",
  /*  296 */  "_LoadP_memory_",
  /*  297 */  "_LoadN_memory_",
  /*  298 */  "_LoadNKlass_memory_",
  /*  299 */  "_AndL_rRegL_immL32",
  /*  300 */  "_AndL__CastP2X_rRegP___LoadL_memory_",
  /*  301 */  "_AndL__LoadL_memory___CastP2X_rRegP_",
  /*  302 */  "_AndI__LoadB_memory__immI8",
  /*  303 */  "_PartialSubtypeCheck_rsi_RegP_rax_RegP",
  /*  304 */  "_LoadVector_memory_",
  /*  305 */  "_Binary_cmpOp_vcmppd_immI8",
  /*  306 */  "_Binary_vecY_vecY",
  /*  307 */  "_Binary_vecX_vecX",
  /*  308 */  "_Binary_vecX__LoadVector_memory_",
  /*  309 */  "_Binary_vecY__LoadVector_memory_",
  /*  310 */  "_Binary_vecZ_vecZ",
  /*  311 */  "_Binary_vecZ__LoadVector_memory_",
  // last internally defined operand
  /*  312 */  "storeSSI",
  /*  313 */  "storeSSL",
  /*  314 */  "storeSSP",
  /*  315 */  "storeSSF",
  /*  316 */  "storeSSD",
  /*  317 */  "leaP8",
  /*  318 */  "leaP32",
  /*  319 */  "leaPIdxOff",
  /*  320 */  "leaPIdxScale",
  /*  321 */  "leaPPosIdxScale",
  /*  322 */  "leaPIdxScaleOff",
  /*  323 */  "leaPPosIdxOff",
  /*  324 */  "leaPPosIdxScaleOff",
  /*  325 */  "leaPCompressedOopOffset",
  /*  326 */  "leaP8Narrow",
  /*  327 */  "leaP32Narrow",
  /*  328 */  "leaPIdxOffNarrow",
  /*  329 */  "leaPIdxScaleNarrow",
  /*  330 */  "leaPIdxScaleOffNarrow",
  /*  331 */  "leaPPosIdxOffNarrow",
  /*  332 */  "leaPPosIdxScaleOffNarrow",
  /*  333 */  "loadConI",
  /*  334 */  "loadConI0",
  /*  335 */  "loadConL",
  /*  336 */  "loadConL0",
  /*  337 */  "loadConUL32",
  /*  338 */  "loadConL32",
  /*  339 */  "loadConP",
  /*  340 */  "loadConP0",
  /*  341 */  "loadConP31",
  /*  342 */  "loadConF",
  /*  343 */  "loadConN0",
  /*  344 */  "loadConN",
  /*  345 */  "loadConNKlass",
  /*  346 */  "loadConF0",
  /*  347 */  "loadConD",
  /*  348 */  "loadConD0",
  /*  349 */  "loadSSI",
  /*  350 */  "loadSSL",
  /*  351 */  "loadSSP",
  /*  352 */  "loadSSF",
  /*  353 */  "loadSSD",
  /*  354 */  "membar_volatile",
  /*  355 */  "castX2P",
  /*  356 */  "castP2X",
  /*  357 */  "checkCastPP",
  /*  358 */  "castPP",
  /*  359 */  "castII",
  /*  360 */  "storePConditional",
  /*  361 */  "storeIConditional",
  /*  362 */  "storeLConditional",
  /*  363 */  "cmpF_cc_reg",
  /*  364 */  "cmpF_cc_reg_CF",
  /*  365 */  "cmpF_cc_mem",
  /*  366 */  "cmpF_cc_memCF",
  /*  367 */  "cmpF_cc_imm",
  /*  368 */  "cmpF_cc_immCF",
  /*  369 */  "cmpD_cc_reg",
  /*  370 */  "cmpD_cc_reg_CF",
  /*  371 */  "cmpD_cc_mem",
  /*  372 */  "cmpD_cc_memCF",
  /*  373 */  "cmpD_cc_imm",
  /*  374 */  "cmpD_cc_immCF",
  /*  375 */  "roundFloat_nop",
  /*  376 */  "roundDouble_nop",
  /*  377 */  "MoveF2I_stack_reg",
  /*  378 */  "MoveI2F_stack_reg",
  /*  379 */  "MoveD2L_stack_reg",
  /*  380 */  "MoveL2D_stack_reg_partial",
  /*  381 */  "MoveL2D_stack_reg",
  /*  382 */  "MoveF2I_reg_reg",
  /*  383 */  "MoveD2L_reg_reg",
  /*  384 */  "MoveI2F_reg_reg",
  /*  385 */  "MoveL2D_reg_reg",
  /*  386 */  "overflowAddI_rReg",
  /*  387 */  "overflowAddI_rReg_imm",
  /*  388 */  "overflowAddL_rReg",
  /*  389 */  "overflowAddL_rReg_imm",
  /*  390 */  "overflowSubI_rReg",
  /*  391 */  "overflowSubI_rReg_imm",
  /*  392 */  "overflowSubL_rReg",
  /*  393 */  "overflowSubL_rReg_imm",
  /*  394 */  "overflowNegI_rReg",
  /*  395 */  "overflowNegL_rReg",
  /*  396 */  "overflowMulI_rReg",
  /*  397 */  "overflowMulI_rReg_imm",
  /*  398 */  "overflowMulL_rReg",
  /*  399 */  "overflowMulL_rReg_imm",
  /*  400 */  "compI_rReg",
  /*  401 */  "compI_rReg_imm",
  /*  402 */  "compI_rReg_mem",
  /*  403 */  "testI_reg",
  /*  404 */  "testI_reg_imm",
  /*  405 */  "testI_reg_mem",
  /*  406 */  "testI_reg_mem_0",
  /*  407 */  "compU_rReg",
  /*  408 */  "compU_rReg_imm",
  /*  409 */  "compU_rReg_mem",
  /*  410 */  "testU_reg",
  /*  411 */  "compP_rReg",
  /*  412 */  "compP_rReg_mem",
  /*  413 */  "compP_mem_rReg",
  /*  414 */  "testP_reg",
  /*  415 */  "testP_mem",
  /*  416 */  "testP_mem_reg0",
  /*  417 */  "compN_rReg",
  /*  418 */  "compN_rReg_mem",
  /*  419 */  "compN_rReg_imm",
  /*  420 */  "compN_mem_imm",
  /*  421 */  "compN_rReg_imm_klass",
  /*  422 */  "compN_mem_imm_klass",
  /*  423 */  "testN_reg",
  /*  424 */  "testN_mem",
  /*  425 */  "testN_mem_reg0",
  /*  426 */  "compL_rReg",
  /*  427 */  "compL_rReg_imm",
  /*  428 */  "compL_rReg_mem",
  /*  429 */  "testL_reg",
  /*  430 */  "testL_reg_imm",
  /*  431 */  "testL_reg_mem",
  /*  432 */  "testL_reg_mem_0",
  /*  433 */  "testL_reg_mem2",
  /*  434 */  "testL_reg_mem2_0",
  /*  435 */  "compUL_rReg",
  /*  436 */  "compUL_rReg_imm",
  /*  437 */  "compUL_rReg_mem",
  /*  438 */  "testUL_reg",
  /*  439 */  "compB_mem_imm",
  /*  440 */  "testB_mem_imm",
  /*  441 */  "partialSubtypeCheck_vs_Zero",
  /*  442 */  "cmpFastLockRTM",
  /*  443 */  "cmpFastLock",
  /*  444 */  "cmpFastUnlock",
  /*  445 */  "safePoint_poll",
  /*  446 */  "tlsLoadP",
  /*  447 */  "absF_reg",
  /*  448 */  "absF_reg_reg",
  /*  449 */  "absF_reg_reg_evex",
  /*  450 */  "absD_reg",
  /*  451 */  "absD_reg_reg",
  /*  452 */  "absD_reg_reg_evex",
  /*  453 */  "negF_reg",
  /*  454 */  "negF_reg_reg",
  /*  455 */  "negD_reg",
  /*  456 */  "negD_reg_reg",
  /*  457 */  "vshiftcnt",
  /*  458 */  "vshiftcnt_0",
  /*  459 */  "vsqrt2D_reg",
  /*  460 */  "vsqrt2D_mem",
  /*  461 */  "vsqrt4D_reg",
  /*  462 */  "vsqrt4D_mem",
  /*  463 */  "vsqrt8D_reg",
  /*  464 */  "vsqrt8D_mem",
  /*  465 */  "vsqrt2F_reg",
  /*  466 */  "vsqrt2F_mem",
  /*  467 */  "vsqrt4F_reg",
  /*  468 */  "vsqrt4F_mem",
  /*  469 */  "vsqrt8F_reg",
  /*  470 */  "vsqrt8F_mem",
  /*  471 */  "vsqrt16F_reg",
  /*  472 */  "vsqrt16F_mem",
  /*  473 */  "vpopcount2I",
  /*  474 */  "vpopcount4I",
  /*  475 */  "vpopcount8I",
  /*  476 */  "vpopcount16I",
  /*  477 */  "loadB",
  /*  478 */  "loadB2L",
  /*  479 */  "loadUB",
  /*  480 */  "loadUB2L",
  /*  481 */  "loadUB2L_immI",
  /*  482 */  "loadS",
  /*  483 */  "loadS2B",
  /*  484 */  "loadS2L",
  /*  485 */  "loadUS",
  /*  486 */  "loadUS2B",
  /*  487 */  "loadUS2L",
  /*  488 */  "loadUS2L_immI_255",
  /*  489 */  "loadUS2L_immI",
  /*  490 */  "loadI",
  /*  491 */  "loadI2B",
  /*  492 */  "loadI2UB",
  /*  493 */  "loadI2S",
  /*  494 */  "loadI2US",
  /*  495 */  "loadI2L",
  /*  496 */  "loadI2L_immI_255",
  /*  497 */  "loadI2L_immI_65535",
  /*  498 */  "loadI2L_immU31",
  /*  499 */  "loadUI2L",
  /*  500 */  "loadL",
  /*  501 */  "loadRange",
  /*  502 */  "loadP",
  /*  503 */  "loadN",
  /*  504 */  "loadKlass",
  /*  505 */  "loadNKlass",
  /*  506 */  "loadF",
  /*  507 */  "loadD_partial",
  /*  508 */  "loadD",
  /*  509 */  "prefetchAlloc",
  /*  510 */  "prefetchAllocNTA",
  /*  511 */  "prefetchAllocT0",
  /*  512 */  "prefetchAllocT2",
  /*  513 */  "storeB",
  /*  514 */  "storeC",
  /*  515 */  "storeI",
  /*  516 */  "storeL",
  /*  517 */  "storeP",
  /*  518 */  "storeImmP0",
  /*  519 */  "storeImmP",
  /*  520 */  "storeN",
  /*  521 */  "storeNKlass",
  /*  522 */  "storeImmN0",
  /*  523 */  "storeImmN",
  /*  524 */  "storeImmNKlass",
  /*  525 */  "storeImmI0",
  /*  526 */  "storeImmI",
  /*  527 */  "storeImmL0",
  /*  528 */  "storeImmL",
  /*  529 */  "storeImmC0",
  /*  530 */  "storeImmI16",
  /*  531 */  "storeImmB0",
  /*  532 */  "storeImmB",
  /*  533 */  "storeImmCM0_reg",
  /*  534 */  "storeImmCM0",
  /*  535 */  "storeF",
  /*  536 */  "storeF0",
  /*  537 */  "storeF_imm",
  /*  538 */  "storeD",
  /*  539 */  "storeD0_imm",
  /*  540 */  "storeD0",
  /*  541 */  "bytes_reverse_int",
  /*  542 */  "bytes_reverse_long",
  /*  543 */  "bytes_reverse_unsigned_short",
  /*  544 */  "bytes_reverse_short",
  /*  545 */  "countLeadingZerosI",
  /*  546 */  "countLeadingZerosI_bsr",
  /*  547 */  "countLeadingZerosL",
  /*  548 */  "countLeadingZerosL_bsr",
  /*  549 */  "countTrailingZerosI",
  /*  550 */  "countTrailingZerosI_bsf",
  /*  551 */  "countTrailingZerosL",
  /*  552 */  "countTrailingZerosL_bsf",
  /*  553 */  "popCountI",
  /*  554 */  "popCountI_mem",
  /*  555 */  "popCountL",
  /*  556 */  "popCountL_mem",
  /*  557 */  "membar_acquire",
  /*  558 */  "membar_acquire_0",
  /*  559 */  "membar_acquire_lock",
  /*  560 */  "membar_release",
  /*  561 */  "membar_release_0",
  /*  562 */  "membar_release_lock",
  /*  563 */  "unnecessary_membar_volatile",
  /*  564 */  "membar_storestore",
  /*  565 */  "convP2I",
  /*  566 */  "convN2I",
  /*  567 */  "encodeHeapOop",
  /*  568 */  "encodeHeapOop_not_null",
  /*  569 */  "decodeHeapOop",
  /*  570 */  "decodeHeapOop_not_null",
  /*  571 */  "encodeKlass_not_null",
  /*  572 */  "decodeKlass_not_null",
  /*  573 */  "jumpXtnd_offset",
  /*  574 */  "jumpXtnd_addr",
  /*  575 */  "jumpXtnd",
  /*  576 */  "cmovI_reg",
  /*  577 */  "cmovI_regU",
  /*  578 */  "cmovI_regUCF",
  /*  579 */  "cmovI_mem",
  /*  580 */  "cmovI_memU",
  /*  581 */  "cmovI_memUCF",
  /*  582 */  "cmovN_reg",
  /*  583 */  "cmovN_regU",
  /*  584 */  "cmovN_regUCF",
  /*  585 */  "cmovP_reg",
  /*  586 */  "cmovP_regU",
  /*  587 */  "cmovP_regUCF",
  /*  588 */  "cmovL_reg",
  /*  589 */  "cmovL_mem",
  /*  590 */  "cmovL_regU",
  /*  591 */  "cmovL_regUCF",
  /*  592 */  "cmovL_memU",
  /*  593 */  "cmovL_memUCF",
  /*  594 */  "cmovF_reg",
  /*  595 */  "cmovF_regU",
  /*  596 */  "cmovF_regUCF",
  /*  597 */  "cmovD_reg",
  /*  598 */  "cmovD_regU",
  /*  599 */  "cmovD_regUCF",
  /*  600 */  "addI_rReg",
  /*  601 */  "addI_rReg_imm",
  /*  602 */  "addI_rReg_mem",
  /*  603 */  "addI_rReg_mem_0",
  /*  604 */  "addI_mem_rReg",
  /*  605 */  "addI_mem_rReg_0",
  /*  606 */  "addI_mem_imm",
  /*  607 */  "incI_rReg",
  /*  608 */  "incI_mem",
  /*  609 */  "decI_rReg",
  /*  610 */  "decI_mem",
  /*  611 */  "leaI_rReg_immI",
  /*  612 */  "addL_rReg",
  /*  613 */  "addL_rReg_imm",
  /*  614 */  "addL_rReg_mem",
  /*  615 */  "addL_rReg_mem_0",
  /*  616 */  "addL_mem_rReg",
  /*  617 */  "addL_mem_rReg_0",
  /*  618 */  "addL_mem_imm",
  /*  619 */  "incL_rReg",
  /*  620 */  "incL_mem",
  /*  621 */  "decL_rReg",
  /*  622 */  "decL_mem",
  /*  623 */  "leaL_rReg_immL",
  /*  624 */  "addP_rReg",
  /*  625 */  "addP_rReg_imm",
  /*  626 */  "leaP_rReg_imm",
  /*  627 */  "loadPLocked",
  /*  628 */  "compareAndSwapP",
  /*  629 */  "compareAndSwapP_0",
  /*  630 */  "compareAndSwapL",
  /*  631 */  "compareAndSwapL_0",
  /*  632 */  "compareAndSwapI",
  /*  633 */  "compareAndSwapI_0",
  /*  634 */  "compareAndSwapB",
  /*  635 */  "compareAndSwapB_0",
  /*  636 */  "compareAndSwapS",
  /*  637 */  "compareAndSwapS_0",
  /*  638 */  "compareAndSwapN",
  /*  639 */  "compareAndSwapN_0",
  /*  640 */  "compareAndExchangeB",
  /*  641 */  "compareAndExchangeS",
  /*  642 */  "compareAndExchangeI",
  /*  643 */  "compareAndExchangeL",
  /*  644 */  "compareAndExchangeN",
  /*  645 */  "compareAndExchangeP",
  /*  646 */  "xaddB_no_res",
  /*  647 */  "xaddB",
  /*  648 */  "xaddS_no_res",
  /*  649 */  "xaddS",
  /*  650 */  "xaddI_no_res",
  /*  651 */  "xaddI",
  /*  652 */  "xaddL_no_res",
  /*  653 */  "xaddL",
  /*  654 */  "xchgB",
  /*  655 */  "xchgS",
  /*  656 */  "xchgI",
  /*  657 */  "xchgL",
  /*  658 */  "xchgP",
  /*  659 */  "xchgN",
  /*  660 */  "subI_rReg",
  /*  661 */  "subI_rReg_imm",
  /*  662 */  "subI_rReg_mem",
  /*  663 */  "subI_mem_rReg",
  /*  664 */  "subI_mem_imm",
  /*  665 */  "subL_rReg",
  /*  666 */  "subL_rReg_imm",
  /*  667 */  "subL_rReg_mem",
  /*  668 */  "subL_mem_rReg",
  /*  669 */  "subL_mem_imm",
  /*  670 */  "subP_rReg",
  /*  671 */  "negI_rReg",
  /*  672 */  "negI_mem",
  /*  673 */  "negL_rReg",
  /*  674 */  "negL_mem",
  /*  675 */  "mulI_rReg",
  /*  676 */  "mulI_rReg_imm",
  /*  677 */  "mulI_mem",
  /*  678 */  "mulI_mem_0",
  /*  679 */  "mulI_mem_imm",
  /*  680 */  "mulL_rReg",
  /*  681 */  "mulL_rReg_imm",
  /*  682 */  "mulL_mem",
  /*  683 */  "mulL_mem_0",
  /*  684 */  "mulL_mem_imm",
  /*  685 */  "mulHiL_rReg",
  /*  686 */  "divI_rReg",
  /*  687 */  "divL_rReg",
  /*  688 */  "divModI_rReg_divmod",
  /*  689 */  "divModL_rReg_divmod",
  /*  690 */  "loadConL_0x6666666666666667",
  /*  691 */  "mul_hi",
  /*  692 */  "sarL_rReg_63",
  /*  693 */  "sarL_rReg_2",
  /*  694 */  "divL_10",
  /*  695 */  "modI_rReg",
  /*  696 */  "modL_rReg",
  /*  697 */  "salI_rReg_1",
  /*  698 */  "salI_mem_1",
  /*  699 */  "salI_rReg_imm",
  /*  700 */  "salI_mem_imm",
  /*  701 */  "salI_rReg_CL",
  /*  702 */  "salI_mem_CL",
  /*  703 */  "sarI_rReg_1",
  /*  704 */  "sarI_mem_1",
  /*  705 */  "sarI_rReg_imm",
  /*  706 */  "sarI_mem_imm",
  /*  707 */  "sarI_rReg_CL",
  /*  708 */  "sarI_mem_CL",
  /*  709 */  "shrI_rReg_1",
  /*  710 */  "shrI_mem_1",
  /*  711 */  "shrI_rReg_imm",
  /*  712 */  "shrI_mem_imm",
  /*  713 */  "shrI_rReg_CL",
  /*  714 */  "shrI_mem_CL",
  /*  715 */  "salL_rReg_1",
  /*  716 */  "salL_mem_1",
  /*  717 */  "salL_rReg_imm",
  /*  718 */  "salL_mem_imm",
  /*  719 */  "salL_rReg_CL",
  /*  720 */  "salL_mem_CL",
  /*  721 */  "sarL_rReg_1",
  /*  722 */  "sarL_mem_1",
  /*  723 */  "sarL_rReg_imm",
  /*  724 */  "sarL_mem_imm",
  /*  725 */  "sarL_rReg_CL",
  /*  726 */  "sarL_mem_CL",
  /*  727 */  "shrL_rReg_1",
  /*  728 */  "shrL_mem_1",
  /*  729 */  "shrL_rReg_imm",
  /*  730 */  "shrL_mem_imm",
  /*  731 */  "shrL_rReg_CL",
  /*  732 */  "shrL_mem_CL",
  /*  733 */  "i2b",
  /*  734 */  "i2s",
  /*  735 */  "rolI_rReg_imm1",
  /*  736 */  "rolI_rReg_imm8",
  /*  737 */  "rolI_rReg_CL",
  /*  738 */  "rolI_rReg_i1",
  /*  739 */  "rolI_rReg_i1_0",
  /*  740 */  "rolI_rReg_i8",
  /*  741 */  "rolI_rReg_i8_0",
  /*  742 */  "rolI_rReg_Var_C0",
  /*  743 */  "rolI_rReg_Var_C0_0",
  /*  744 */  "rolI_rReg_Var_C32",
  /*  745 */  "rolI_rReg_Var_C32_0",
  /*  746 */  "rorI_rReg_imm1",
  /*  747 */  "rorI_rReg_imm8",
  /*  748 */  "rorI_rReg_CL",
  /*  749 */  "rorI_rReg_i1",
  /*  750 */  "rorI_rReg_i1_0",
  /*  751 */  "rorI_rReg_i8",
  /*  752 */  "rorI_rReg_i8_0",
  /*  753 */  "rorI_rReg_Var_C0",
  /*  754 */  "rorI_rReg_Var_C0_0",
  /*  755 */  "rorI_rReg_Var_C32",
  /*  756 */  "rorI_rReg_Var_C32_0",
  /*  757 */  "rolL_rReg_imm1",
  /*  758 */  "rolL_rReg_imm8",
  /*  759 */  "rolL_rReg_CL",
  /*  760 */  "rolL_rReg_i1",
  /*  761 */  "rolL_rReg_i1_0",
  /*  762 */  "rolL_rReg_i8",
  /*  763 */  "rolL_rReg_i8_0",
  /*  764 */  "rolL_rReg_Var_C0",
  /*  765 */  "rolL_rReg_Var_C0_0",
  /*  766 */  "rolL_rReg_Var_C64",
  /*  767 */  "rolL_rReg_Var_C64_0",
  /*  768 */  "rorL_rReg_imm1",
  /*  769 */  "rorL_rReg_imm8",
  /*  770 */  "rorL_rReg_CL",
  /*  771 */  "rorL_rReg_i1",
  /*  772 */  "rorL_rReg_i1_0",
  /*  773 */  "rorL_rReg_i8",
  /*  774 */  "rorL_rReg_i8_0",
  /*  775 */  "rorL_rReg_Var_C0",
  /*  776 */  "rorL_rReg_Var_C0_0",
  /*  777 */  "rorL_rReg_Var_C64",
  /*  778 */  "rorL_rReg_Var_C64_0",
  /*  779 */  "andI_rReg",
  /*  780 */  "andI_rReg_imm255",
  /*  781 */  "andI2L_rReg_imm255",
  /*  782 */  "andI_rReg_imm65535",
  /*  783 */  "andI2L_rReg_imm65535",
  /*  784 */  "andI_rReg_imm",
  /*  785 */  "andI_rReg_mem",
  /*  786 */  "andI_rReg_mem_0",
  /*  787 */  "andI_mem_rReg",
  /*  788 */  "andI_mem_rReg_0",
  /*  789 */  "andI_mem_imm",
  /*  790 */  "andnI_rReg_rReg_mem",
  /*  791 */  "andnI_rReg_rReg_mem_0",
  /*  792 */  "andnI_rReg_rReg_rReg",
  /*  793 */  "andnI_rReg_rReg_rReg_0",
  /*  794 */  "blsiI_rReg_rReg",
  /*  795 */  "blsiI_rReg_rReg_0",
  /*  796 */  "blsiI_rReg_mem",
  /*  797 */  "blsiI_rReg_mem_0",
  /*  798 */  "blsmskI_rReg_mem",
  /*  799 */  "blsmskI_rReg_mem_0",
  /*  800 */  "blsmskI_rReg_rReg",
  /*  801 */  "blsmskI_rReg_rReg_0",
  /*  802 */  "blsrI_rReg_rReg",
  /*  803 */  "blsrI_rReg_rReg_0",
  /*  804 */  "blsrI_rReg_mem",
  /*  805 */  "blsrI_rReg_mem_0",
  /*  806 */  "orI_rReg",
  /*  807 */  "orI_rReg_imm",
  /*  808 */  "orI_rReg_mem",
  /*  809 */  "orI_rReg_mem_0",
  /*  810 */  "orI_mem_rReg",
  /*  811 */  "orI_mem_rReg_0",
  /*  812 */  "orI_mem_imm",
  /*  813 */  "xorI_rReg",
  /*  814 */  "xorI_rReg_im1",
  /*  815 */  "xorI_rReg_imm",
  /*  816 */  "xorI_rReg_mem",
  /*  817 */  "xorI_rReg_mem_0",
  /*  818 */  "xorI_mem_rReg",
  /*  819 */  "xorI_mem_rReg_0",
  /*  820 */  "xorI_mem_imm",
  /*  821 */  "andL_rReg",
  /*  822 */  "andL_rReg_imm255",
  /*  823 */  "andL_rReg_imm65535",
  /*  824 */  "andL_rReg_imm",
  /*  825 */  "andL_rReg_mem",
  /*  826 */  "andL_rReg_mem_0",
  /*  827 */  "andL_mem_rReg",
  /*  828 */  "andL_mem_rReg_0",
  /*  829 */  "andL_mem_imm",
  /*  830 */  "andnL_rReg_rReg_mem",
  /*  831 */  "andnL_rReg_rReg_mem_0",
  /*  832 */  "andnL_rReg_rReg_rReg",
  /*  833 */  "andnL_rReg_rReg_rReg_0",
  /*  834 */  "blsiL_rReg_rReg",
  /*  835 */  "blsiL_rReg_rReg_0",
  /*  836 */  "blsiL_rReg_mem",
  /*  837 */  "blsiL_rReg_mem_0",
  /*  838 */  "blsmskL_rReg_mem",
  /*  839 */  "blsmskL_rReg_mem_0",
  /*  840 */  "blsmskL_rReg_rReg",
  /*  841 */  "blsmskL_rReg_rReg_0",
  /*  842 */  "blsrL_rReg_rReg",
  /*  843 */  "blsrL_rReg_rReg_0",
  /*  844 */  "blsrL_rReg_mem",
  /*  845 */  "blsrL_rReg_mem_0",
  /*  846 */  "orL_rReg",
  /*  847 */  "orL_rReg_castP2X",
  /*  848 */  "orL_rReg_castP2X_0",
  /*  849 */  "orL_rReg_imm",
  /*  850 */  "orL_rReg_mem",
  /*  851 */  "orL_rReg_mem_0",
  /*  852 */  "orL_mem_rReg",
  /*  853 */  "orL_mem_rReg_0",
  /*  854 */  "orL_mem_imm",
  /*  855 */  "xorL_rReg",
  /*  856 */  "xorL_rReg_im1",
  /*  857 */  "xorL_rReg_imm",
  /*  858 */  "xorL_rReg_mem",
  /*  859 */  "xorL_rReg_mem_0",
  /*  860 */  "xorL_mem_rReg",
  /*  861 */  "xorL_mem_rReg_0",
  /*  862 */  "xorL_mem_imm",
  /*  863 */  "convI2B",
  /*  864 */  "convP2B",
  /*  865 */  "cmpLTMask",
  /*  866 */  "cmpLTMask0",
  /*  867 */  "cadd_cmpLTMask",
  /*  868 */  "cadd_cmpLTMask_1",
  /*  869 */  "cadd_cmpLTMask_0",
  /*  870 */  "cadd_cmpLTMask_2",
  /*  871 */  "and_cmpLTMask",
  /*  872 */  "and_cmpLTMask_0",
  /*  873 */  "cmpF_reg",
  /*  874 */  "cmpF_mem",
  /*  875 */  "cmpF_imm",
  /*  876 */  "cmpD_reg",
  /*  877 */  "cmpD_mem",
  /*  878 */  "cmpD_imm",
  /*  879 */  "convF2D_reg_reg",
  /*  880 */  "convF2D_reg_mem",
  /*  881 */  "convD2F_reg_reg",
  /*  882 */  "convD2F_reg_mem",
  /*  883 */  "convF2I_reg_reg",
  /*  884 */  "convF2L_reg_reg",
  /*  885 */  "convD2I_reg_reg",
  /*  886 */  "convD2L_reg_reg",
  /*  887 */  "convI2F_reg_reg",
  /*  888 */  "convI2F_reg_mem",
  /*  889 */  "convI2D_reg_reg",
  /*  890 */  "convI2D_reg_mem",
  /*  891 */  "convXI2F_reg",
  /*  892 */  "convXI2D_reg",
  /*  893 */  "convL2F_reg_reg",
  /*  894 */  "convL2F_reg_mem",
  /*  895 */  "convL2D_reg_reg",
  /*  896 */  "convL2D_reg_mem",
  /*  897 */  "convI2L_reg_reg",
  /*  898 */  "convI2L_reg_reg_zex",
  /*  899 */  "convI2L_reg_mem_zex",
  /*  900 */  "zerox_long_reg_reg",
  /*  901 */  "convL2I_reg_reg",
  /*  902 */  "MoveF2I_reg_stack",
  /*  903 */  "MoveI2F_reg_stack",
  /*  904 */  "MoveD2L_reg_stack",
  /*  905 */  "MoveL2D_reg_stack",
  /*  906 */  "rep_stos",
  /*  907 */  "rep_stos_large",
  /*  908 */  "string_compareL",
  /*  909 */  "string_compareU",
  /*  910 */  "string_compareLU",
  /*  911 */  "string_compareUL",
  /*  912 */  "string_indexof_conL",
  /*  913 */  "string_indexof_conU",
  /*  914 */  "string_indexof_conUL",
  /*  915 */  "string_indexofL",
  /*  916 */  "string_indexofU",
  /*  917 */  "string_indexofUL",
  /*  918 */  "string_indexofU_char",
  /*  919 */  "string_equals",
  /*  920 */  "array_equalsB",
  /*  921 */  "array_equalsC",
  /*  922 */  "has_negatives",
  /*  923 */  "string_compress",
  /*  924 */  "string_inflate",
  /*  925 */  "encode_iso_array",
  /*  926 */  "cmpL3_reg_reg",
  /*  927 */  "cmovI_reg_g",
  /*  928 */  "minI_rReg",
  /*  929 */  "cmovI_reg_l",
  /*  930 */  "maxI_rReg",
  /*  931 */  "jmpDir",
  /*  932 */  "jmpCon",
  /*  933 */  "jmpLoopEnd",
  /*  934 */  "jmpLoopEndU",
  /*  935 */  "jmpLoopEndUCF",
  /*  936 */  "jmpLoopEnd_and_restoreMask",
  /*  937 */  "jmpLoopEndU_and_restoreMask",
  /*  938 */  "jmpLoopEndUCF_and_restoreMask",
  /*  939 */  "jmpConU",
  /*  940 */  "jmpConUCF",
  /*  941 */  "jmpConUCF2",
  /*  942 */  "partialSubtypeCheck",
  /*  943 */  "jmpDir_short",
  /*  944 */  "jmpCon_short",
  /*  945 */  "jmpLoopEnd_short",
  /*  946 */  "jmpLoopEndU_short",
  /*  947 */  "jmpLoopEndUCF_short",
  /*  948 */  "jmpConU_short",
  /*  949 */  "jmpConUCF_short",
  /*  950 */  "jmpConUCF2_short",
  /*  951 */  "safePoint_poll_far",
  /*  952 */  "safePoint_poll_tls",
  /*  953 */  "CallStaticJavaDirect",
  /*  954 */  "CallDynamicJavaDirect",
  /*  955 */  "CallRuntimeDirect",
  /*  956 */  "CallLeafDirect",
  /*  957 */  "CallLeafNoFPDirect",
  /*  958 */  "Ret",
  /*  959 */  "TailCalljmpInd",
  /*  960 */  "tailjmpInd",
  /*  961 */  "CreateException",
  /*  962 */  "RethrowException",
  /*  963 */  "loadBarrierSlowRegNoVec",
  /*  964 */  "loadBarrierSlowRegXmmAndYmm",
  /*  965 */  "loadBarrierSlowRegZmm",
  /*  966 */  "loadBarrierWeakSlowRegNoVec",
  /*  967 */  "loadBarrierWeakSlowRegXmmAndYmm",
  /*  968 */  "loadBarrierWeakSlowRegZmm",
  /*  969 */  "ShouldNotReachHere",
  /*  970 */  "setMask",
  /*  971 */  "addF_reg",
  /*  972 */  "addF_mem",
  /*  973 */  "addF_mem_0",
  /*  974 */  "addF_imm",
  /*  975 */  "addF_reg_reg",
  /*  976 */  "addF_reg_mem",
  /*  977 */  "addF_reg_mem_0",
  /*  978 */  "addF_reg_imm",
  /*  979 */  "addD_reg",
  /*  980 */  "addD_mem",
  /*  981 */  "addD_mem_0",
  /*  982 */  "addD_imm",
  /*  983 */  "addD_reg_reg",
  /*  984 */  "addD_reg_mem",
  /*  985 */  "addD_reg_mem_0",
  /*  986 */  "addD_reg_imm",
  /*  987 */  "subF_reg",
  /*  988 */  "subF_mem",
  /*  989 */  "subF_imm",
  /*  990 */  "subF_reg_reg",
  /*  991 */  "subF_reg_mem",
  /*  992 */  "subF_reg_imm",
  /*  993 */  "subD_reg",
  /*  994 */  "subD_mem",
  /*  995 */  "subD_imm",
  /*  996 */  "subD_reg_reg",
  /*  997 */  "subD_reg_mem",
  /*  998 */  "subD_reg_imm",
  /*  999 */  "mulF_reg",
  /* 1000 */  "mulF_mem",
  /* 1001 */  "mulF_mem_0",
  /* 1002 */  "mulF_imm",
  /* 1003 */  "mulF_reg_reg",
  /* 1004 */  "mulF_reg_mem",
  /* 1005 */  "mulF_reg_mem_0",
  /* 1006 */  "mulF_reg_imm",
  /* 1007 */  "mulD_reg",
  /* 1008 */  "mulD_mem",
  /* 1009 */  "mulD_mem_0",
  /* 1010 */  "mulD_imm",
  /* 1011 */  "mulD_reg_reg",
  /* 1012 */  "mulD_reg_mem",
  /* 1013 */  "mulD_reg_mem_0",
  /* 1014 */  "mulD_reg_imm",
  /* 1015 */  "divF_reg",
  /* 1016 */  "divF_mem",
  /* 1017 */  "divF_imm",
  /* 1018 */  "divF_reg_reg",
  /* 1019 */  "divF_reg_mem",
  /* 1020 */  "divF_reg_imm",
  /* 1021 */  "divD_reg",
  /* 1022 */  "divD_mem",
  /* 1023 */  "divD_imm",
  /* 1024 */  "divD_reg_reg",
  /* 1025 */  "divD_reg_mem",
  /* 1026 */  "divD_reg_imm",
  /* 1027 */  "absF_reg_reg_evex_special",
  /* 1028 */  "absD_reg_reg_evex_special",
  /* 1029 */  "sqrtF_reg",
  /* 1030 */  "sqrtF_mem",
  /* 1031 */  "sqrtF_imm",
  /* 1032 */  "sqrtD_reg",
  /* 1033 */  "sqrtD_mem",
  /* 1034 */  "sqrtD_imm",
  /* 1035 */  "onspinwait",
  /* 1036 */  "fmaD_reg",
  /* 1037 */  "fmaF_reg",
  /* 1038 */  "loadV4",
  /* 1039 */  "loadV8",
  /* 1040 */  "loadV16",
  /* 1041 */  "loadV32",
  /* 1042 */  "loadV64_dword",
  /* 1043 */  "loadV64_qword",
  /* 1044 */  "storeV4",
  /* 1045 */  "storeV8",
  /* 1046 */  "storeV16",
  /* 1047 */  "storeV32",
  /* 1048 */  "storeV64_dword",
  /* 1049 */  "storeV64_qword",
  /* 1050 */  "Repl4B_mem",
  /* 1051 */  "Repl8B_mem",
  /* 1052 */  "Repl16B",
  /* 1053 */  "Repl16B_mem",
  /* 1054 */  "Repl32B",
  /* 1055 */  "Repl32B_mem",
  /* 1056 */  "Repl16B_imm",
  /* 1057 */  "Repl32B_imm",
  /* 1058 */  "Repl4S",
  /* 1059 */  "Repl4S_mem",
  /* 1060 */  "Repl8S",
  /* 1061 */  "Repl8S_mem",
  /* 1062 */  "Repl8S_imm",
  /* 1063 */  "Repl16S",
  /* 1064 */  "Repl16S_mem",
  /* 1065 */  "Repl16S_imm",
  /* 1066 */  "Repl4I",
  /* 1067 */  "Repl4I_mem",
  /* 1068 */  "Repl8I",
  /* 1069 */  "Repl8I_mem",
  /* 1070 */  "Repl4I_imm",
  /* 1071 */  "Repl8I_imm",
  /* 1072 */  "Repl2L_mem",
  /* 1073 */  "Repl4L",
  /* 1074 */  "Repl4L_imm",
  /* 1075 */  "Repl4L_mem",
  /* 1076 */  "Repl2F_mem",
  /* 1077 */  "Repl4F_mem",
  /* 1078 */  "Repl8F",
  /* 1079 */  "Repl8F_mem",
  /* 1080 */  "Repl2F_zero",
  /* 1081 */  "Repl4F_zero",
  /* 1082 */  "Repl8F_zero",
  /* 1083 */  "Repl2D_mem",
  /* 1084 */  "Repl4D",
  /* 1085 */  "Repl4D_mem",
  /* 1086 */  "Repl2D_zero",
  /* 1087 */  "Repl4D_zero",
  /* 1088 */  "Repl4B",
  /* 1089 */  "Repl8B",
  /* 1090 */  "Repl4B_imm",
  /* 1091 */  "Repl8B_imm",
  /* 1092 */  "Repl4B_zero",
  /* 1093 */  "Repl8B_zero",
  /* 1094 */  "Repl16B_zero",
  /* 1095 */  "Repl32B_zero",
  /* 1096 */  "Repl2S",
  /* 1097 */  "Repl2S_imm",
  /* 1098 */  "Repl4S_imm",
  /* 1099 */  "Repl2S_zero",
  /* 1100 */  "Repl4S_zero",
  /* 1101 */  "Repl8S_zero",
  /* 1102 */  "Repl16S_zero",
  /* 1103 */  "Repl2I",
  /* 1104 */  "Repl2I_mem",
  /* 1105 */  "Repl2I_imm",
  /* 1106 */  "Repl2I_zero",
  /* 1107 */  "Repl4I_zero",
  /* 1108 */  "Repl8I_zero",
  /* 1109 */  "Repl2L",
  /* 1110 */  "Repl2L_imm",
  /* 1111 */  "Repl2L_zero",
  /* 1112 */  "Repl4L_zero",
  /* 1113 */  "Repl2F",
  /* 1114 */  "Repl4F",
  /* 1115 */  "Repl2D",
  /* 1116 */  "Repl4B_mem_evex",
  /* 1117 */  "Repl8B_mem_evex",
  /* 1118 */  "Repl16B_evex",
  /* 1119 */  "Repl16B_mem_evex",
  /* 1120 */  "Repl32B_evex",
  /* 1121 */  "Repl32B_mem_evex",
  /* 1122 */  "Repl64B_evex",
  /* 1123 */  "Repl64B_mem_evex",
  /* 1124 */  "Repl16B_imm_evex",
  /* 1125 */  "Repl32B_imm_evex",
  /* 1126 */  "Repl64B_imm_evex",
  /* 1127 */  "Repl64B_zero_evex",
  /* 1128 */  "Repl4S_evex",
  /* 1129 */  "Repl4S_mem_evex",
  /* 1130 */  "Repl8S_evex",
  /* 1131 */  "Repl8S_mem_evex",
  /* 1132 */  "Repl16S_evex",
  /* 1133 */  "Repl16S_mem_evex",
  /* 1134 */  "Repl32S_evex",
  /* 1135 */  "Repl32S_mem_evex",
  /* 1136 */  "Repl8S_imm_evex",
  /* 1137 */  "Repl16S_imm_evex",
  /* 1138 */  "Repl32S_imm_evex",
  /* 1139 */  "Repl32S_zero_evex",
  /* 1140 */  "Repl4I_evex",
  /* 1141 */  "Repl4I_mem_evex",
  /* 1142 */  "Repl8I_evex",
  /* 1143 */  "Repl8I_mem_evex",
  /* 1144 */  "Repl16I_evex",
  /* 1145 */  "Repl16I_mem_evex",
  /* 1146 */  "Repl4I_imm_evex",
  /* 1147 */  "Repl8I_imm_evex",
  /* 1148 */  "Repl16I_imm_evex",
  /* 1149 */  "Repl16I_zero_evex",
  /* 1150 */  "Repl4L_evex",
  /* 1151 */  "Repl8L_evex",
  /* 1152 */  "Repl4L_imm_evex",
  /* 1153 */  "Repl8L_imm_evex",
  /* 1154 */  "Repl2L_mem_evex",
  /* 1155 */  "Repl4L_mem_evex",
  /* 1156 */  "Repl8L_mem_evex",
  /* 1157 */  "Repl8L_zero_evex",
  /* 1158 */  "Repl8F_evex",
  /* 1159 */  "Repl8F_mem_evex",
  /* 1160 */  "Repl16F_evex",
  /* 1161 */  "Repl16F_mem_evex",
  /* 1162 */  "Repl2F_zero_evex",
  /* 1163 */  "Repl4F_zero_evex",
  /* 1164 */  "Repl8F_zero_evex",
  /* 1165 */  "Repl16F_zero_evex",
  /* 1166 */  "Repl4D_evex",
  /* 1167 */  "Repl4D_mem_evex",
  /* 1168 */  "Repl8D_evex",
  /* 1169 */  "Repl8D_mem_evex",
  /* 1170 */  "Repl2D_zero_evex",
  /* 1171 */  "Repl4D_zero_evex",
  /* 1172 */  "Repl8D_zero_evex",
  /* 1173 */  "rsadd2I_reduction_reg",
  /* 1174 */  "rvadd2I_reduction_reg",
  /* 1175 */  "rvadd2I_reduction_reg_evex",
  /* 1176 */  "rsadd4I_reduction_reg",
  /* 1177 */  "rvadd4I_reduction_reg",
  /* 1178 */  "rvadd4I_reduction_reg_evex",
  /* 1179 */  "rvadd8I_reduction_reg",
  /* 1180 */  "rvadd8I_reduction_reg_evex",
  /* 1181 */  "rvadd16I_reduction_reg_evex",
  /* 1182 */  "rvadd2L_reduction_reg",
  /* 1183 */  "rvadd4L_reduction_reg",
  /* 1184 */  "rvadd8L_reduction_reg",
  /* 1185 */  "rsadd2F_reduction_reg",
  /* 1186 */  "rvadd2F_reduction_reg",
  /* 1187 */  "rsadd4F_reduction_reg",
  /* 1188 */  "rvadd4F_reduction_reg",
  /* 1189 */  "radd8F_reduction_reg",
  /* 1190 */  "radd16F_reduction_reg",
  /* 1191 */  "rsadd2D_reduction_reg",
  /* 1192 */  "rvadd2D_reduction_reg",
  /* 1193 */  "rvadd4D_reduction_reg",
  /* 1194 */  "rvadd8D_reduction_reg",
  /* 1195 */  "rsmul2I_reduction_reg",
  /* 1196 */  "rvmul2I_reduction_reg",
  /* 1197 */  "rsmul4I_reduction_reg",
  /* 1198 */  "rvmul4I_reduction_reg",
  /* 1199 */  "rvmul8I_reduction_reg",
  /* 1200 */  "rvmul16I_reduction_reg",
  /* 1201 */  "rvmul2L_reduction_reg",
  /* 1202 */  "rvmul4L_reduction_reg",
  /* 1203 */  "rvmul8L_reduction_reg",
  /* 1204 */  "rsmul2F_reduction",
  /* 1205 */  "rvmul2F_reduction_reg",
  /* 1206 */  "rsmul4F_reduction_reg",
  /* 1207 */  "rvmul4F_reduction_reg",
  /* 1208 */  "rvmul8F_reduction_reg",
  /* 1209 */  "rvmul16F_reduction_reg",
  /* 1210 */  "rsmul2D_reduction_reg",
  /* 1211 */  "rvmul2D_reduction_reg",
  /* 1212 */  "rvmul4D_reduction_reg",
  /* 1213 */  "rvmul8D_reduction_reg",
  /* 1214 */  "vadd4B",
  /* 1215 */  "vadd4B_reg_avx",
  /* 1216 */  "vadd4B_reg_evex",
  /* 1217 */  "vadd4B_reg_evex_special",
  /* 1218 */  "vadd4B_mem_avx",
  /* 1219 */  "vadd4B_mem_avx_0",
  /* 1220 */  "vadd4B_mem_evex",
  /* 1221 */  "vadd4B_mem_evex_0",
  /* 1222 */  "vadd4B_mem_evex_special",
  /* 1223 */  "vadd4B_mem_evex_special_0",
  /* 1224 */  "vadd8B",
  /* 1225 */  "vadd8B_reg_avx",
  /* 1226 */  "vadd8B_reg_evex",
  /* 1227 */  "vadd8B_reg_evex_special",
  /* 1228 */  "vadd8B_mem_avx",
  /* 1229 */  "vadd8B_mem_avx_0",
  /* 1230 */  "vadd8B_mem_evex",
  /* 1231 */  "vadd8B_mem_evex_0",
  /* 1232 */  "vadd8B_mem_evex_special",
  /* 1233 */  "vadd8B_mem_evex_special_0",
  /* 1234 */  "vadd16B",
  /* 1235 */  "vadd16B_reg_avx",
  /* 1236 */  "vadd16B_reg_evex",
  /* 1237 */  "vadd16B_reg_evex_special",
  /* 1238 */  "vadd16B_mem_avx",
  /* 1239 */  "vadd16B_mem_avx_0",
  /* 1240 */  "vadd16B_mem_evex",
  /* 1241 */  "vadd16B_mem_evex_0",
  /* 1242 */  "vadd16B_mem_evex_special",
  /* 1243 */  "vadd16B_mem_evex_special_0",
  /* 1244 */  "vadd32B_reg_avx",
  /* 1245 */  "vadd32B_reg_evex",
  /* 1246 */  "vadd32B_reg_evex_special",
  /* 1247 */  "vadd32B_mem_avx",
  /* 1248 */  "vadd32B_mem_avx_0",
  /* 1249 */  "vadd32B_mem_evex",
  /* 1250 */  "vadd32B_mem_evex_0",
  /* 1251 */  "vadd32B_mem_evex_special",
  /* 1252 */  "vadd32B_mem_evex_special_0",
  /* 1253 */  "vadd64B_reg",
  /* 1254 */  "vadd64B_mem",
  /* 1255 */  "vadd64B_mem_0",
  /* 1256 */  "vadd2S",
  /* 1257 */  "vadd2S_reg_avx",
  /* 1258 */  "vadd2S_reg_evex",
  /* 1259 */  "vadd2S_reg_evex_special",
  /* 1260 */  "vadd2S_mem_avx",
  /* 1261 */  "vadd2S_mem_avx_0",
  /* 1262 */  "vadd2S_mem_evex",
  /* 1263 */  "vadd2S_mem_evex_0",
  /* 1264 */  "vadd2S_mem_evex_special",
  /* 1265 */  "vadd2S_mem_evex_special_0",
  /* 1266 */  "vadd4S",
  /* 1267 */  "vadd4S_reg_avx",
  /* 1268 */  "vadd4S_reg_evex",
  /* 1269 */  "vadd4S_reg_evex_special",
  /* 1270 */  "vadd4S_mem_avx",
  /* 1271 */  "vadd4S_mem_avx_0",
  /* 1272 */  "vadd4S_mem_evex",
  /* 1273 */  "vadd4S_mem_evex_0",
  /* 1274 */  "vadd4S_mem_evex_special",
  /* 1275 */  "vadd4S_mem_evex_special_0",
  /* 1276 */  "vadd8S",
  /* 1277 */  "vadd8S_reg_avx",
  /* 1278 */  "vadd8S_reg_evex",
  /* 1279 */  "vadd8S_reg_evex_special",
  /* 1280 */  "vadd8S_mem_avx",
  /* 1281 */  "vadd8S_mem_avx_0",
  /* 1282 */  "vadd8S_mem_evex",
  /* 1283 */  "vadd8S_mem_evex_0",
  /* 1284 */  "vadd8S_mem_evex_special",
  /* 1285 */  "vadd8S_mem_evex_special_0",
  /* 1286 */  "vadd16S_reg_avx",
  /* 1287 */  "vadd16S_reg_evex",
  /* 1288 */  "vadd16S_reg_evex_special",
  /* 1289 */  "vadd16S_mem_avx",
  /* 1290 */  "vadd16S_mem_avx_0",
  /* 1291 */  "vadd16S_mem_evex",
  /* 1292 */  "vadd16S_mem_evex_0",
  /* 1293 */  "vadd16S_mem_evex_special",
  /* 1294 */  "vadd16S_mem_evex_special_0",
  /* 1295 */  "vadd32S_reg",
  /* 1296 */  "vadd32S_mem",
  /* 1297 */  "vadd32S_mem_0",
  /* 1298 */  "vadd2I",
  /* 1299 */  "vadd2I_reg",
  /* 1300 */  "vadd2I_mem",
  /* 1301 */  "vadd2I_mem_0",
  /* 1302 */  "vadd4I",
  /* 1303 */  "vadd4I_reg",
  /* 1304 */  "vadd4I_mem",
  /* 1305 */  "vadd4I_mem_0",
  /* 1306 */  "vadd8I_reg",
  /* 1307 */  "vadd8I_mem",
  /* 1308 */  "vadd8I_mem_0",
  /* 1309 */  "vadd16I_reg",
  /* 1310 */  "vadd16I_mem",
  /* 1311 */  "vadd16I_mem_0",
  /* 1312 */  "vadd2L",
  /* 1313 */  "vadd2L_reg",
  /* 1314 */  "vadd2L_mem",
  /* 1315 */  "vadd2L_mem_0",
  /* 1316 */  "vadd4L_reg",
  /* 1317 */  "vadd4L_mem",
  /* 1318 */  "vadd4L_mem_0",
  /* 1319 */  "vadd8L_reg",
  /* 1320 */  "vadd8L_mem",
  /* 1321 */  "vadd8L_mem_0",
  /* 1322 */  "vadd2F",
  /* 1323 */  "vadd2F_reg",
  /* 1324 */  "vadd2F_mem",
  /* 1325 */  "vadd2F_mem_0",
  /* 1326 */  "vadd4F",
  /* 1327 */  "vadd4F_reg",
  /* 1328 */  "vadd4F_mem",
  /* 1329 */  "vadd4F_mem_0",
  /* 1330 */  "vadd8F_reg",
  /* 1331 */  "vadd8F_mem",
  /* 1332 */  "vadd8F_mem_0",
  /* 1333 */  "vadd16F_reg",
  /* 1334 */  "vadd16F_mem",
  /* 1335 */  "vadd16F_mem_0",
  /* 1336 */  "vadd2D",
  /* 1337 */  "vadd2D_reg",
  /* 1338 */  "vadd2D_mem",
  /* 1339 */  "vadd2D_mem_0",
  /* 1340 */  "vadd4D_reg",
  /* 1341 */  "vadd4D_mem",
  /* 1342 */  "vadd4D_mem_0",
  /* 1343 */  "vadd8D_reg",
  /* 1344 */  "vadd8D_mem",
  /* 1345 */  "vadd8D_mem_0",
  /* 1346 */  "vsub4B",
  /* 1347 */  "vsub4B_reg_avx",
  /* 1348 */  "vsub4B_reg_evex",
  /* 1349 */  "vsub4B_reg_exex_special",
  /* 1350 */  "vsub4B_mem_avx",
  /* 1351 */  "vsub4B_mem_evex",
  /* 1352 */  "vsub4B_mem_evex_special",
  /* 1353 */  "vsub8B",
  /* 1354 */  "vsub8B_reg_avx",
  /* 1355 */  "vsub8B_reg_evex",
  /* 1356 */  "vsub8B_reg_evex_special",
  /* 1357 */  "vsub8B_mem_avx",
  /* 1358 */  "vsub8B_mem_evex",
  /* 1359 */  "vsub8B_mem_evex_special",
  /* 1360 */  "vsub16B",
  /* 1361 */  "vsub16B_reg_avx",
  /* 1362 */  "vsub16B_reg_evex",
  /* 1363 */  "vsub16B_reg_evex_special",
  /* 1364 */  "vsub16B_mem_avx",
  /* 1365 */  "vsub16B_mem_evex",
  /* 1366 */  "vsub16B_mem_evex_special",
  /* 1367 */  "vsub32B_reg_avx",
  /* 1368 */  "vsub32B_reg_evex",
  /* 1369 */  "vsub32B_reg_evex_special",
  /* 1370 */  "vsub32B_mem_avx",
  /* 1371 */  "vsub32B_mem_evex",
  /* 1372 */  "vsub32B_mem_evex_special",
  /* 1373 */  "vsub64B_reg",
  /* 1374 */  "vsub64B_mem",
  /* 1375 */  "vsub2S",
  /* 1376 */  "vsub2S_reg_avx",
  /* 1377 */  "vsub2S_reg_evex",
  /* 1378 */  "vsub2S_reg_evex_special",
  /* 1379 */  "vsub2S_mem_avx",
  /* 1380 */  "vsub2S_mem_evex",
  /* 1381 */  "vsub2S_mem_evex_special",
  /* 1382 */  "vsub4S",
  /* 1383 */  "vsub4S_reg_avx",
  /* 1384 */  "vsub4S_reg_evex",
  /* 1385 */  "vsub4S_reg_evex_special",
  /* 1386 */  "vsub4S_mem_avx",
  /* 1387 */  "vsub4S_mem_evex",
  /* 1388 */  "vsub4S_mem_evex_special",
  /* 1389 */  "vsub8S",
  /* 1390 */  "vsub8S_reg_avx",
  /* 1391 */  "vsub8S_reg_evex",
  /* 1392 */  "vsub8S_reg_evex_special",
  /* 1393 */  "vsub8S_mem_avx",
  /* 1394 */  "vsub8S_mem_evex",
  /* 1395 */  "vsub8S_mem_evex_special",
  /* 1396 */  "vsub16S_reg_avx",
  /* 1397 */  "vsub16S_reg_evex",
  /* 1398 */  "vsub16S_reg_evex_special",
  /* 1399 */  "vsub16S_mem_avx",
  /* 1400 */  "vsub16S_mem_evex",
  /* 1401 */  "vsub16S_mem_evex_special",
  /* 1402 */  "vsub32S_reg",
  /* 1403 */  "vsub32S_mem",
  /* 1404 */  "vsub2I",
  /* 1405 */  "vsub2I_reg",
  /* 1406 */  "vsub2I_mem",
  /* 1407 */  "vsub4I",
  /* 1408 */  "vsub4I_reg",
  /* 1409 */  "vsub4I_mem",
  /* 1410 */  "vsub8I_reg",
  /* 1411 */  "vsub8I_mem",
  /* 1412 */  "vsub16I_reg",
  /* 1413 */  "vsub16I_mem",
  /* 1414 */  "vsub2L",
  /* 1415 */  "vsub2L_reg",
  /* 1416 */  "vsub2L_mem",
  /* 1417 */  "vsub4L_reg",
  /* 1418 */  "vsub4L_mem",
  /* 1419 */  "vsub8L_reg",
  /* 1420 */  "vsub8L_mem",
  /* 1421 */  "vsub2F",
  /* 1422 */  "vsub2F_reg",
  /* 1423 */  "vsub2F_mem",
  /* 1424 */  "vsub4F",
  /* 1425 */  "vsub4F_reg",
  /* 1426 */  "vsub4F_mem",
  /* 1427 */  "vsub8F_reg",
  /* 1428 */  "vsub8F_mem",
  /* 1429 */  "vsub16F_reg",
  /* 1430 */  "vsub16F_mem",
  /* 1431 */  "vsub2D",
  /* 1432 */  "vsub2D_reg",
  /* 1433 */  "vsub2D_mem",
  /* 1434 */  "vsub4D_reg",
  /* 1435 */  "vsub4D_mem",
  /* 1436 */  "vsub8D_reg",
  /* 1437 */  "vsub8D_mem",
  /* 1438 */  "vmul2S",
  /* 1439 */  "vmul2S_reg_avx",
  /* 1440 */  "vmul2S_reg_evex",
  /* 1441 */  "vmul2S_evex_special",
  /* 1442 */  "vmul2S_mem_avx",
  /* 1443 */  "vmul2S_mem_avx_0",
  /* 1444 */  "vmul2S_mem_evex",
  /* 1445 */  "vmul2S_mem_evex_0",
  /* 1446 */  "vmul2S_mem_evex_special",
  /* 1447 */  "vmul2S_mem_evex_special_0",
  /* 1448 */  "vmul4S",
  /* 1449 */  "vmul4S_reg_avx",
  /* 1450 */  "vmul4S_reg_evex",
  /* 1451 */  "vmul4S_reg_evex_special",
  /* 1452 */  "vmul4S_mem_avx",
  /* 1453 */  "vmul4S_mem_avx_0",
  /* 1454 */  "vmul4S_mem_evex",
  /* 1455 */  "vmul4S_mem_evex_0",
  /* 1456 */  "vmul4S_mem_evex_special",
  /* 1457 */  "vmul4S_mem_evex_special_0",
  /* 1458 */  "vmul8S",
  /* 1459 */  "vmul8S_reg_avx",
  /* 1460 */  "vmul8S_reg_evex",
  /* 1461 */  "vmul8S_reg_evex_special",
  /* 1462 */  "vmul8S_mem_avx",
  /* 1463 */  "vmul8S_mem_avx_0",
  /* 1464 */  "vmul8S_mem_evex",
  /* 1465 */  "vmul8S_mem_evex_0",
  /* 1466 */  "vmul8S_mem_evex_special",
  /* 1467 */  "vmul8S_mem_evex_special_0",
  /* 1468 */  "vmul16S_reg_avx",
  /* 1469 */  "vmul16S_reg_evex",
  /* 1470 */  "vmul16S_reg_evex_special",
  /* 1471 */  "vmul16S_mem_avx",
  /* 1472 */  "vmul16S_mem_avx_0",
  /* 1473 */  "vmul16S_mem_evex",
  /* 1474 */  "vmul16S_mem_evex_0",
  /* 1475 */  "vmul16S_mem_evex_special",
  /* 1476 */  "vmul16S_mem_evex_special_0",
  /* 1477 */  "vmul32S_reg",
  /* 1478 */  "vmul32S_mem",
  /* 1479 */  "vmul32S_mem_0",
  /* 1480 */  "vmul2I",
  /* 1481 */  "vmul2I_reg",
  /* 1482 */  "vmul2I_mem",
  /* 1483 */  "vmul2I_mem_0",
  /* 1484 */  "vmul4I",
  /* 1485 */  "vmul4I_reg",
  /* 1486 */  "vmul4I_mem",
  /* 1487 */  "vmul4I_mem_0",
  /* 1488 */  "vmul2L_reg",
  /* 1489 */  "vmul2L_mem",
  /* 1490 */  "vmul2L_mem_0",
  /* 1491 */  "vmul4L_reg",
  /* 1492 */  "vmul4L_mem",
  /* 1493 */  "vmul4L_mem_0",
  /* 1494 */  "vmul8L_reg",
  /* 1495 */  "vmul8L_mem",
  /* 1496 */  "vmul8L_mem_0",
  /* 1497 */  "vmul8I_reg",
  /* 1498 */  "vmul8I_mem",
  /* 1499 */  "vmul8I_mem_0",
  /* 1500 */  "vmul16I_reg",
  /* 1501 */  "vmul16I_mem",
  /* 1502 */  "vmul16I_mem_0",
  /* 1503 */  "vmul2F",
  /* 1504 */  "vmul2F_reg",
  /* 1505 */  "vmul2F_mem",
  /* 1506 */  "vmul2F_mem_0",
  /* 1507 */  "vmul4F",
  /* 1508 */  "vmul4F_reg",
  /* 1509 */  "vmul4F_mem",
  /* 1510 */  "vmul4F_mem_0",
  /* 1511 */  "vmul8F_reg",
  /* 1512 */  "vmul8F_mem",
  /* 1513 */  "vmul8F_mem_0",
  /* 1514 */  "vmul16F_reg",
  /* 1515 */  "vmul16F_mem",
  /* 1516 */  "vmul16F_mem_0",
  /* 1517 */  "vmul2D",
  /* 1518 */  "vmul2D_reg",
  /* 1519 */  "vmul2D_mem",
  /* 1520 */  "vmul2D_mem_0",
  /* 1521 */  "vmul4D_reg",
  /* 1522 */  "vmul4D_mem",
  /* 1523 */  "vmul4D_mem_0",
  /* 1524 */  "vmul8D_reg",
  /* 1525 */  "vmul8D_mem",
  /* 1526 */  "vmul8D_mem_0",
  /* 1527 */  "vcmov8F_reg",
  /* 1528 */  "vcmov4D_reg",
  /* 1529 */  "vdiv2F",
  /* 1530 */  "vdiv2F_reg",
  /* 1531 */  "vdiv2F_mem",
  /* 1532 */  "vdiv4F",
  /* 1533 */  "vdiv4F_reg",
  /* 1534 */  "vdiv4F_mem",
  /* 1535 */  "vdiv8F_reg",
  /* 1536 */  "vdiv8F_mem",
  /* 1537 */  "vdiv16F_reg",
  /* 1538 */  "vdiv16F_mem",
  /* 1539 */  "vdiv2D",
  /* 1540 */  "vdiv2D_reg",
  /* 1541 */  "vdiv2D_mem",
  /* 1542 */  "vdiv4D_reg",
  /* 1543 */  "vdiv4D_mem",
  /* 1544 */  "vdiv8D_reg",
  /* 1545 */  "vdiv8D_mem",
  /* 1546 */  "vsll2S",
  /* 1547 */  "vsll2S_imm",
  /* 1548 */  "vsll2S_reg_avx",
  /* 1549 */  "vsll2S_reg_evex",
  /* 1550 */  "vsll2S_reg_evex_special",
  /* 1551 */  "vsll2S_reg_imm_avx",
  /* 1552 */  "vsll2S_reg_imm_evex",
  /* 1553 */  "vsll2S_reg_imm_evex_special",
  /* 1554 */  "vsll4S",
  /* 1555 */  "vsll4S_imm",
  /* 1556 */  "vsll4S_reg_avx",
  /* 1557 */  "vsll4S_reg_evex",
  /* 1558 */  "vsll4S_reg_evex_special",
  /* 1559 */  "vsll4S_reg_imm_avx",
  /* 1560 */  "vsll4S_reg_imm_evex",
  /* 1561 */  "vsll4S_reg_imm_evex_special",
  /* 1562 */  "vsll8S",
  /* 1563 */  "vsll8S_imm",
  /* 1564 */  "vsll8S_reg_avx",
  /* 1565 */  "vsll8S_reg_evex",
  /* 1566 */  "vsll8S_reg_evex_special",
  /* 1567 */  "vsll8S_reg_imm_avx",
  /* 1568 */  "vsll8S_reg_imm_evex",
  /* 1569 */  "vsll8S_reg_imm_evex_special",
  /* 1570 */  "vsll16S_reg_avx",
  /* 1571 */  "vsll16S_reg_evex",
  /* 1572 */  "vsll16S_reg_evex_special",
  /* 1573 */  "vsll16S_reg_imm_avx",
  /* 1574 */  "vsll16S_reg_imm_evex",
  /* 1575 */  "vsll16S_reg_imm_evex_special",
  /* 1576 */  "vsll32S_reg",
  /* 1577 */  "vsll32S_reg_imm",
  /* 1578 */  "vsll2I",
  /* 1579 */  "vsll2I_imm",
  /* 1580 */  "vsll2I_reg",
  /* 1581 */  "vsll2I_reg_imm",
  /* 1582 */  "vsll4I",
  /* 1583 */  "vsll4I_imm",
  /* 1584 */  "vsll4I_reg",
  /* 1585 */  "vsll4I_reg_imm",
  /* 1586 */  "vsll8I_reg",
  /* 1587 */  "vsll8I_reg_imm",
  /* 1588 */  "vsll16I_reg",
  /* 1589 */  "vsll16I_reg_imm",
  /* 1590 */  "vsll2L",
  /* 1591 */  "vsll2L_imm",
  /* 1592 */  "vsll2L_reg",
  /* 1593 */  "vsll2L_reg_imm",
  /* 1594 */  "vsll4L_reg",
  /* 1595 */  "vsll4L_reg_imm",
  /* 1596 */  "vsll8L_reg",
  /* 1597 */  "vsll8L_reg_imm",
  /* 1598 */  "vsrl2S",
  /* 1599 */  "vsrl2S_imm",
  /* 1600 */  "vsrl2S_reg_avx",
  /* 1601 */  "vsrl2S_reg_evex",
  /* 1602 */  "vsrl2S_reg_evex_special",
  /* 1603 */  "vsrl2S_reg_imm_avx",
  /* 1604 */  "vsrl2S_reg_imm_evex",
  /* 1605 */  "vsrl2S_reg_imm_evex_special",
  /* 1606 */  "vsrl4S",
  /* 1607 */  "vsrl4S_imm",
  /* 1608 */  "vsrl4S_reg_avx",
  /* 1609 */  "vsrl4S_reg_evex",
  /* 1610 */  "vsrl4S_reg_evex_special",
  /* 1611 */  "vsrl4S_reg_imm_avx",
  /* 1612 */  "vsrl4S_reg_imm_evex",
  /* 1613 */  "vsrl4S_reg_imm_evex_special",
  /* 1614 */  "vsrl8S",
  /* 1615 */  "vsrl8S_imm",
  /* 1616 */  "vsrl8S_reg_avx",
  /* 1617 */  "vsrl8S_reg_evex",
  /* 1618 */  "vsrl8S_reg_evex_special",
  /* 1619 */  "vsrl8S_reg_imm_avx",
  /* 1620 */  "vsrl8S_reg_imm_evex",
  /* 1621 */  "vsrl8S_reg_imm_evex_special",
  /* 1622 */  "vsrl16S_reg_avx",
  /* 1623 */  "vsrl16S_reg_evex",
  /* 1624 */  "vsrl16S_reg_evex_special",
  /* 1625 */  "vsrl16S_reg_imm_avx",
  /* 1626 */  "vsrl16S_reg_imm_evex",
  /* 1627 */  "vsrl16S_reg_imm_evex_special",
  /* 1628 */  "vsrl32S_reg",
  /* 1629 */  "vsrl32S_reg_imm",
  /* 1630 */  "vsrl2I",
  /* 1631 */  "vsrl2I_imm",
  /* 1632 */  "vsrl2I_reg",
  /* 1633 */  "vsrl2I_reg_imm",
  /* 1634 */  "vsrl4I",
  /* 1635 */  "vsrl4I_imm",
  /* 1636 */  "vsrl4I_reg",
  /* 1637 */  "vsrl4I_reg_imm",
  /* 1638 */  "vsrl8I_reg",
  /* 1639 */  "vsrl8I_reg_imm",
  /* 1640 */  "vsrl16I_reg",
  /* 1641 */  "vsrl16I_reg_imm",
  /* 1642 */  "vsrl2L",
  /* 1643 */  "vsrl2L_imm",
  /* 1644 */  "vsrl2L_reg",
  /* 1645 */  "vsrl2L_reg_imm",
  /* 1646 */  "vsrl4L_reg",
  /* 1647 */  "vsrl4L_reg_imm",
  /* 1648 */  "vsrl8L_reg",
  /* 1649 */  "vsrl8L_reg_imm",
  /* 1650 */  "vsra2S",
  /* 1651 */  "vsra2S_imm",
  /* 1652 */  "vsra2S_reg_avx",
  /* 1653 */  "vsra2S_reg_evex",
  /* 1654 */  "vsra2S_reg_evex_special",
  /* 1655 */  "vsra2S_reg_imm_avx",
  /* 1656 */  "vsra2S_reg_imm_evex",
  /* 1657 */  "vsra2S_reg_imm_evex_special",
  /* 1658 */  "vsra4S",
  /* 1659 */  "vsra4S_imm",
  /* 1660 */  "vsra4S_reg_avx",
  /* 1661 */  "vsra4S_reg_evex",
  /* 1662 */  "vsra4S_reg_evex_special",
  /* 1663 */  "vsra4S_reg_imm_avx",
  /* 1664 */  "vsra4S_reg_imm_evex",
  /* 1665 */  "vsra4S_reg_imm_evex_special",
  /* 1666 */  "vsra8S",
  /* 1667 */  "vsra8S_imm",
  /* 1668 */  "vsra8S_reg_avx",
  /* 1669 */  "vsra8S_reg_evex",
  /* 1670 */  "vsra8S_reg_evex_special",
  /* 1671 */  "vsra8S_reg_imm_avx",
  /* 1672 */  "vsra8S_reg_imm_evex",
  /* 1673 */  "vsra8S_reg_imm_evex_special",
  /* 1674 */  "vsra16S_reg_avx",
  /* 1675 */  "vsra16S_reg_evex",
  /* 1676 */  "vsra16S_reg_evex_special",
  /* 1677 */  "vsra16S_reg_imm_avx",
  /* 1678 */  "vsra16S_reg_imm_evex",
  /* 1679 */  "vsra16S_reg_imm_evex_special",
  /* 1680 */  "vsra32S_reg",
  /* 1681 */  "vsra32S_reg_imm",
  /* 1682 */  "vsra2I",
  /* 1683 */  "vsra2I_imm",
  /* 1684 */  "vsra2I_reg",
  /* 1685 */  "vsra2I_reg_imm",
  /* 1686 */  "vsra4I",
  /* 1687 */  "vsra4I_imm",
  /* 1688 */  "vsra4I_reg",
  /* 1689 */  "vsra4I_reg_imm",
  /* 1690 */  "vsra8I_reg",
  /* 1691 */  "vsra8I_reg_imm",
  /* 1692 */  "vsra16I_reg",
  /* 1693 */  "vsra16I_reg_imm",
  /* 1694 */  "vand4B",
  /* 1695 */  "vand4B_reg",
  /* 1696 */  "vand4B_mem",
  /* 1697 */  "vand4B_mem_0",
  /* 1698 */  "vand8B",
  /* 1699 */  "vand8B_reg",
  /* 1700 */  "vand8B_mem",
  /* 1701 */  "vand8B_mem_0",
  /* 1702 */  "vand16B",
  /* 1703 */  "vand16B_reg",
  /* 1704 */  "vand16B_mem",
  /* 1705 */  "vand16B_mem_0",
  /* 1706 */  "vand32B_reg",
  /* 1707 */  "vand32B_mem",
  /* 1708 */  "vand32B_mem_0",
  /* 1709 */  "vand64B_reg",
  /* 1710 */  "vand64B_mem",
  /* 1711 */  "vand64B_mem_0",
  /* 1712 */  "vor4B",
  /* 1713 */  "vor4B_reg",
  /* 1714 */  "vor4B_mem",
  /* 1715 */  "vor4B_mem_0",
  /* 1716 */  "vor8B",
  /* 1717 */  "vor8B_reg",
  /* 1718 */  "vor8B_mem",
  /* 1719 */  "vor8B_mem_0",
  /* 1720 */  "vor16B",
  /* 1721 */  "vor16B_reg",
  /* 1722 */  "vor16B_mem",
  /* 1723 */  "vor16B_mem_0",
  /* 1724 */  "vor32B_reg",
  /* 1725 */  "vor32B_mem",
  /* 1726 */  "vor32B_mem_0",
  /* 1727 */  "vor64B_reg",
  /* 1728 */  "vor64B_mem",
  /* 1729 */  "vor64B_mem_0",
  /* 1730 */  "vxor4B",
  /* 1731 */  "vxor4B_reg",
  /* 1732 */  "vxor4B_mem",
  /* 1733 */  "vxor4B_mem_0",
  /* 1734 */  "vxor8B",
  /* 1735 */  "vxor8B_reg",
  /* 1736 */  "vxor8B_mem",
  /* 1737 */  "vxor8B_mem_0",
  /* 1738 */  "vxor16B",
  /* 1739 */  "vxor16B_reg",
  /* 1740 */  "vxor16B_mem",
  /* 1741 */  "vxor16B_mem_0",
  /* 1742 */  "vxor32B_reg",
  /* 1743 */  "vxor32B_mem",
  /* 1744 */  "vxor32B_mem_0",
  /* 1745 */  "vxor64B_reg",
  /* 1746 */  "vxor64B_mem",
  /* 1747 */  "vxor64B_mem_0",
  /* 1748 */  "vfma2D_reg",
  /* 1749 */  "vfma2D_mem",
  /* 1750 */  "vfma4D_reg",
  /* 1751 */  "vfma4D_mem",
  /* 1752 */  "vfma8D_reg",
  /* 1753 */  "vfma8D_mem",
  /* 1754 */  "vfma4F_reg",
  /* 1755 */  "vfma4F_mem",
  /* 1756 */  "vfma8F_reg",
  /* 1757 */  "vfma8F_mem",
  /* 1758 */  "vfma16F_reg",
  /* 1759 */  "vfma16F_mem",
  // last instruction
  "invalid rule name" // no trailing comma
};

const        bool  swallowed[] = {
  /*    0 */  false,
  /*    1 */  false,
  /*    2 */  false,
  /*    3 */  false,
  /*    4 */  false,
  /*    5 */  false,
  /*    6 */  false,
  /*    7 */  false,
  /*    8 */  true,
  /*    9 */  true,
  /*   10 */  true,
  /*   11 */  true,
  /*   12 */  true,
  /*   13 */  true,
  /*   14 */  true,
  /*   15 */  true,
  /*   16 */  true,
  /*   17 */  true,
  /*   18 */  true,
  /*   19 */  true,
  /*   20 */  true,
  /*   21 */  true,
  /*   22 */  true,
  /*   23 */  true,
  /*   24 */  true,
  /*   25 */  true,
  /*   26 */  true,
  /*   27 */  true,
  /*   28 */  true,
  /*   29 */  true,
  /*   30 */  true,
  /*   31 */  true,
  /*   32 */  true,
  /*   33 */  true,
  /*   34 */  true,
  /*   35 */  true,
  /*   36 */  true,
  /*   37 */  true,
  /*   38 */  true,
  /*   39 */  true,
  /*   40 */  true,
  /*   41 */  true,
  /*   42 */  true,
  /*   43 */  true,
  /*   44 */  true,
  /*   45 */  false,
  /*   46 */  false,
  /*   47 */  false,
  /*   48 */  false,
  /*   49 */  false,
  /*   50 */  false,
  /*   51 */  false,
  /*   52 */  false,
  /*   53 */  false,
  /*   54 */  false,
  /*   55 */  false,
  /*   56 */  false,
  /*   57 */  false,
  /*   58 */  false,
  /*   59 */  false,
  /*   60 */  false,
  /*   61 */  false,
  /*   62 */  false,
  /*   63 */  false,
  /*   64 */  false,
  /*   65 */  false,
  /*   66 */  false,
  /*   67 */  false,
  /*   68 */  false,
  /*   69 */  false,
  /*   70 */  false,
  /*   71 */  false,
  /*   72 */  false,
  /*   73 */  false,
  /*   74 */  false,
  /*   75 */  false,
  /*   76 */  false,
  /*   77 */  false,
  /*   78 */  false,
  /*   79 */  false,
  /*   80 */  false,
  /*   81 */  false,
  /*   82 */  false,
  /*   83 */  false,
  /*   84 */  false,
  /*   85 */  false,
  /*   86 */  false,
  /*   87 */  false,
  /*   88 */  false,
  /*   89 */  false,
  /*   90 */  false,
  /*   91 */  false,
  /*   92 */  false,
  /*   93 */  false,
  /*   94 */  false,
  /*   95 */  false,
  /*   96 */  false,
  /*   97 */  false,
  /*   98 */  false,
  /*   99 */  false,
  /*  100 */  false,
  /*  101 */  false,
  /*  102 */  false,
  /*  103 */  false,
  /*  104 */  false,
  /*  105 */  false,
  /*  106 */  false,
  /*  107 */  true,
  /*  108 */  true,
  /*  109 */  true,
  /*  110 */  true,
  /*  111 */  false,
  /*  112 */  false,
  /*  113 */  false,
  /*  114 */  false,
  /*  115 */  false,
  /*  116 */  false,
  /*  117 */  false,
  /*  118 */  false,
  /*  119 */  false,
  /*  120 */  false,
  /*  121 */  false,
  /*  122 */  false,
  /*  123 */  false,
  /*  124 */  false,
  /*  125 */  false,
  /*  126 */  false,
  /*  127 */  false,
  /*  128 */  false,
  /*  129 */  false,
  /*  130 */  false,
  /*  131 */  false,
  /*  132 */  false,
  /*  133 */  false,
  /*  134 */  false,
  /*  135 */  false,
  /*  136 */  false,
  /*  137 */  false,
  /*  138 */  false,
  /*  139 */  false,
  /*  140 */  false,
  /*  141 */  false,
  /*  142 */  false,
  /*  143 */  false,
  /*  144 */  true,
  // last operand
  /*  145 */  false,
  // last operand class
  /*  146 */  false,
  /*  147 */  false,
  /*  148 */  false,
  /*  149 */  false,
  /*  150 */  false,
  /*  151 */  false,
  /*  152 */  false,
  /*  153 */  false,
  /*  154 */  false,
  /*  155 */  false,
  /*  156 */  false,
  /*  157 */  false,
  /*  158 */  false,
  /*  159 */  false,
  /*  160 */  false,
  /*  161 */  false,
  /*  162 */  false,
  /*  163 */  false,
  /*  164 */  false,
  /*  165 */  false,
  /*  166 */  false,
  /*  167 */  false,
  /*  168 */  false,
  /*  169 */  false,
  /*  170 */  false,
  /*  171 */  false,
  /*  172 */  false,
  /*  173 */  false,
  /*  174 */  false,
  /*  175 */  false,
  /*  176 */  false,
  /*  177 */  false,
  /*  178 */  false,
  /*  179 */  false,
  /*  180 */  false,
  /*  181 */  false,
  /*  182 */  false,
  /*  183 */  false,
  /*  184 */  false,
  /*  185 */  false,
  /*  186 */  false,
  /*  187 */  false,
  /*  188 */  false,
  /*  189 */  false,
  /*  190 */  false,
  /*  191 */  false,
  /*  192 */  false,
  /*  193 */  false,
  /*  194 */  false,
  /*  195 */  false,
  /*  196 */  false,
  /*  197 */  false,
  /*  198 */  false,
  /*  199 */  false,
  /*  200 */  false,
  /*  201 */  false,
  /*  202 */  false,
  /*  203 */  false,
  /*  204 */  false,
  /*  205 */  false,
  /*  206 */  false,
  /*  207 */  false,
  /*  208 */  false,
  /*  209 */  false,
  /*  210 */  false,
  /*  211 */  false,
  /*  212 */  false,
  /*  213 */  false,
  /*  214 */  false,
  /*  215 */  false,
  /*  216 */  false,
  /*  217 */  false,
  /*  218 */  false,
  /*  219 */  false,
  /*  220 */  false,
  /*  221 */  false,
  /*  222 */  false,
  /*  223 */  false,
  /*  224 */  false,
  /*  225 */  false,
  /*  226 */  false,
  /*  227 */  false,
  /*  228 */  false,
  /*  229 */  false,
  /*  230 */  false,
  /*  231 */  false,
  /*  232 */  false,
  /*  233 */  false,
  /*  234 */  false,
  /*  235 */  false,
  /*  236 */  false,
  /*  237 */  false,
  /*  238 */  false,
  /*  239 */  false,
  /*  240 */  false,
  /*  241 */  false,
  /*  242 */  false,
  /*  243 */  false,
  /*  244 */  false,
  /*  245 */  false,
  /*  246 */  false,
  /*  247 */  false,
  /*  248 */  false,
  /*  249 */  false,
  /*  250 */  false,
  /*  251 */  false,
  /*  252 */  false,
  /*  253 */  false,
  /*  254 */  false,
  /*  255 */  false,
  /*  256 */  false,
  /*  257 */  false,
  /*  258 */  false,
  /*  259 */  false,
  /*  260 */  false,
  /*  261 */  false,
  /*  262 */  false,
  /*  263 */  false,
  /*  264 */  false,
  /*  265 */  false,
  /*  266 */  false,
  /*  267 */  false,
  /*  268 */  false,
  /*  269 */  false,
  /*  270 */  false,
  /*  271 */  false,
  /*  272 */  false,
  /*  273 */  false,
  /*  274 */  false,
  /*  275 */  false,
  /*  276 */  false,
  /*  277 */  false,
  /*  278 */  false,
  /*  279 */  false,
  /*  280 */  false,
  /*  281 */  false,
  /*  282 */  false,
  /*  283 */  false,
  /*  284 */  false,
  /*  285 */  false,
  /*  286 */  false,
  /*  287 */  false,
  /*  288 */  false,
  /*  289 */  false,
  /*  290 */  false,
  /*  291 */  false,
  /*  292 */  false,
  /*  293 */  false,
  /*  294 */  false,
  /*  295 */  false,
  /*  296 */  false,
  /*  297 */  false,
  /*  298 */  false,
  /*  299 */  false,
  /*  300 */  false,
  /*  301 */  false,
  /*  302 */  false,
  /*  303 */  false,
  /*  304 */  false,
  /*  305 */  false,
  /*  306 */  false,
  /*  307 */  false,
  /*  308 */  false,
  /*  309 */  false,
  /*  310 */  false,
  /*  311 */  false,
  // last internally defined operand
  /*  312 */  false,
  /*  313 */  false,
  /*  314 */  false,
  /*  315 */  false,
  /*  316 */  false,
  /*  317 */  false,
  /*  318 */  false,
  /*  319 */  false,
  /*  320 */  false,
  /*  321 */  false,
  /*  322 */  false,
  /*  323 */  false,
  /*  324 */  false,
  /*  325 */  false,
  /*  326 */  false,
  /*  327 */  false,
  /*  328 */  false,
  /*  329 */  false,
  /*  330 */  false,
  /*  331 */  false,
  /*  332 */  false,
  /*  333 */  false,
  /*  334 */  false,
  /*  335 */  false,
  /*  336 */  false,
  /*  337 */  false,
  /*  338 */  false,
  /*  339 */  false,
  /*  340 */  false,
  /*  341 */  false,
  /*  342 */  false,
  /*  343 */  false,
  /*  344 */  false,
  /*  345 */  false,
  /*  346 */  false,
  /*  347 */  false,
  /*  348 */  false,
  /*  349 */  false,
  /*  350 */  false,
  /*  351 */  false,
  /*  352 */  false,
  /*  353 */  false,
  /*  354 */  false,
  /*  355 */  false,
  /*  356 */  false,
  /*  357 */  false,
  /*  358 */  false,
  /*  359 */  false,
  /*  360 */  false,
  /*  361 */  false,
  /*  362 */  false,
  /*  363 */  false,
  /*  364 */  false,
  /*  365 */  false,
  /*  366 */  false,
  /*  367 */  false,
  /*  368 */  false,
  /*  369 */  false,
  /*  370 */  false,
  /*  371 */  false,
  /*  372 */  false,
  /*  373 */  false,
  /*  374 */  false,
  /*  375 */  false,
  /*  376 */  false,
  /*  377 */  false,
  /*  378 */  false,
  /*  379 */  false,
  /*  380 */  false,
  /*  381 */  false,
  /*  382 */  false,
  /*  383 */  false,
  /*  384 */  false,
  /*  385 */  false,
  /*  386 */  false,
  /*  387 */  false,
  /*  388 */  false,
  /*  389 */  false,
  /*  390 */  false,
  /*  391 */  false,
  /*  392 */  false,
  /*  393 */  false,
  /*  394 */  false,
  /*  395 */  false,
  /*  396 */  false,
  /*  397 */  false,
  /*  398 */  false,
  /*  399 */  false,
  /*  400 */  false,
  /*  401 */  false,
  /*  402 */  false,
  /*  403 */  false,
  /*  404 */  false,
  /*  405 */  false,
  /*  406 */  false,
  /*  407 */  false,
  /*  408 */  false,
  /*  409 */  false,
  /*  410 */  false,
  /*  411 */  false,
  /*  412 */  false,
  /*  413 */  false,
  /*  414 */  false,
  /*  415 */  false,
  /*  416 */  false,
  /*  417 */  false,
  /*  418 */  false,
  /*  419 */  false,
  /*  420 */  false,
  /*  421 */  false,
  /*  422 */  false,
  /*  423 */  false,
  /*  424 */  false,
  /*  425 */  false,
  /*  426 */  false,
  /*  427 */  false,
  /*  428 */  false,
  /*  429 */  false,
  /*  430 */  false,
  /*  431 */  false,
  /*  432 */  false,
  /*  433 */  false,
  /*  434 */  false,
  /*  435 */  false,
  /*  436 */  false,
  /*  437 */  false,
  /*  438 */  false,
  /*  439 */  false,
  /*  440 */  false,
  /*  441 */  false,
  /*  442 */  false,
  /*  443 */  false,
  /*  444 */  false,
  /*  445 */  false,
  /*  446 */  false,
  /*  447 */  false,
  /*  448 */  false,
  /*  449 */  false,
  /*  450 */  false,
  /*  451 */  false,
  /*  452 */  false,
  /*  453 */  false,
  /*  454 */  false,
  /*  455 */  false,
  /*  456 */  false,
  /*  457 */  false,
  /*  458 */  false,
  /*  459 */  false,
  /*  460 */  false,
  /*  461 */  false,
  /*  462 */  false,
  /*  463 */  false,
  /*  464 */  false,
  /*  465 */  false,
  /*  466 */  false,
  /*  467 */  false,
  /*  468 */  false,
  /*  469 */  false,
  /*  470 */  false,
  /*  471 */  false,
  /*  472 */  false,
  /*  473 */  false,
  /*  474 */  false,
  /*  475 */  false,
  /*  476 */  false,
  /*  477 */  false,
  /*  478 */  false,
  /*  479 */  false,
  /*  480 */  false,
  /*  481 */  false,
  /*  482 */  false,
  /*  483 */  false,
  /*  484 */  false,
  /*  485 */  false,
  /*  486 */  false,
  /*  487 */  false,
  /*  488 */  false,
  /*  489 */  false,
  /*  490 */  false,
  /*  491 */  false,
  /*  492 */  false,
  /*  493 */  false,
  /*  494 */  false,
  /*  495 */  false,
  /*  496 */  false,
  /*  497 */  false,
  /*  498 */  false,
  /*  499 */  false,
  /*  500 */  false,
  /*  501 */  false,
  /*  502 */  false,
  /*  503 */  false,
  /*  504 */  false,
  /*  505 */  false,
  /*  506 */  false,
  /*  507 */  false,
  /*  508 */  false,
  /*  509 */  false,
  /*  510 */  false,
  /*  511 */  false,
  /*  512 */  false,
  /*  513 */  false,
  /*  514 */  false,
  /*  515 */  false,
  /*  516 */  false,
  /*  517 */  false,
  /*  518 */  false,
  /*  519 */  false,
  /*  520 */  false,
  /*  521 */  false,
  /*  522 */  false,
  /*  523 */  false,
  /*  524 */  false,
  /*  525 */  false,
  /*  526 */  false,
  /*  527 */  false,
  /*  528 */  false,
  /*  529 */  false,
  /*  530 */  false,
  /*  531 */  false,
  /*  532 */  false,
  /*  533 */  false,
  /*  534 */  false,
  /*  535 */  false,
  /*  536 */  false,
  /*  537 */  false,
  /*  538 */  false,
  /*  539 */  false,
  /*  540 */  false,
  /*  541 */  false,
  /*  542 */  false,
  /*  543 */  false,
  /*  544 */  false,
  /*  545 */  false,
  /*  546 */  false,
  /*  547 */  false,
  /*  548 */  false,
  /*  549 */  false,
  /*  550 */  false,
  /*  551 */  false,
  /*  552 */  false,
  /*  553 */  false,
  /*  554 */  false,
  /*  555 */  false,
  /*  556 */  false,
  /*  557 */  false,
  /*  558 */  false,
  /*  559 */  false,
  /*  560 */  false,
  /*  561 */  false,
  /*  562 */  false,
  /*  563 */  false,
  /*  564 */  false,
  /*  565 */  false,
  /*  566 */  false,
  /*  567 */  false,
  /*  568 */  false,
  /*  569 */  false,
  /*  570 */  false,
  /*  571 */  false,
  /*  572 */  false,
  /*  573 */  false,
  /*  574 */  false,
  /*  575 */  false,
  /*  576 */  false,
  /*  577 */  false,
  /*  578 */  false,
  /*  579 */  false,
  /*  580 */  false,
  /*  581 */  false,
  /*  582 */  false,
  /*  583 */  false,
  /*  584 */  false,
  /*  585 */  false,
  /*  586 */  false,
  /*  587 */  false,
  /*  588 */  false,
  /*  589 */  false,
  /*  590 */  false,
  /*  591 */  false,
  /*  592 */  false,
  /*  593 */  false,
  /*  594 */  false,
  /*  595 */  false,
  /*  596 */  false,
  /*  597 */  false,
  /*  598 */  false,
  /*  599 */  false,
  /*  600 */  false,
  /*  601 */  false,
  /*  602 */  false,
  /*  603 */  false,
  /*  604 */  false,
  /*  605 */  false,
  /*  606 */  false,
  /*  607 */  false,
  /*  608 */  false,
  /*  609 */  false,
  /*  610 */  false,
  /*  611 */  false,
  /*  612 */  false,
  /*  613 */  false,
  /*  614 */  false,
  /*  615 */  false,
  /*  616 */  false,
  /*  617 */  false,
  /*  618 */  false,
  /*  619 */  false,
  /*  620 */  false,
  /*  621 */  false,
  /*  622 */  false,
  /*  623 */  false,
  /*  624 */  false,
  /*  625 */  false,
  /*  626 */  false,
  /*  627 */  false,
  /*  628 */  false,
  /*  629 */  false,
  /*  630 */  false,
  /*  631 */  false,
  /*  632 */  false,
  /*  633 */  false,
  /*  634 */  false,
  /*  635 */  false,
  /*  636 */  false,
  /*  637 */  false,
  /*  638 */  false,
  /*  639 */  false,
  /*  640 */  false,
  /*  641 */  false,
  /*  642 */  false,
  /*  643 */  false,
  /*  644 */  false,
  /*  645 */  false,
  /*  646 */  false,
  /*  647 */  false,
  /*  648 */  false,
  /*  649 */  false,
  /*  650 */  false,
  /*  651 */  false,
  /*  652 */  false,
  /*  653 */  false,
  /*  654 */  false,
  /*  655 */  false,
  /*  656 */  false,
  /*  657 */  false,
  /*  658 */  false,
  /*  659 */  false,
  /*  660 */  false,
  /*  661 */  false,
  /*  662 */  false,
  /*  663 */  false,
  /*  664 */  false,
  /*  665 */  false,
  /*  666 */  false,
  /*  667 */  false,
  /*  668 */  false,
  /*  669 */  false,
  /*  670 */  false,
  /*  671 */  false,
  /*  672 */  false,
  /*  673 */  false,
  /*  674 */  false,
  /*  675 */  false,
  /*  676 */  false,
  /*  677 */  false,
  /*  678 */  false,
  /*  679 */  false,
  /*  680 */  false,
  /*  681 */  false,
  /*  682 */  false,
  /*  683 */  false,
  /*  684 */  false,
  /*  685 */  false,
  /*  686 */  false,
  /*  687 */  false,
  /*  688 */  false,
  /*  689 */  false,
  /*  690 */  false,
  /*  691 */  false,
  /*  692 */  false,
  /*  693 */  false,
  /*  694 */  false,
  /*  695 */  false,
  /*  696 */  false,
  /*  697 */  false,
  /*  698 */  false,
  /*  699 */  false,
  /*  700 */  false,
  /*  701 */  false,
  /*  702 */  false,
  /*  703 */  false,
  /*  704 */  false,
  /*  705 */  false,
  /*  706 */  false,
  /*  707 */  false,
  /*  708 */  false,
  /*  709 */  false,
  /*  710 */  false,
  /*  711 */  false,
  /*  712 */  false,
  /*  713 */  false,
  /*  714 */  false,
  /*  715 */  false,
  /*  716 */  false,
  /*  717 */  false,
  /*  718 */  false,
  /*  719 */  false,
  /*  720 */  false,
  /*  721 */  false,
  /*  722 */  false,
  /*  723 */  false,
  /*  724 */  false,
  /*  725 */  false,
  /*  726 */  false,
  /*  727 */  false,
  /*  728 */  false,
  /*  729 */  false,
  /*  730 */  false,
  /*  731 */  false,
  /*  732 */  false,
  /*  733 */  false,
  /*  734 */  false,
  /*  735 */  false,
  /*  736 */  false,
  /*  737 */  false,
  /*  738 */  false,
  /*  739 */  false,
  /*  740 */  false,
  /*  741 */  false,
  /*  742 */  false,
  /*  743 */  false,
  /*  744 */  false,
  /*  745 */  false,
  /*  746 */  false,
  /*  747 */  false,
  /*  748 */  false,
  /*  749 */  false,
  /*  750 */  false,
  /*  751 */  false,
  /*  752 */  false,
  /*  753 */  false,
  /*  754 */  false,
  /*  755 */  false,
  /*  756 */  false,
  /*  757 */  false,
  /*  758 */  false,
  /*  759 */  false,
  /*  760 */  false,
  /*  761 */  false,
  /*  762 */  false,
  /*  763 */  false,
  /*  764 */  false,
  /*  765 */  false,
  /*  766 */  false,
  /*  767 */  false,
  /*  768 */  false,
  /*  769 */  false,
  /*  770 */  false,
  /*  771 */  false,
  /*  772 */  false,
  /*  773 */  false,
  /*  774 */  false,
  /*  775 */  false,
  /*  776 */  false,
  /*  777 */  false,
  /*  778 */  false,
  /*  779 */  false,
  /*  780 */  false,
  /*  781 */  false,
  /*  782 */  false,
  /*  783 */  false,
  /*  784 */  false,
  /*  785 */  false,
  /*  786 */  false,
  /*  787 */  false,
  /*  788 */  false,
  /*  789 */  false,
  /*  790 */  false,
  /*  791 */  false,
  /*  792 */  false,
  /*  793 */  false,
  /*  794 */  false,
  /*  795 */  false,
  /*  796 */  false,
  /*  797 */  false,
  /*  798 */  false,
  /*  799 */  false,
  /*  800 */  false,
  /*  801 */  false,
  /*  802 */  false,
  /*  803 */  false,
  /*  804 */  false,
  /*  805 */  false,
  /*  806 */  false,
  /*  807 */  false,
  /*  808 */  false,
  /*  809 */  false,
  /*  810 */  false,
  /*  811 */  false,
  /*  812 */  false,
  /*  813 */  false,
  /*  814 */  false,
  /*  815 */  false,
  /*  816 */  false,
  /*  817 */  false,
  /*  818 */  false,
  /*  819 */  false,
  /*  820 */  false,
  /*  821 */  false,
  /*  822 */  false,
  /*  823 */  false,
  /*  824 */  false,
  /*  825 */  false,
  /*  826 */  false,
  /*  827 */  false,
  /*  828 */  false,
  /*  829 */  false,
  /*  830 */  false,
  /*  831 */  false,
  /*  832 */  false,
  /*  833 */  false,
  /*  834 */  false,
  /*  835 */  false,
  /*  836 */  false,
  /*  837 */  false,
  /*  838 */  false,
  /*  839 */  false,
  /*  840 */  false,
  /*  841 */  false,
  /*  842 */  false,
  /*  843 */  false,
  /*  844 */  false,
  /*  845 */  false,
  /*  846 */  false,
  /*  847 */  false,
  /*  848 */  false,
  /*  849 */  false,
  /*  850 */  false,
  /*  851 */  false,
  /*  852 */  false,
  /*  853 */  false,
  /*  854 */  false,
  /*  855 */  false,
  /*  856 */  false,
  /*  857 */  false,
  /*  858 */  false,
  /*  859 */  false,
  /*  860 */  false,
  /*  861 */  false,
  /*  862 */  false,
  /*  863 */  false,
  /*  864 */  false,
  /*  865 */  false,
  /*  866 */  false,
  /*  867 */  false,
  /*  868 */  false,
  /*  869 */  false,
  /*  870 */  false,
  /*  871 */  false,
  /*  872 */  false,
  /*  873 */  false,
  /*  874 */  false,
  /*  875 */  false,
  /*  876 */  false,
  /*  877 */  false,
  /*  878 */  false,
  /*  879 */  false,
  /*  880 */  false,
  /*  881 */  false,
  /*  882 */  false,
  /*  883 */  false,
  /*  884 */  false,
  /*  885 */  false,
  /*  886 */  false,
  /*  887 */  false,
  /*  888 */  false,
  /*  889 */  false,
  /*  890 */  false,
  /*  891 */  false,
  /*  892 */  false,
  /*  893 */  false,
  /*  894 */  false,
  /*  895 */  false,
  /*  896 */  false,
  /*  897 */  false,
  /*  898 */  false,
  /*  899 */  false,
  /*  900 */  false,
  /*  901 */  false,
  /*  902 */  false,
  /*  903 */  false,
  /*  904 */  false,
  /*  905 */  false,
  /*  906 */  false,
  /*  907 */  false,
  /*  908 */  false,
  /*  909 */  false,
  /*  910 */  false,
  /*  911 */  false,
  /*  912 */  false,
  /*  913 */  false,
  /*  914 */  false,
  /*  915 */  false,
  /*  916 */  false,
  /*  917 */  false,
  /*  918 */  false,
  /*  919 */  false,
  /*  920 */  false,
  /*  921 */  false,
  /*  922 */  false,
  /*  923 */  false,
  /*  924 */  false,
  /*  925 */  false,
  /*  926 */  false,
  /*  927 */  false,
  /*  928 */  false,
  /*  929 */  false,
  /*  930 */  false,
  /*  931 */  false,
  /*  932 */  false,
  /*  933 */  false,
  /*  934 */  false,
  /*  935 */  false,
  /*  936 */  false,
  /*  937 */  false,
  /*  938 */  false,
  /*  939 */  false,
  /*  940 */  false,
  /*  941 */  false,
  /*  942 */  false,
  /*  943 */  false,
  /*  944 */  false,
  /*  945 */  false,
  /*  946 */  false,
  /*  947 */  false,
  /*  948 */  false,
  /*  949 */  false,
  /*  950 */  false,
  /*  951 */  false,
  /*  952 */  false,
  /*  953 */  false,
  /*  954 */  false,
  /*  955 */  false,
  /*  956 */  false,
  /*  957 */  false,
  /*  958 */  false,
  /*  959 */  false,
  /*  960 */  false,
  /*  961 */  false,
  /*  962 */  false,
  /*  963 */  false,
  /*  964 */  false,
  /*  965 */  false,
  /*  966 */  false,
  /*  967 */  false,
  /*  968 */  false,
  /*  969 */  false,
  /*  970 */  false,
  /*  971 */  false,
  /*  972 */  false,
  /*  973 */  false,
  /*  974 */  false,
  /*  975 */  false,
  /*  976 */  false,
  /*  977 */  false,
  /*  978 */  false,
  /*  979 */  false,
  /*  980 */  false,
  /*  981 */  false,
  /*  982 */  false,
  /*  983 */  false,
  /*  984 */  false,
  /*  985 */  false,
  /*  986 */  false,
  /*  987 */  false,
  /*  988 */  false,
  /*  989 */  false,
  /*  990 */  false,
  /*  991 */  false,
  /*  992 */  false,
  /*  993 */  false,
  /*  994 */  false,
  /*  995 */  false,
  /*  996 */  false,
  /*  997 */  false,
  /*  998 */  false,
  /*  999 */  false,
  /* 1000 */  false,
  /* 1001 */  false,
  /* 1002 */  false,
  /* 1003 */  false,
  /* 1004 */  false,
  /* 1005 */  false,
  /* 1006 */  false,
  /* 1007 */  false,
  /* 1008 */  false,
  /* 1009 */  false,
  /* 1010 */  false,
  /* 1011 */  false,
  /* 1012 */  false,
  /* 1013 */  false,
  /* 1014 */  false,
  /* 1015 */  false,
  /* 1016 */  false,
  /* 1017 */  false,
  /* 1018 */  false,
  /* 1019 */  false,
  /* 1020 */  false,
  /* 1021 */  false,
  /* 1022 */  false,
  /* 1023 */  false,
  /* 1024 */  false,
  /* 1025 */  false,
  /* 1026 */  false,
  /* 1027 */  false,
  /* 1028 */  false,
  /* 1029 */  false,
  /* 1030 */  false,
  /* 1031 */  false,
  /* 1032 */  false,
  /* 1033 */  false,
  /* 1034 */  false,
  /* 1035 */  false,
  /* 1036 */  false,
  /* 1037 */  false,
  /* 1038 */  false,
  /* 1039 */  false,
  /* 1040 */  false,
  /* 1041 */  false,
  /* 1042 */  false,
  /* 1043 */  false,
  /* 1044 */  false,
  /* 1045 */  false,
  /* 1046 */  false,
  /* 1047 */  false,
  /* 1048 */  false,
  /* 1049 */  false,
  /* 1050 */  false,
  /* 1051 */  false,
  /* 1052 */  false,
  /* 1053 */  false,
  /* 1054 */  false,
  /* 1055 */  false,
  /* 1056 */  false,
  /* 1057 */  false,
  /* 1058 */  false,
  /* 1059 */  false,
  /* 1060 */  false,
  /* 1061 */  false,
  /* 1062 */  false,
  /* 1063 */  false,
  /* 1064 */  false,
  /* 1065 */  false,
  /* 1066 */  false,
  /* 1067 */  false,
  /* 1068 */  false,
  /* 1069 */  false,
  /* 1070 */  false,
  /* 1071 */  false,
  /* 1072 */  false,
  /* 1073 */  false,
  /* 1074 */  false,
  /* 1075 */  false,
  /* 1076 */  false,
  /* 1077 */  false,
  /* 1078 */  false,
  /* 1079 */  false,
  /* 1080 */  false,
  /* 1081 */  false,
  /* 1082 */  false,
  /* 1083 */  false,
  /* 1084 */  false,
  /* 1085 */  false,
  /* 1086 */  false,
  /* 1087 */  false,
  /* 1088 */  false,
  /* 1089 */  false,
  /* 1090 */  false,
  /* 1091 */  false,
  /* 1092 */  false,
  /* 1093 */  false,
  /* 1094 */  false,
  /* 1095 */  false,
  /* 1096 */  false,
  /* 1097 */  false,
  /* 1098 */  false,
  /* 1099 */  false,
  /* 1100 */  false,
  /* 1101 */  false,
  /* 1102 */  false,
  /* 1103 */  false,
  /* 1104 */  false,
  /* 1105 */  false,
  /* 1106 */  false,
  /* 1107 */  false,
  /* 1108 */  false,
  /* 1109 */  false,
  /* 1110 */  false,
  /* 1111 */  false,
  /* 1112 */  false,
  /* 1113 */  false,
  /* 1114 */  false,
  /* 1115 */  false,
  /* 1116 */  false,
  /* 1117 */  false,
  /* 1118 */  false,
  /* 1119 */  false,
  /* 1120 */  false,
  /* 1121 */  false,
  /* 1122 */  false,
  /* 1123 */  false,
  /* 1124 */  false,
  /* 1125 */  false,
  /* 1126 */  false,
  /* 1127 */  false,
  /* 1128 */  false,
  /* 1129 */  false,
  /* 1130 */  false,
  /* 1131 */  false,
  /* 1132 */  false,
  /* 1133 */  false,
  /* 1134 */  false,
  /* 1135 */  false,
  /* 1136 */  false,
  /* 1137 */  false,
  /* 1138 */  false,
  /* 1139 */  false,
  /* 1140 */  false,
  /* 1141 */  false,
  /* 1142 */  false,
  /* 1143 */  false,
  /* 1144 */  false,
  /* 1145 */  false,
  /* 1146 */  false,
  /* 1147 */  false,
  /* 1148 */  false,
  /* 1149 */  false,
  /* 1150 */  false,
  /* 1151 */  false,
  /* 1152 */  false,
  /* 1153 */  false,
  /* 1154 */  false,
  /* 1155 */  false,
  /* 1156 */  false,
  /* 1157 */  false,
  /* 1158 */  false,
  /* 1159 */  false,
  /* 1160 */  false,
  /* 1161 */  false,
  /* 1162 */  false,
  /* 1163 */  false,
  /* 1164 */  false,
  /* 1165 */  false,
  /* 1166 */  false,
  /* 1167 */  false,
  /* 1168 */  false,
  /* 1169 */  false,
  /* 1170 */  false,
  /* 1171 */  false,
  /* 1172 */  false,
  /* 1173 */  false,
  /* 1174 */  false,
  /* 1175 */  false,
  /* 1176 */  false,
  /* 1177 */  false,
  /* 1178 */  false,
  /* 1179 */  false,
  /* 1180 */  false,
  /* 1181 */  false,
  /* 1182 */  false,
  /* 1183 */  false,
  /* 1184 */  false,
  /* 1185 */  false,
  /* 1186 */  false,
  /* 1187 */  false,
  /* 1188 */  false,
  /* 1189 */  false,
  /* 1190 */  false,
  /* 1191 */  false,
  /* 1192 */  false,
  /* 1193 */  false,
  /* 1194 */  false,
  /* 1195 */  false,
  /* 1196 */  false,
  /* 1197 */  false,
  /* 1198 */  false,
  /* 1199 */  false,
  /* 1200 */  false,
  /* 1201 */  false,
  /* 1202 */  false,
  /* 1203 */  false,
  /* 1204 */  false,
  /* 1205 */  false,
  /* 1206 */  false,
  /* 1207 */  false,
  /* 1208 */  false,
  /* 1209 */  false,
  /* 1210 */  false,
  /* 1211 */  false,
  /* 1212 */  false,
  /* 1213 */  false,
  /* 1214 */  false,
  /* 1215 */  false,
  /* 1216 */  false,
  /* 1217 */  false,
  /* 1218 */  false,
  /* 1219 */  false,
  /* 1220 */  false,
  /* 1221 */  false,
  /* 1222 */  false,
  /* 1223 */  false,
  /* 1224 */  false,
  /* 1225 */  false,
  /* 1226 */  false,
  /* 1227 */  false,
  /* 1228 */  false,
  /* 1229 */  false,
  /* 1230 */  false,
  /* 1231 */  false,
  /* 1232 */  false,
  /* 1233 */  false,
  /* 1234 */  false,
  /* 1235 */  false,
  /* 1236 */  false,
  /* 1237 */  false,
  /* 1238 */  false,
  /* 1239 */  false,
  /* 1240 */  false,
  /* 1241 */  false,
  /* 1242 */  false,
  /* 1243 */  false,
  /* 1244 */  false,
  /* 1245 */  false,
  /* 1246 */  false,
  /* 1247 */  false,
  /* 1248 */  false,
  /* 1249 */  false,
  /* 1250 */  false,
  /* 1251 */  false,
  /* 1252 */  false,
  /* 1253 */  false,
  /* 1254 */  false,
  /* 1255 */  false,
  /* 1256 */  false,
  /* 1257 */  false,
  /* 1258 */  false,
  /* 1259 */  false,
  /* 1260 */  false,
  /* 1261 */  false,
  /* 1262 */  false,
  /* 1263 */  false,
  /* 1264 */  false,
  /* 1265 */  false,
  /* 1266 */  false,
  /* 1267 */  false,
  /* 1268 */  false,
  /* 1269 */  false,
  /* 1270 */  false,
  /* 1271 */  false,
  /* 1272 */  false,
  /* 1273 */  false,
  /* 1274 */  false,
  /* 1275 */  false,
  /* 1276 */  false,
  /* 1277 */  false,
  /* 1278 */  false,
  /* 1279 */  false,
  /* 1280 */  false,
  /* 1281 */  false,
  /* 1282 */  false,
  /* 1283 */  false,
  /* 1284 */  false,
  /* 1285 */  false,
  /* 1286 */  false,
  /* 1287 */  false,
  /* 1288 */  false,
  /* 1289 */  false,
  /* 1290 */  false,
  /* 1291 */  false,
  /* 1292 */  false,
  /* 1293 */  false,
  /* 1294 */  false,
  /* 1295 */  false,
  /* 1296 */  false,
  /* 1297 */  false,
  /* 1298 */  false,
  /* 1299 */  false,
  /* 1300 */  false,
  /* 1301 */  false,
  /* 1302 */  false,
  /* 1303 */  false,
  /* 1304 */  false,
  /* 1305 */  false,
  /* 1306 */  false,
  /* 1307 */  false,
  /* 1308 */  false,
  /* 1309 */  false,
  /* 1310 */  false,
  /* 1311 */  false,
  /* 1312 */  false,
  /* 1313 */  false,
  /* 1314 */  false,
  /* 1315 */  false,
  /* 1316 */  false,
  /* 1317 */  false,
  /* 1318 */  false,
  /* 1319 */  false,
  /* 1320 */  false,
  /* 1321 */  false,
  /* 1322 */  false,
  /* 1323 */  false,
  /* 1324 */  false,
  /* 1325 */  false,
  /* 1326 */  false,
  /* 1327 */  false,
  /* 1328 */  false,
  /* 1329 */  false,
  /* 1330 */  false,
  /* 1331 */  false,
  /* 1332 */  false,
  /* 1333 */  false,
  /* 1334 */  false,
  /* 1335 */  false,
  /* 1336 */  false,
  /* 1337 */  false,
  /* 1338 */  false,
  /* 1339 */  false,
  /* 1340 */  false,
  /* 1341 */  false,
  /* 1342 */  false,
  /* 1343 */  false,
  /* 1344 */  false,
  /* 1345 */  false,
  /* 1346 */  false,
  /* 1347 */  false,
  /* 1348 */  false,
  /* 1349 */  false,
  /* 1350 */  false,
  /* 1351 */  false,
  /* 1352 */  false,
  /* 1353 */  false,
  /* 1354 */  false,
  /* 1355 */  false,
  /* 1356 */  false,
  /* 1357 */  false,
  /* 1358 */  false,
  /* 1359 */  false,
  /* 1360 */  false,
  /* 1361 */  false,
  /* 1362 */  false,
  /* 1363 */  false,
  /* 1364 */  false,
  /* 1365 */  false,
  /* 1366 */  false,
  /* 1367 */  false,
  /* 1368 */  false,
  /* 1369 */  false,
  /* 1370 */  false,
  /* 1371 */  false,
  /* 1372 */  false,
  /* 1373 */  false,
  /* 1374 */  false,
  /* 1375 */  false,
  /* 1376 */  false,
  /* 1377 */  false,
  /* 1378 */  false,
  /* 1379 */  false,
  /* 1380 */  false,
  /* 1381 */  false,
  /* 1382 */  false,
  /* 1383 */  false,
  /* 1384 */  false,
  /* 1385 */  false,
  /* 1386 */  false,
  /* 1387 */  false,
  /* 1388 */  false,
  /* 1389 */  false,
  /* 1390 */  false,
  /* 1391 */  false,
  /* 1392 */  false,
  /* 1393 */  false,
  /* 1394 */  false,
  /* 1395 */  false,
  /* 1396 */  false,
  /* 1397 */  false,
  /* 1398 */  false,
  /* 1399 */  false,
  /* 1400 */  false,
  /* 1401 */  false,
  /* 1402 */  false,
  /* 1403 */  false,
  /* 1404 */  false,
  /* 1405 */  false,
  /* 1406 */  false,
  /* 1407 */  false,
  /* 1408 */  false,
  /* 1409 */  false,
  /* 1410 */  false,
  /* 1411 */  false,
  /* 1412 */  false,
  /* 1413 */  false,
  /* 1414 */  false,
  /* 1415 */  false,
  /* 1416 */  false,
  /* 1417 */  false,
  /* 1418 */  false,
  /* 1419 */  false,
  /* 1420 */  false,
  /* 1421 */  false,
  /* 1422 */  false,
  /* 1423 */  false,
  /* 1424 */  false,
  /* 1425 */  false,
  /* 1426 */  false,
  /* 1427 */  false,
  /* 1428 */  false,
  /* 1429 */  false,
  /* 1430 */  false,
  /* 1431 */  false,
  /* 1432 */  false,
  /* 1433 */  false,
  /* 1434 */  false,
  /* 1435 */  false,
  /* 1436 */  false,
  /* 1437 */  false,
  /* 1438 */  false,
  /* 1439 */  false,
  /* 1440 */  false,
  /* 1441 */  false,
  /* 1442 */  false,
  /* 1443 */  false,
  /* 1444 */  false,
  /* 1445 */  false,
  /* 1446 */  false,
  /* 1447 */  false,
  /* 1448 */  false,
  /* 1449 */  false,
  /* 1450 */  false,
  /* 1451 */  false,
  /* 1452 */  false,
  /* 1453 */  false,
  /* 1454 */  false,
  /* 1455 */  false,
  /* 1456 */  false,
  /* 1457 */  false,
  /* 1458 */  false,
  /* 1459 */  false,
  /* 1460 */  false,
  /* 1461 */  false,
  /* 1462 */  false,
  /* 1463 */  false,
  /* 1464 */  false,
  /* 1465 */  false,
  /* 1466 */  false,
  /* 1467 */  false,
  /* 1468 */  false,
  /* 1469 */  false,
  /* 1470 */  false,
  /* 1471 */  false,
  /* 1472 */  false,
  /* 1473 */  false,
  /* 1474 */  false,
  /* 1475 */  false,
  /* 1476 */  false,
  /* 1477 */  false,
  /* 1478 */  false,
  /* 1479 */  false,
  /* 1480 */  false,
  /* 1481 */  false,
  /* 1482 */  false,
  /* 1483 */  false,
  /* 1484 */  false,
  /* 1485 */  false,
  /* 1486 */  false,
  /* 1487 */  false,
  /* 1488 */  false,
  /* 1489 */  false,
  /* 1490 */  false,
  /* 1491 */  false,
  /* 1492 */  false,
  /* 1493 */  false,
  /* 1494 */  false,
  /* 1495 */  false,
  /* 1496 */  false,
  /* 1497 */  false,
  /* 1498 */  false,
  /* 1499 */  false,
  /* 1500 */  false,
  /* 1501 */  false,
  /* 1502 */  false,
  /* 1503 */  false,
  /* 1504 */  false,
  /* 1505 */  false,
  /* 1506 */  false,
  /* 1507 */  false,
  /* 1508 */  false,
  /* 1509 */  false,
  /* 1510 */  false,
  /* 1511 */  false,
  /* 1512 */  false,
  /* 1513 */  false,
  /* 1514 */  false,
  /* 1515 */  false,
  /* 1516 */  false,
  /* 1517 */  false,
  /* 1518 */  false,
  /* 1519 */  false,
  /* 1520 */  false,
  /* 1521 */  false,
  /* 1522 */  false,
  /* 1523 */  false,
  /* 1524 */  false,
  /* 1525 */  false,
  /* 1526 */  false,
  /* 1527 */  false,
  /* 1528 */  false,
  /* 1529 */  false,
  /* 1530 */  false,
  /* 1531 */  false,
  /* 1532 */  false,
  /* 1533 */  false,
  /* 1534 */  false,
  /* 1535 */  false,
  /* 1536 */  false,
  /* 1537 */  false,
  /* 1538 */  false,
  /* 1539 */  false,
  /* 1540 */  false,
  /* 1541 */  false,
  /* 1542 */  false,
  /* 1543 */  false,
  /* 1544 */  false,
  /* 1545 */  false,
  /* 1546 */  false,
  /* 1547 */  false,
  /* 1548 */  false,
  /* 1549 */  false,
  /* 1550 */  false,
  /* 1551 */  false,
  /* 1552 */  false,
  /* 1553 */  false,
  /* 1554 */  false,
  /* 1555 */  false,
  /* 1556 */  false,
  /* 1557 */  false,
  /* 1558 */  false,
  /* 1559 */  false,
  /* 1560 */  false,
  /* 1561 */  false,
  /* 1562 */  false,
  /* 1563 */  false,
  /* 1564 */  false,
  /* 1565 */  false,
  /* 1566 */  false,
  /* 1567 */  false,
  /* 1568 */  false,
  /* 1569 */  false,
  /* 1570 */  false,
  /* 1571 */  false,
  /* 1572 */  false,
  /* 1573 */  false,
  /* 1574 */  false,
  /* 1575 */  false,
  /* 1576 */  false,
  /* 1577 */  false,
  /* 1578 */  false,
  /* 1579 */  false,
  /* 1580 */  false,
  /* 1581 */  false,
  /* 1582 */  false,
  /* 1583 */  false,
  /* 1584 */  false,
  /* 1585 */  false,
  /* 1586 */  false,
  /* 1587 */  false,
  /* 1588 */  false,
  /* 1589 */  false,
  /* 1590 */  false,
  /* 1591 */  false,
  /* 1592 */  false,
  /* 1593 */  false,
  /* 1594 */  false,
  /* 1595 */  false,
  /* 1596 */  false,
  /* 1597 */  false,
  /* 1598 */  false,
  /* 1599 */  false,
  /* 1600 */  false,
  /* 1601 */  false,
  /* 1602 */  false,
  /* 1603 */  false,
  /* 1604 */  false,
  /* 1605 */  false,
  /* 1606 */  false,
  /* 1607 */  false,
  /* 1608 */  false,
  /* 1609 */  false,
  /* 1610 */  false,
  /* 1611 */  false,
  /* 1612 */  false,
  /* 1613 */  false,
  /* 1614 */  false,
  /* 1615 */  false,
  /* 1616 */  false,
  /* 1617 */  false,
  /* 1618 */  false,
  /* 1619 */  false,
  /* 1620 */  false,
  /* 1621 */  false,
  /* 1622 */  false,
  /* 1623 */  false,
  /* 1624 */  false,
  /* 1625 */  false,
  /* 1626 */  false,
  /* 1627 */  false,
  /* 1628 */  false,
  /* 1629 */  false,
  /* 1630 */  false,
  /* 1631 */  false,
  /* 1632 */  false,
  /* 1633 */  false,
  /* 1634 */  false,
  /* 1635 */  false,
  /* 1636 */  false,
  /* 1637 */  false,
  /* 1638 */  false,
  /* 1639 */  false,
  /* 1640 */  false,
  /* 1641 */  false,
  /* 1642 */  false,
  /* 1643 */  false,
  /* 1644 */  false,
  /* 1645 */  false,
  /* 1646 */  false,
  /* 1647 */  false,
  /* 1648 */  false,
  /* 1649 */  false,
  /* 1650 */  false,
  /* 1651 */  false,
  /* 1652 */  false,
  /* 1653 */  false,
  /* 1654 */  false,
  /* 1655 */  false,
  /* 1656 */  false,
  /* 1657 */  false,
  /* 1658 */  false,
  /* 1659 */  false,
  /* 1660 */  false,
  /* 1661 */  false,
  /* 1662 */  false,
  /* 1663 */  false,
  /* 1664 */  false,
  /* 1665 */  false,
  /* 1666 */  false,
  /* 1667 */  false,
  /* 1668 */  false,
  /* 1669 */  false,
  /* 1670 */  false,
  /* 1671 */  false,
  /* 1672 */  false,
  /* 1673 */  false,
  /* 1674 */  false,
  /* 1675 */  false,
  /* 1676 */  false,
  /* 1677 */  false,
  /* 1678 */  false,
  /* 1679 */  false,
  /* 1680 */  false,
  /* 1681 */  false,
  /* 1682 */  false,
  /* 1683 */  false,
  /* 1684 */  false,
  /* 1685 */  false,
  /* 1686 */  false,
  /* 1687 */  false,
  /* 1688 */  false,
  /* 1689 */  false,
  /* 1690 */  false,
  /* 1691 */  false,
  /* 1692 */  false,
  /* 1693 */  false,
  /* 1694 */  false,
  /* 1695 */  false,
  /* 1696 */  false,
  /* 1697 */  false,
  /* 1698 */  false,
  /* 1699 */  false,
  /* 1700 */  false,
  /* 1701 */  false,
  /* 1702 */  false,
  /* 1703 */  false,
  /* 1704 */  false,
  /* 1705 */  false,
  /* 1706 */  false,
  /* 1707 */  false,
  /* 1708 */  false,
  /* 1709 */  false,
  /* 1710 */  false,
  /* 1711 */  false,
  /* 1712 */  false,
  /* 1713 */  false,
  /* 1714 */  false,
  /* 1715 */  false,
  /* 1716 */  false,
  /* 1717 */  false,
  /* 1718 */  false,
  /* 1719 */  false,
  /* 1720 */  false,
  /* 1721 */  false,
  /* 1722 */  false,
  /* 1723 */  false,
  /* 1724 */  false,
  /* 1725 */  false,
  /* 1726 */  false,
  /* 1727 */  false,
  /* 1728 */  false,
  /* 1729 */  false,
  /* 1730 */  false,
  /* 1731 */  false,
  /* 1732 */  false,
  /* 1733 */  false,
  /* 1734 */  false,
  /* 1735 */  false,
  /* 1736 */  false,
  /* 1737 */  false,
  /* 1738 */  false,
  /* 1739 */  false,
  /* 1740 */  false,
  /* 1741 */  false,
  /* 1742 */  false,
  /* 1743 */  false,
  /* 1744 */  false,
  /* 1745 */  false,
  /* 1746 */  false,
  /* 1747 */  false,
  /* 1748 */  false,
  /* 1749 */  false,
  /* 1750 */  false,
  /* 1751 */  false,
  /* 1752 */  false,
  /* 1753 */  false,
  /* 1754 */  false,
  /* 1755 */  false,
  /* 1756 */  false,
  /* 1757 */  false,
  /* 1758 */  false,
  /* 1759 */  false,
  // last instruction
  false // no trailing comma
};

// Mapping from machine-independent opcode to boolean
const        char must_clone[] = {
  0, // Node: 0
  0, // Set: 1
  0, // RegN: 2
  0, // RegI: 3
  0, // RegP: 4
  0, // RegF: 5
  0, // RegD: 6
  0, // RegL: 7
  0, // RegFlags: 8
  0, // VecS: 9
  0, // VecD: 10
  0, // VecX: 11
  0, // VecY: 12
  0, // VecZ: 13
  0, // _last_machine_leaf: 14
  0, // AbsD: 15
  0, // AbsF: 16
  0, // AbsI: 17
  0, // AddD: 18
  0, // AddF: 19
  0, // AddI: 20
  0, // AddL: 21
  0, // AddP: 22
  0, // Allocate: 23
  0, // AllocateArray: 24
  0, // AndI: 25
  0, // AndL: 26
  0, // ArrayCopy: 27
  0, // AryEq: 28
  0, // AtanD: 29
  1, // Binary: 30
  1, // Bool: 31
  0, // BoxLock: 32
  0, // ReverseBytesI: 33
  0, // ReverseBytesL: 34
  0, // ReverseBytesUS: 35
  0, // ReverseBytesS: 36
  0, // CProj: 37
  0, // CallDynamicJava: 38
  0, // CallJava: 39
  0, // CallLeaf: 40
  0, // CallLeafNoFP: 41
  0, // CallRuntime: 42
  0, // CallStaticJava: 43
  0, // CastII: 44
  0, // CastX2P: 45
  0, // CastP2X: 46
  0, // CastPP: 47
  0, // Catch: 48
  0, // CatchProj: 49
  0, // CheckCastPP: 50
  0, // ClearArray: 51
  0, // ConstraintCast: 52
  0, // CMoveD: 53
  0, // CMoveVD: 54
  0, // CMoveF: 55
  0, // CMoveVF: 56
  0, // CMoveI: 57
  0, // CMoveL: 58
  0, // CMoveP: 59
  0, // CMoveN: 60
  1, // CmpN: 61
  1, // CmpD: 62
  0, // CmpD3: 63
  1, // CmpF: 64
  0, // CmpF3: 65
  1, // CmpI: 66
  1, // CmpL: 67
  0, // CmpL3: 68
  0, // CmpLTMask: 69
  1, // CmpP: 70
  1, // CmpU: 71
  1, // CmpUL: 72
  0, // CompareAndSwapB: 73
  0, // CompareAndSwapS: 74
  0, // CompareAndSwapI: 75
  0, // CompareAndSwapL: 76
  0, // CompareAndSwapP: 77
  0, // CompareAndSwapN: 78
  0, // WeakCompareAndSwapB: 79
  0, // WeakCompareAndSwapS: 80
  0, // WeakCompareAndSwapI: 81
  0, // WeakCompareAndSwapL: 82
  0, // WeakCompareAndSwapP: 83
  0, // WeakCompareAndSwapN: 84
  0, // CompareAndExchangeB: 85
  0, // CompareAndExchangeS: 86
  0, // CompareAndExchangeI: 87
  0, // CompareAndExchangeL: 88
  0, // CompareAndExchangeP: 89
  0, // CompareAndExchangeN: 90
  0, // GetAndAddB: 91
  0, // GetAndAddS: 92
  0, // GetAndAddI: 93
  0, // GetAndAddL: 94
  0, // GetAndSetB: 95
  0, // GetAndSetS: 96
  0, // GetAndSetI: 97
  0, // GetAndSetL: 98
  0, // GetAndSetP: 99
  0, // GetAndSetN: 100
  0, // Con: 101
  0, // ConN: 102
  0, // ConNKlass: 103
  0, // ConD: 104
  0, // ConF: 105
  0, // ConI: 106
  0, // ConL: 107
  0, // ConP: 108
  0, // Conv2B: 109
  0, // ConvD2F: 110
  0, // ConvD2I: 111
  0, // ConvD2L: 112
  0, // ConvF2D: 113
  0, // ConvF2I: 114
  0, // ConvF2L: 115
  0, // ConvI2D: 116
  0, // ConvI2F: 117
  0, // ConvI2L: 118
  0, // ConvL2D: 119
  0, // ConvL2F: 120
  0, // ConvL2I: 121
  0, // CountedLoop: 122
  0, // CountedLoopEnd: 123
  0, // OuterStripMinedLoop: 124
  0, // OuterStripMinedLoopEnd: 125
  0, // CountLeadingZerosI: 126
  0, // CountLeadingZerosL: 127
  0, // CountTrailingZerosI: 128
  0, // CountTrailingZerosL: 129
  0, // CreateEx: 130
  0, // DecodeN: 131
  0, // DecodeNKlass: 132
  0, // DivD: 133
  0, // DivF: 134
  0, // DivI: 135
  0, // DivL: 136
  0, // DivMod: 137
  0, // DivModI: 138
  0, // DivModL: 139
  0, // EncodeISOArray: 140
  0, // EncodeP: 141
  0, // EncodePKlass: 142
  1, // FastLock: 143
  1, // FastUnlock: 144
  0, // FmaD: 145
  0, // FmaF: 146
  0, // Goto: 147
  0, // Halt: 148
  0, // HasNegatives: 149
  0, // If: 150
  0, // RangeCheck: 151
  0, // IfFalse: 152
  0, // IfTrue: 153
  0, // Initialize: 154
  0, // JProj: 155
  0, // Jump: 156
  0, // JumpProj: 157
  0, // LShiftI: 158
  0, // LShiftL: 159
  0, // LoadB: 160
  0, // LoadUB: 161
  0, // LoadUS: 162
  0, // LoadD: 163
  0, // LoadD_unaligned: 164
  0, // LoadF: 165
  0, // LoadI: 166
  0, // LoadKlass: 167
  0, // LoadNKlass: 168
  0, // LoadL: 169
  0, // LoadL_unaligned: 170
  0, // LoadPLocked: 171
  0, // LoadP: 172
  0, // LoadN: 173
  0, // LoadRange: 174
  0, // LoadS: 175
  0, // LoadBarrier: 176
  0, // LoadBarrierSlowReg: 177
  0, // LoadBarrierWeakSlowReg: 178
  0, // Lock: 179
  0, // Loop: 180
  0, // LoopLimit: 181
  0, // Mach: 182
  0, // MachProj: 183
  0, // MaxI: 184
  0, // MemBarAcquire: 185
  0, // LoadFence: 186
  0, // SetVectMaskI: 187
  0, // MemBarAcquireLock: 188
  0, // MemBarCPUOrder: 189
  0, // MemBarRelease: 190
  0, // StoreFence: 191
  0, // MemBarReleaseLock: 192
  0, // MemBarVolatile: 193
  0, // MemBarStoreStore: 194
  0, // MergeMem: 195
  0, // MinI: 196
  0, // ModD: 197
  0, // ModF: 198
  0, // ModI: 199
  0, // ModL: 200
  0, // MoveI2F: 201
  0, // MoveF2I: 202
  0, // MoveL2D: 203
  0, // MoveD2L: 204
  0, // MulD: 205
  0, // MulF: 206
  0, // MulHiL: 207
  0, // MulI: 208
  0, // MulL: 209
  0, // Multi: 210
  0, // NegD: 211
  0, // NegF: 212
  0, // NeverBranch: 213
  0, // OnSpinWait: 214
  0, // Opaque1: 215
  0, // Opaque2: 216
  0, // Opaque3: 217
  0, // Opaque4: 218
  0, // ProfileBoolean: 219
  0, // OrI: 220
  0, // OrL: 221
  1, // OverflowAddI: 222
  1, // OverflowSubI: 223
  1, // OverflowMulI: 224
  1, // OverflowAddL: 225
  1, // OverflowSubL: 226
  1, // OverflowMulL: 227
  0, // PCTable: 228
  0, // Parm: 229
  0, // PartialSubtypeCheck: 230
  0, // Phi: 231
  0, // PopCountI: 232
  0, // PopCountL: 233
  0, // PopCountVI: 234
  0, // PrefetchAllocation: 235
  0, // Proj: 236
  0, // RShiftI: 237
  0, // RShiftL: 238
  0, // Region: 239
  0, // Rethrow: 240
  0, // Return: 241
  0, // Root: 242
  0, // RoundDouble: 243
  0, // RoundFloat: 244
  0, // SafePoint: 245
  0, // SafePointScalarObject: 246
  0, // SCMemProj: 247
  0, // SqrtD: 248
  0, // SqrtF: 249
  0, // Start: 250
  0, // StartOSR: 251
  0, // StoreB: 252
  0, // StoreC: 253
  0, // StoreCM: 254
  0, // StorePConditional: 255
  0, // StoreIConditional: 256
  0, // StoreLConditional: 257
  0, // StoreD: 258
  0, // StoreF: 259
  0, // StoreI: 260
  0, // StoreL: 261
  0, // StoreP: 262
  0, // StoreN: 263
  0, // StoreNKlass: 264
  0, // StrComp: 265
  0, // StrCompressedCopy: 266
  0, // StrEquals: 267
  0, // StrIndexOf: 268
  0, // StrIndexOfChar: 269
  0, // StrInflatedCopy: 270
  0, // SubD: 271
  0, // SubF: 272
  0, // SubI: 273
  0, // SubL: 274
  0, // TailCall: 275
  0, // TailJump: 276
  0, // ThreadLocal: 277
  0, // Unlock: 278
  0, // URShiftI: 279
  0, // URShiftL: 280
  0, // XorI: 281
  0, // XorL: 282
  0, // Vector: 283
  0, // AddVB: 284
  0, // AddVS: 285
  0, // AddVI: 286
  0, // AddReductionVI: 287
  0, // AddVL: 288
  0, // AddReductionVL: 289
  0, // AddVF: 290
  0, // AddReductionVF: 291
  0, // AddVD: 292
  0, // AddReductionVD: 293
  0, // SubVB: 294
  0, // SubVS: 295
  0, // SubVI: 296
  0, // SubVL: 297
  0, // SubVF: 298
  0, // SubVD: 299
  0, // MulVS: 300
  0, // MulVI: 301
  0, // MulReductionVI: 302
  0, // MulVL: 303
  0, // MulReductionVL: 304
  0, // MulVF: 305
  0, // MulReductionVF: 306
  0, // MulVD: 307
  0, // MulReductionVD: 308
  0, // FmaVD: 309
  0, // FmaVF: 310
  0, // DivVF: 311
  0, // DivVD: 312
  0, // AbsVF: 313
  0, // AbsVD: 314
  0, // NegVF: 315
  0, // NegVD: 316
  0, // SqrtVD: 317
  0, // SqrtVF: 318
  0, // LShiftCntV: 319
  0, // RShiftCntV: 320
  0, // LShiftVB: 321
  0, // LShiftVS: 322
  0, // LShiftVI: 323
  0, // LShiftVL: 324
  0, // RShiftVB: 325
  0, // RShiftVS: 326
  0, // RShiftVI: 327
  0, // RShiftVL: 328
  0, // URShiftVB: 329
  0, // URShiftVS: 330
  0, // URShiftVI: 331
  0, // URShiftVL: 332
  0, // AndV: 333
  0, // OrV: 334
  0, // XorV: 335
  0, // LoadVector: 336
  0, // StoreVector: 337
  0, // Pack: 338
  0, // PackB: 339
  0, // PackS: 340
  0, // PackI: 341
  0, // PackL: 342
  0, // PackF: 343
  0, // PackD: 344
  0, // Pack2L: 345
  0, // Pack2D: 346
  0, // ReplicateB: 347
  0, // ReplicateS: 348
  0, // ReplicateI: 349
  0, // ReplicateL: 350
  0, // ReplicateF: 351
  0, // ReplicateD: 352
  0, // Extract: 353
  0, // ExtractB: 354
  0, // ExtractUB: 355
  0, // ExtractC: 356
  0, // ExtractS: 357
  0, // ExtractI: 358
  0, // ExtractL: 359
  0, // ExtractF: 360
  0 // no trailing comma // ExtractD: 361
};
//  The following instructions can cisc-spill
//  popCountI can cisc-spill operand 1 to popCountI_mem
//  popCountL can cisc-spill operand 1 to popCountL_mem
//  cmovI_reg can cisc-spill operand 4 to cmovI_mem
//  cmovI_regU can cisc-spill operand 4 to cmovI_memU
//  cmovI_regUCF can cisc-spill operand 4 to cmovI_memUCF
//  cmovL_reg can cisc-spill operand 4 to cmovL_mem
//  cmovL_regU can cisc-spill operand 4 to cmovL_memU
//  cmovL_regUCF can cisc-spill operand 4 to cmovL_memUCF
//  addI_rReg can cisc-spill operand 2 to addI_rReg_mem
//  addL_rReg can cisc-spill operand 2 to addL_rReg_mem
//  subI_rReg can cisc-spill operand 2 to subI_rReg_mem
//  subL_rReg can cisc-spill operand 2 to subL_rReg_mem
//  mulI_rReg can cisc-spill operand 2 to mulI_mem
//  mulI_rReg_imm can cisc-spill operand 1 to mulI_mem_imm
//  mulL_rReg can cisc-spill operand 2 to mulL_mem
//  mulL_rReg_imm can cisc-spill operand 1 to mulL_mem_imm
//  i2b can cisc-spill operand 1 to loadI2B
//  i2s can cisc-spill operand 1 to loadI2S
//  andI_rReg can cisc-spill operand 2 to andI_rReg_mem
//  andI2L_rReg_imm255 can cisc-spill operand 1 to loadI2L_immI_255
//  andI2L_rReg_imm65535 can cisc-spill operand 1 to loadI2L_immI_65535
//  andnI_rReg_rReg_rReg can cisc-spill operand 3 to andnI_rReg_rReg_mem
//  andnI_rReg_rReg_rReg_0 can cisc-spill operand 1 to andnI_rReg_rReg_mem_0
//  orI_rReg can cisc-spill operand 2 to orI_rReg_mem
//  xorI_rReg can cisc-spill operand 2 to xorI_rReg_mem
//  andL_rReg can cisc-spill operand 2 to andL_rReg_mem
//  andnL_rReg_rReg_rReg can cisc-spill operand 3 to andnL_rReg_rReg_mem
//  andnL_rReg_rReg_rReg_0 can cisc-spill operand 1 to andnL_rReg_rReg_mem_0
//  orL_rReg can cisc-spill operand 2 to orL_rReg_mem
//  xorL_rReg can cisc-spill operand 2 to xorL_rReg_mem
//  cmpF_cc_reg can cisc-spill operand 2 to cmpF_cc_mem
//  cmpF_cc_reg_CF can cisc-spill operand 2 to cmpF_cc_memCF
//  cmpD_cc_reg can cisc-spill operand 2 to cmpD_cc_mem
//  cmpD_cc_reg_CF can cisc-spill operand 2 to cmpD_cc_memCF
//  cmpF_reg can cisc-spill operand 2 to cmpF_mem
//  cmpD_reg can cisc-spill operand 2 to cmpD_mem
//  convF2D_reg_reg can cisc-spill operand 1 to convF2D_reg_mem
//  convD2F_reg_reg can cisc-spill operand 1 to convD2F_reg_mem
//  convL2F_reg_reg can cisc-spill operand 1 to convL2F_reg_mem
//  convL2D_reg_reg can cisc-spill operand 1 to convL2D_reg_mem
//  convI2L_reg_reg can cisc-spill operand 1 to loadI2L
//  convI2L_reg_reg_zex can cisc-spill operand 1 to loadUI2L
//  MoveF2I_reg_reg can cisc-spill operand 1 to MoveF2I_stack_reg
//  MoveD2L_reg_reg can cisc-spill operand 1 to MoveD2L_stack_reg
//  MoveI2F_reg_reg can cisc-spill operand 1 to MoveI2F_stack_reg
//  compI_rReg can cisc-spill operand 2 to compI_rReg_mem
//  compU_rReg can cisc-spill operand 2 to compU_rReg_mem
//  compP_rReg can cisc-spill operand 2 to compP_rReg_mem
//  compL_rReg can cisc-spill operand 2 to compL_rReg_mem
//  compUL_rReg can cisc-spill operand 2 to compUL_rReg_mem
//  addF_reg can cisc-spill operand 2 to addF_mem
//  addF_reg_reg can cisc-spill operand 2 to addF_reg_mem
//  addD_reg can cisc-spill operand 2 to addD_mem
//  addD_reg_reg can cisc-spill operand 2 to addD_reg_mem
//  subF_reg can cisc-spill operand 2 to subF_mem
//  subF_reg_reg can cisc-spill operand 2 to subF_reg_mem
//  subD_reg can cisc-spill operand 2 to subD_mem
//  subD_reg_reg can cisc-spill operand 2 to subD_reg_mem
//  mulF_reg can cisc-spill operand 2 to mulF_mem
//  mulF_reg_reg can cisc-spill operand 2 to mulF_reg_mem
//  mulD_reg can cisc-spill operand 2 to mulD_mem
//  mulD_reg_reg can cisc-spill operand 2 to mulD_reg_mem
//  divF_reg can cisc-spill operand 2 to divF_mem
//  divF_reg_reg can cisc-spill operand 2 to divF_reg_mem
//  divD_reg can cisc-spill operand 2 to divD_mem
//  divD_reg_reg can cisc-spill operand 2 to divD_reg_mem
//  sqrtF_reg can cisc-spill operand 1 to sqrtF_mem
//  sqrtD_reg can cisc-spill operand 1 to sqrtD_mem
//  Repl8I can cisc-spill operand 1 to Repl8I_mem
//  Repl4L can cisc-spill operand 1 to Repl4L_mem
//  Repl8F can cisc-spill operand 1 to Repl8F_mem
//  Repl4D can cisc-spill operand 1 to Repl4D_mem
//  Repl2I can cisc-spill operand 1 to Repl2I_mem
//  Repl4I_evex can cisc-spill operand 1 to Repl4I_mem_evex
//  Repl8I_evex can cisc-spill operand 1 to Repl8I_mem_evex
//  Repl16I_evex can cisc-spill operand 1 to Repl16I_mem_evex
//  Repl4L_evex can cisc-spill operand 1 to Repl4L_mem_evex
//  Repl8L_evex can cisc-spill operand 1 to Repl8L_mem_evex
//  Repl8F_evex can cisc-spill operand 1 to Repl8F_mem_evex
//  Repl16F_evex can cisc-spill operand 1 to Repl16F_mem_evex
//  Repl4D_evex can cisc-spill operand 1 to Repl4D_mem_evex
//  Repl8D_evex can cisc-spill operand 1 to Repl8D_mem_evex



// An array of character pointers to machine register names.
const char *Matcher::regName[REG_COUNT] = {
  "R10",
  "R10_H",
  "R11",
  "R11_H",
  "R8",
  "R8_H",
  "R9",
  "R9_H",
  "R12",
  "R12_H",
  "RCX",
  "RCX_H",
  "RBX",
  "RBX_H",
  "RDI",
  "RDI_H",
  "RDX",
  "RDX_H",
  "RSI",
  "RSI_H",
  "RAX",
  "RAX_H",
  "RBP",
  "RBP_H",
  "R13",
  "R13_H",
  "R14",
  "R14_H",
  "R15",
  "R15_H",
  "RSP",
  "RSP_H",
  "XMM0",
  "XMM0b",
  "XMM0c",
  "XMM0d",
  "XMM0e",
  "XMM0f",
  "XMM0g",
  "XMM0h",
  "XMM0i",
  "XMM0j",
  "XMM0k",
  "XMM0l",
  "XMM0m",
  "XMM0n",
  "XMM0o",
  "XMM0p",
  "XMM1",
  "XMM1b",
  "XMM1c",
  "XMM1d",
  "XMM1e",
  "XMM1f",
  "XMM1g",
  "XMM1h",
  "XMM1i",
  "XMM1j",
  "XMM1k",
  "XMM1l",
  "XMM1m",
  "XMM1n",
  "XMM1o",
  "XMM1p",
  "XMM2",
  "XMM2b",
  "XMM2c",
  "XMM2d",
  "XMM2e",
  "XMM2f",
  "XMM2g",
  "XMM2h",
  "XMM2i",
  "XMM2j",
  "XMM2k",
  "XMM2l",
  "XMM2m",
  "XMM2n",
  "XMM2o",
  "XMM2p",
  "XMM3",
  "XMM3b",
  "XMM3c",
  "XMM3d",
  "XMM3e",
  "XMM3f",
  "XMM3g",
  "XMM3h",
  "XMM3i",
  "XMM3j",
  "XMM3k",
  "XMM3l",
  "XMM3m",
  "XMM3n",
  "XMM3o",
  "XMM3p",
  "XMM4",
  "XMM4b",
  "XMM4c",
  "XMM4d",
  "XMM4e",
  "XMM4f",
  "XMM4g",
  "XMM4h",
  "XMM4i",
  "XMM4j",
  "XMM4k",
  "XMM4l",
  "XMM4m",
  "XMM4n",
  "XMM4o",
  "XMM4p",
  "XMM5",
  "XMM5b",
  "XMM5c",
  "XMM5d",
  "XMM5e",
  "XMM5f",
  "XMM5g",
  "XMM5h",
  "XMM5i",
  "XMM5j",
  "XMM5k",
  "XMM5l",
  "XMM5m",
  "XMM5n",
  "XMM5o",
  "XMM5p",
  "XMM6",
  "XMM6b",
  "XMM6c",
  "XMM6d",
  "XMM6e",
  "XMM6f",
  "XMM6g",
  "XMM6h",
  "XMM6i",
  "XMM6j",
  "XMM6k",
  "XMM6l",
  "XMM6m",
  "XMM6n",
  "XMM6o",
  "XMM6p",
  "XMM7",
  "XMM7b",
  "XMM7c",
  "XMM7d",
  "XMM7e",
  "XMM7f",
  "XMM7g",
  "XMM7h",
  "XMM7i",
  "XMM7j",
  "XMM7k",
  "XMM7l",
  "XMM7m",
  "XMM7n",
  "XMM7o",
  "XMM7p",
  "XMM8",
  "XMM8b",
  "XMM8c",
  "XMM8d",
  "XMM8e",
  "XMM8f",
  "XMM8g",
  "XMM8h",
  "XMM8i",
  "XMM8j",
  "XMM8k",
  "XMM8l",
  "XMM8m",
  "XMM8n",
  "XMM8o",
  "XMM8p",
  "XMM9",
  "XMM9b",
  "XMM9c",
  "XMM9d",
  "XMM9e",
  "XMM9f",
  "XMM9g",
  "XMM9h",
  "XMM9i",
  "XMM9j",
  "XMM9k",
  "XMM9l",
  "XMM9m",
  "XMM9n",
  "XMM9o",
  "XMM9p",
  "XMM10",
  "XMM10b",
  "XMM10c",
  "XMM10d",
  "XMM10e",
  "XMM10f",
  "XMM10g",
  "XMM10h",
  "XMM10i",
  "XMM10j",
  "XMM10k",
  "XMM10l",
  "XMM10m",
  "XMM10n",
  "XMM10o",
  "XMM10p",
  "XMM11",
  "XMM11b",
  "XMM11c",
  "XMM11d",
  "XMM11e",
  "XMM11f",
  "XMM11g",
  "XMM11h",
  "XMM11i",
  "XMM11j",
  "XMM11k",
  "XMM11l",
  "XMM11m",
  "XMM11n",
  "XMM11o",
  "XMM11p",
  "XMM12",
  "XMM12b",
  "XMM12c",
  "XMM12d",
  "XMM12e",
  "XMM12f",
  "XMM12g",
  "XMM12h",
  "XMM12i",
  "XMM12j",
  "XMM12k",
  "XMM12l",
  "XMM12m",
  "XMM12n",
  "XMM12o",
  "XMM12p",
  "XMM13",
  "XMM13b",
  "XMM13c",
  "XMM13d",
  "XMM13e",
  "XMM13f",
  "XMM13g",
  "XMM13h",
  "XMM13i",
  "XMM13j",
  "XMM13k",
  "XMM13l",
  "XMM13m",
  "XMM13n",
  "XMM13o",
  "XMM13p",
  "XMM14",
  "XMM14b",
  "XMM14c",
  "XMM14d",
  "XMM14e",
  "XMM14f",
  "XMM14g",
  "XMM14h",
  "XMM14i",
  "XMM14j",
  "XMM14k",
  "XMM14l",
  "XMM14m",
  "XMM14n",
  "XMM14o",
  "XMM14p",
  "XMM15",
  "XMM15b",
  "XMM15c",
  "XMM15d",
  "XMM15e",
  "XMM15f",
  "XMM15g",
  "XMM15h",
  "XMM15i",
  "XMM15j",
  "XMM15k",
  "XMM15l",
  "XMM15m",
  "XMM15n",
  "XMM15o",
  "XMM15p",
  "XMM16",
  "XMM16b",
  "XMM16c",
  "XMM16d",
  "XMM16e",
  "XMM16f",
  "XMM16g",
  "XMM16h",
  "XMM16i",
  "XMM16j",
  "XMM16k",
  "XMM16l",
  "XMM16m",
  "XMM16n",
  "XMM16o",
  "XMM16p",
  "XMM17",
  "XMM17b",
  "XMM17c",
  "XMM17d",
  "XMM17e",
  "XMM17f",
  "XMM17g",
  "XMM17h",
  "XMM17i",
  "XMM17j",
  "XMM17k",
  "XMM17l",
  "XMM17m",
  "XMM17n",
  "XMM17o",
  "XMM17p",
  "XMM18",
  "XMM18b",
  "XMM18c",
  "XMM18d",
  "XMM18e",
  "XMM18f",
  "XMM18g",
  "XMM18h",
  "XMM18i",
  "XMM18j",
  "XMM18k",
  "XMM18l",
  "XMM18m",
  "XMM18n",
  "XMM18o",
  "XMM18p",
  "XMM19",
  "XMM19b",
  "XMM19c",
  "XMM19d",
  "XMM19e",
  "XMM19f",
  "XMM19g",
  "XMM19h",
  "XMM19i",
  "XMM19j",
  "XMM19k",
  "XMM19l",
  "XMM19m",
  "XMM19n",
  "XMM19o",
  "XMM19p",
  "XMM20",
  "XMM20b",
  "XMM20c",
  "XMM20d",
  "XMM20e",
  "XMM20f",
  "XMM20g",
  "XMM20h",
  "XMM20i",
  "XMM20j",
  "XMM20k",
  "XMM20l",
  "XMM20m",
  "XMM20n",
  "XMM20o",
  "XMM20p",
  "XMM21",
  "XMM21b",
  "XMM21c",
  "XMM21d",
  "XMM21e",
  "XMM21f",
  "XMM21g",
  "XMM21h",
  "XMM21i",
  "XMM21j",
  "XMM21k",
  "XMM21l",
  "XMM21m",
  "XMM21n",
  "XMM21o",
  "XMM21p",
  "XMM22",
  "XMM22b",
  "XMM22c",
  "XMM22d",
  "XMM22e",
  "XMM22f",
  "XMM22g",
  "XMM22h",
  "XMM22i",
  "XMM22j",
  "XMM22k",
  "XMM22l",
  "XMM22m",
  "XMM22n",
  "XMM22o",
  "XMM22p",
  "XMM23",
  "XMM23b",
  "XMM23c",
  "XMM23d",
  "XMM23e",
  "XMM23f",
  "XMM23g",
  "XMM23h",
  "XMM23i",
  "XMM23j",
  "XMM23k",
  "XMM23l",
  "XMM23m",
  "XMM23n",
  "XMM23o",
  "XMM23p",
  "XMM24",
  "XMM24b",
  "XMM24c",
  "XMM24d",
  "XMM24e",
  "XMM24f",
  "XMM24g",
  "XMM24h",
  "XMM24i",
  "XMM24j",
  "XMM24k",
  "XMM24l",
  "XMM24m",
  "XMM24n",
  "XMM24o",
  "XMM24p",
  "XMM25",
  "XMM25b",
  "XMM25c",
  "XMM25d",
  "XMM25e",
  "XMM25f",
  "XMM25g",
  "XMM25h",
  "XMM25i",
  "XMM25j",
  "XMM25k",
  "XMM25l",
  "XMM25m",
  "XMM25n",
  "XMM25o",
  "XMM25p",
  "XMM26",
  "XMM26b",
  "XMM26c",
  "XMM26d",
  "XMM26e",
  "XMM26f",
  "XMM26g",
  "XMM26h",
  "XMM26i",
  "XMM26j",
  "XMM26k",
  "XMM26l",
  "XMM26m",
  "XMM26n",
  "XMM26o",
  "XMM26p",
  "XMM27",
  "XMM27b",
  "XMM27c",
  "XMM27d",
  "XMM27e",
  "XMM27f",
  "XMM27g",
  "XMM27h",
  "XMM27i",
  "XMM27j",
  "XMM27k",
  "XMM27l",
  "XMM27m",
  "XMM27n",
  "XMM27o",
  "XMM27p",
  "XMM28",
  "XMM28b",
  "XMM28c",
  "XMM28d",
  "XMM28e",
  "XMM28f",
  "XMM28g",
  "XMM28h",
  "XMM28i",
  "XMM28j",
  "XMM28k",
  "XMM28l",
  "XMM28m",
  "XMM28n",
  "XMM28o",
  "XMM28p",
  "XMM29",
  "XMM29b",
  "XMM29c",
  "XMM29d",
  "XMM29e",
  "XMM29f",
  "XMM29g",
  "XMM29h",
  "XMM29i",
  "XMM29j",
  "XMM29k",
  "XMM29l",
  "XMM29m",
  "XMM29n",
  "XMM29o",
  "XMM29p",
  "XMM30",
  "XMM30b",
  "XMM30c",
  "XMM30d",
  "XMM30e",
  "XMM30f",
  "XMM30g",
  "XMM30h",
  "XMM30i",
  "XMM30j",
  "XMM30k",
  "XMM30l",
  "XMM30m",
  "XMM30n",
  "XMM30o",
  "XMM30p",
  "XMM31",
  "XMM31b",
  "XMM31c",
  "XMM31d",
  "XMM31e",
  "XMM31f",
  "XMM31g",
  "XMM31h",
  "XMM31i",
  "XMM31j",
  "XMM31k",
  "XMM31l",
  "XMM31m",
  "XMM31n",
  "XMM31o",
  "XMM31p",
  "RFLAGS" // no trailing comma
};

// An array of character pointers to machine register names.
const VMReg OptoReg::opto2vm[REG_COUNT] = {
	r10->as_VMReg(),
	r10->as_VMReg()->next(),
	r11->as_VMReg(),
	r11->as_VMReg()->next(),
	r8->as_VMReg(),
	r8->as_VMReg()->next(),
	r9->as_VMReg(),
	r9->as_VMReg()->next(),
	r12->as_VMReg(),
	r12->as_VMReg()->next(),
	rcx->as_VMReg(),
	rcx->as_VMReg()->next(),
	rbx->as_VMReg(),
	rbx->as_VMReg()->next(),
	rdi->as_VMReg(),
	rdi->as_VMReg()->next(),
	rdx->as_VMReg(),
	rdx->as_VMReg()->next(),
	rsi->as_VMReg(),
	rsi->as_VMReg()->next(),
	rax->as_VMReg(),
	rax->as_VMReg()->next(),
	rbp->as_VMReg(),
	rbp->as_VMReg()->next(),
	r13->as_VMReg(),
	r13->as_VMReg()->next(),
	r14->as_VMReg(),
	r14->as_VMReg()->next(),
	r15->as_VMReg(),
	r15->as_VMReg()->next(),
	rsp->as_VMReg(),
	rsp->as_VMReg()->next(),
	xmm0->as_VMReg(),
	xmm0->as_VMReg()->next(1),
	xmm0->as_VMReg()->next(2),
	xmm0->as_VMReg()->next(3),
	xmm0->as_VMReg()->next(4),
	xmm0->as_VMReg()->next(5),
	xmm0->as_VMReg()->next(6),
	xmm0->as_VMReg()->next(7),
	xmm0->as_VMReg()->next(8),
	xmm0->as_VMReg()->next(9),
	xmm0->as_VMReg()->next(10),
	xmm0->as_VMReg()->next(11),
	xmm0->as_VMReg()->next(12),
	xmm0->as_VMReg()->next(13),
	xmm0->as_VMReg()->next(14),
	xmm0->as_VMReg()->next(15),
	xmm1->as_VMReg(),
	xmm1->as_VMReg()->next(1),
	xmm1->as_VMReg()->next(2),
	xmm1->as_VMReg()->next(3),
	xmm1->as_VMReg()->next(4),
	xmm1->as_VMReg()->next(5),
	xmm1->as_VMReg()->next(6),
	xmm1->as_VMReg()->next(7),
	xmm1->as_VMReg()->next(8),
	xmm1->as_VMReg()->next(9),
	xmm1->as_VMReg()->next(10),
	xmm1->as_VMReg()->next(11),
	xmm1->as_VMReg()->next(12),
	xmm1->as_VMReg()->next(13),
	xmm1->as_VMReg()->next(14),
	xmm1->as_VMReg()->next(15),
	xmm2->as_VMReg(),
	xmm2->as_VMReg()->next(1),
	xmm2->as_VMReg()->next(2),
	xmm2->as_VMReg()->next(3),
	xmm2->as_VMReg()->next(4),
	xmm2->as_VMReg()->next(5),
	xmm2->as_VMReg()->next(6),
	xmm2->as_VMReg()->next(7),
	xmm2->as_VMReg()->next(8),
	xmm2->as_VMReg()->next(9),
	xmm2->as_VMReg()->next(10),
	xmm2->as_VMReg()->next(11),
	xmm2->as_VMReg()->next(12),
	xmm2->as_VMReg()->next(13),
	xmm2->as_VMReg()->next(14),
	xmm2->as_VMReg()->next(15),
	xmm3->as_VMReg(),
	xmm3->as_VMReg()->next(1),
	xmm3->as_VMReg()->next(2),
	xmm3->as_VMReg()->next(3),
	xmm3->as_VMReg()->next(4),
	xmm3->as_VMReg()->next(5),
	xmm3->as_VMReg()->next(6),
	xmm3->as_VMReg()->next(7),
	xmm3->as_VMReg()->next(8),
	xmm3->as_VMReg()->next(9),
	xmm3->as_VMReg()->next(10),
	xmm3->as_VMReg()->next(11),
	xmm3->as_VMReg()->next(12),
	xmm3->as_VMReg()->next(13),
	xmm3->as_VMReg()->next(14),
	xmm3->as_VMReg()->next(15),
	xmm4->as_VMReg(),
	xmm4->as_VMReg()->next(1),
	xmm4->as_VMReg()->next(2),
	xmm4->as_VMReg()->next(3),
	xmm4->as_VMReg()->next(4),
	xmm4->as_VMReg()->next(5),
	xmm4->as_VMReg()->next(6),
	xmm4->as_VMReg()->next(7),
	xmm4->as_VMReg()->next(8),
	xmm4->as_VMReg()->next(9),
	xmm4->as_VMReg()->next(10),
	xmm4->as_VMReg()->next(11),
	xmm4->as_VMReg()->next(12),
	xmm4->as_VMReg()->next(13),
	xmm4->as_VMReg()->next(14),
	xmm4->as_VMReg()->next(15),
	xmm5->as_VMReg(),
	xmm5->as_VMReg()->next(1),
	xmm5->as_VMReg()->next(2),
	xmm5->as_VMReg()->next(3),
	xmm5->as_VMReg()->next(4),
	xmm5->as_VMReg()->next(5),
	xmm5->as_VMReg()->next(6),
	xmm5->as_VMReg()->next(7),
	xmm5->as_VMReg()->next(8),
	xmm5->as_VMReg()->next(9),
	xmm5->as_VMReg()->next(10),
	xmm5->as_VMReg()->next(11),
	xmm5->as_VMReg()->next(12),
	xmm5->as_VMReg()->next(13),
	xmm5->as_VMReg()->next(14),
	xmm5->as_VMReg()->next(15),
	xmm6->as_VMReg(),
	xmm6->as_VMReg()->next(1),
	xmm6->as_VMReg()->next(2),
	xmm6->as_VMReg()->next(3),
	xmm6->as_VMReg()->next(4),
	xmm6->as_VMReg()->next(5),
	xmm6->as_VMReg()->next(6),
	xmm6->as_VMReg()->next(7),
	xmm6->as_VMReg()->next(8),
	xmm6->as_VMReg()->next(9),
	xmm6->as_VMReg()->next(10),
	xmm6->as_VMReg()->next(11),
	xmm6->as_VMReg()->next(12),
	xmm6->as_VMReg()->next(13),
	xmm6->as_VMReg()->next(14),
	xmm6->as_VMReg()->next(15),
	xmm7->as_VMReg(),
	xmm7->as_VMReg()->next(1),
	xmm7->as_VMReg()->next(2),
	xmm7->as_VMReg()->next(3),
	xmm7->as_VMReg()->next(4),
	xmm7->as_VMReg()->next(5),
	xmm7->as_VMReg()->next(6),
	xmm7->as_VMReg()->next(7),
	xmm7->as_VMReg()->next(8),
	xmm7->as_VMReg()->next(9),
	xmm7->as_VMReg()->next(10),
	xmm7->as_VMReg()->next(11),
	xmm7->as_VMReg()->next(12),
	xmm7->as_VMReg()->next(13),
	xmm7->as_VMReg()->next(14),
	xmm7->as_VMReg()->next(15),
	xmm8->as_VMReg(),
	xmm8->as_VMReg()->next(1),
	xmm8->as_VMReg()->next(2),
	xmm8->as_VMReg()->next(3),
	xmm8->as_VMReg()->next(4),
	xmm8->as_VMReg()->next(5),
	xmm8->as_VMReg()->next(6),
	xmm8->as_VMReg()->next(7),
	xmm8->as_VMReg()->next(8),
	xmm8->as_VMReg()->next(9),
	xmm8->as_VMReg()->next(10),
	xmm8->as_VMReg()->next(11),
	xmm8->as_VMReg()->next(12),
	xmm8->as_VMReg()->next(13),
	xmm8->as_VMReg()->next(14),
	xmm8->as_VMReg()->next(15),
	xmm9->as_VMReg(),
	xmm9->as_VMReg()->next(1),
	xmm9->as_VMReg()->next(2),
	xmm9->as_VMReg()->next(3),
	xmm9->as_VMReg()->next(4),
	xmm9->as_VMReg()->next(5),
	xmm9->as_VMReg()->next(6),
	xmm9->as_VMReg()->next(7),
	xmm9->as_VMReg()->next(8),
	xmm9->as_VMReg()->next(9),
	xmm9->as_VMReg()->next(10),
	xmm9->as_VMReg()->next(11),
	xmm9->as_VMReg()->next(12),
	xmm9->as_VMReg()->next(13),
	xmm9->as_VMReg()->next(14),
	xmm9->as_VMReg()->next(15),
	xmm10->as_VMReg(),
	xmm10->as_VMReg()->next(1),
	xmm10->as_VMReg()->next(2),
	xmm10->as_VMReg()->next(3),
	xmm10->as_VMReg()->next(4),
	xmm10->as_VMReg()->next(5),
	xmm10->as_VMReg()->next(6),
	xmm10->as_VMReg()->next(7),
	xmm10->as_VMReg()->next(8),
	xmm10->as_VMReg()->next(9),
	xmm10->as_VMReg()->next(10),
	xmm10->as_VMReg()->next(11),
	xmm10->as_VMReg()->next(12),
	xmm10->as_VMReg()->next(13),
	xmm10->as_VMReg()->next(14),
	xmm10->as_VMReg()->next(15),
	xmm11->as_VMReg(),
	xmm11->as_VMReg()->next(1),
	xmm11->as_VMReg()->next(2),
	xmm11->as_VMReg()->next(3),
	xmm11->as_VMReg()->next(4),
	xmm11->as_VMReg()->next(5),
	xmm11->as_VMReg()->next(6),
	xmm11->as_VMReg()->next(7),
	xmm11->as_VMReg()->next(8),
	xmm11->as_VMReg()->next(9),
	xmm11->as_VMReg()->next(10),
	xmm11->as_VMReg()->next(11),
	xmm11->as_VMReg()->next(12),
	xmm11->as_VMReg()->next(13),
	xmm11->as_VMReg()->next(14),
	xmm11->as_VMReg()->next(15),
	xmm12->as_VMReg(),
	xmm12->as_VMReg()->next(1),
	xmm12->as_VMReg()->next(2),
	xmm12->as_VMReg()->next(3),
	xmm12->as_VMReg()->next(4),
	xmm12->as_VMReg()->next(5),
	xmm12->as_VMReg()->next(6),
	xmm12->as_VMReg()->next(7),
	xmm12->as_VMReg()->next(8),
	xmm12->as_VMReg()->next(9),
	xmm12->as_VMReg()->next(10),
	xmm12->as_VMReg()->next(11),
	xmm12->as_VMReg()->next(12),
	xmm12->as_VMReg()->next(13),
	xmm12->as_VMReg()->next(14),
	xmm12->as_VMReg()->next(15),
	xmm13->as_VMReg(),
	xmm13->as_VMReg()->next(1),
	xmm13->as_VMReg()->next(2),
	xmm13->as_VMReg()->next(3),
	xmm13->as_VMReg()->next(4),
	xmm13->as_VMReg()->next(5),
	xmm13->as_VMReg()->next(6),
	xmm13->as_VMReg()->next(7),
	xmm13->as_VMReg()->next(8),
	xmm13->as_VMReg()->next(9),
	xmm13->as_VMReg()->next(10),
	xmm13->as_VMReg()->next(11),
	xmm13->as_VMReg()->next(12),
	xmm13->as_VMReg()->next(13),
	xmm13->as_VMReg()->next(14),
	xmm13->as_VMReg()->next(15),
	xmm14->as_VMReg(),
	xmm14->as_VMReg()->next(1),
	xmm14->as_VMReg()->next(2),
	xmm14->as_VMReg()->next(3),
	xmm14->as_VMReg()->next(4),
	xmm14->as_VMReg()->next(5),
	xmm14->as_VMReg()->next(6),
	xmm14->as_VMReg()->next(7),
	xmm14->as_VMReg()->next(8),
	xmm14->as_VMReg()->next(9),
	xmm14->as_VMReg()->next(10),
	xmm14->as_VMReg()->next(11),
	xmm14->as_VMReg()->next(12),
	xmm14->as_VMReg()->next(13),
	xmm14->as_VMReg()->next(14),
	xmm14->as_VMReg()->next(15),
	xmm15->as_VMReg(),
	xmm15->as_VMReg()->next(1),
	xmm15->as_VMReg()->next(2),
	xmm15->as_VMReg()->next(3),
	xmm15->as_VMReg()->next(4),
	xmm15->as_VMReg()->next(5),
	xmm15->as_VMReg()->next(6),
	xmm15->as_VMReg()->next(7),
	xmm15->as_VMReg()->next(8),
	xmm15->as_VMReg()->next(9),
	xmm15->as_VMReg()->next(10),
	xmm15->as_VMReg()->next(11),
	xmm15->as_VMReg()->next(12),
	xmm15->as_VMReg()->next(13),
	xmm15->as_VMReg()->next(14),
	xmm15->as_VMReg()->next(15),
	xmm16->as_VMReg(),
	xmm16->as_VMReg()->next(1),
	xmm16->as_VMReg()->next(2),
	xmm16->as_VMReg()->next(3),
	xmm16->as_VMReg()->next(4),
	xmm16->as_VMReg()->next(5),
	xmm16->as_VMReg()->next(6),
	xmm16->as_VMReg()->next(7),
	xmm16->as_VMReg()->next(8),
	xmm16->as_VMReg()->next(9),
	xmm16->as_VMReg()->next(10),
	xmm16->as_VMReg()->next(11),
	xmm16->as_VMReg()->next(12),
	xmm16->as_VMReg()->next(13),
	xmm16->as_VMReg()->next(14),
	xmm16->as_VMReg()->next(15),
	xmm17->as_VMReg(),
	xmm17->as_VMReg()->next(1),
	xmm17->as_VMReg()->next(2),
	xmm17->as_VMReg()->next(3),
	xmm17->as_VMReg()->next(4),
	xmm17->as_VMReg()->next(5),
	xmm17->as_VMReg()->next(6),
	xmm17->as_VMReg()->next(7),
	xmm17->as_VMReg()->next(8),
	xmm17->as_VMReg()->next(9),
	xmm17->as_VMReg()->next(10),
	xmm17->as_VMReg()->next(11),
	xmm17->as_VMReg()->next(12),
	xmm17->as_VMReg()->next(13),
	xmm17->as_VMReg()->next(14),
	xmm17->as_VMReg()->next(15),
	xmm18->as_VMReg(),
	xmm18->as_VMReg()->next(1),
	xmm18->as_VMReg()->next(2),
	xmm18->as_VMReg()->next(3),
	xmm18->as_VMReg()->next(4),
	xmm18->as_VMReg()->next(5),
	xmm18->as_VMReg()->next(6),
	xmm18->as_VMReg()->next(7),
	xmm18->as_VMReg()->next(8),
	xmm18->as_VMReg()->next(9),
	xmm18->as_VMReg()->next(10),
	xmm18->as_VMReg()->next(11),
	xmm18->as_VMReg()->next(12),
	xmm18->as_VMReg()->next(13),
	xmm18->as_VMReg()->next(14),
	xmm18->as_VMReg()->next(15),
	xmm19->as_VMReg(),
	xmm19->as_VMReg()->next(1),
	xmm19->as_VMReg()->next(2),
	xmm19->as_VMReg()->next(3),
	xmm19->as_VMReg()->next(4),
	xmm19->as_VMReg()->next(5),
	xmm19->as_VMReg()->next(6),
	xmm19->as_VMReg()->next(7),
	xmm19->as_VMReg()->next(8),
	xmm19->as_VMReg()->next(9),
	xmm19->as_VMReg()->next(10),
	xmm19->as_VMReg()->next(11),
	xmm19->as_VMReg()->next(12),
	xmm19->as_VMReg()->next(13),
	xmm19->as_VMReg()->next(14),
	xmm19->as_VMReg()->next(15),
	xmm20->as_VMReg(),
	xmm20->as_VMReg()->next(1),
	xmm20->as_VMReg()->next(2),
	xmm20->as_VMReg()->next(3),
	xmm20->as_VMReg()->next(4),
	xmm20->as_VMReg()->next(5),
	xmm20->as_VMReg()->next(6),
	xmm20->as_VMReg()->next(7),
	xmm20->as_VMReg()->next(8),
	xmm20->as_VMReg()->next(9),
	xmm20->as_VMReg()->next(10),
	xmm20->as_VMReg()->next(11),
	xmm20->as_VMReg()->next(12),
	xmm20->as_VMReg()->next(13),
	xmm20->as_VMReg()->next(14),
	xmm20->as_VMReg()->next(15),
	xmm21->as_VMReg(),
	xmm21->as_VMReg()->next(1),
	xmm21->as_VMReg()->next(2),
	xmm21->as_VMReg()->next(3),
	xmm21->as_VMReg()->next(4),
	xmm21->as_VMReg()->next(5),
	xmm21->as_VMReg()->next(6),
	xmm21->as_VMReg()->next(7),
	xmm21->as_VMReg()->next(8),
	xmm21->as_VMReg()->next(9),
	xmm21->as_VMReg()->next(10),
	xmm21->as_VMReg()->next(11),
	xmm21->as_VMReg()->next(12),
	xmm21->as_VMReg()->next(13),
	xmm21->as_VMReg()->next(14),
	xmm21->as_VMReg()->next(15),
	xmm22->as_VMReg(),
	xmm22->as_VMReg()->next(1),
	xmm22->as_VMReg()->next(2),
	xmm22->as_VMReg()->next(3),
	xmm22->as_VMReg()->next(4),
	xmm22->as_VMReg()->next(5),
	xmm22->as_VMReg()->next(6),
	xmm22->as_VMReg()->next(7),
	xmm22->as_VMReg()->next(8),
	xmm22->as_VMReg()->next(9),
	xmm22->as_VMReg()->next(10),
	xmm22->as_VMReg()->next(11),
	xmm22->as_VMReg()->next(12),
	xmm22->as_VMReg()->next(13),
	xmm22->as_VMReg()->next(14),
	xmm22->as_VMReg()->next(15),
	xmm23->as_VMReg(),
	xmm23->as_VMReg()->next(1),
	xmm23->as_VMReg()->next(2),
	xmm23->as_VMReg()->next(3),
	xmm23->as_VMReg()->next(4),
	xmm23->as_VMReg()->next(5),
	xmm23->as_VMReg()->next(6),
	xmm23->as_VMReg()->next(7),
	xmm23->as_VMReg()->next(8),
	xmm23->as_VMReg()->next(9),
	xmm23->as_VMReg()->next(10),
	xmm23->as_VMReg()->next(11),
	xmm23->as_VMReg()->next(12),
	xmm23->as_VMReg()->next(13),
	xmm23->as_VMReg()->next(14),
	xmm23->as_VMReg()->next(15),
	xmm24->as_VMReg(),
	xmm24->as_VMReg()->next(1),
	xmm24->as_VMReg()->next(2),
	xmm24->as_VMReg()->next(3),
	xmm24->as_VMReg()->next(4),
	xmm24->as_VMReg()->next(5),
	xmm24->as_VMReg()->next(6),
	xmm24->as_VMReg()->next(7),
	xmm24->as_VMReg()->next(8),
	xmm24->as_VMReg()->next(9),
	xmm24->as_VMReg()->next(10),
	xmm24->as_VMReg()->next(11),
	xmm24->as_VMReg()->next(12),
	xmm24->as_VMReg()->next(13),
	xmm24->as_VMReg()->next(14),
	xmm24->as_VMReg()->next(15),
	xmm25->as_VMReg(),
	xmm25->as_VMReg()->next(1),
	xmm25->as_VMReg()->next(2),
	xmm25->as_VMReg()->next(3),
	xmm25->as_VMReg()->next(4),
	xmm25->as_VMReg()->next(5),
	xmm25->as_VMReg()->next(6),
	xmm25->as_VMReg()->next(7),
	xmm25->as_VMReg()->next(8),
	xmm25->as_VMReg()->next(9),
	xmm25->as_VMReg()->next(10),
	xmm25->as_VMReg()->next(11),
	xmm25->as_VMReg()->next(12),
	xmm25->as_VMReg()->next(13),
	xmm25->as_VMReg()->next(14),
	xmm25->as_VMReg()->next(15),
	xmm26->as_VMReg(),
	xmm26->as_VMReg()->next(1),
	xmm26->as_VMReg()->next(2),
	xmm26->as_VMReg()->next(3),
	xmm26->as_VMReg()->next(4),
	xmm26->as_VMReg()->next(5),
	xmm26->as_VMReg()->next(6),
	xmm26->as_VMReg()->next(7),
	xmm26->as_VMReg()->next(8),
	xmm26->as_VMReg()->next(9),
	xmm26->as_VMReg()->next(10),
	xmm26->as_VMReg()->next(11),
	xmm26->as_VMReg()->next(12),
	xmm26->as_VMReg()->next(13),
	xmm26->as_VMReg()->next(14),
	xmm26->as_VMReg()->next(15),
	xmm27->as_VMReg(),
	xmm27->as_VMReg()->next(1),
	xmm27->as_VMReg()->next(2),
	xmm27->as_VMReg()->next(3),
	xmm27->as_VMReg()->next(4),
	xmm27->as_VMReg()->next(5),
	xmm27->as_VMReg()->next(6),
	xmm27->as_VMReg()->next(7),
	xmm27->as_VMReg()->next(8),
	xmm27->as_VMReg()->next(9),
	xmm27->as_VMReg()->next(10),
	xmm27->as_VMReg()->next(11),
	xmm27->as_VMReg()->next(12),
	xmm27->as_VMReg()->next(13),
	xmm27->as_VMReg()->next(14),
	xmm27->as_VMReg()->next(15),
	xmm28->as_VMReg(),
	xmm28->as_VMReg()->next(1),
	xmm28->as_VMReg()->next(2),
	xmm28->as_VMReg()->next(3),
	xmm28->as_VMReg()->next(4),
	xmm28->as_VMReg()->next(5),
	xmm28->as_VMReg()->next(6),
	xmm28->as_VMReg()->next(7),
	xmm28->as_VMReg()->next(8),
	xmm28->as_VMReg()->next(9),
	xmm28->as_VMReg()->next(10),
	xmm28->as_VMReg()->next(11),
	xmm28->as_VMReg()->next(12),
	xmm28->as_VMReg()->next(13),
	xmm28->as_VMReg()->next(14),
	xmm28->as_VMReg()->next(15),
	xmm29->as_VMReg(),
	xmm29->as_VMReg()->next(1),
	xmm29->as_VMReg()->next(2),
	xmm29->as_VMReg()->next(3),
	xmm29->as_VMReg()->next(4),
	xmm29->as_VMReg()->next(5),
	xmm29->as_VMReg()->next(6),
	xmm29->as_VMReg()->next(7),
	xmm29->as_VMReg()->next(8),
	xmm29->as_VMReg()->next(9),
	xmm29->as_VMReg()->next(10),
	xmm29->as_VMReg()->next(11),
	xmm29->as_VMReg()->next(12),
	xmm29->as_VMReg()->next(13),
	xmm29->as_VMReg()->next(14),
	xmm29->as_VMReg()->next(15),
	xmm30->as_VMReg(),
	xmm30->as_VMReg()->next(1),
	xmm30->as_VMReg()->next(2),
	xmm30->as_VMReg()->next(3),
	xmm30->as_VMReg()->next(4),
	xmm30->as_VMReg()->next(5),
	xmm30->as_VMReg()->next(6),
	xmm30->as_VMReg()->next(7),
	xmm30->as_VMReg()->next(8),
	xmm30->as_VMReg()->next(9),
	xmm30->as_VMReg()->next(10),
	xmm30->as_VMReg()->next(11),
	xmm30->as_VMReg()->next(12),
	xmm30->as_VMReg()->next(13),
	xmm30->as_VMReg()->next(14),
	xmm30->as_VMReg()->next(15),
	xmm31->as_VMReg(),
	xmm31->as_VMReg()->next(1),
	xmm31->as_VMReg()->next(2),
	xmm31->as_VMReg()->next(3),
	xmm31->as_VMReg()->next(4),
	xmm31->as_VMReg()->next(5),
	xmm31->as_VMReg()->next(6),
	xmm31->as_VMReg()->next(7),
	xmm31->as_VMReg()->next(8),
	xmm31->as_VMReg()->next(9),
	xmm31->as_VMReg()->next(10),
	xmm31->as_VMReg()->next(11),
	xmm31->as_VMReg()->next(12),
	xmm31->as_VMReg()->next(13),
	xmm31->as_VMReg()->next(14),
	xmm31->as_VMReg()->next(15),
	VMRegImpl::Bad() // no trailing comma
	};

 OptoReg::Name OptoReg::vm2opto[ConcreteRegisterImpl::number_of_registers];

// An array of the machine register encode values
const unsigned char Matcher::_regEncode[REG_COUNT] = {
  (unsigned char)'\xA',  // R10
  (unsigned char)'\xA',  // R10_H
  (unsigned char)'\xB',  // R11
  (unsigned char)'\xB',  // R11_H
  (unsigned char)'\x8',  // R8
  (unsigned char)'\x8',  // R8_H
  (unsigned char)'\x9',  // R9
  (unsigned char)'\x9',  // R9_H
  (unsigned char)'\xC',  // R12
  (unsigned char)'\xC',  // R12_H
  (unsigned char)'\x1',  // RCX
  (unsigned char)'\x1',  // RCX_H
  (unsigned char)'\x3',  // RBX
  (unsigned char)'\x3',  // RBX_H
  (unsigned char)'\x7',  // RDI
  (unsigned char)'\x7',  // RDI_H
  (unsigned char)'\x2',  // RDX
  (unsigned char)'\x2',  // RDX_H
  (unsigned char)'\x6',  // RSI
  (unsigned char)'\x6',  // RSI_H
  (unsigned char)'\x0',  // RAX
  (unsigned char)'\x0',  // RAX_H
  (unsigned char)'\x5',  // RBP
  (unsigned char)'\x5',  // RBP_H
  (unsigned char)'\xD',  // R13
  (unsigned char)'\xD',  // R13_H
  (unsigned char)'\xE',  // R14
  (unsigned char)'\xE',  // R14_H
  (unsigned char)'\xF',  // R15
  (unsigned char)'\xF',  // R15_H
  (unsigned char)'\x4',  // RSP
  (unsigned char)'\x4',  // RSP_H
  (unsigned char)'\x0',  // XMM0
  (unsigned char)'\x0',  // XMM0b
  (unsigned char)'\x0',  // XMM0c
  (unsigned char)'\x0',  // XMM0d
  (unsigned char)'\x0',  // XMM0e
  (unsigned char)'\x0',  // XMM0f
  (unsigned char)'\x0',  // XMM0g
  (unsigned char)'\x0',  // XMM0h
  (unsigned char)'\x0',  // XMM0i
  (unsigned char)'\x0',  // XMM0j
  (unsigned char)'\x0',  // XMM0k
  (unsigned char)'\x0',  // XMM0l
  (unsigned char)'\x0',  // XMM0m
  (unsigned char)'\x0',  // XMM0n
  (unsigned char)'\x0',  // XMM0o
  (unsigned char)'\x0',  // XMM0p
  (unsigned char)'\x1',  // XMM1
  (unsigned char)'\x1',  // XMM1b
  (unsigned char)'\x1',  // XMM1c
  (unsigned char)'\x1',  // XMM1d
  (unsigned char)'\x1',  // XMM1e
  (unsigned char)'\x1',  // XMM1f
  (unsigned char)'\x1',  // XMM1g
  (unsigned char)'\x1',  // XMM1h
  (unsigned char)'\x1',  // XMM1i
  (unsigned char)'\x1',  // XMM1j
  (unsigned char)'\x1',  // XMM1k
  (unsigned char)'\x1',  // XMM1l
  (unsigned char)'\x1',  // XMM1m
  (unsigned char)'\x1',  // XMM1n
  (unsigned char)'\x1',  // XMM1o
  (unsigned char)'\x1',  // XMM1p
  (unsigned char)'\x2',  // XMM2
  (unsigned char)'\x2',  // XMM2b
  (unsigned char)'\x2',  // XMM2c
  (unsigned char)'\x2',  // XMM2d
  (unsigned char)'\x2',  // XMM2e
  (unsigned char)'\x2',  // XMM2f
  (unsigned char)'\x2',  // XMM2g
  (unsigned char)'\x2',  // XMM2h
  (unsigned char)'\x2',  // XMM2i
  (unsigned char)'\x2',  // XMM2j
  (unsigned char)'\x2',  // XMM2k
  (unsigned char)'\x2',  // XMM2l
  (unsigned char)'\x2',  // XMM2m
  (unsigned char)'\x2',  // XMM2n
  (unsigned char)'\x2',  // XMM2o
  (unsigned char)'\x2',  // XMM2p
  (unsigned char)'\x3',  // XMM3
  (unsigned char)'\x3',  // XMM3b
  (unsigned char)'\x3',  // XMM3c
  (unsigned char)'\x3',  // XMM3d
  (unsigned char)'\x3',  // XMM3e
  (unsigned char)'\x3',  // XMM3f
  (unsigned char)'\x3',  // XMM3g
  (unsigned char)'\x3',  // XMM3h
  (unsigned char)'\x3',  // XMM3i
  (unsigned char)'\x3',  // XMM3j
  (unsigned char)'\x3',  // XMM3k
  (unsigned char)'\x3',  // XMM3l
  (unsigned char)'\x3',  // XMM3m
  (unsigned char)'\x3',  // XMM3n
  (unsigned char)'\x3',  // XMM3o
  (unsigned char)'\x3',  // XMM3p
  (unsigned char)'\x4',  // XMM4
  (unsigned char)'\x4',  // XMM4b
  (unsigned char)'\x4',  // XMM4c
  (unsigned char)'\x4',  // XMM4d
  (unsigned char)'\x4',  // XMM4e
  (unsigned char)'\x4',  // XMM4f
  (unsigned char)'\x4',  // XMM4g
  (unsigned char)'\x4',  // XMM4h
  (unsigned char)'\x4',  // XMM4i
  (unsigned char)'\x4',  // XMM4j
  (unsigned char)'\x4',  // XMM4k
  (unsigned char)'\x4',  // XMM4l
  (unsigned char)'\x4',  // XMM4m
  (unsigned char)'\x4',  // XMM4n
  (unsigned char)'\x4',  // XMM4o
  (unsigned char)'\x4',  // XMM4p
  (unsigned char)'\x5',  // XMM5
  (unsigned char)'\x5',  // XMM5b
  (unsigned char)'\x5',  // XMM5c
  (unsigned char)'\x5',  // XMM5d
  (unsigned char)'\x5',  // XMM5e
  (unsigned char)'\x5',  // XMM5f
  (unsigned char)'\x5',  // XMM5g
  (unsigned char)'\x5',  // XMM5h
  (unsigned char)'\x5',  // XMM5i
  (unsigned char)'\x5',  // XMM5j
  (unsigned char)'\x5',  // XMM5k
  (unsigned char)'\x5',  // XMM5l
  (unsigned char)'\x5',  // XMM5m
  (unsigned char)'\x5',  // XMM5n
  (unsigned char)'\x5',  // XMM5o
  (unsigned char)'\x5',  // XMM5p
  (unsigned char)'\x6',  // XMM6
  (unsigned char)'\x6',  // XMM6b
  (unsigned char)'\x6',  // XMM6c
  (unsigned char)'\x6',  // XMM6d
  (unsigned char)'\x6',  // XMM6e
  (unsigned char)'\x6',  // XMM6f
  (unsigned char)'\x6',  // XMM6g
  (unsigned char)'\x6',  // XMM6h
  (unsigned char)'\x6',  // XMM6i
  (unsigned char)'\x6',  // XMM6j
  (unsigned char)'\x6',  // XMM6k
  (unsigned char)'\x6',  // XMM6l
  (unsigned char)'\x6',  // XMM6m
  (unsigned char)'\x6',  // XMM6n
  (unsigned char)'\x6',  // XMM6o
  (unsigned char)'\x6',  // XMM6p
  (unsigned char)'\x7',  // XMM7
  (unsigned char)'\x7',  // XMM7b
  (unsigned char)'\x7',  // XMM7c
  (unsigned char)'\x7',  // XMM7d
  (unsigned char)'\x7',  // XMM7e
  (unsigned char)'\x7',  // XMM7f
  (unsigned char)'\x7',  // XMM7g
  (unsigned char)'\x7',  // XMM7h
  (unsigned char)'\x7',  // XMM7i
  (unsigned char)'\x7',  // XMM7j
  (unsigned char)'\x7',  // XMM7k
  (unsigned char)'\x7',  // XMM7l
  (unsigned char)'\x7',  // XMM7m
  (unsigned char)'\x7',  // XMM7n
  (unsigned char)'\x7',  // XMM7o
  (unsigned char)'\x7',  // XMM7p
  (unsigned char)'\x8',  // XMM8
  (unsigned char)'\x8',  // XMM8b
  (unsigned char)'\x8',  // XMM8c
  (unsigned char)'\x8',  // XMM8d
  (unsigned char)'\x8',  // XMM8e
  (unsigned char)'\x8',  // XMM8f
  (unsigned char)'\x8',  // XMM8g
  (unsigned char)'\x8',  // XMM8h
  (unsigned char)'\x8',  // XMM8i
  (unsigned char)'\x8',  // XMM8j
  (unsigned char)'\x8',  // XMM8k
  (unsigned char)'\x8',  // XMM8l
  (unsigned char)'\x8',  // XMM8m
  (unsigned char)'\x8',  // XMM8n
  (unsigned char)'\x8',  // XMM8o
  (unsigned char)'\x8',  // XMM8p
  (unsigned char)'\x9',  // XMM9
  (unsigned char)'\x9',  // XMM9b
  (unsigned char)'\x9',  // XMM9c
  (unsigned char)'\x9',  // XMM9d
  (unsigned char)'\x9',  // XMM9e
  (unsigned char)'\x9',  // XMM9f
  (unsigned char)'\x9',  // XMM9g
  (unsigned char)'\x9',  // XMM9h
  (unsigned char)'\x9',  // XMM9i
  (unsigned char)'\x9',  // XMM9j
  (unsigned char)'\x9',  // XMM9k
  (unsigned char)'\x9',  // XMM9l
  (unsigned char)'\x9',  // XMM9m
  (unsigned char)'\x9',  // XMM9n
  (unsigned char)'\x9',  // XMM9o
  (unsigned char)'\x9',  // XMM9p
  (unsigned char)'\xA',  // XMM10
  (unsigned char)'\xA',  // XMM10b
  (unsigned char)'\xA',  // XMM10c
  (unsigned char)'\xA',  // XMM10d
  (unsigned char)'\xA',  // XMM10e
  (unsigned char)'\xA',  // XMM10f
  (unsigned char)'\xA',  // XMM10g
  (unsigned char)'\xA',  // XMM10h
  (unsigned char)'\xA',  // XMM10i
  (unsigned char)'\xA',  // XMM10j
  (unsigned char)'\xA',  // XMM10k
  (unsigned char)'\xA',  // XMM10l
  (unsigned char)'\xA',  // XMM10m
  (unsigned char)'\xA',  // XMM10n
  (unsigned char)'\xA',  // XMM10o
  (unsigned char)'\xA',  // XMM10p
  (unsigned char)'\xB',  // XMM11
  (unsigned char)'\xB',  // XMM11b
  (unsigned char)'\xB',  // XMM11c
  (unsigned char)'\xB',  // XMM11d
  (unsigned char)'\xB',  // XMM11e
  (unsigned char)'\xB',  // XMM11f
  (unsigned char)'\xB',  // XMM11g
  (unsigned char)'\xB',  // XMM11h
  (unsigned char)'\xB',  // XMM11i
  (unsigned char)'\xB',  // XMM11j
  (unsigned char)'\xB',  // XMM11k
  (unsigned char)'\xB',  // XMM11l
  (unsigned char)'\xB',  // XMM11m
  (unsigned char)'\xB',  // XMM11n
  (unsigned char)'\xB',  // XMM11o
  (unsigned char)'\xB',  // XMM11p
  (unsigned char)'\xC',  // XMM12
  (unsigned char)'\xC',  // XMM12b
  (unsigned char)'\xC',  // XMM12c
  (unsigned char)'\xC',  // XMM12d
  (unsigned char)'\xC',  // XMM12e
  (unsigned char)'\xC',  // XMM12f
  (unsigned char)'\xC',  // XMM12g
  (unsigned char)'\xC',  // XMM12h
  (unsigned char)'\xC',  // XMM12i
  (unsigned char)'\xC',  // XMM12j
  (unsigned char)'\xC',  // XMM12k
  (unsigned char)'\xC',  // XMM12l
  (unsigned char)'\xC',  // XMM12m
  (unsigned char)'\xC',  // XMM12n
  (unsigned char)'\xC',  // XMM12o
  (unsigned char)'\xC',  // XMM12p
  (unsigned char)'\xD',  // XMM13
  (unsigned char)'\xD',  // XMM13b
  (unsigned char)'\xD',  // XMM13c
  (unsigned char)'\xD',  // XMM13d
  (unsigned char)'\xD',  // XMM13e
  (unsigned char)'\xD',  // XMM13f
  (unsigned char)'\xD',  // XMM13g
  (unsigned char)'\xD',  // XMM13h
  (unsigned char)'\xD',  // XMM13i
  (unsigned char)'\xD',  // XMM13j
  (unsigned char)'\xD',  // XMM13k
  (unsigned char)'\xD',  // XMM13l
  (unsigned char)'\xD',  // XMM13m
  (unsigned char)'\xD',  // XMM13n
  (unsigned char)'\xD',  // XMM13o
  (unsigned char)'\xD',  // XMM13p
  (unsigned char)'\xE',  // XMM14
  (unsigned char)'\xE',  // XMM14b
  (unsigned char)'\xE',  // XMM14c
  (unsigned char)'\xE',  // XMM14d
  (unsigned char)'\xE',  // XMM14e
  (unsigned char)'\xE',  // XMM14f
  (unsigned char)'\xE',  // XMM14g
  (unsigned char)'\xE',  // XMM14h
  (unsigned char)'\xE',  // XMM14i
  (unsigned char)'\xE',  // XMM14j
  (unsigned char)'\xE',  // XMM14k
  (unsigned char)'\xE',  // XMM14l
  (unsigned char)'\xE',  // XMM14m
  (unsigned char)'\xE',  // XMM14n
  (unsigned char)'\xE',  // XMM14o
  (unsigned char)'\xE',  // XMM14p
  (unsigned char)'\xF',  // XMM15
  (unsigned char)'\xF',  // XMM15b
  (unsigned char)'\xF',  // XMM15c
  (unsigned char)'\xF',  // XMM15d
  (unsigned char)'\xF',  // XMM15e
  (unsigned char)'\xF',  // XMM15f
  (unsigned char)'\xF',  // XMM15g
  (unsigned char)'\xF',  // XMM15h
  (unsigned char)'\xF',  // XMM15i
  (unsigned char)'\xF',  // XMM15j
  (unsigned char)'\xF',  // XMM15k
  (unsigned char)'\xF',  // XMM15l
  (unsigned char)'\xF',  // XMM15m
  (unsigned char)'\xF',  // XMM15n
  (unsigned char)'\xF',  // XMM15o
  (unsigned char)'\xF',  // XMM15p
  (unsigned char)'\x10',  // XMM16
  (unsigned char)'\x10',  // XMM16b
  (unsigned char)'\x10',  // XMM16c
  (unsigned char)'\x10',  // XMM16d
  (unsigned char)'\x10',  // XMM16e
  (unsigned char)'\x10',  // XMM16f
  (unsigned char)'\x10',  // XMM16g
  (unsigned char)'\x10',  // XMM16h
  (unsigned char)'\x10',  // XMM16i
  (unsigned char)'\x10',  // XMM16j
  (unsigned char)'\x10',  // XMM16k
  (unsigned char)'\x10',  // XMM16l
  (unsigned char)'\x10',  // XMM16m
  (unsigned char)'\x10',  // XMM16n
  (unsigned char)'\x10',  // XMM16o
  (unsigned char)'\x10',  // XMM16p
  (unsigned char)'\x11',  // XMM17
  (unsigned char)'\x11',  // XMM17b
  (unsigned char)'\x11',  // XMM17c
  (unsigned char)'\x11',  // XMM17d
  (unsigned char)'\x11',  // XMM17e
  (unsigned char)'\x11',  // XMM17f
  (unsigned char)'\x11',  // XMM17g
  (unsigned char)'\x11',  // XMM17h
  (unsigned char)'\x11',  // XMM17i
  (unsigned char)'\x11',  // XMM17j
  (unsigned char)'\x11',  // XMM17k
  (unsigned char)'\x11',  // XMM17l
  (unsigned char)'\x11',  // XMM17m
  (unsigned char)'\x11',  // XMM17n
  (unsigned char)'\x11',  // XMM17o
  (unsigned char)'\x11',  // XMM17p
  (unsigned char)'\x12',  // XMM18
  (unsigned char)'\x12',  // XMM18b
  (unsigned char)'\x12',  // XMM18c
  (unsigned char)'\x12',  // XMM18d
  (unsigned char)'\x12',  // XMM18e
  (unsigned char)'\x12',  // XMM18f
  (unsigned char)'\x12',  // XMM18g
  (unsigned char)'\x12',  // XMM18h
  (unsigned char)'\x12',  // XMM18i
  (unsigned char)'\x12',  // XMM18j
  (unsigned char)'\x12',  // XMM18k
  (unsigned char)'\x12',  // XMM18l
  (unsigned char)'\x12',  // XMM18m
  (unsigned char)'\x12',  // XMM18n
  (unsigned char)'\x12',  // XMM18o
  (unsigned char)'\x12',  // XMM18p
  (unsigned char)'\x13',  // XMM19
  (unsigned char)'\x13',  // XMM19b
  (unsigned char)'\x13',  // XMM19c
  (unsigned char)'\x13',  // XMM19d
  (unsigned char)'\x13',  // XMM19e
  (unsigned char)'\x13',  // XMM19f
  (unsigned char)'\x13',  // XMM19g
  (unsigned char)'\x13',  // XMM19h
  (unsigned char)'\x13',  // XMM19i
  (unsigned char)'\x13',  // XMM19j
  (unsigned char)'\x13',  // XMM19k
  (unsigned char)'\x13',  // XMM19l
  (unsigned char)'\x13',  // XMM19m
  (unsigned char)'\x13',  // XMM19n
  (unsigned char)'\x13',  // XMM19o
  (unsigned char)'\x13',  // XMM19p
  (unsigned char)'\x14',  // XMM20
  (unsigned char)'\x14',  // XMM20b
  (unsigned char)'\x14',  // XMM20c
  (unsigned char)'\x14',  // XMM20d
  (unsigned char)'\x14',  // XMM20e
  (unsigned char)'\x14',  // XMM20f
  (unsigned char)'\x14',  // XMM20g
  (unsigned char)'\x14',  // XMM20h
  (unsigned char)'\x14',  // XMM20i
  (unsigned char)'\x14',  // XMM20j
  (unsigned char)'\x14',  // XMM20k
  (unsigned char)'\x14',  // XMM20l
  (unsigned char)'\x14',  // XMM20m
  (unsigned char)'\x14',  // XMM20n
  (unsigned char)'\x14',  // XMM20o
  (unsigned char)'\x14',  // XMM20p
  (unsigned char)'\x15',  // XMM21
  (unsigned char)'\x15',  // XMM21b
  (unsigned char)'\x15',  // XMM21c
  (unsigned char)'\x15',  // XMM21d
  (unsigned char)'\x15',  // XMM21e
  (unsigned char)'\x15',  // XMM21f
  (unsigned char)'\x15',  // XMM21g
  (unsigned char)'\x15',  // XMM21h
  (unsigned char)'\x15',  // XMM21i
  (unsigned char)'\x15',  // XMM21j
  (unsigned char)'\x15',  // XMM21k
  (unsigned char)'\x15',  // XMM21l
  (unsigned char)'\x15',  // XMM21m
  (unsigned char)'\x15',  // XMM21n
  (unsigned char)'\x15',  // XMM21o
  (unsigned char)'\x15',  // XMM21p
  (unsigned char)'\x16',  // XMM22
  (unsigned char)'\x16',  // XMM22b
  (unsigned char)'\x16',  // XMM22c
  (unsigned char)'\x16',  // XMM22d
  (unsigned char)'\x16',  // XMM22e
  (unsigned char)'\x16',  // XMM22f
  (unsigned char)'\x16',  // XMM22g
  (unsigned char)'\x16',  // XMM22h
  (unsigned char)'\x16',  // XMM22i
  (unsigned char)'\x16',  // XMM22j
  (unsigned char)'\x16',  // XMM22k
  (unsigned char)'\x16',  // XMM22l
  (unsigned char)'\x16',  // XMM22m
  (unsigned char)'\x16',  // XMM22n
  (unsigned char)'\x16',  // XMM22o
  (unsigned char)'\x16',  // XMM22p
  (unsigned char)'\x17',  // XMM23
  (unsigned char)'\x17',  // XMM23b
  (unsigned char)'\x17',  // XMM23c
  (unsigned char)'\x17',  // XMM23d
  (unsigned char)'\x17',  // XMM23e
  (unsigned char)'\x17',  // XMM23f
  (unsigned char)'\x17',  // XMM23g
  (unsigned char)'\x17',  // XMM23h
  (unsigned char)'\x17',  // XMM23i
  (unsigned char)'\x17',  // XMM23j
  (unsigned char)'\x17',  // XMM23k
  (unsigned char)'\x17',  // XMM23l
  (unsigned char)'\x17',  // XMM23m
  (unsigned char)'\x17',  // XMM23n
  (unsigned char)'\x17',  // XMM23o
  (unsigned char)'\x17',  // XMM23p
  (unsigned char)'\x18',  // XMM24
  (unsigned char)'\x18',  // XMM24b
  (unsigned char)'\x18',  // XMM24c
  (unsigned char)'\x18',  // XMM24d
  (unsigned char)'\x18',  // XMM24e
  (unsigned char)'\x18',  // XMM24f
  (unsigned char)'\x18',  // XMM24g
  (unsigned char)'\x18',  // XMM24h
  (unsigned char)'\x18',  // XMM24i
  (unsigned char)'\x18',  // XMM24j
  (unsigned char)'\x18',  // XMM24k
  (unsigned char)'\x18',  // XMM24l
  (unsigned char)'\x18',  // XMM24m
  (unsigned char)'\x18',  // XMM24n
  (unsigned char)'\x18',  // XMM24o
  (unsigned char)'\x18',  // XMM24p
  (unsigned char)'\x19',  // XMM25
  (unsigned char)'\x19',  // XMM25b
  (unsigned char)'\x19',  // XMM25c
  (unsigned char)'\x19',  // XMM25d
  (unsigned char)'\x19',  // XMM25e
  (unsigned char)'\x19',  // XMM25f
  (unsigned char)'\x19',  // XMM25g
  (unsigned char)'\x19',  // XMM25h
  (unsigned char)'\x19',  // XMM25i
  (unsigned char)'\x19',  // XMM25j
  (unsigned char)'\x19',  // XMM25k
  (unsigned char)'\x19',  // XMM25l
  (unsigned char)'\x19',  // XMM25m
  (unsigned char)'\x19',  // XMM25n
  (unsigned char)'\x19',  // XMM25o
  (unsigned char)'\x19',  // XMM25p
  (unsigned char)'\x1A',  // XMM26
  (unsigned char)'\x1A',  // XMM26b
  (unsigned char)'\x1A',  // XMM26c
  (unsigned char)'\x1A',  // XMM26d
  (unsigned char)'\x1A',  // XMM26e
  (unsigned char)'\x1A',  // XMM26f
  (unsigned char)'\x1A',  // XMM26g
  (unsigned char)'\x1A',  // XMM26h
  (unsigned char)'\x1A',  // XMM26i
  (unsigned char)'\x1A',  // XMM26j
  (unsigned char)'\x1A',  // XMM26k
  (unsigned char)'\x1A',  // XMM26l
  (unsigned char)'\x1A',  // XMM26m
  (unsigned char)'\x1A',  // XMM26n
  (unsigned char)'\x1A',  // XMM26o
  (unsigned char)'\x1A',  // XMM26p
  (unsigned char)'\x1B',  // XMM27
  (unsigned char)'\x1B',  // XMM27b
  (unsigned char)'\x1B',  // XMM27c
  (unsigned char)'\x1B',  // XMM27d
  (unsigned char)'\x1B',  // XMM27e
  (unsigned char)'\x1B',  // XMM27f
  (unsigned char)'\x1B',  // XMM27g
  (unsigned char)'\x1B',  // XMM27h
  (unsigned char)'\x1B',  // XMM27i
  (unsigned char)'\x1B',  // XMM27j
  (unsigned char)'\x1B',  // XMM27k
  (unsigned char)'\x1B',  // XMM27l
  (unsigned char)'\x1B',  // XMM27m
  (unsigned char)'\x1B',  // XMM27n
  (unsigned char)'\x1B',  // XMM27o
  (unsigned char)'\x1B',  // XMM27p
  (unsigned char)'\x1C',  // XMM28
  (unsigned char)'\x1C',  // XMM28b
  (unsigned char)'\x1C',  // XMM28c
  (unsigned char)'\x1C',  // XMM28d
  (unsigned char)'\x1C',  // XMM28e
  (unsigned char)'\x1C',  // XMM28f
  (unsigned char)'\x1C',  // XMM28g
  (unsigned char)'\x1C',  // XMM28h
  (unsigned char)'\x1C',  // XMM28i
  (unsigned char)'\x1C',  // XMM28j
  (unsigned char)'\x1C',  // XMM28k
  (unsigned char)'\x1C',  // XMM28l
  (unsigned char)'\x1C',  // XMM28m
  (unsigned char)'\x1C',  // XMM28n
  (unsigned char)'\x1C',  // XMM28o
  (unsigned char)'\x1C',  // XMM28p
  (unsigned char)'\x1D',  // XMM29
  (unsigned char)'\x1D',  // XMM29b
  (unsigned char)'\x1D',  // XMM29c
  (unsigned char)'\x1D',  // XMM29d
  (unsigned char)'\x1D',  // XMM29e
  (unsigned char)'\x1D',  // XMM29f
  (unsigned char)'\x1D',  // XMM29g
  (unsigned char)'\x1D',  // XMM29h
  (unsigned char)'\x1D',  // XMM29i
  (unsigned char)'\x1D',  // XMM29j
  (unsigned char)'\x1D',  // XMM29k
  (unsigned char)'\x1D',  // XMM29l
  (unsigned char)'\x1D',  // XMM29m
  (unsigned char)'\x1D',  // XMM29n
  (unsigned char)'\x1D',  // XMM29o
  (unsigned char)'\x1D',  // XMM29p
  (unsigned char)'\x1E',  // XMM30
  (unsigned char)'\x1E',  // XMM30b
  (unsigned char)'\x1E',  // XMM30c
  (unsigned char)'\x1E',  // XMM30d
  (unsigned char)'\x1E',  // XMM30e
  (unsigned char)'\x1E',  // XMM30f
  (unsigned char)'\x1E',  // XMM30g
  (unsigned char)'\x1E',  // XMM30h
  (unsigned char)'\x1E',  // XMM30i
  (unsigned char)'\x1E',  // XMM30j
  (unsigned char)'\x1E',  // XMM30k
  (unsigned char)'\x1E',  // XMM30l
  (unsigned char)'\x1E',  // XMM30m
  (unsigned char)'\x1E',  // XMM30n
  (unsigned char)'\x1E',  // XMM30o
  (unsigned char)'\x1E',  // XMM30p
  (unsigned char)'\x1F',  // XMM31
  (unsigned char)'\x1F',  // XMM31b
  (unsigned char)'\x1F',  // XMM31c
  (unsigned char)'\x1F',  // XMM31d
  (unsigned char)'\x1F',  // XMM31e
  (unsigned char)'\x1F',  // XMM31f
  (unsigned char)'\x1F',  // XMM31g
  (unsigned char)'\x1F',  // XMM31h
  (unsigned char)'\x1F',  // XMM31i
  (unsigned char)'\x1F',  // XMM31j
  (unsigned char)'\x1F',  // XMM31k
  (unsigned char)'\x1F',  // XMM31l
  (unsigned char)'\x1F',  // XMM31m
  (unsigned char)'\x1F',  // XMM31n
  (unsigned char)'\x1F',  // XMM31o
  (unsigned char)'\x1F',  // XMM31p
  (unsigned char)'\x10' // no trailing comma  // RFLAGS
};


//------------------Define classes derived from MachOper---------------------
MachOper  *labelOper::clone() const {
  return  new labelOper(_label, _block_num);
}
uint labelOper::opcode() const { return LABEL; }

const RegMask *sRegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *sRegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *sRegFOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *sRegDOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *sRegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

MachOper  *methodOper::clone() const {
  return  new methodOper(_method);
}
uint methodOper::opcode() const { return METHOD; }

const RegMask *rRegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_REG_mask();
}

const RegMask *rax_RegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_RAX_REG_mask();
}

const RegMask *rbx_RegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_RBX_REG_mask();
}

const RegMask *rcx_RegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_RCX_REG_mask();
}

const RegMask *rdx_RegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_RDX_REG_mask();
}

const RegMask *rdi_RegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_RDI_REG_mask();
}

const RegMask *no_rcx_RegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_NO_RCX_REG_mask();
}

const RegMask *no_rax_rdx_RegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_NO_RAX_RDX_REG_mask();
}

const RegMask *any_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &ANY_REG_mask();
}

const RegMask *rRegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

const RegMask *rRegNOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_REG_mask();
}

const RegMask *no_rax_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_NO_RAX_REG_mask();
}

const RegMask *no_rbp_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_NO_RBP_mask();
}

const RegMask *no_rax_rbx_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_NO_RAX_RBX_REG_mask();
}

const RegMask *rax_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_RAX_REG_mask();
}

const RegMask *rax_RegNOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_RAX_REG_mask();
}

const RegMask *rbx_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_RBX_REG_mask();
}

const RegMask *rsi_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_RSI_REG_mask();
}

const RegMask *rdi_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_RDI_REG_mask();
}

const RegMask *r15_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_R15_REG_mask();
}

const RegMask *rex_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REX_REG_mask();
}

const RegMask *rRegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &LONG_REG_mask();
}

const RegMask *no_rax_rdx_RegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &LONG_NO_RAX_RDX_REG_mask();
}

const RegMask *no_rax_RegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &LONG_NO_RAX_RDX_REG_mask();
}

const RegMask *no_rcx_RegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &LONG_NO_RCX_REG_mask();
}

const RegMask *rax_RegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &LONG_RAX_REG_mask();
}

const RegMask *rcx_RegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &LONG_RCX_REG_mask();
}

const RegMask *rdx_RegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &LONG_RDX_REG_mask();
}

const RegMask *rFlagsRegOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_FLAGS_mask();
}

const RegMask *rFlagsRegUOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_FLAGS_mask();
}

const RegMask *rFlagsRegUCFOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_FLAGS_mask();
}

const RegMask *regFOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &FLOAT_REG_mask();
}

const RegMask *regDOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &DOUBLE_REG_mask();
}

const RegMask *vecSOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &VECTORS_REG_mask();
}

const RegMask *vecDOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &VECTORD_REG_mask();
}

const RegMask *vecXOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &VECTORX_REG_mask();
}

const RegMask *vecYOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &VECTORY_REG_mask();
}

const RegMask *indirectOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask();
}

const RegMask *indOffset8Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &ANY_REG_mask();
}

const RegMask *indOffset32Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &ANY_REG_mask();
}

const RegMask *indIndexOffsetOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &ANY_REG_mask();
  case 1: return &LONG_REG_mask();
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indIndexOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &ANY_REG_mask();
  case 1: return &LONG_REG_mask();
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indIndexScaleOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &ANY_REG_mask();
  case 1: return &LONG_REG_mask();
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indPosIndexScaleOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &ANY_REG_mask();
  case 1: return &INT_REG_mask();
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indIndexScaleOffsetOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &ANY_REG_mask();
  case 1: return &LONG_REG_mask();
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indPosIndexOffsetOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &ANY_REG_mask();
  case 1: return &INT_REG_mask();
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indPosIndexScaleOffsetOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &ANY_REG_mask();
  case 1: return &INT_REG_mask();
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indCompressedOopOffsetOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_REG_mask();
}

const RegMask *indirectNarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_REG_mask();
}

const RegMask *indOffset8NarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_REG_mask();
}

const RegMask *indOffset32NarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_REG_mask();
}

const RegMask *indIndexOffsetNarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &INT_REG_mask();
  case 1: return &LONG_REG_mask();
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indIndexNarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &INT_REG_mask();
  case 1: return &LONG_REG_mask();
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indIndexScaleNarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &INT_REG_mask();
  case 1: return &LONG_REG_mask();
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indIndexScaleOffsetNarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &INT_REG_mask();
  case 1: return &LONG_REG_mask();
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indPosIndexOffsetNarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  return &INT_REG_mask();
}

const RegMask *indPosIndexScaleOffsetNarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  return &INT_REG_mask();
}

const RegMask *stackSlotPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *stackSlotIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *stackSlotFOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *stackSlotDOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *stackSlotLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *rxmm0Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM0_REG_mask();
}

const RegMask *rxmm1Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM1_REG_mask();
}

const RegMask *rxmm2Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM2_REG_mask();
}

const RegMask *rxmm3Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM3_REG_mask();
}

const RegMask *rxmm4Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM4_REG_mask();
}

const RegMask *rxmm5Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM5_REG_mask();
}

const RegMask *rxmm6Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM6_REG_mask();
}

const RegMask *rxmm7Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM7_REG_mask();
}

const RegMask *rxmm8Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM8_REG_mask();
}

const RegMask *rxmm9Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM9_REG_mask();
}

const RegMask *rxmm10Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM10_REG_mask();
}

const RegMask *rxmm11Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM11_REG_mask();
}

const RegMask *rxmm12Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM12_REG_mask();
}

const RegMask *rxmm13Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM13_REG_mask();
}

const RegMask *rxmm14Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM14_REG_mask();
}

const RegMask *rxmm15Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM15_REG_mask();
}

const RegMask *rxmm16Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM16_REG_mask();
}

const RegMask *rxmm17Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM17_REG_mask();
}

const RegMask *rxmm18Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM18_REG_mask();
}

const RegMask *rxmm19Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM19_REG_mask();
}

const RegMask *rxmm20Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM20_REG_mask();
}

const RegMask *rxmm21Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM21_REG_mask();
}

const RegMask *rxmm22Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM22_REG_mask();
}

const RegMask *rxmm23Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM23_REG_mask();
}

const RegMask *rxmm24Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM24_REG_mask();
}

const RegMask *rxmm25Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM25_REG_mask();
}

const RegMask *rxmm26Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM26_REG_mask();
}

const RegMask *rxmm27Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM27_REG_mask();
}

const RegMask *rxmm28Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM28_REG_mask();
}

const RegMask *rxmm29Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM29_REG_mask();
}

const RegMask *rxmm30Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM30_REG_mask();
}

const RegMask *rxmm31Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &XMM31_REG_mask();
}

const RegMask *vecZOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &VECTORZ_REG_mask();
}

//------------------Define members for classes derived from MachNode----------

void popCountINode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *popCountINode::cisc_version(int offset) {
  popCountI_memNode *node = new popCountI_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void popCountLNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *popCountLNode::cisc_version(int offset) {
  popCountL_memNode *node = new popCountL_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void cmovI_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *cmovI_regNode::cisc_version(int offset) {
  cmovI_memNode *node = new cmovI_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void cmovI_regUNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *cmovI_regUNode::cisc_version(int offset) {
  cmovI_memUNode *node = new cmovI_memUNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void cmovI_regUCFNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *cmovI_regUCFNode::cisc_version(int offset) {
  cmovI_memUCFNode *node = new cmovI_memUCFNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void cmovL_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *cmovL_regNode::cisc_version(int offset) {
  cmovL_memNode *node = new cmovL_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void cmovL_regUNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *cmovL_regUNode::cisc_version(int offset) {
  cmovL_memUNode *node = new cmovL_memUNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void cmovL_regUCFNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *cmovL_regUCFNode::cisc_version(int offset) {
  cmovL_memUCFNode *node = new cmovL_memUCFNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void addI_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *addI_rRegNode::cisc_version(int offset) {
  addI_rReg_memNode *node = new addI_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void addL_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *addL_rRegNode::cisc_version(int offset) {
  addL_rReg_memNode *node = new addL_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void subI_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *subI_rRegNode::cisc_version(int offset) {
  subI_rReg_memNode *node = new subI_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void subL_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *subL_rRegNode::cisc_version(int offset) {
  subL_rReg_memNode *node = new subL_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void mulI_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *mulI_rRegNode::cisc_version(int offset) {
  mulI_memNode *node = new mulI_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void mulI_rReg_immNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *mulI_rReg_immNode::cisc_version(int offset) {
  mulI_mem_immNode *node = new mulI_mem_immNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void mulL_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *mulL_rRegNode::cisc_version(int offset) {
  mulL_memNode *node = new mulL_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void mulL_rReg_immNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *mulL_rReg_immNode::cisc_version(int offset) {
  mulL_mem_immNode *node = new mulL_mem_immNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void i2bNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *i2bNode::cisc_version(int offset) {
  loadI2BNode *node = new loadI2BNode();
  node->_num_opnds = 3;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void i2sNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *i2sNode::cisc_version(int offset) {
  loadI2SNode *node = new loadI2SNode();
  node->_num_opnds = 3;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void andI_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *andI_rRegNode::cisc_version(int offset) {
  andI_rReg_memNode *node = new andI_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void andI2L_rReg_imm255Node::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *andI2L_rReg_imm255Node::cisc_version(int offset) {
  loadI2L_immI_255Node *node = new loadI2L_immI_255Node();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void andI2L_rReg_imm65535Node::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *andI2L_rReg_imm65535Node::cisc_version(int offset) {
  loadI2L_immI_65535Node *node = new loadI2L_immI_65535Node();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void andnI_rReg_rReg_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *andnI_rReg_rReg_rRegNode::cisc_version(int offset) {
  andnI_rReg_rReg_memNode *node = new andnI_rReg_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void andnI_rReg_rReg_rReg_0Node::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *andnI_rReg_rReg_rReg_0Node::cisc_version(int offset) {
  andnI_rReg_rReg_mem_0Node *node = new andnI_rReg_rReg_mem_0Node();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void orI_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *orI_rRegNode::cisc_version(int offset) {
  orI_rReg_memNode *node = new orI_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void xorI_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *xorI_rRegNode::cisc_version(int offset) {
  xorI_rReg_memNode *node = new xorI_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void andL_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *andL_rRegNode::cisc_version(int offset) {
  andL_rReg_memNode *node = new andL_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void andnL_rReg_rReg_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *andnL_rReg_rReg_rRegNode::cisc_version(int offset) {
  andnL_rReg_rReg_memNode *node = new andnL_rReg_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void andnL_rReg_rReg_rReg_0Node::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *andnL_rReg_rReg_rReg_0Node::cisc_version(int offset) {
  andnL_rReg_rReg_mem_0Node *node = new andnL_rReg_rReg_mem_0Node();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void orL_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *orL_rRegNode::cisc_version(int offset) {
  orL_rReg_memNode *node = new orL_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void xorL_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *xorL_rRegNode::cisc_version(int offset) {
  xorL_rReg_memNode *node = new xorL_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void cmpF_cc_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *cmpF_cc_regNode::cisc_version(int offset) {
  cmpF_cc_memNode *node = new cmpF_cc_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void cmpF_cc_reg_CFNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *cmpF_cc_reg_CFNode::cisc_version(int offset) {
  cmpF_cc_memCFNode *node = new cmpF_cc_memCFNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void cmpD_cc_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *cmpD_cc_regNode::cisc_version(int offset) {
  cmpD_cc_memNode *node = new cmpD_cc_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void cmpD_cc_reg_CFNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *cmpD_cc_reg_CFNode::cisc_version(int offset) {
  cmpD_cc_memCFNode *node = new cmpD_cc_memCFNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void cmpF_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *cmpF_regNode::cisc_version(int offset) {
  cmpF_memNode *node = new cmpF_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void cmpD_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *cmpD_regNode::cisc_version(int offset) {
  cmpD_memNode *node = new cmpD_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void convF2D_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *convF2D_reg_regNode::cisc_version(int offset) {
  convF2D_reg_memNode *node = new convF2D_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void convD2F_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *convD2F_reg_regNode::cisc_version(int offset) {
  convD2F_reg_memNode *node = new convD2F_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void convL2F_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *convL2F_reg_regNode::cisc_version(int offset) {
  convL2F_reg_memNode *node = new convL2F_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void convL2D_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *convL2D_reg_regNode::cisc_version(int offset) {
  convL2D_reg_memNode *node = new convL2D_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void convI2L_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *convI2L_reg_regNode::cisc_version(int offset) {
  loadI2LNode *node = new loadI2LNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void convI2L_reg_reg_zexNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *convI2L_reg_reg_zexNode::cisc_version(int offset) {
  loadUI2LNode *node = new loadUI2LNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void MoveF2I_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *MoveF2I_reg_regNode::cisc_version(int offset) {
  MoveF2I_stack_regNode *node = new MoveF2I_stack_regNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void MoveD2L_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *MoveD2L_reg_regNode::cisc_version(int offset) {
  MoveD2L_stack_regNode *node = new MoveD2L_stack_regNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void MoveI2F_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *MoveI2F_reg_regNode::cisc_version(int offset) {
  MoveI2F_stack_regNode *node = new MoveI2F_stack_regNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void compI_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *compI_rRegNode::cisc_version(int offset) {
  compI_rReg_memNode *node = new compI_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void compU_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *compU_rRegNode::cisc_version(int offset) {
  compU_rReg_memNode *node = new compU_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void compP_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_PTR_REG_mask();
}

// Build CISC version of this instruction
MachNode *compP_rRegNode::cisc_version(int offset) {
  compP_rReg_memNode *node = new compP_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void compL_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *compL_rRegNode::cisc_version(int offset) {
  compL_rReg_memNode *node = new compL_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void compUL_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *compUL_rRegNode::cisc_version(int offset) {
  compUL_rReg_memNode *node = new compUL_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}

// Build short branch version of this instruction
MachNode *jmpDirNode::short_branch_version() {
  jmpDir_shortNode *node = new jmpDir_shortNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  return node;
}

// Build short branch version of this instruction
MachNode *jmpConNode::short_branch_version() {
  jmpCon_shortNode *node = new jmpCon_shortNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  return node;
}

// Build short branch version of this instruction
MachNode *jmpLoopEndNode::short_branch_version() {
  jmpLoopEnd_shortNode *node = new jmpLoopEnd_shortNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  return node;
}

// Build short branch version of this instruction
MachNode *jmpLoopEndUNode::short_branch_version() {
  jmpLoopEndU_shortNode *node = new jmpLoopEndU_shortNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  return node;
}

// Build short branch version of this instruction
MachNode *jmpLoopEndUCFNode::short_branch_version() {
  jmpLoopEndUCF_shortNode *node = new jmpLoopEndUCF_shortNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  return node;
}

// Build short branch version of this instruction
MachNode *jmpConUNode::short_branch_version() {
  jmpConU_shortNode *node = new jmpConU_shortNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  return node;
}

// Build short branch version of this instruction
MachNode *jmpConUCFNode::short_branch_version() {
  jmpConUCF_shortNode *node = new jmpConUCF_shortNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  return node;
}

// Build short branch version of this instruction
MachNode *jmpConUCF2Node::short_branch_version() {
  jmpConUCF2_shortNode *node = new jmpConUCF2_shortNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  return node;
}


void addF_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *addF_regNode::cisc_version(int offset) {
  addF_memNode *node = new addF_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void addF_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *addF_reg_regNode::cisc_version(int offset) {
  addF_reg_memNode *node = new addF_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void addD_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *addD_regNode::cisc_version(int offset) {
  addD_memNode *node = new addD_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void addD_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *addD_reg_regNode::cisc_version(int offset) {
  addD_reg_memNode *node = new addD_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void subF_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *subF_regNode::cisc_version(int offset) {
  subF_memNode *node = new subF_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void subF_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *subF_reg_regNode::cisc_version(int offset) {
  subF_reg_memNode *node = new subF_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void subD_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *subD_regNode::cisc_version(int offset) {
  subD_memNode *node = new subD_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void subD_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *subD_reg_regNode::cisc_version(int offset) {
  subD_reg_memNode *node = new subD_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void mulF_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *mulF_regNode::cisc_version(int offset) {
  mulF_memNode *node = new mulF_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void mulF_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *mulF_reg_regNode::cisc_version(int offset) {
  mulF_reg_memNode *node = new mulF_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void mulD_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *mulD_regNode::cisc_version(int offset) {
  mulD_memNode *node = new mulD_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void mulD_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *mulD_reg_regNode::cisc_version(int offset) {
  mulD_reg_memNode *node = new mulD_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void divF_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *divF_regNode::cisc_version(int offset) {
  divF_memNode *node = new divF_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void divF_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *divF_reg_regNode::cisc_version(int offset) {
  divF_reg_memNode *node = new divF_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void divD_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *divD_regNode::cisc_version(int offset) {
  divD_memNode *node = new divD_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void divD_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *divD_reg_regNode::cisc_version(int offset) {
  divD_reg_memNode *node = new divD_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void sqrtF_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *sqrtF_regNode::cisc_version(int offset) {
  sqrtF_memNode *node = new sqrtF_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void sqrtD_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *sqrtD_regNode::cisc_version(int offset) {
  sqrtD_memNode *node = new sqrtD_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void Repl8INode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *Repl8INode::cisc_version(int offset) {
  Repl8I_memNode *node = new Repl8I_memNode();
  node->_bottom_type = bottom_type();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void Repl4LNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *Repl4LNode::cisc_version(int offset) {
  Repl4L_memNode *node = new Repl4L_memNode();
  node->_bottom_type = bottom_type();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void Repl8FNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *Repl8FNode::cisc_version(int offset) {
  Repl8F_memNode *node = new Repl8F_memNode();
  node->_bottom_type = bottom_type();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void Repl4DNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *Repl4DNode::cisc_version(int offset) {
  Repl4D_memNode *node = new Repl4D_memNode();
  node->_bottom_type = bottom_type();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void Repl2INode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *Repl2INode::cisc_version(int offset) {
  Repl2I_memNode *node = new Repl2I_memNode();
  node->_bottom_type = bottom_type();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void Repl4I_evexNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *Repl4I_evexNode::cisc_version(int offset) {
  Repl4I_mem_evexNode *node = new Repl4I_mem_evexNode();
  node->_bottom_type = bottom_type();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void Repl8I_evexNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *Repl8I_evexNode::cisc_version(int offset) {
  Repl8I_mem_evexNode *node = new Repl8I_mem_evexNode();
  node->_bottom_type = bottom_type();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void Repl16I_evexNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask();
}

// Build CISC version of this instruction
MachNode *Repl16I_evexNode::cisc_version(int offset) {
  Repl16I_mem_evexNode *node = new Repl16I_mem_evexNode();
  node->_bottom_type = bottom_type();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void Repl4L_evexNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *Repl4L_evexNode::cisc_version(int offset) {
  Repl4L_mem_evexNode *node = new Repl4L_mem_evexNode();
  node->_bottom_type = bottom_type();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void Repl8L_evexNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask();
}

// Build CISC version of this instruction
MachNode *Repl8L_evexNode::cisc_version(int offset) {
  Repl8L_mem_evexNode *node = new Repl8L_mem_evexNode();
  node->_bottom_type = bottom_type();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void Repl8F_evexNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *Repl8F_evexNode::cisc_version(int offset) {
  Repl8F_mem_evexNode *node = new Repl8F_mem_evexNode();
  node->_bottom_type = bottom_type();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void Repl16F_evexNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask();
}

// Build CISC version of this instruction
MachNode *Repl16F_evexNode::cisc_version(int offset) {
  Repl16F_mem_evexNode *node = new Repl16F_mem_evexNode();
  node->_bottom_type = bottom_type();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void Repl4D_evexNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *Repl4D_evexNode::cisc_version(int offset) {
  Repl4D_mem_evexNode *node = new Repl4D_mem_evexNode();
  node->_bottom_type = bottom_type();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


void Repl8D_evexNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask();
}

// Build CISC version of this instruction
MachNode *Repl8D_evexNode::cisc_version(int offset) {
  Repl8D_mem_evexNode *node = new Repl8D_mem_evexNode();
  node->_bottom_type = bottom_type();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new indOffset32Oper(offset));

  return node;
}


// Copy _idx, inputs and operands to new node
void MachNode::fill_new_machnode(MachNode* node) const {
  // New node must use same node index
  node->set_idx( _idx );
  // Copy machine-independent inputs
  for( uint j = 0; j < req(); j++ ) {
    node->add_req(in(j));
  }
  // Copy my operands, except for cisc position
  int nopnds = num_opnds();
  assert( node->num_opnds() == (uint)nopnds, "Must have same number of operands");
  MachOper **to = node->_opnds;
  for( int i = 0; i < nopnds; i++ ) {
    if( i != cisc_operand() ) 
      to[i] = _opnds[i]->clone();
  }
}

void jmpDirNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(1));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpDirNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(1));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpConNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpConNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpLoopEndNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpLoopEndNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpLoopEndUNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpLoopEndUNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpLoopEndUCFNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpLoopEndUCFNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpLoopEnd_and_restoreMaskNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpLoopEnd_and_restoreMaskNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpLoopEndU_and_restoreMaskNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpLoopEndU_and_restoreMaskNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpLoopEndUCF_and_restoreMaskNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpLoopEndUCF_and_restoreMaskNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpConUNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpConUNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpConUCFNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpConUCFNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpConUCF2Node::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpConUCF2Node::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpDir_shortNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(1));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpDir_shortNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(1));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpCon_shortNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpCon_shortNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpLoopEnd_shortNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpLoopEnd_shortNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpLoopEndU_shortNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpLoopEndU_shortNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpLoopEndUCF_shortNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpLoopEndUCF_shortNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpConU_shortNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpConU_shortNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpConUCF_shortNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpConUCF_shortNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void jmpConUCF2_shortNode::label_set( Label* label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = label;
  oper->_block_num = block_num;
}
void jmpConUCF2_shortNode::save_label( Label** label, uint* block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  *label = oper->_label;
  *block_num = oper->_block_num;
}
void CallStaticJavaDirectNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

void CallDynamicJavaDirectNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

void CallRuntimeDirectNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

void CallLeafDirectNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

void CallLeafNoFPDirectNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

int loadBNode::reloc() const {
  return 1;
}

int loadB2LNode::reloc() const {
  return 1;
}

int loadUBNode::reloc() const {
  return 1;
}

int loadUB2LNode::reloc() const {
  return 1;
}

int loadUB2L_immINode::reloc() const {
  return 1;
}

int loadSNode::reloc() const {
  return 1;
}

int loadS2BNode::reloc() const {
  return 1;
}

int loadS2LNode::reloc() const {
  return 1;
}

int loadUSNode::reloc() const {
  return 1;
}

int loadUS2BNode::reloc() const {
  return 1;
}

int loadUS2LNode::reloc() const {
  return 1;
}

int loadUS2L_immI_255Node::reloc() const {
  return 1;
}

int loadUS2L_immINode::reloc() const {
  return 1;
}

int loadINode::reloc() const {
  return 1;
}

int loadI2BNode::reloc() const {
  return 1;
}

int loadI2UBNode::reloc() const {
  return 1;
}

int loadI2SNode::reloc() const {
  return 1;
}

int loadI2USNode::reloc() const {
  return 1;
}

int loadI2LNode::reloc() const {
  return 1;
}

int loadI2L_immI_255Node::reloc() const {
  return 1;
}

int loadI2L_immI_65535Node::reloc() const {
  return 1;
}

int loadI2L_immU31Node::reloc() const {
  return 1;
}

int loadUI2LNode::reloc() const {
  return 1;
}

int loadLNode::reloc() const {
  return 1;
}

int loadRangeNode::reloc() const {
  return 1;
}

int loadPNode::reloc() const {
  return 1;
}

int loadNNode::reloc() const {
  return 1;
}

int loadKlassNode::reloc() const {
  return 1;
}

int loadNKlassNode::reloc() const {
  return 1;
}

int loadFNode::reloc() const {
  return 1;
}

int loadD_partialNode::reloc() const {
  return 1;
}

int loadDNode::reloc() const {
  return 1;
}

int loadConPNode::reloc() const {
  return 1;
}

int loadConP0Node::reloc() const {
  return 1;
}

int loadConP31Node::reloc() const {
  return 1;
}

int loadConFNode::reloc() const {
  return 2;
}

int loadConF0Node::reloc() const {
  return 2;
}

int loadConDNode::reloc() const {
  return 2;
}

int loadConD0Node::reloc() const {
  return 2;
}

int prefetchAllocNode::reloc() const {
  return 1;
}

int prefetchAllocNTANode::reloc() const {
  return 1;
}

int prefetchAllocT0Node::reloc() const {
  return 1;
}

int prefetchAllocT2Node::reloc() const {
  return 1;
}

int storeBNode::reloc() const {
  return 2;
}

int storeCNode::reloc() const {
  return 2;
}

int storeINode::reloc() const {
  return 2;
}

int storeLNode::reloc() const {
  return 2;
}

int storePNode::reloc() const {
  return 2;
}

int storeImmP0Node::reloc() const {
  return 3;
}

int storeImmPNode::reloc() const {
  return 3;
}

int storeNNode::reloc() const {
  return 2;
}

int storeNKlassNode::reloc() const {
  return 2;
}

int storeImmN0Node::reloc() const {
  return 2;
}

int storeImmNNode::reloc() const {
  return 2;
}

int storeImmNKlassNode::reloc() const {
  return 2;
}

int storeImmI0Node::reloc() const {
  return 2;
}

int storeImmINode::reloc() const {
  return 2;
}

int storeImmL0Node::reloc() const {
  return 2;
}

int storeImmLNode::reloc() const {
  return 2;
}

int storeImmC0Node::reloc() const {
  return 2;
}

int storeImmI16Node::reloc() const {
  return 2;
}

int storeImmB0Node::reloc() const {
  return 2;
}

int storeImmBNode::reloc() const {
  return 2;
}

int storeImmCM0_regNode::reloc() const {
  return 2;
}

int storeImmCM0Node::reloc() const {
  return 2;
}

int storeFNode::reloc() const {
  return 2;
}

int storeF0Node::reloc() const {
  return 3;
}

int storeF_immNode::reloc() const {
  return 3;
}

int storeDNode::reloc() const {
  return 2;
}

int storeD0_immNode::reloc() const {
  return 3;
}

int storeD0Node::reloc() const {
  return 3;
}

int popCountI_memNode::reloc() const {
  return 1;
}

int popCountL_memNode::reloc() const {
  return 1;
}

int cmovI_memNode::reloc() const {
  return 1;
}

int cmovI_memUNode::reloc() const {
  return 1;
}

int cmovI_memUCFNode::reloc() const {
  return 1;
}

int cmovL_memNode::reloc() const {
  return 1;
}

int cmovL_memUNode::reloc() const {
  return 1;
}

int cmovL_memUCFNode::reloc() const {
  return 1;
}

int addI_rReg_memNode::reloc() const {
  return 1;
}

int addI_rReg_mem_0Node::reloc() const {
  return 1;
}

int addI_mem_rRegNode::reloc() const {
  return 3;
}

int addI_mem_rReg_0Node::reloc() const {
  return 3;
}

int addI_mem_immNode::reloc() const {
  return 3;
}

int incI_memNode::reloc() const {
  return 3;
}

int decI_memNode::reloc() const {
  return 3;
}

int addL_rReg_memNode::reloc() const {
  return 1;
}

int addL_rReg_mem_0Node::reloc() const {
  return 1;
}

int addL_mem_rRegNode::reloc() const {
  return 3;
}

int addL_mem_rReg_0Node::reloc() const {
  return 3;
}

int addL_mem_immNode::reloc() const {
  return 3;
}

int incL_memNode::reloc() const {
  return 3;
}

int decL_memNode::reloc() const {
  return 3;
}

int loadPLockedNode::reloc() const {
  return 1;
}

int storePConditionalNode::reloc() const {
  return 1;
}

int storeIConditionalNode::reloc() const {
  return 1;
}

int storeLConditionalNode::reloc() const {
  return 1;
}

int compareAndSwapPNode::reloc() const {
  return 1;
}

int compareAndSwapP_0Node::reloc() const {
  return 1;
}

int compareAndSwapLNode::reloc() const {
  return 1;
}

int compareAndSwapL_0Node::reloc() const {
  return 1;
}

int compareAndSwapINode::reloc() const {
  return 1;
}

int compareAndSwapI_0Node::reloc() const {
  return 1;
}

int compareAndSwapBNode::reloc() const {
  return 1;
}

int compareAndSwapB_0Node::reloc() const {
  return 1;
}

int compareAndSwapSNode::reloc() const {
  return 1;
}

int compareAndSwapS_0Node::reloc() const {
  return 1;
}

int compareAndSwapNNode::reloc() const {
  return 1;
}

int compareAndSwapN_0Node::reloc() const {
  return 1;
}

int compareAndExchangeBNode::reloc() const {
  return 1;
}

int compareAndExchangeSNode::reloc() const {
  return 1;
}

int compareAndExchangeINode::reloc() const {
  return 1;
}

int compareAndExchangeLNode::reloc() const {
  return 1;
}

int compareAndExchangeNNode::reloc() const {
  return 1;
}

int compareAndExchangePNode::reloc() const {
  return 1;
}

int xaddB_no_resNode::reloc() const {
  return 1;
}

int xaddBNode::reloc() const {
  return 1;
}

int xaddS_no_resNode::reloc() const {
  return 1;
}

int xaddSNode::reloc() const {
  return 1;
}

int xaddI_no_resNode::reloc() const {
  return 1;
}

int xaddINode::reloc() const {
  return 1;
}

int xaddL_no_resNode::reloc() const {
  return 1;
}

int xaddLNode::reloc() const {
  return 1;
}

int xchgBNode::reloc() const {
  return 1;
}

int xchgSNode::reloc() const {
  return 1;
}

int xchgINode::reloc() const {
  return 1;
}

int xchgLNode::reloc() const {
  return 1;
}

int xchgPNode::reloc() const {
  return 1;
}

int xchgNNode::reloc() const {
  return 1;
}

int subI_rReg_memNode::reloc() const {
  return 1;
}

int subI_mem_rRegNode::reloc() const {
  return 3;
}

int subI_mem_immNode::reloc() const {
  return 3;
}

int subL_rReg_memNode::reloc() const {
  return 1;
}

int subL_mem_rRegNode::reloc() const {
  return 3;
}

int subL_mem_immNode::reloc() const {
  return 3;
}

int negI_memNode::reloc() const {
  return 3;
}

int negL_memNode::reloc() const {
  return 3;
}

int mulI_memNode::reloc() const {
  return 1;
}

int mulI_mem_0Node::reloc() const {
  return 1;
}

int mulI_mem_immNode::reloc() const {
  return 1;
}

int mulL_memNode::reloc() const {
  return 1;
}

int mulL_mem_0Node::reloc() const {
  return 1;
}

int mulL_mem_immNode::reloc() const {
  return 1;
}

int salI_mem_1Node::reloc() const {
  return 3;
}

int salI_mem_immNode::reloc() const {
  return 3;
}

int salI_mem_CLNode::reloc() const {
  return 3;
}

int sarI_mem_1Node::reloc() const {
  return 3;
}

int sarI_mem_immNode::reloc() const {
  return 3;
}

int sarI_mem_CLNode::reloc() const {
  return 3;
}

int shrI_mem_1Node::reloc() const {
  return 3;
}

int shrI_mem_immNode::reloc() const {
  return 3;
}

int shrI_mem_CLNode::reloc() const {
  return 3;
}

int salL_mem_1Node::reloc() const {
  return 3;
}

int salL_mem_immNode::reloc() const {
  return 3;
}

int salL_mem_CLNode::reloc() const {
  return 3;
}

int sarL_mem_1Node::reloc() const {
  return 3;
}

int sarL_mem_immNode::reloc() const {
  return 3;
}

int sarL_mem_CLNode::reloc() const {
  return 3;
}

int shrL_mem_1Node::reloc() const {
  return 3;
}

int shrL_mem_immNode::reloc() const {
  return 3;
}

int shrL_mem_CLNode::reloc() const {
  return 3;
}

int andI_rReg_memNode::reloc() const {
  return 1;
}

int andI_rReg_mem_0Node::reloc() const {
  return 1;
}

int andI_mem_rRegNode::reloc() const {
  return 3;
}

int andI_mem_rReg_0Node::reloc() const {
  return 3;
}

int andI_mem_immNode::reloc() const {
  return 3;
}

int andnI_rReg_rReg_memNode::reloc() const {
  return 1;
}

int andnI_rReg_rReg_mem_0Node::reloc() const {
  return 1;
}

int blsiI_rReg_memNode::reloc() const {
  return 2;
}

int blsiI_rReg_mem_0Node::reloc() const {
  return 2;
}

int blsmskI_rReg_memNode::reloc() const {
  return 2;
}

int blsmskI_rReg_mem_0Node::reloc() const {
  return 2;
}

int blsrI_rReg_memNode::reloc() const {
  return 2;
}

int blsrI_rReg_mem_0Node::reloc() const {
  return 2;
}

int orI_rReg_memNode::reloc() const {
  return 1;
}

int orI_rReg_mem_0Node::reloc() const {
  return 1;
}

int orI_mem_rRegNode::reloc() const {
  return 3;
}

int orI_mem_rReg_0Node::reloc() const {
  return 3;
}

int orI_mem_immNode::reloc() const {
  return 3;
}

int xorI_rReg_memNode::reloc() const {
  return 1;
}

int xorI_rReg_mem_0Node::reloc() const {
  return 1;
}

int xorI_mem_rRegNode::reloc() const {
  return 3;
}

int xorI_mem_rReg_0Node::reloc() const {
  return 3;
}

int xorI_mem_immNode::reloc() const {
  return 3;
}

int andL_rReg_memNode::reloc() const {
  return 1;
}

int andL_rReg_mem_0Node::reloc() const {
  return 1;
}

int andL_mem_rRegNode::reloc() const {
  return 3;
}

int andL_mem_rReg_0Node::reloc() const {
  return 3;
}

int andL_mem_immNode::reloc() const {
  return 3;
}

int andnL_rReg_rReg_memNode::reloc() const {
  return 1;
}

int andnL_rReg_rReg_mem_0Node::reloc() const {
  return 1;
}

int blsiL_rReg_memNode::reloc() const {
  return 2;
}

int blsiL_rReg_mem_0Node::reloc() const {
  return 2;
}

int blsmskL_rReg_memNode::reloc() const {
  return 2;
}

int blsmskL_rReg_mem_0Node::reloc() const {
  return 2;
}

int blsrL_rReg_memNode::reloc() const {
  return 2;
}

int blsrL_rReg_mem_0Node::reloc() const {
  return 2;
}

int orL_rReg_memNode::reloc() const {
  return 1;
}

int orL_rReg_mem_0Node::reloc() const {
  return 1;
}

int orL_mem_rRegNode::reloc() const {
  return 3;
}

int orL_mem_rReg_0Node::reloc() const {
  return 3;
}

int orL_mem_immNode::reloc() const {
  return 3;
}

int xorL_rReg_memNode::reloc() const {
  return 1;
}

int xorL_rReg_mem_0Node::reloc() const {
  return 1;
}

int xorL_mem_rRegNode::reloc() const {
  return 3;
}

int xorL_mem_rReg_0Node::reloc() const {
  return 3;
}

int xorL_mem_immNode::reloc() const {
  return 3;
}

int cmpF_cc_memNode::reloc() const {
  return 1;
}

int cmpF_cc_memCFNode::reloc() const {
  return 1;
}

int cmpF_cc_immNode::reloc() const {
  return 1;
}

int cmpF_cc_immCFNode::reloc() const {
  return 1;
}

int cmpD_cc_memNode::reloc() const {
  return 1;
}

int cmpD_cc_memCFNode::reloc() const {
  return 1;
}

int cmpD_cc_immNode::reloc() const {
  return 1;
}

int cmpD_cc_immCFNode::reloc() const {
  return 1;
}

int cmpF_memNode::reloc() const {
  return 1;
}

int cmpF_immNode::reloc() const {
  return 1;
}

int cmpD_memNode::reloc() const {
  return 1;
}

int cmpD_immNode::reloc() const {
  return 1;
}

int convF2D_reg_memNode::reloc() const {
  return 1;
}

int convD2F_reg_memNode::reloc() const {
  return 1;
}

int convI2F_reg_memNode::reloc() const {
  return 1;
}

int convI2D_reg_memNode::reloc() const {
  return 1;
}

int convL2F_reg_memNode::reloc() const {
  return 1;
}

int convL2D_reg_memNode::reloc() const {
  return 1;
}

int convI2L_reg_mem_zexNode::reloc() const {
  return 1;
}

int compI_rReg_memNode::reloc() const {
  return 1;
}

int testI_reg_memNode::reloc() const {
  return 1;
}

int testI_reg_mem_0Node::reloc() const {
  return 1;
}

int compU_rReg_memNode::reloc() const {
  return 1;
}

int compP_rReg_memNode::reloc() const {
  return 1;
}

int compP_mem_rRegNode::reloc() const {
  return 1;
}

int testP_regNode::reloc() const {
  return 1;
}

int testP_memNode::reloc() const {
  return 2;
}

int testP_mem_reg0Node::reloc() const {
  return 2;
}

int compN_rReg_memNode::reloc() const {
  return 1;
}

int compN_mem_immNode::reloc() const {
  return 1;
}

int compN_mem_imm_klassNode::reloc() const {
  return 1;
}

int testN_memNode::reloc() const {
  return 1;
}

int testN_mem_reg0Node::reloc() const {
  return 1;
}

int compL_rReg_memNode::reloc() const {
  return 1;
}

int testL_reg_memNode::reloc() const {
  return 1;
}

int testL_reg_mem_0Node::reloc() const {
  return 1;
}

int testL_reg_mem2Node::reloc() const {
  return 1;
}

int testL_reg_mem2_0Node::reloc() const {
  return 1;
}

int compUL_rReg_memNode::reloc() const {
  return 1;
}

int compB_mem_immNode::reloc() const {
  return 1;
}

int testB_mem_immNode::reloc() const {
  return 1;
}

int partialSubtypeCheck_vs_ZeroNode::reloc() const {
  return 1;
}

int safePoint_pollNode::reloc() const {
  return 1;
}

int safePoint_poll_farNode::reloc() const {
  return 1;
}

int safePoint_poll_tlsNode::reloc() const {
  return 1;
}

int CallStaticJavaDirectNode::reloc() const {
  return 1;
}

int CallDynamicJavaDirectNode::reloc() const {
  return 1;
}

int CallRuntimeDirectNode::reloc() const {
  return 1;
}

int CallLeafDirectNode::reloc() const {
  return 1;
}

int CallLeafNoFPDirectNode::reloc() const {
  return 1;
}

int RetNode::reloc() const {
  return 1;
}

int TailCalljmpIndNode::reloc() const {
  return 1;
}

int tailjmpIndNode::reloc() const {
  return 1;
}

int RethrowExceptionNode::reloc() const {
  return 1;
}

int loadBarrierSlowRegNoVecNode::reloc() const {
  return 1;
}

int loadBarrierSlowRegXmmAndYmmNode::reloc() const {
  return 1;
}

int loadBarrierSlowRegZmmNode::reloc() const {
  return 1;
}

int loadBarrierWeakSlowRegNoVecNode::reloc() const {
  return 1;
}

int loadBarrierWeakSlowRegXmmAndYmmNode::reloc() const {
  return 1;
}

int loadBarrierWeakSlowRegZmmNode::reloc() const {
  return 1;
}

int addF_memNode::reloc() const {
  return 1;
}

int addF_mem_0Node::reloc() const {
  return 1;
}

int addF_immNode::reloc() const {
  return 1;
}

int addF_reg_memNode::reloc() const {
  return 1;
}

int addF_reg_mem_0Node::reloc() const {
  return 1;
}

int addF_reg_immNode::reloc() const {
  return 1;
}

int addD_memNode::reloc() const {
  return 1;
}

int addD_mem_0Node::reloc() const {
  return 1;
}

int addD_immNode::reloc() const {
  return 1;
}

int addD_reg_memNode::reloc() const {
  return 1;
}

int addD_reg_mem_0Node::reloc() const {
  return 1;
}

int addD_reg_immNode::reloc() const {
  return 1;
}

int subF_memNode::reloc() const {
  return 1;
}

int subF_immNode::reloc() const {
  return 1;
}

int subF_reg_memNode::reloc() const {
  return 1;
}

int subF_reg_immNode::reloc() const {
  return 1;
}

int subD_memNode::reloc() const {
  return 1;
}

int subD_immNode::reloc() const {
  return 1;
}

int subD_reg_memNode::reloc() const {
  return 1;
}

int subD_reg_immNode::reloc() const {
  return 1;
}

int mulF_memNode::reloc() const {
  return 1;
}

int mulF_mem_0Node::reloc() const {
  return 1;
}

int mulF_immNode::reloc() const {
  return 1;
}

int mulF_reg_memNode::reloc() const {
  return 1;
}

int mulF_reg_mem_0Node::reloc() const {
  return 1;
}

int mulF_reg_immNode::reloc() const {
  return 1;
}

int mulD_memNode::reloc() const {
  return 1;
}

int mulD_mem_0Node::reloc() const {
  return 1;
}

int mulD_immNode::reloc() const {
  return 1;
}

int mulD_reg_memNode::reloc() const {
  return 1;
}

int mulD_reg_mem_0Node::reloc() const {
  return 1;
}

int mulD_reg_immNode::reloc() const {
  return 1;
}

int divF_memNode::reloc() const {
  return 1;
}

int divF_immNode::reloc() const {
  return 1;
}

int divF_reg_memNode::reloc() const {
  return 1;
}

int divF_reg_immNode::reloc() const {
  return 1;
}

int divD_memNode::reloc() const {
  return 1;
}

int divD_immNode::reloc() const {
  return 1;
}

int divD_reg_memNode::reloc() const {
  return 1;
}

int divD_reg_immNode::reloc() const {
  return 1;
}

int sqrtF_memNode::reloc() const {
  return 1;
}

int sqrtF_immNode::reloc() const {
  return 1;
}

int sqrtD_memNode::reloc() const {
  return 1;
}

int sqrtD_immNode::reloc() const {
  return 1;
}

int loadV4Node::reloc() const {
  return 1;
}

int loadV8Node::reloc() const {
  return 1;
}

int loadV16Node::reloc() const {
  return 1;
}

int loadV32Node::reloc() const {
  return 1;
}

int loadV64_dwordNode::reloc() const {
  return 1;
}

int loadV64_qwordNode::reloc() const {
  return 1;
}

int storeV4Node::reloc() const {
  return 2;
}

int storeV8Node::reloc() const {
  return 2;
}

int storeV16Node::reloc() const {
  return 2;
}

int storeV32Node::reloc() const {
  return 2;
}

int storeV64_dwordNode::reloc() const {
  return 2;
}

int storeV64_qwordNode::reloc() const {
  return 2;
}

int Repl4B_memNode::reloc() const {
  return 1;
}

int Repl8B_memNode::reloc() const {
  return 1;
}

int Repl16B_memNode::reloc() const {
  return 1;
}

int Repl32B_memNode::reloc() const {
  return 1;
}

int Repl4S_memNode::reloc() const {
  return 1;
}

int Repl8S_memNode::reloc() const {
  return 1;
}

int Repl16S_memNode::reloc() const {
  return 1;
}

int Repl4I_memNode::reloc() const {
  return 1;
}

int Repl8I_memNode::reloc() const {
  return 1;
}

int Repl2L_memNode::reloc() const {
  return 1;
}

int Repl4L_memNode::reloc() const {
  return 1;
}

int Repl2F_memNode::reloc() const {
  return 1;
}

int Repl4F_memNode::reloc() const {
  return 1;
}

int Repl8F_memNode::reloc() const {
  return 1;
}

int Repl2F_zeroNode::reloc() const {
  return 1;
}

int Repl4F_zeroNode::reloc() const {
  return 1;
}

int Repl8F_zeroNode::reloc() const {
  return 1;
}

int Repl2D_memNode::reloc() const {
  return 1;
}

int Repl4D_memNode::reloc() const {
  return 1;
}

int Repl2D_zeroNode::reloc() const {
  return 1;
}

int Repl4D_zeroNode::reloc() const {
  return 1;
}

int Repl2I_memNode::reloc() const {
  return 1;
}

int Repl4B_mem_evexNode::reloc() const {
  return 1;
}

int Repl8B_mem_evexNode::reloc() const {
  return 1;
}

int Repl16B_mem_evexNode::reloc() const {
  return 1;
}

int Repl32B_mem_evexNode::reloc() const {
  return 1;
}

int Repl64B_mem_evexNode::reloc() const {
  return 1;
}

int Repl4S_mem_evexNode::reloc() const {
  return 1;
}

int Repl8S_mem_evexNode::reloc() const {
  return 1;
}

int Repl16S_mem_evexNode::reloc() const {
  return 1;
}

int Repl32S_mem_evexNode::reloc() const {
  return 1;
}

int Repl4I_mem_evexNode::reloc() const {
  return 1;
}

int Repl8I_mem_evexNode::reloc() const {
  return 1;
}

int Repl16I_mem_evexNode::reloc() const {
  return 1;
}

int Repl2L_mem_evexNode::reloc() const {
  return 1;
}

int Repl4L_mem_evexNode::reloc() const {
  return 1;
}

int Repl8L_mem_evexNode::reloc() const {
  return 1;
}

int Repl8F_mem_evexNode::reloc() const {
  return 1;
}

int Repl16F_mem_evexNode::reloc() const {
  return 1;
}

int Repl2F_zero_evexNode::reloc() const {
  return 1;
}

int Repl4F_zero_evexNode::reloc() const {
  return 1;
}

int Repl8F_zero_evexNode::reloc() const {
  return 1;
}

int Repl16F_zero_evexNode::reloc() const {
  return 1;
}

int Repl4D_mem_evexNode::reloc() const {
  return 1;
}

int Repl8D_mem_evexNode::reloc() const {
  return 1;
}

int Repl2D_zero_evexNode::reloc() const {
  return 1;
}

int Repl4D_zero_evexNode::reloc() const {
  return 1;
}

int Repl8D_zero_evexNode::reloc() const {
  return 1;
}

int vadd4B_mem_avxNode::reloc() const {
  return 1;
}

int vadd4B_mem_avx_0Node::reloc() const {
  return 1;
}

int vadd4B_mem_evexNode::reloc() const {
  return 1;
}

int vadd4B_mem_evex_0Node::reloc() const {
  return 1;
}

int vadd4B_mem_evex_specialNode::reloc() const {
  return 1;
}

int vadd4B_mem_evex_special_0Node::reloc() const {
  return 1;
}

int vadd8B_mem_avxNode::reloc() const {
  return 1;
}

int vadd8B_mem_avx_0Node::reloc() const {
  return 1;
}

int vadd8B_mem_evexNode::reloc() const {
  return 1;
}

int vadd8B_mem_evex_0Node::reloc() const {
  return 1;
}

int vadd8B_mem_evex_specialNode::reloc() const {
  return 1;
}

int vadd8B_mem_evex_special_0Node::reloc() const {
  return 1;
}

int vadd16B_mem_avxNode::reloc() const {
  return 1;
}

int vadd16B_mem_avx_0Node::reloc() const {
  return 1;
}

int vadd16B_mem_evexNode::reloc() const {
  return 1;
}

int vadd16B_mem_evex_0Node::reloc() const {
  return 1;
}

int vadd16B_mem_evex_specialNode::reloc() const {
  return 1;
}

int vadd16B_mem_evex_special_0Node::reloc() const {
  return 1;
}

int vadd32B_mem_avxNode::reloc() const {
  return 1;
}

int vadd32B_mem_avx_0Node::reloc() const {
  return 1;
}

int vadd32B_mem_evexNode::reloc() const {
  return 1;
}

int vadd32B_mem_evex_0Node::reloc() const {
  return 1;
}

int vadd32B_mem_evex_specialNode::reloc() const {
  return 1;
}

int vadd32B_mem_evex_special_0Node::reloc() const {
  return 1;
}

int vadd64B_memNode::reloc() const {
  return 1;
}

int vadd64B_mem_0Node::reloc() const {
  return 1;
}

int vadd2S_mem_avxNode::reloc() const {
  return 1;
}

int vadd2S_mem_avx_0Node::reloc() const {
  return 1;
}

int vadd2S_mem_evexNode::reloc() const {
  return 1;
}

int vadd2S_mem_evex_0Node::reloc() const {
  return 1;
}

int vadd2S_mem_evex_specialNode::reloc() const {
  return 1;
}

int vadd2S_mem_evex_special_0Node::reloc() const {
  return 1;
}

int vadd4S_mem_avxNode::reloc() const {
  return 1;
}

int vadd4S_mem_avx_0Node::reloc() const {
  return 1;
}

int vadd4S_mem_evexNode::reloc() const {
  return 1;
}

int vadd4S_mem_evex_0Node::reloc() const {
  return 1;
}

int vadd4S_mem_evex_specialNode::reloc() const {
  return 1;
}

int vadd4S_mem_evex_special_0Node::reloc() const {
  return 1;
}

int vadd8S_mem_avxNode::reloc() const {
  return 1;
}

int vadd8S_mem_avx_0Node::reloc() const {
  return 1;
}

int vadd8S_mem_evexNode::reloc() const {
  return 1;
}

int vadd8S_mem_evex_0Node::reloc() const {
  return 1;
}

int vadd8S_mem_evex_specialNode::reloc() const {
  return 1;
}

int vadd8S_mem_evex_special_0Node::reloc() const {
  return 1;
}

int vadd16S_mem_avxNode::reloc() const {
  return 1;
}

int vadd16S_mem_avx_0Node::reloc() const {
  return 1;
}

int vadd16S_mem_evexNode::reloc() const {
  return 1;
}

int vadd16S_mem_evex_0Node::reloc() const {
  return 1;
}

int vadd16S_mem_evex_specialNode::reloc() const {
  return 1;
}

int vadd16S_mem_evex_special_0Node::reloc() const {
  return 1;
}

int vadd32S_memNode::reloc() const {
  return 1;
}

int vadd32S_mem_0Node::reloc() const {
  return 1;
}

int vadd2I_memNode::reloc() const {
  return 1;
}

int vadd2I_mem_0Node::reloc() const {
  return 1;
}

int vadd4I_memNode::reloc() const {
  return 1;
}

int vadd4I_mem_0Node::reloc() const {
  return 1;
}

int vadd8I_memNode::reloc() const {
  return 1;
}

int vadd8I_mem_0Node::reloc() const {
  return 1;
}

int vadd16I_memNode::reloc() const {
  return 1;
}

int vadd16I_mem_0Node::reloc() const {
  return 1;
}

int vadd2L_memNode::reloc() const {
  return 1;
}

int vadd2L_mem_0Node::reloc() const {
  return 1;
}

int vadd4L_memNode::reloc() const {
  return 1;
}

int vadd4L_mem_0Node::reloc() const {
  return 1;
}

int vadd8L_memNode::reloc() const {
  return 1;
}

int vadd8L_mem_0Node::reloc() const {
  return 1;
}

int vadd2F_memNode::reloc() const {
  return 1;
}

int vadd2F_mem_0Node::reloc() const {
  return 1;
}

int vadd4F_memNode::reloc() const {
  return 1;
}

int vadd4F_mem_0Node::reloc() const {
  return 1;
}

int vadd8F_memNode::reloc() const {
  return 1;
}

int vadd8F_mem_0Node::reloc() const {
  return 1;
}

int vadd16F_memNode::reloc() const {
  return 1;
}

int vadd16F_mem_0Node::reloc() const {
  return 1;
}

int vadd2D_memNode::reloc() const {
  return 1;
}

int vadd2D_mem_0Node::reloc() const {
  return 1;
}

int vadd4D_memNode::reloc() const {
  return 1;
}

int vadd4D_mem_0Node::reloc() const {
  return 1;
}

int vadd8D_memNode::reloc() const {
  return 1;
}

int vadd8D_mem_0Node::reloc() const {
  return 1;
}

int vsub4B_mem_avxNode::reloc() const {
  return 1;
}

int vsub4B_mem_evexNode::reloc() const {
  return 1;
}

int vsub4B_mem_evex_specialNode::reloc() const {
  return 1;
}

int vsub8B_mem_avxNode::reloc() const {
  return 1;
}

int vsub8B_mem_evexNode::reloc() const {
  return 1;
}

int vsub8B_mem_evex_specialNode::reloc() const {
  return 1;
}

int vsub16B_mem_avxNode::reloc() const {
  return 1;
}

int vsub16B_mem_evexNode::reloc() const {
  return 1;
}

int vsub16B_mem_evex_specialNode::reloc() const {
  return 1;
}

int vsub32B_mem_avxNode::reloc() const {
  return 1;
}

int vsub32B_mem_evexNode::reloc() const {
  return 1;
}

int vsub32B_mem_evex_specialNode::reloc() const {
  return 1;
}

int vsub64B_memNode::reloc() const {
  return 1;
}

int vsub2S_mem_avxNode::reloc() const {
  return 1;
}

int vsub2S_mem_evexNode::reloc() const {
  return 1;
}

int vsub2S_mem_evex_specialNode::reloc() const {
  return 1;
}

int vsub4S_mem_avxNode::reloc() const {
  return 1;
}

int vsub4S_mem_evexNode::reloc() const {
  return 1;
}

int vsub4S_mem_evex_specialNode::reloc() const {
  return 1;
}

int vsub8S_mem_avxNode::reloc() const {
  return 1;
}

int vsub8S_mem_evexNode::reloc() const {
  return 1;
}

int vsub8S_mem_evex_specialNode::reloc() const {
  return 1;
}

int vsub16S_mem_avxNode::reloc() const {
  return 1;
}

int vsub16S_mem_evexNode::reloc() const {
  return 1;
}

int vsub16S_mem_evex_specialNode::reloc() const {
  return 1;
}

int vsub32S_memNode::reloc() const {
  return 1;
}

int vsub2I_memNode::reloc() const {
  return 1;
}

int vsub4I_memNode::reloc() const {
  return 1;
}

int vsub8I_memNode::reloc() const {
  return 1;
}

int vsub16I_memNode::reloc() const {
  return 1;
}

int vsub2L_memNode::reloc() const {
  return 1;
}

int vsub4L_memNode::reloc() const {
  return 1;
}

int vsub8L_memNode::reloc() const {
  return 1;
}

int vsub2F_memNode::reloc() const {
  return 1;
}

int vsub4F_memNode::reloc() const {
  return 1;
}

int vsub8F_memNode::reloc() const {
  return 1;
}

int vsub16F_memNode::reloc() const {
  return 1;
}

int vsub2D_memNode::reloc() const {
  return 1;
}

int vsub4D_memNode::reloc() const {
  return 1;
}

int vsub8D_memNode::reloc() const {
  return 1;
}

int vmul2S_mem_avxNode::reloc() const {
  return 1;
}

int vmul2S_mem_avx_0Node::reloc() const {
  return 1;
}

int vmul2S_mem_evexNode::reloc() const {
  return 1;
}

int vmul2S_mem_evex_0Node::reloc() const {
  return 1;
}

int vmul2S_mem_evex_specialNode::reloc() const {
  return 1;
}

int vmul2S_mem_evex_special_0Node::reloc() const {
  return 1;
}

int vmul4S_mem_avxNode::reloc() const {
  return 1;
}

int vmul4S_mem_avx_0Node::reloc() const {
  return 1;
}

int vmul4S_mem_evexNode::reloc() const {
  return 1;
}

int vmul4S_mem_evex_0Node::reloc() const {
  return 1;
}

int vmul4S_mem_evex_specialNode::reloc() const {
  return 1;
}

int vmul4S_mem_evex_special_0Node::reloc() const {
  return 1;
}

int vmul8S_mem_avxNode::reloc() const {
  return 1;
}

int vmul8S_mem_avx_0Node::reloc() const {
  return 1;
}

int vmul8S_mem_evexNode::reloc() const {
  return 1;
}

int vmul8S_mem_evex_0Node::reloc() const {
  return 1;
}

int vmul8S_mem_evex_specialNode::reloc() const {
  return 1;
}

int vmul8S_mem_evex_special_0Node::reloc() const {
  return 1;
}

int vmul16S_mem_avxNode::reloc() const {
  return 1;
}

int vmul16S_mem_avx_0Node::reloc() const {
  return 1;
}

int vmul16S_mem_evexNode::reloc() const {
  return 1;
}

int vmul16S_mem_evex_0Node::reloc() const {
  return 1;
}

int vmul16S_mem_evex_specialNode::reloc() const {
  return 1;
}

int vmul16S_mem_evex_special_0Node::reloc() const {
  return 1;
}

int vmul32S_memNode::reloc() const {
  return 1;
}

int vmul32S_mem_0Node::reloc() const {
  return 1;
}

int vmul2I_memNode::reloc() const {
  return 1;
}

int vmul2I_mem_0Node::reloc() const {
  return 1;
}

int vmul4I_memNode::reloc() const {
  return 1;
}

int vmul4I_mem_0Node::reloc() const {
  return 1;
}

int vmul2L_memNode::reloc() const {
  return 1;
}

int vmul2L_mem_0Node::reloc() const {
  return 1;
}

int vmul4L_memNode::reloc() const {
  return 1;
}

int vmul4L_mem_0Node::reloc() const {
  return 1;
}

int vmul8L_memNode::reloc() const {
  return 1;
}

int vmul8L_mem_0Node::reloc() const {
  return 1;
}

int vmul8I_memNode::reloc() const {
  return 1;
}

int vmul8I_mem_0Node::reloc() const {
  return 1;
}

int vmul16I_memNode::reloc() const {
  return 1;
}

int vmul16I_mem_0Node::reloc() const {
  return 1;
}

int vmul2F_memNode::reloc() const {
  return 1;
}

int vmul2F_mem_0Node::reloc() const {
  return 1;
}

int vmul4F_memNode::reloc() const {
  return 1;
}

int vmul4F_mem_0Node::reloc() const {
  return 1;
}

int vmul8F_memNode::reloc() const {
  return 1;
}

int vmul8F_mem_0Node::reloc() const {
  return 1;
}

int vmul16F_memNode::reloc() const {
  return 1;
}

int vmul16F_mem_0Node::reloc() const {
  return 1;
}

int vmul2D_memNode::reloc() const {
  return 1;
}

int vmul2D_mem_0Node::reloc() const {
  return 1;
}

int vmul4D_memNode::reloc() const {
  return 1;
}

int vmul4D_mem_0Node::reloc() const {
  return 1;
}

int vmul8D_memNode::reloc() const {
  return 1;
}

int vmul8D_mem_0Node::reloc() const {
  return 1;
}

int vdiv2F_memNode::reloc() const {
  return 1;
}

int vdiv4F_memNode::reloc() const {
  return 1;
}

int vdiv8F_memNode::reloc() const {
  return 1;
}

int vdiv16F_memNode::reloc() const {
  return 1;
}

int vdiv2D_memNode::reloc() const {
  return 1;
}

int vdiv4D_memNode::reloc() const {
  return 1;
}

int vdiv8D_memNode::reloc() const {
  return 1;
}

int vsqrt2D_memNode::reloc() const {
  return 1;
}

int vsqrt4D_memNode::reloc() const {
  return 1;
}

int vsqrt8D_memNode::reloc() const {
  return 1;
}

int vsqrt2F_memNode::reloc() const {
  return 1;
}

int vsqrt4F_memNode::reloc() const {
  return 1;
}

int vsqrt8F_memNode::reloc() const {
  return 1;
}

int vsqrt16F_memNode::reloc() const {
  return 1;
}

int vand4B_memNode::reloc() const {
  return 1;
}

int vand4B_mem_0Node::reloc() const {
  return 1;
}

int vand8B_memNode::reloc() const {
  return 1;
}

int vand8B_mem_0Node::reloc() const {
  return 1;
}

int vand16B_memNode::reloc() const {
  return 1;
}

int vand16B_mem_0Node::reloc() const {
  return 1;
}

int vand32B_memNode::reloc() const {
  return 1;
}

int vand32B_mem_0Node::reloc() const {
  return 1;
}

int vand64B_memNode::reloc() const {
  return 1;
}

int vand64B_mem_0Node::reloc() const {
  return 1;
}

int vor4B_memNode::reloc() const {
  return 1;
}

int vor4B_mem_0Node::reloc() const {
  return 1;
}

int vor8B_memNode::reloc() const {
  return 1;
}

int vor8B_mem_0Node::reloc() const {
  return 1;
}

int vor16B_memNode::reloc() const {
  return 1;
}

int vor16B_mem_0Node::reloc() const {
  return 1;
}

int vor32B_memNode::reloc() const {
  return 1;
}

int vor32B_mem_0Node::reloc() const {
  return 1;
}

int vor64B_memNode::reloc() const {
  return 1;
}

int vor64B_mem_0Node::reloc() const {
  return 1;
}

int vxor4B_memNode::reloc() const {
  return 1;
}

int vxor4B_mem_0Node::reloc() const {
  return 1;
}

int vxor8B_memNode::reloc() const {
  return 1;
}

int vxor8B_mem_0Node::reloc() const {
  return 1;
}

int vxor16B_memNode::reloc() const {
  return 1;
}

int vxor16B_mem_0Node::reloc() const {
  return 1;
}

int vxor32B_memNode::reloc() const {
  return 1;
}

int vxor32B_mem_0Node::reloc() const {
  return 1;
}

int vxor64B_memNode::reloc() const {
  return 1;
}

int vxor64B_mem_0Node::reloc() const {
  return 1;
}

int vfma2D_memNode::reloc() const {
  return 1;
}

int vfma4D_memNode::reloc() const {
  return 1;
}

int vfma8D_memNode::reloc() const {
  return 1;
}

int vfma4F_memNode::reloc() const {
  return 1;
}

int vfma8F_memNode::reloc() const {
  return 1;
}

int vfma16F_memNode::reloc() const {
  return 1;
}


void loadBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4914 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movsbl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19208 "ad_x86.cpp"
  }
}

void loadB2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4929 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movsbq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19224 "ad_x86.cpp"
  }
}

void loadUBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4944 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movzbl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19240 "ad_x86.cpp"
  }
}

void loadUB2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4959 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movzbq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19256 "ad_x86.cpp"
  }
}

void loadUB2L_immINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {
    MacroAssembler _masm(&cbuf);

#line 4973 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register Rdst = opnd_array(0)->as_Register(ra_,this)/* dst */;
    __ movzbq(Rdst, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ andl(Rdst, opnd_array(2)->constant()& right_n_bits(8));
  
#line 19275 "ad_x86.cpp"
  }
}

void loadSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4989 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movswl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19291 "ad_x86.cpp"
  }
}

void loadS2BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// twentyfour
  {
    MacroAssembler _masm(&cbuf);

#line 5002 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movsbl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19308 "ad_x86.cpp"
  }
}

void loadS2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5016 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movswq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19324 "ad_x86.cpp"
  }
}

void loadUSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5031 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movzwl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19340 "ad_x86.cpp"
  }
}

void loadUS2BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// twentyfour
  {
    MacroAssembler _masm(&cbuf);

#line 5044 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movsbl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19357 "ad_x86.cpp"
  }
}

void loadUS2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5058 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movzwq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19373 "ad_x86.cpp"
  }
}

void loadUS2L_immI_255Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {
    MacroAssembler _masm(&cbuf);

#line 5070 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movzbq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19390 "ad_x86.cpp"
  }
}

void loadUS2L_immINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {
    MacroAssembler _masm(&cbuf);

#line 5083 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register Rdst = opnd_array(0)->as_Register(ra_,this)/* dst */;
    __ movzwq(Rdst, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ andl(Rdst, opnd_array(2)->constant()& right_n_bits(16));
  
#line 19409 "ad_x86.cpp"
  }
}

void loadINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5099 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19425 "ad_x86.cpp"
  }
}

void loadI2BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// twentyfour
  {
    MacroAssembler _masm(&cbuf);

#line 5112 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movsbl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19442 "ad_x86.cpp"
  }
}

void loadI2UBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {
    MacroAssembler _masm(&cbuf);

#line 5124 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movzbl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19459 "ad_x86.cpp"
  }
}

void loadI2SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// sixteen
  {
    MacroAssembler _masm(&cbuf);

#line 5136 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movswl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19476 "ad_x86.cpp"
  }
}

void loadI2USNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {
    MacroAssembler _masm(&cbuf);

#line 5148 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movzwl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19493 "ad_x86.cpp"
  }
}

void loadI2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5162 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movslq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19509 "ad_x86.cpp"
  }
}

void loadI2L_immI_255Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {
    MacroAssembler _masm(&cbuf);

#line 5174 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movzbq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19526 "ad_x86.cpp"
  }
}

void loadI2L_immI_65535Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {
    MacroAssembler _masm(&cbuf);

#line 5185 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movzwq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19543 "ad_x86.cpp"
  }
}

void loadI2L_immU31Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {
    MacroAssembler _masm(&cbuf);

#line 5198 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register Rdst = opnd_array(0)->as_Register(ra_,this)/* dst */;
    __ movl(Rdst, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ andl(Rdst, opnd_array(2)->constant());
  
#line 19562 "ad_x86.cpp"
  }
}

void loadUI2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {
    MacroAssembler _masm(&cbuf);

#line 5214 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19579 "ad_x86.cpp"
  }
}

void loadLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5229 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19595 "ad_x86.cpp"
  }
}

void loadRangeNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 19636 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 19644 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 19660 "ad_x86.cpp"
  }
}

void loadPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 19703 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 19711 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 19727 "ad_x86.cpp"
  }
}

void loadNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5267 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

     __ movl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
   
#line 19743 "ad_x86.cpp"
  }
}

void loadKlassNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 19786 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 19794 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 19810 "ad_x86.cpp"
  }
}

void loadNKlassNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5293 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19826 "ad_x86.cpp"
  }
}

void loadFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5306 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movflt(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19842 "ad_x86.cpp"
  }
}

void loadD_partialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5320 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movdbl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19858 "ad_x86.cpp"
  }
}

void loadDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5333 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movdbl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 19874 "ad_x86.cpp"
  }
}

void leaP8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 19917 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 19925 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 19941 "ad_x86.cpp"
  }
}

void leaP32Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 19984 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 19992 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 20008 "ad_x86.cpp"
  }
}

void leaPIdxOffNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 20051 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 20059 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 20075 "ad_x86.cpp"
  }
}

void leaPIdxScaleNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 20118 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 20126 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 20142 "ad_x86.cpp"
  }
}

void leaPPosIdxScaleNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 20185 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 20193 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 20209 "ad_x86.cpp"
  }
}

void leaPIdxScaleOffNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 20252 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 20260 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 20276 "ad_x86.cpp"
  }
}

void leaPPosIdxOffNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 20319 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 20327 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 20343 "ad_x86.cpp"
  }
}

void leaPPosIdxScaleOffNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 20386 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 20394 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 20410 "ad_x86.cpp"
  }
}

void leaPCompressedOopOffsetNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 20453 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 20461 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 20477 "ad_x86.cpp"
  }
}

void leaP8NarrowNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 20520 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 20528 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 20544 "ad_x86.cpp"
  }
}

void leaP32NarrowNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 20587 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 20595 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 20611 "ad_x86.cpp"
  }
}

void leaPIdxOffNarrowNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 20654 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 20662 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 20678 "ad_x86.cpp"
  }
}

void leaPIdxScaleNarrowNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 20721 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 20729 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 20745 "ad_x86.cpp"
  }
}

void leaPIdxScaleOffNarrowNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 20788 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 20796 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 20812 "ad_x86.cpp"
  }
}

void leaPPosIdxOffNarrowNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 20855 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 20863 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 20879 "ad_x86.cpp"
  }
}

void leaPPosIdxScaleOffNarrowNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 20922 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 20930 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 20946 "ad_x86.cpp"
  }
}

void loadConINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2243 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    emit_d32(cbuf, opnd_array(1)->constant());
  
#line 20967 "ad_x86.cpp"
  }
}

void loadConI0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* dst */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 20992 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 21000 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* dst */ & 7, opnd_array(0)->reg(ra_,this)/* dst */ & 7);
  
#line 21008 "ad_x86.cpp"
  }
}

void loadConLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2254 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    emit_d64(cbuf, opnd_array(1)->constantL());
  
#line 21031 "ad_x86.cpp"
  }
}

void loadConL0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* dst */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 21056 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 21064 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* dst */ & 7, opnd_array(0)->reg(ra_,this)/* dst */ & 7);
  
#line 21072 "ad_x86.cpp"
  }
}

void loadConUL32Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2267 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // same as load_immI, but this time we care about zeroes in the high word
    int dstenc = opnd_array(0)->reg(ra_,this)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    emit_d32(cbuf, opnd_array(1)->constantL());
  
#line 21094 "ad_x86.cpp"
  }
}

void loadConL32Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2279 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xC7);
    emit_rm(cbuf, 0x03, 0x00, dstenc);
    emit_d32(cbuf, opnd_array(1)->constantL());
  
#line 21118 "ad_x86.cpp"
  }
}

void loadConPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {

#line 2305 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    // This next line should be generated from ADLC
    if (opnd_array(1)->constant_reloc() != relocInfo::none) {
      emit_d64_reloc(cbuf, opnd_array(1)->constant(), opnd_array(1)->constant_reloc(), RELOC_IMM64);
    } else {
      emit_d64(cbuf, opnd_array(1)->constant());
    }
  
#line 21146 "ad_x86.cpp"
  }
}

void loadConP0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* dst */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 21171 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 21179 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* dst */ & 7, opnd_array(0)->reg(ra_,this)/* dst */ & 7);
  
#line 21187 "ad_x86.cpp"
  }
}

void loadConP31Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2293 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // same as load_immI, but this time we care about zeroes in the high word
    int dstenc = opnd_array(0)->reg(ra_,this)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    
if ( opnd_array(1)->constant_reloc() != relocInfo::none ) {
  emit_d32_reloc(cbuf, opnd_array(1)->constant(), opnd_array(1)->constant_reloc(), 0);
} else {
  emit_d32(cbuf, opnd_array(1)->constant());
};
  
#line 21214 "ad_x86.cpp"
  }
}

void loadConFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 5634 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movflt(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 21230 "ad_x86.cpp"
  }
}

void loadConFNode::eval_constant(Compile* C) {
  {

#line 5635 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"
    _constant = C->constant_table().add(this, opnd_array(1));
#line 21239 "ad_x86.cpp"
  }
}
void loadConN0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5644 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ xorq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(0)->as_Register(ra_,this)/* dst */);
  
#line 21254 "ad_x86.cpp"
  }
}

void loadConNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5655 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    address con = (address)opnd_array(1)->constant();
    if (con == NULL) {
      ShouldNotReachHere();
    } else {
      __ set_narrow_oop(opnd_array(0)->as_Register(ra_,this)/* dst */, (jobject)opnd_array(1)->constant());
    }
  
#line 21275 "ad_x86.cpp"
  }
}

void loadConNKlassNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5671 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    address con = (address)opnd_array(1)->constant();
    if (con == NULL) {
      ShouldNotReachHere();
    } else {
      __ set_narrow_klass(opnd_array(0)->as_Register(ra_,this)/* dst */, (Klass*)opnd_array(1)->constant());
    }
  
#line 21296 "ad_x86.cpp"
  }
}

void loadConF0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5688 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ xorps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 21312 "ad_x86.cpp"
  }
}

void loadConDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 5699 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movdbl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 21328 "ad_x86.cpp"
  }
}

void loadConDNode::eval_constant(Compile* C) {
  {

#line 5700 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"
    _constant = C->constant_table().add(this, opnd_array(1));
#line 21337 "ad_x86.cpp"
  }
}
void loadConD0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5711 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ xorpd (opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 21352 "ad_x86.cpp"
  }
}

void loadSSINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 21393 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 21401 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 21417 "ad_x86.cpp"
  }
}

void loadSSLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 21460 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 21468 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 21484 "ad_x86.cpp"
  }
}

void loadSSPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 21527 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 21535 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 21551 "ad_x86.cpp"
  }
}

void loadSSFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5756 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movflt(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address(rsp, opnd_array(1)->disp(ra_,this,idx1)));
  
#line 21567 "ad_x86.cpp"
  }
}

void loadSSDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5769 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movdbl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address(rsp, opnd_array(1)->disp(ra_,this,idx1)));
  
#line 21583 "ad_x86.cpp"
  }
}

void prefetchAllocNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 5784 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ prefetchw(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 21599 "ad_x86.cpp"
  }
}

void prefetchAllocNTANode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 5796 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ prefetchnta(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 21615 "ad_x86.cpp"
  }
}

void prefetchAllocT0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 5808 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ prefetcht0(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 21631 "ad_x86.cpp"
  }
}

void prefetchAllocT2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 5820 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ prefetcht2(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 21647 "ad_x86.cpp"
  }
}

void storeBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2419 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        } else if (opnd_array(2)->reg(ra_,this,idx2)/* src */ >= 4) {
          emit_opcode(cbuf, Assembler::REX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 21691 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x88 /*primary()*/));
  
#line 21699 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 21715 "ad_x86.cpp"
  }
}

void storeCNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 1860 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, 0x66);
  
#line 21731 "ad_x86.cpp"
  }
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 21765 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 21773 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 21789 "ad_x86.cpp"
  }
}

void storeINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 21831 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 21839 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 21855 "ad_x86.cpp"
  }
}

void storeLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 21899 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 21907 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 21923 "ad_x86.cpp"
  }
}

void storePNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 21967 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 21975 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 21991 "ad_x86.cpp"
  }
}

void storeImmP0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 5895 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movq(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), r12);
  
#line 22008 "ad_x86.cpp"
  }
}

void storeImmPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 22036 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xC7 /*primary()*/));
  
#line 22044 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 22064 "ad_x86.cpp"
  }
  {

#line 2323 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Output immediate
    
if ( opnd_array(2)->constant_reloc() != relocInfo::none ) {
  emit_d32_reloc(cbuf, opnd_array(2)->constant(), opnd_array(2)->constant_reloc(), 0);
} else {
  emit_d32(cbuf, opnd_array(2)->constant());
};
  
#line 22078 "ad_x86.cpp"
  }
}

void storeNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5920 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->as_Register(ra_,this,idx2)/* src */);
  
#line 22095 "ad_x86.cpp"
  }
}

void storeNKlassNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5932 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->as_Register(ra_,this,idx2)/* src */);
  
#line 22112 "ad_x86.cpp"
  }
}

void storeImmN0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 5945 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), r12);
  
#line 22129 "ad_x86.cpp"
  }
}

void storeImmNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5957 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    address con = (address)opnd_array(2)->constant();
    if (con == NULL) {
      __ movl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), (int32_t)0);
    } else {
      __ set_narrow_oop(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), (jobject)opnd_array(2)->constant());
    }
  
#line 22151 "ad_x86.cpp"
  }
}

void storeImmNKlassNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5974 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ set_narrow_klass(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), (Klass*)opnd_array(2)->constant());
  
#line 22168 "ad_x86.cpp"
  }
}

void storeImmI0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 5988 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), r12);
  
#line 22185 "ad_x86.cpp"
  }
}

void storeImmINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 22211 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xC7 /*primary()*/));
  
#line 22219 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 22239 "ad_x86.cpp"
  }
  {

#line 2323 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Output immediate
    emit_d32(cbuf, opnd_array(2)->constant());
  
#line 22248 "ad_x86.cpp"
  }
}

void storeImmL0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 6013 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movq(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), r12);
  
#line 22265 "ad_x86.cpp"
  }
}

void storeImmLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 22293 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xC7 /*primary()*/));
  
#line 22301 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 22321 "ad_x86.cpp"
  }
  {

#line 2323 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Output immediate
    emit_d32(cbuf, opnd_array(2)->constantL());
  
#line 22330 "ad_x86.cpp"
  }
}

void storeImmC0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 6038 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movw(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), r12);
  
#line 22347 "ad_x86.cpp"
  }
}

void storeImmI16Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 1860 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, 0x66);
  
#line 22363 "ad_x86.cpp"
  }
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 22381 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xC7 /*primary()*/));
  
#line 22389 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 22409 "ad_x86.cpp"
  }
  {

#line 2337 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Output immediate
    emit_d16(cbuf, opnd_array(2)->constant());
  
#line 22418 "ad_x86.cpp"
  }
}

void storeImmB0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 6064 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movb(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), r12);
  
#line 22435 "ad_x86.cpp"
  }
}

void storeImmBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 22461 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xC6 /*primary()*/));
  
#line 22469 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 22489 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 22503 "ad_x86.cpp"
  }
}

void storeImmCM0_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 6089 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movb(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), r12);
  
#line 22520 "ad_x86.cpp"
  }
}

void storeImmCM0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 22546 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xC6 /*primary()*/));
  
#line 22554 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 22574 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 22588 "ad_x86.cpp"
  }
}

void storeFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6113 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movflt(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 22605 "ad_x86.cpp"
  }
}

void storeF0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 6127 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), r12);
  
#line 22622 "ad_x86.cpp"
  }
}

void storeF_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 22648 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xC7 /*primary()*/));
  
#line 22656 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 22676 "ad_x86.cpp"
  }
  {

#line 2329 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Output Float immediate bits
    jfloat jf = opnd_array(2)->constantF();
    jint jf_as_bits = jint_cast(jf);
    emit_d32(cbuf, jf_as_bits);
  
#line 22687 "ad_x86.cpp"
  }
}

void storeDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6151 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movdbl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 22704 "ad_x86.cpp"
  }
}

void storeD0_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 22732 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xC7 /*primary()*/));
  
#line 22740 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 22760 "ad_x86.cpp"
  }
  {

#line 2329 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Output Float immediate bits
    jfloat jf = opnd_array(2)->constantD();
    jint jf_as_bits = jint_cast(jf);
    emit_d32(cbuf, jf_as_bits);
  
#line 22771 "ad_x86.cpp"
  }
}

void storeD0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 6177 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movq(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), r12);
  
#line 22788 "ad_x86.cpp"
  }
}

void storeSSINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 22829 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 22837 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* src */;
    int base = opnd_array(0)->base(ra_,this,idx0);
    int index = opnd_array(0)->index(ra_,this,idx0);
    int scale = opnd_array(0)->scale();
    int disp = opnd_array(0)->disp(ra_,this,0);
    relocInfo::relocType disp_reloc = opnd_array(0)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 22853 "ad_x86.cpp"
  }
}

void storeSSLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 22896 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 22904 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* src */;
    int base = opnd_array(0)->base(ra_,this,idx0);
    int index = opnd_array(0)->index(ra_,this,idx0);
    int scale = opnd_array(0)->scale();
    int disp = opnd_array(0)->disp(ra_,this,0);
    relocInfo::relocType disp_reloc = opnd_array(0)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 22920 "ad_x86.cpp"
  }
}

void storeSSPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 22963 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 22971 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* src */;
    int base = opnd_array(0)->base(ra_,this,idx0);
    int index = opnd_array(0)->index(ra_,this,idx0);
    int scale = opnd_array(0)->scale();
    int disp = opnd_array(0)->disp(ra_,this,0);
    relocInfo::relocType disp_reloc = opnd_array(0)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 22987 "ad_x86.cpp"
  }
}

void storeSSFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6222 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movflt(Address(rsp, opnd_array(0)->disp(ra_,this,0)), opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
  
#line 23003 "ad_x86.cpp"
  }
}

void storeSSDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6234 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movdbl(Address(rsp, opnd_array(0)->disp(ra_,this,0)), opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
  
#line 23019 "ad_x86.cpp"
  }
}

void bytes_reverse_intNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 23036 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 23044 "ad_x86.cpp"
  }
  {

#line 2082 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // BSWAP
    emit_cc(cbuf, (0xC8 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */);
  
#line 23053 "ad_x86.cpp"
  }
}

void bytes_reverse_longNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 23072 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 23080 "ad_x86.cpp"
  }
  {

#line 2082 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // BSWAP
    emit_cc(cbuf, (0xC8 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */);
  
#line 23089 "ad_x86.cpp"
  }
}

void bytes_reverse_unsigned_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  {
    MacroAssembler _masm(&cbuf);

#line 6265 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ bswapl(opnd_array(1)->as_Register(ra_,this,idx1)/* dst */);
    __ shrl(opnd_array(1)->as_Register(ra_,this,idx1)/* dst */, 16);
  
#line 23106 "ad_x86.cpp"
  }
}

void bytes_reverse_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  {
    MacroAssembler _masm(&cbuf);

#line 6278 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ bswapl(opnd_array(1)->as_Register(ra_,this,idx1)/* dst */);
    __ sarl(opnd_array(1)->as_Register(ra_,this,idx1)/* dst */, 16);
  
#line 23123 "ad_x86.cpp"
  }
}

void countLeadingZerosINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6293 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ lzcntl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 23139 "ad_x86.cpp"
  }
}

void countLeadingZerosI_bsrNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6310 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register Rdst = opnd_array(0)->as_Register(ra_,this)/* dst */;
    Register Rsrc = opnd_array(1)->as_Register(ra_,this,idx1)/* src */;
    Label skip;
    __ bsrl(Rdst, Rsrc);
    __ jccb(Assembler::notZero, skip);
    __ movl(Rdst, -1);
    __ bind(skip);
    __ negl(Rdst);
    __ addl(Rdst, BitsPerInt - 1);
  
#line 23163 "ad_x86.cpp"
  }
}

void countLeadingZerosLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6330 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ lzcntq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 23179 "ad_x86.cpp"
  }
}

void countLeadingZerosL_bsrNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6347 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register Rdst = opnd_array(0)->as_Register(ra_,this)/* dst */;
    Register Rsrc = opnd_array(1)->as_Register(ra_,this,idx1)/* src */;
    Label skip;
    __ bsrq(Rdst, Rsrc);
    __ jccb(Assembler::notZero, skip);
    __ movl(Rdst, -1);
    __ bind(skip);
    __ negl(Rdst);
    __ addl(Rdst, BitsPerLong - 1);
  
#line 23203 "ad_x86.cpp"
  }
}

void countTrailingZerosINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6367 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ tzcntl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 23219 "ad_x86.cpp"
  }
}

void countTrailingZerosI_bsfNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6382 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register Rdst = opnd_array(0)->as_Register(ra_,this)/* dst */;
    Label done;
    __ bsfl(Rdst, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ jccb(Assembler::notZero, done);
    __ movl(Rdst, BitsPerInt);
    __ bind(done);
  
#line 23240 "ad_x86.cpp"
  }
}

void countTrailingZerosLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6399 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ tzcntq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 23256 "ad_x86.cpp"
  }
}

void countTrailingZerosL_bsfNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6414 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register Rdst = opnd_array(0)->as_Register(ra_,this)/* dst */;
    Label done;
    __ bsfq(Rdst, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ jccb(Assembler::notZero, done);
    __ movl(Rdst, BitsPerLong);
    __ bind(done);
  
#line 23277 "ad_x86.cpp"
  }
}

void popCountINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6434 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ popcntl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 23293 "ad_x86.cpp"
  }
}

void popCountI_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6446 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ popcntl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 23309 "ad_x86.cpp"
  }
}

void popCountLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ popcntq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 23325 "ad_x86.cpp"
  }
}

void popCountL_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6472 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ popcntq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 23341 "ad_x86.cpp"
  }
}

void membar_acquireNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  // User did not define which encode class to use.
}

uint membar_acquireNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void membar_acquire_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  // User did not define which encode class to use.
}

uint membar_acquire_0Node::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void membar_acquire_lockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  // User did not define which encode class to use.
}

uint membar_acquire_lockNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void membar_releaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  // User did not define which encode class to use.
}

uint membar_releaseNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void membar_release_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  // User did not define which encode class to use.
}

uint membar_release_0Node::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void membar_release_lockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  // User did not define which encode class to use.
}

uint membar_release_lockNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void membar_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 6541 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ membar(Assembler::StoreLoad);
  
#line 23435 "ad_x86.cpp"
  }
}

void unnecessary_membar_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  // User did not define which encode class to use.
}

uint unnecessary_membar_volatileNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void membar_storestoreNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  // User did not define which encode class to use.
}

uint membar_storestoreNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void castX2PNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6576 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */!= opnd_array(1)->reg(ra_,this,idx1)/* src */) {
      __ movptr(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    }
  
#line 23479 "ad_x86.cpp"
  }
}

void castP2XNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6589 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */!= opnd_array(1)->reg(ra_,this,idx1)/* src */) {
      __ movptr(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    }
  
#line 23497 "ad_x86.cpp"
  }
}

void convP2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6603 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 23513 "ad_x86.cpp"
  }
}

void convN2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6617 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 23529 "ad_x86.cpp"
  }
}

void encodeHeapOopNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6629 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register s = opnd_array(1)->as_Register(ra_,this,idx1)/* src */;
    Register d = opnd_array(0)->as_Register(ra_,this)/* dst */;
    if (s != d) {
      __ movq(d, s);
    }
    __ encode_heap_oop(d);
  
#line 23550 "ad_x86.cpp"
  }
}

void encodeHeapOop_not_nullNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6645 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ encode_heap_oop_not_null(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 23566 "ad_x86.cpp"
  }
}

void decodeHeapOopNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6657 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register s = opnd_array(1)->as_Register(ra_,this,idx1)/* src */;
    Register d = opnd_array(0)->as_Register(ra_,this)/* dst */;
    if (s != d) {
      __ movq(d, s);
    }
    __ decode_heap_oop(d);
  
#line 23587 "ad_x86.cpp"
  }
}

void decodeHeapOop_not_nullNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6674 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register s = opnd_array(1)->as_Register(ra_,this,idx1)/* src */;
    Register d = opnd_array(0)->as_Register(ra_,this)/* dst */;
    if (s != d) {
      __ decode_heap_oop_not_null(d, s);
    } else {
      __ decode_heap_oop_not_null(d);
    }
  
#line 23609 "ad_x86.cpp"
  }
}

void encodeKlass_not_nullNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6690 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ encode_klass_not_null(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 23625 "ad_x86.cpp"
  }
}

void decodeKlass_not_nullNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6700 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register s = opnd_array(1)->as_Register(ra_,this,idx1)/* src */;
    Register d = opnd_array(0)->as_Register(ra_,this)/* dst */;
    if (s != d) {
      __ decode_klass_not_null(d, s);
    } else {
      __ decode_klass_not_null(d);
    }
  
#line 23647 "ad_x86.cpp"
  }
}

void jumpXtnd_offsetNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  ra_->C->constant_table().fill_jump_table(cbuf, (MachConstantNode*) this, _index2label);
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// shift
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dest
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 6724 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
    // to do that and the compiler is using that register as one it can allocate.
    // So we build it all by hand.
    // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
    // ArrayAddress dispatch(table, index);
    Address dispatch(opnd_array(3)->as_Register(ra_,this,idx3)/* dest */, opnd_array(1)->as_Register(ra_,this,idx1)/* switch_val */, (Address::ScaleFactor) opnd_array(2)->constant());
    __ lea(opnd_array(3)->as_Register(ra_,this,idx3)/* dest */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ jmp(dispatch);
  
#line 23673 "ad_x86.cpp"
  }
}

void jumpXtnd_offsetNode::eval_constant(Compile* C) {
  _constant = C->constant_table().add_jump_table(this);
  // User did not define an encode section.
}
void jumpXtnd_addrNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  ra_->C->constant_table().fill_jump_table(cbuf, (MachConstantNode*) this, _index2label);
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// shift
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// offset
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dest
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 6744 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
    // to do that and the compiler is using that register as one it can allocate.
    // So we build it all by hand.
    // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
    // ArrayAddress dispatch(table, index);
    Address dispatch(opnd_array(4)->as_Register(ra_,this,idx4)/* dest */, opnd_array(1)->as_Register(ra_,this,idx1)/* switch_val */, (Address::ScaleFactor) opnd_array(2)->constant(), (int) opnd_array(3)->constantL());
    __ lea(opnd_array(4)->as_Register(ra_,this,idx4)/* dest */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ jmp(dispatch);
  
#line 23704 "ad_x86.cpp"
  }
}

void jumpXtnd_addrNode::eval_constant(Compile* C) {
  _constant = C->constant_table().add_jump_table(this);
  // User did not define an encode section.
}
void jumpXtndNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  ra_->C->constant_table().fill_jump_table(cbuf, (MachConstantNode*) this, _index2label);
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dest
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 6764 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
    // to do that and the compiler is using that register as one it can allocate.
    // So we build it all by hand.
    // Address index(noreg, switch_reg, Address::times_1);
    // ArrayAddress dispatch(table, index);
    Address dispatch(opnd_array(2)->as_Register(ra_,this,idx2)/* dest */, opnd_array(1)->as_Register(ra_,this,idx1)/* switch_val */, Address::times_1);
    __ lea(opnd_array(2)->as_Register(ra_,this,idx2)/* dest */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ jmp(dispatch);
  
#line 23733 "ad_x86.cpp"
  }
}

void jumpXtndNode::eval_constant(Compile* C) {
  _constant = C->constant_table().add_jump_table(this);
  // User did not define an encode section.
}
void cmovI_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* dst */ < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 23765 "ad_x86.cpp"
  }
  {

#line 2100 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 23775 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3)/* dst */ & 7, opnd_array(4)->reg(ra_,this,idx4)/* src */ & 7);
  
#line 23783 "ad_x86.cpp"
  }
}

void cmovI_regUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* dst */ < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 23811 "ad_x86.cpp"
  }
  {

#line 2100 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 23821 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3)/* dst */ & 7, opnd_array(4)->reg(ra_,this,idx4)/* src */ & 7);
  
#line 23829 "ad_x86.cpp"
  }
}

void cmovI_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* dst */ < 8) {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 23873 "ad_x86.cpp"
  }
  {

#line 2100 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 23883 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* dst */;
    int base = opnd_array(4)->base(ra_,this,idx4);
    int index = opnd_array(4)->index(ra_,this,idx4);
    int scale = opnd_array(4)->scale();
    int disp = opnd_array(4)->disp(ra_,this,idx4);
    relocInfo::relocType disp_reloc = opnd_array(4)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 23899 "ad_x86.cpp"
  }
}

void cmovI_memUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* dst */ < 8) {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 23943 "ad_x86.cpp"
  }
  {

#line 2100 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 23953 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* dst */;
    int base = opnd_array(4)->base(ra_,this,idx4);
    int index = opnd_array(4)->index(ra_,this,idx4);
    int scale = opnd_array(4)->scale();
    int disp = opnd_array(4)->disp(ra_,this,idx4);
    relocInfo::relocType disp_reloc = opnd_array(4)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 23969 "ad_x86.cpp"
  }
}

void cmovN_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* dst */ < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 23997 "ad_x86.cpp"
  }
  {

#line 2100 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 24007 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3)/* dst */ & 7, opnd_array(4)->reg(ra_,this,idx4)/* src */ & 7);
  
#line 24015 "ad_x86.cpp"
  }
}

void cmovN_regUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* dst */ < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 24043 "ad_x86.cpp"
  }
  {

#line 2100 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 24053 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3)/* dst */ & 7, opnd_array(4)->reg(ra_,this,idx4)/* src */ & 7);
  
#line 24061 "ad_x86.cpp"
  }
}

void cmovP_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* dst */ < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 24091 "ad_x86.cpp"
  }
  {

#line 2100 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 24101 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3)/* dst */ & 7, opnd_array(4)->reg(ra_,this,idx4)/* src */ & 7);
  
#line 24109 "ad_x86.cpp"
  }
}

void cmovP_regUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* dst */ < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 24139 "ad_x86.cpp"
  }
  {

#line 2100 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 24149 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3)/* dst */ & 7, opnd_array(4)->reg(ra_,this,idx4)/* src */ & 7);
  
#line 24157 "ad_x86.cpp"
  }
}

void cmovL_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* dst */ < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 24187 "ad_x86.cpp"
  }
  {

#line 2100 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 24197 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3)/* dst */ & 7, opnd_array(4)->reg(ra_,this,idx4)/* src */ & 7);
  
#line 24205 "ad_x86.cpp"
  }
}

void cmovL_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* dst */ < 8) {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 24251 "ad_x86.cpp"
  }
  {

#line 2100 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 24261 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* dst */;
    int base = opnd_array(4)->base(ra_,this,idx4);
    int index = opnd_array(4)->index(ra_,this,idx4);
    int scale = opnd_array(4)->scale();
    int disp = opnd_array(4)->disp(ra_,this,idx4);
    relocInfo::relocType disp_reloc = opnd_array(4)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 24277 "ad_x86.cpp"
  }
}

void cmovL_regUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* dst */ < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 24307 "ad_x86.cpp"
  }
  {

#line 2100 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 24317 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3)/* dst */ & 7, opnd_array(4)->reg(ra_,this,idx4)/* src */ & 7);
  
#line 24325 "ad_x86.cpp"
  }
}

void cmovL_memUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* dst */ < 8) {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 24371 "ad_x86.cpp"
  }
  {

#line 2100 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 24381 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* dst */;
    int base = opnd_array(4)->base(ra_,this,idx4);
    int index = opnd_array(4)->index(ra_,this,idx4);
    int scale = opnd_array(4)->scale();
    int disp = opnd_array(4)->disp(ra_,this,idx4);
    relocInfo::relocType disp_reloc = opnd_array(4)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 24397 "ad_x86.cpp"
  }
}

void cmovF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6997 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label Lskip;
    // Invert sense of branch from sense of CMOV
    __ jccb((Assembler::Condition)(opnd_array(1)->ccode()^1), Lskip);
    __ movflt(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* src */);
    __ bind(Lskip);
  
#line 24420 "ad_x86.cpp"
  }
}

void cmovF_regUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7027 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label Lskip;
    // Invert sense of branch from sense of CMOV
    __ jccb((Assembler::Condition)(opnd_array(1)->ccode()^1), Lskip);
    __ movflt(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* src */);
    __ bind(Lskip);
  
#line 24443 "ad_x86.cpp"
  }
}

void cmovD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7053 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label Lskip;
    // Invert sense of branch from sense of CMOV
    __ jccb((Assembler::Condition)(opnd_array(1)->ccode()^1), Lskip);
    __ movdbl(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* src */);
    __ bind(Lskip);
  
#line 24466 "ad_x86.cpp"
  }
}

void cmovD_regUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// dst
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label Lskip;
    // Invert sense of branch from sense of CMOV
    __ jccb((Assembler::Condition)(opnd_array(1)->ccode()^1), Lskip);
    __ movdbl(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* src */);
    __ bind(Lskip);
  
#line 24489 "ad_x86.cpp"
  }
}

void addI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 24515 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x03 /*primary()*/));
  
#line 24523 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 24531 "ad_x86.cpp"
  }
}

void addI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2029 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x00 /*secondary()*/), dstenc);
  
#line 24562 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 24576 "ad_x86.cpp"
  }
}

void addI_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 24618 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x03 /*primary()*/));
  
#line 24626 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 24642 "ad_x86.cpp"
  }
}

void addI_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 24684 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x03 /*primary()*/));
  
#line 24692 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 24708 "ad_x86.cpp"
  }
}

void addI_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 24750 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x01 /*primary()*/));
  
#line 24758 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 24774 "ad_x86.cpp"
  }
}

void addI_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 24816 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x01 /*primary()*/));
  
#line 24824 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 24840 "ad_x86.cpp"
  }
}

void addI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 24866 "ad_x86.cpp"
  }
  {

#line 2017 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 24881 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 24901 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 24915 "ad_x86.cpp"
  }
}

void incI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 24933 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 24941 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x00 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 24950 "ad_x86.cpp"
  }
}

void incI_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 24976 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 24984 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 25004 "ad_x86.cpp"
  }
}

void decI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 25022 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 25030 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x01 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 25039 "ad_x86.cpp"
  }
}

void decI_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 25065 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 25073 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x01);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 25093 "ad_x86.cpp"
  }
}

void leaI_rReg_immINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src0
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x67));
  
#line 25109 "ad_x86.cpp"
  }
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src0 */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src0 */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 25127 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 25135 "ad_x86.cpp"
  }
  {

#line 2594 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int reg_encoding = opnd_array(0)->reg(ra_,this)/* dst */;
    int base         = opnd_array(1)->reg(ra_,this,idx1)/* src0 */;      // 0xFFFFFFFF indicates no base
    int index        = 0x04;            // 0x04 indicates no index
    int scale        = 0x00;            // 0x00 indicates no scale
    int displace     = opnd_array(2)->constant(); // 0x00 indicates no displacement
    relocInfo::relocType disp_reloc = relocInfo::none;
    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
                  disp_reloc);
  
#line 25150 "ad_x86.cpp"
  }
}

void addL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 25178 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x03 /*primary()*/));
  
#line 25186 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 25194 "ad_x86.cpp"
  }
}

void addL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2049 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x00 /*secondary()*/), dstenc);
  
#line 25227 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 25241 "ad_x86.cpp"
  }
}

void addL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 25285 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x03 /*primary()*/));
  
#line 25293 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 25309 "ad_x86.cpp"
  }
}

void addL_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 25353 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x03 /*primary()*/));
  
#line 25361 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 25377 "ad_x86.cpp"
  }
}

void addL_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 25421 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x01 /*primary()*/));
  
#line 25429 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 25445 "ad_x86.cpp"
  }
}

void addL_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 25489 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x01 /*primary()*/));
  
#line 25497 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 25513 "ad_x86.cpp"
  }
}

void addL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 25541 "ad_x86.cpp"
  }
  {

#line 2017 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 25556 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 25576 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 25590 "ad_x86.cpp"
  }
}

void incL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 25610 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 25618 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x00 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 25627 "ad_x86.cpp"
  }
}

void incL_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 25655 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 25663 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 25683 "ad_x86.cpp"
  }
}

void decL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 25703 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 25711 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x01 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 25720 "ad_x86.cpp"
  }
}

void decL_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 25748 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 25756 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x01);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 25776 "ad_x86.cpp"
  }
}

void leaL_rReg_immLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src0
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src0 */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src0 */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 25804 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 25812 "ad_x86.cpp"
  }
  {

#line 2594 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int reg_encoding = opnd_array(0)->reg(ra_,this)/* dst */;
    int base         = opnd_array(1)->reg(ra_,this,idx1)/* src0 */;      // 0xFFFFFFFF indicates no base
    int index        = 0x04;            // 0x04 indicates no index
    int scale        = 0x00;            // 0x00 indicates no scale
    int displace     = opnd_array(2)->constantL(); // 0x00 indicates no displacement
    relocInfo::relocType disp_reloc = relocInfo::none;
    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
                  disp_reloc);
  
#line 25827 "ad_x86.cpp"
  }
}

void addP_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 25855 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x03 /*primary()*/));
  
#line 25863 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 25871 "ad_x86.cpp"
  }
}

void addP_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2049 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x00 /*secondary()*/), dstenc);
  
#line 25904 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 25918 "ad_x86.cpp"
  }
}

void leaP_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src0
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src0 */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src0 */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 25946 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 25954 "ad_x86.cpp"
  }
  {

#line 2594 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int reg_encoding = opnd_array(0)->reg(ra_,this)/* dst */;
    int base         = opnd_array(1)->reg(ra_,this,idx1)/* src0 */;      // 0xFFFFFFFF indicates no base
    int index        = 0x04;            // 0x04 indicates no index
    int scale        = 0x00;            // 0x00 indicates no scale
    int displace     = opnd_array(2)->constantL(); // 0x00 indicates no displacement
    relocInfo::relocType disp_reloc = relocInfo::none;
    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
                  disp_reloc);
  
#line 25969 "ad_x86.cpp"
  }
}

void checkCastPPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  // User did not define which encode class to use.
}

uint checkCastPPNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void castPPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  // User did not define which encode class to use.
}

uint castPPNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void castIINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  // User did not define which encode class to use.
}

uint castIINode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void loadPLockedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 26051 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 26059 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 26075 "ad_x86.cpp"
  }
}

void storePConditionalNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// heap_top_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 26094 "ad_x86.cpp"
  }
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 26130 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 26138 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 26146 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 26162 "ad_x86.cpp"
  }
}

void storeIConditionalNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 26181 "ad_x86.cpp"
  }
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 26215 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 26223 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 26231 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 26247 "ad_x86.cpp"
  }
}

void storeLConditionalNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 26266 "ad_x86.cpp"
  }
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 26302 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 26310 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 26318 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 26334 "ad_x86.cpp"
  }
}

void compareAndSwapPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 26353 "ad_x86.cpp"
  }
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 26389 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 26397 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 26405 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 26421 "ad_x86.cpp"
  }
  {

#line 2395 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 26431 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 26439 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 26447 "ad_x86.cpp"
  }
  {

#line 1865 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 26455 "ad_x86.cpp"
  }
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 26473 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 26481 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 26489 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* res */ & 7, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 26497 "ad_x86.cpp"
  }
}

void compareAndSwapP_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 26516 "ad_x86.cpp"
  }
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 26552 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 26560 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 26568 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 26584 "ad_x86.cpp"
  }
  {

#line 2395 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 26594 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 26602 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 26610 "ad_x86.cpp"
  }
  {

#line 1865 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 26618 "ad_x86.cpp"
  }
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 26636 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 26644 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 26652 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* res */ & 7, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 26660 "ad_x86.cpp"
  }
}

void compareAndSwapLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 26679 "ad_x86.cpp"
  }
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 26715 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 26723 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 26731 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 26747 "ad_x86.cpp"
  }
  {

#line 2395 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 26757 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 26765 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 26773 "ad_x86.cpp"
  }
  {

#line 1865 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 26781 "ad_x86.cpp"
  }
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 26799 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 26807 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 26815 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* res */ & 7, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 26823 "ad_x86.cpp"
  }
}

void compareAndSwapL_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 26842 "ad_x86.cpp"
  }
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 26878 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 26886 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 26894 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 26910 "ad_x86.cpp"
  }
  {

#line 2395 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 26920 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 26928 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 26936 "ad_x86.cpp"
  }
  {

#line 1865 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 26944 "ad_x86.cpp"
  }
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 26962 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 26970 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 26978 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* res */ & 7, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 26986 "ad_x86.cpp"
  }
}

void compareAndSwapINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 27005 "ad_x86.cpp"
  }
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 27039 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 27047 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 27055 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 27071 "ad_x86.cpp"
  }
  {

#line 2395 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 27081 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 27089 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 27097 "ad_x86.cpp"
  }
  {

#line 1865 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 27105 "ad_x86.cpp"
  }
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 27123 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 27131 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 27139 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* res */ & 7, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 27147 "ad_x86.cpp"
  }
}

void compareAndSwapI_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 27166 "ad_x86.cpp"
  }
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 27200 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 27208 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 27216 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 27232 "ad_x86.cpp"
  }
  {

#line 2395 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 27242 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 27250 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 27258 "ad_x86.cpp"
  }
  {

#line 1865 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 27266 "ad_x86.cpp"
  }
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 27284 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 27292 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 27300 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* res */ & 7, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 27308 "ad_x86.cpp"
  }
}

void compareAndSwapBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 27327 "ad_x86.cpp"
  }
  {

#line 2419 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        } else if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ >= 4) {
          emit_opcode(cbuf, Assembler::REX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 27363 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 27371 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB0 /*secondary()*/));
  
#line 27379 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 27395 "ad_x86.cpp"
  }
  {

#line 2395 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 27405 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 27413 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 27421 "ad_x86.cpp"
  }
  {

#line 1865 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 27429 "ad_x86.cpp"
  }
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 27447 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 27455 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 27463 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* res */ & 7, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 27471 "ad_x86.cpp"
  }
}

void compareAndSwapB_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 27490 "ad_x86.cpp"
  }
  {

#line 2419 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        } else if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ >= 4) {
          emit_opcode(cbuf, Assembler::REX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 27526 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 27534 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB0 /*secondary()*/));
  
#line 27542 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 27558 "ad_x86.cpp"
  }
  {

#line 2395 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 27568 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 27576 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 27584 "ad_x86.cpp"
  }
  {

#line 1865 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 27592 "ad_x86.cpp"
  }
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 27610 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 27618 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 27626 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* res */ & 7, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 27634 "ad_x86.cpp"
  }
}

void compareAndSwapSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 27653 "ad_x86.cpp"
  }
  {

#line 1860 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, 0x66);
  
#line 27661 "ad_x86.cpp"
  }
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 27695 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 27703 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 27711 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 27727 "ad_x86.cpp"
  }
  {

#line 2395 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 27737 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 27745 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 27753 "ad_x86.cpp"
  }
  {

#line 1865 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 27761 "ad_x86.cpp"
  }
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 27779 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 27787 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 27795 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* res */ & 7, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 27803 "ad_x86.cpp"
  }
}

void compareAndSwapS_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 27822 "ad_x86.cpp"
  }
  {

#line 1860 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, 0x66);
  
#line 27830 "ad_x86.cpp"
  }
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 27864 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 27872 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 27880 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 27896 "ad_x86.cpp"
  }
  {

#line 2395 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 27906 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 27914 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 27922 "ad_x86.cpp"
  }
  {

#line 1865 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 27930 "ad_x86.cpp"
  }
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 27948 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 27956 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 27964 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* res */ & 7, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 27972 "ad_x86.cpp"
  }
}

void compareAndSwapNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 27991 "ad_x86.cpp"
  }
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 28025 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 28033 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 28041 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 28057 "ad_x86.cpp"
  }
  {

#line 2395 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 28067 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 28075 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 28083 "ad_x86.cpp"
  }
  {

#line 1865 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 28091 "ad_x86.cpp"
  }
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 28109 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 28117 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 28125 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* res */ & 7, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 28133 "ad_x86.cpp"
  }
}

void compareAndSwapN_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 28152 "ad_x86.cpp"
  }
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 28186 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 28194 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 28202 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 28218 "ad_x86.cpp"
  }
  {

#line 2395 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 28228 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 28236 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 28244 "ad_x86.cpp"
  }
  {

#line 1865 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 28252 "ad_x86.cpp"
  }
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* res */ >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* res */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* res */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 28270 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 28278 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 28286 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* res */ & 7, opnd_array(0)->reg(ra_,this)/* res */ & 7);
  
#line 28294 "ad_x86.cpp"
  }
}

void compareAndExchangeBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 28313 "ad_x86.cpp"
  }
  {

#line 2419 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        } else if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ >= 4) {
          emit_opcode(cbuf, Assembler::REX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 28349 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 28357 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB0 /*secondary()*/));
  
#line 28365 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 28381 "ad_x86.cpp"
  }
}

void compareAndExchangeSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 28400 "ad_x86.cpp"
  }
  {

#line 1860 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, 0x66);
  
#line 28408 "ad_x86.cpp"
  }
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 28442 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 28450 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 28458 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 28474 "ad_x86.cpp"
  }
}

void compareAndExchangeINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 28493 "ad_x86.cpp"
  }
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 28527 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 28535 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 28543 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 28559 "ad_x86.cpp"
  }
}

void compareAndExchangeLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 28578 "ad_x86.cpp"
  }
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 28614 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 28622 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 28630 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 28646 "ad_x86.cpp"
  }
}

void compareAndExchangeNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 28665 "ad_x86.cpp"
  }
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 28699 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 28707 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 28715 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 28731 "ad_x86.cpp"
  }
}

void compareAndExchangePNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem_ptr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// oldval
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// newval
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 28750 "ad_x86.cpp"
  }
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3)/* newval */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 28786 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 28794 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 28802 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3)/* newval */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 28818 "ad_x86.cpp"
  }
}

void xaddB_no_resNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// add
  {
    MacroAssembler _masm(&cbuf);

#line 7734 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) { __ lock(); }
    __ addb(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->constant());
  
#line 28836 "ad_x86.cpp"
  }
}

void xaddBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newval
  {
    MacroAssembler _masm(&cbuf);

#line 7745 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) { __ lock(); }
    __ xaddb(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->as_Register(ra_,this,idx2)/* newval */);
  
#line 28854 "ad_x86.cpp"
  }
}

void xaddS_no_resNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// add
  {
    MacroAssembler _masm(&cbuf);

#line 7757 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) { __ lock(); }
    __ addw(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->constant());
  
#line 28872 "ad_x86.cpp"
  }
}

void xaddSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newval
  {
    MacroAssembler _masm(&cbuf);

#line 7768 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) { __ lock(); }
    __ xaddw(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->as_Register(ra_,this,idx2)/* newval */);
  
#line 28890 "ad_x86.cpp"
  }
}

void xaddI_no_resNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// add
  {
    MacroAssembler _masm(&cbuf);

#line 7780 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) { __ lock(); }
    __ addl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->constant());
  
#line 28908 "ad_x86.cpp"
  }
}

void xaddINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newval
  {
    MacroAssembler _masm(&cbuf);

#line 7791 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) { __ lock(); }
    __ xaddl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->as_Register(ra_,this,idx2)/* newval */);
  
#line 28926 "ad_x86.cpp"
  }
}

void xaddL_no_resNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// add
  {
    MacroAssembler _masm(&cbuf);

#line 7803 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) { __ lock(); }
    __ addq(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->constantL());
  
#line 28944 "ad_x86.cpp"
  }
}

void xaddLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newval
  {
    MacroAssembler _masm(&cbuf);

#line 7814 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (os::is_MP()) { __ lock(); }
    __ xaddq(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->as_Register(ra_,this,idx2)/* newval */);
  
#line 28962 "ad_x86.cpp"
  }
}

void xchgBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newval
  {
    MacroAssembler _masm(&cbuf);

#line 7824 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ xchgb(opnd_array(2)->as_Register(ra_,this,idx2)/* newval */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 28979 "ad_x86.cpp"
  }
}

void xchgSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newval
  {
    MacroAssembler _masm(&cbuf);

#line 7833 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ xchgw(opnd_array(2)->as_Register(ra_,this,idx2)/* newval */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 28996 "ad_x86.cpp"
  }
}

void xchgINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newval
  {
    MacroAssembler _masm(&cbuf);

#line 7842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ xchgl(opnd_array(2)->as_Register(ra_,this,idx2)/* newval */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 29013 "ad_x86.cpp"
  }
}

void xchgLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newval
  {
    MacroAssembler _masm(&cbuf);

#line 7851 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ xchgq(opnd_array(2)->as_Register(ra_,this,idx2)/* newval */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 29030 "ad_x86.cpp"
  }
}

void xchgPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newval
  {
    MacroAssembler _masm(&cbuf);

#line 7860 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ xchgq(opnd_array(2)->as_Register(ra_,this,idx2)/* newval */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 29047 "ad_x86.cpp"
  }
}

void xchgNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// newval
  {
    MacroAssembler _masm(&cbuf);

#line 7869 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ xchgl(opnd_array(2)->as_Register(ra_,this,idx2)/* newval */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 29064 "ad_x86.cpp"
  }
}

void subI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 29090 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x2B /*primary()*/));
  
#line 29098 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 29106 "ad_x86.cpp"
  }
}

void subI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2029 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x05 /*secondary()*/), dstenc);
  
#line 29137 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 29151 "ad_x86.cpp"
  }
}

void subI_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 29193 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x2B /*primary()*/));
  
#line 29201 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 29217 "ad_x86.cpp"
  }
}

void subI_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 29259 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x29 /*primary()*/));
  
#line 29267 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 29283 "ad_x86.cpp"
  }
}

void subI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 29309 "ad_x86.cpp"
  }
  {

#line 2017 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 29324 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x05);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 29344 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 29358 "ad_x86.cpp"
  }
}

void subL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 29386 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x2B /*primary()*/));
  
#line 29394 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 29402 "ad_x86.cpp"
  }
}

void subL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2049 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x05 /*secondary()*/), dstenc);
  
#line 29435 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 29449 "ad_x86.cpp"
  }
}

void subL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 29493 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x2B /*primary()*/));
  
#line 29501 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 29517 "ad_x86.cpp"
  }
}

void subL_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 29561 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x29 /*primary()*/));
  
#line 29569 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 29585 "ad_x86.cpp"
  }
}

void subL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 29613 "ad_x86.cpp"
  }
  {

#line 2017 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 29628 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x05);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 29648 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 29662 "ad_x86.cpp"
  }
}

void subP_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(3)->reg(ra_,this,idx3)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(3)->reg(ra_,this,idx3)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 29691 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x2B /*primary()*/));
  
#line 29699 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(3)->reg(ra_,this,idx3)/* src */ & 7);
  
#line 29707 "ad_x86.cpp"
  }
}

void negI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* dst */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 29725 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 29733 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x03 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2)/* dst */ & 7);
  
#line 29742 "ad_x86.cpp"
  }
}

void negI_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 29768 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 29776 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x03 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 29796 "ad_x86.cpp"
  }
}

void negL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* dst */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 29816 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 29824 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x03 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2)/* dst */ & 7);
  
#line 29833 "ad_x86.cpp"
  }
}

void negL_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 29861 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 29869 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x03 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 29889 "ad_x86.cpp"
  }
}

void mulI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 29915 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 29923 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xAF /*secondary()*/));
  
#line 29931 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 29939 "ad_x86.cpp"
  }
}

void mulI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 29965 "ad_x86.cpp"
  }
  {

#line 2017 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x69 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x69 /*primary()*/));
    }
  
#line 29980 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* dst */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 29988 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 30002 "ad_x86.cpp"
  }
}

void mulI_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 30044 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 30052 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xAF /*secondary()*/));
  
#line 30060 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 30076 "ad_x86.cpp"
  }
}

void mulI_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 30118 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 30126 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xAF /*secondary()*/));
  
#line 30134 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 30150 "ad_x86.cpp"
  }
}

void mulI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 30192 "ad_x86.cpp"
  }
  {

#line 2017 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x69 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x69 /*primary()*/));
    }
  
#line 30207 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 30223 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 30237 "ad_x86.cpp"
  }
}

void mulL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 30265 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 30273 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xAF /*secondary()*/));
  
#line 30281 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 30289 "ad_x86.cpp"
  }
}

void mulL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 30317 "ad_x86.cpp"
  }
  {

#line 2017 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x69 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x69 /*primary()*/));
    }
  
#line 30332 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* dst */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 30340 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 30354 "ad_x86.cpp"
  }
}

void mulL_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 30398 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 30406 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xAF /*secondary()*/));
  
#line 30414 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 30430 "ad_x86.cpp"
  }
}

void mulL_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 30474 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 30482 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xAF /*secondary()*/));
  
#line 30490 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 30506 "ad_x86.cpp"
  }
}

void mulL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 30550 "ad_x86.cpp"
  }
  {

#line 2017 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x69 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x69 /*primary()*/));
    }
  
#line 30565 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 30581 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 30595 "ad_x86.cpp"
  }
}

void mulHiL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rax
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 30615 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 30623 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 30632 "ad_x86.cpp"
  }
}

void divI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// rax
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// div
  {

#line 1881 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Full implementation of Java idiv and irem; checks for
    // special case as described in JVM spec., p.243 & p.271.
    //
    //         normal case                           special case
    //
    // input : rax: dividend                         min_int
    //         reg: divisor                          -1
    //
    // output: rax: quotient  (= rax idiv reg)       min_int
    //         rdx: remainder (= rax irem reg)       0
    //
    //  Code sequnce:
    //
    //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
    //    5:   75 07/08                jne    e <normal>
    //    7:   33 d2                   xor    %edx,%edx
    //  [div >= 8 -> offset + 1]
    //  [REX_B]
    //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
    //    c:   74 03/04                je     11 <done>
    // 000000000000000e <normal>:
    //    e:   99                      cltd
    //  [div >= 8 -> offset + 1]
    //  [REX_B]
    //    f:   f7 f9                   idiv   $div
    // 0000000000000011 <done>:

    // cmp    $0x80000000,%eax
    emit_opcode(cbuf, 0x3d);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x80);

    // jne    e <normal>
    emit_opcode(cbuf, 0x75);
    emit_d8(cbuf, opnd_array(2)->reg(ra_,this,idx2)/* div */ < 8 ? 0x07 : 0x08);

    // xor    %edx,%edx
    emit_opcode(cbuf, 0x33);
    emit_d8(cbuf, 0xD2);

    // cmp    $0xffffffffffffffff,%ecx
    if (opnd_array(2)->reg(ra_,this,idx2)/* div */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x7, opnd_array(2)->reg(ra_,this,idx2)/* div */ & 7);
    emit_d8(cbuf, 0xFF);

    // je     11 <done>
    emit_opcode(cbuf, 0x74);
    emit_d8(cbuf, opnd_array(2)->reg(ra_,this,idx2)/* div */ < 8 ? 0x03 : 0x04);

    // <normal>
    // cltd
    emit_opcode(cbuf, 0x99);

    // idivl (note: must be emitted by the user of this rule)
    // <done>
  
#line 30707 "ad_x86.cpp"
  }
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* div */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 30717 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 30725 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2)/* div */ & 7);
  
#line 30734 "ad_x86.cpp"
  }
}

void divL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// rax
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// div
  {

#line 1945 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Full implementation of Java ldiv and lrem; checks for
    // special case as described in JVM spec., p.243 & p.271.
    //
    //         normal case                           special case
    //
    // input : rax: dividend                         min_long
    //         reg: divisor                          -1
    //
    // output: rax: quotient  (= rax idiv reg)       min_long
    //         rdx: remainder (= rax irem reg)       0
    //
    //  Code sequnce:
    //
    //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
    //    7:   00 00 80
    //    a:   48 39 d0                cmp    %rdx,%rax
    //    d:   75 08                   jne    17 <normal>
    //    f:   33 d2                   xor    %edx,%edx
    //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
    //   15:   74 05                   je     1c <done>
    // 0000000000000017 <normal>:
    //   17:   48 99                   cqto
    //   19:   48 f7 f9                idiv   $div
    // 000000000000001c <done>:

    // mov    $0x8000000000000000,%rdx
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0xBA);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x80);

    // cmp    %rdx,%rax
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x39);
    emit_d8(cbuf, 0xD0);

    // jne    17 <normal>
    emit_opcode(cbuf, 0x75);
    emit_d8(cbuf, 0x08);

    // xor    %edx,%edx
    emit_opcode(cbuf, 0x33);
    emit_d8(cbuf, 0xD2);

    // cmp    $0xffffffffffffffff,$div
    emit_opcode(cbuf, opnd_array(2)->reg(ra_,this,idx2)/* div */ < 8 ? Assembler::REX_W : Assembler::REX_WB);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x7, opnd_array(2)->reg(ra_,this,idx2)/* div */ & 7);
    emit_d8(cbuf, 0xFF);

    // je     1e <done>
    emit_opcode(cbuf, 0x74);
    emit_d8(cbuf, 0x05);

    // <normal>
    // cqto
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x99);

    // idivq (note: must be emitted by the user of this rule)
    // <done>
  
#line 30816 "ad_x86.cpp"
  }
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* div */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 30828 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 30836 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2)/* div */ & 7);
  
#line 30845 "ad_x86.cpp"
  }
}

void divModI_rReg_divmodNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// div
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rdx
  {

#line 1881 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Full implementation of Java idiv and irem; checks for
    // special case as described in JVM spec., p.243 & p.271.
    //
    //         normal case                           special case
    //
    // input : rax: dividend                         min_int
    //         reg: divisor                          -1
    //
    // output: rax: quotient  (= rax idiv reg)       min_int
    //         rdx: remainder (= rax irem reg)       0
    //
    //  Code sequnce:
    //
    //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
    //    5:   75 07/08                jne    e <normal>
    //    7:   33 d2                   xor    %edx,%edx
    //  [div >= 8 -> offset + 1]
    //  [REX_B]
    //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
    //    c:   74 03/04                je     11 <done>
    // 000000000000000e <normal>:
    //    e:   99                      cltd
    //  [div >= 8 -> offset + 1]
    //  [REX_B]
    //    f:   f7 f9                   idiv   $div
    // 0000000000000011 <done>:

    // cmp    $0x80000000,%eax
    emit_opcode(cbuf, 0x3d);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x80);

    // jne    e <normal>
    emit_opcode(cbuf, 0x75);
    emit_d8(cbuf, opnd_array(2)->reg(ra_,this,idx2)/* div */ < 8 ? 0x07 : 0x08);

    // xor    %edx,%edx
    emit_opcode(cbuf, 0x33);
    emit_d8(cbuf, 0xD2);

    // cmp    $0xffffffffffffffff,%ecx
    if (opnd_array(2)->reg(ra_,this,idx2)/* div */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x7, opnd_array(2)->reg(ra_,this,idx2)/* div */ & 7);
    emit_d8(cbuf, 0xFF);

    // je     11 <done>
    emit_opcode(cbuf, 0x74);
    emit_d8(cbuf, opnd_array(2)->reg(ra_,this,idx2)/* div */ < 8 ? 0x03 : 0x04);

    // <normal>
    // cltd
    emit_opcode(cbuf, 0x99);

    // idivl (note: must be emitted by the user of this rule)
    // <done>
  
#line 30920 "ad_x86.cpp"
  }
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* div */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 30930 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 30938 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2)/* div */ & 7);
  
#line 30947 "ad_x86.cpp"
  }
}

void divModL_rReg_divmodNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// div
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rdx
  {

#line 1945 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Full implementation of Java ldiv and lrem; checks for
    // special case as described in JVM spec., p.243 & p.271.
    //
    //         normal case                           special case
    //
    // input : rax: dividend                         min_long
    //         reg: divisor                          -1
    //
    // output: rax: quotient  (= rax idiv reg)       min_long
    //         rdx: remainder (= rax irem reg)       0
    //
    //  Code sequnce:
    //
    //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
    //    7:   00 00 80
    //    a:   48 39 d0                cmp    %rdx,%rax
    //    d:   75 08                   jne    17 <normal>
    //    f:   33 d2                   xor    %edx,%edx
    //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
    //   15:   74 05                   je     1c <done>
    // 0000000000000017 <normal>:
    //   17:   48 99                   cqto
    //   19:   48 f7 f9                idiv   $div
    // 000000000000001c <done>:

    // mov    $0x8000000000000000,%rdx
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0xBA);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x80);

    // cmp    %rdx,%rax
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x39);
    emit_d8(cbuf, 0xD0);

    // jne    17 <normal>
    emit_opcode(cbuf, 0x75);
    emit_d8(cbuf, 0x08);

    // xor    %edx,%edx
    emit_opcode(cbuf, 0x33);
    emit_d8(cbuf, 0xD2);

    // cmp    $0xffffffffffffffff,$div
    emit_opcode(cbuf, opnd_array(2)->reg(ra_,this,idx2)/* div */ < 8 ? Assembler::REX_W : Assembler::REX_WB);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x7, opnd_array(2)->reg(ra_,this,idx2)/* div */ & 7);
    emit_d8(cbuf, 0xFF);

    // je     1e <done>
    emit_opcode(cbuf, 0x74);
    emit_d8(cbuf, 0x05);

    // <normal>
    // cqto
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x99);

    // idivq (note: must be emitted by the user of this rule)
    // <done>
  
#line 31029 "ad_x86.cpp"
  }
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* div */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 31041 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 31049 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2)/* div */ & 7);
  
#line 31058 "ad_x86.cpp"
  }
}

void loadConL_0x6666666666666667Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {

#line 2254 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    emit_d64(cbuf, (0x6666666666666667));
  
#line 31081 "ad_x86.cpp"
  }
}

void mul_hiNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// rax
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 31101 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 31109 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 31118 "ad_x86.cpp"
  }
}

void sarL_rReg_63Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  {

#line 2228 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), dstenc);
    emit_d8(cbuf, (0x3F));
  
#line 31143 "ad_x86.cpp"
  }
}

void sarL_rReg_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  {

#line 2228 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), dstenc);
    emit_d8(cbuf, (0x2));
  
#line 31168 "ad_x86.cpp"
  }
}

void modI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// rax
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// div
  {

#line 1881 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Full implementation of Java idiv and irem; checks for
    // special case as described in JVM spec., p.243 & p.271.
    //
    //         normal case                           special case
    //
    // input : rax: dividend                         min_int
    //         reg: divisor                          -1
    //
    // output: rax: quotient  (= rax idiv reg)       min_int
    //         rdx: remainder (= rax irem reg)       0
    //
    //  Code sequnce:
    //
    //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
    //    5:   75 07/08                jne    e <normal>
    //    7:   33 d2                   xor    %edx,%edx
    //  [div >= 8 -> offset + 1]
    //  [REX_B]
    //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
    //    c:   74 03/04                je     11 <done>
    // 000000000000000e <normal>:
    //    e:   99                      cltd
    //  [div >= 8 -> offset + 1]
    //  [REX_B]
    //    f:   f7 f9                   idiv   $div
    // 0000000000000011 <done>:

    // cmp    $0x80000000,%eax
    emit_opcode(cbuf, 0x3d);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x80);

    // jne    e <normal>
    emit_opcode(cbuf, 0x75);
    emit_d8(cbuf, opnd_array(2)->reg(ra_,this,idx2)/* div */ < 8 ? 0x07 : 0x08);

    // xor    %edx,%edx
    emit_opcode(cbuf, 0x33);
    emit_d8(cbuf, 0xD2);

    // cmp    $0xffffffffffffffff,%ecx
    if (opnd_array(2)->reg(ra_,this,idx2)/* div */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x7, opnd_array(2)->reg(ra_,this,idx2)/* div */ & 7);
    emit_d8(cbuf, 0xFF);

    // je     11 <done>
    emit_opcode(cbuf, 0x74);
    emit_d8(cbuf, opnd_array(2)->reg(ra_,this,idx2)/* div */ < 8 ? 0x03 : 0x04);

    // <normal>
    // cltd
    emit_opcode(cbuf, 0x99);

    // idivl (note: must be emitted by the user of this rule)
    // <done>
  
#line 31243 "ad_x86.cpp"
  }
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* div */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 31253 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 31261 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2)/* div */ & 7);
  
#line 31270 "ad_x86.cpp"
  }
}

void modL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// rax
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// div
  {

#line 1945 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Full implementation of Java ldiv and lrem; checks for
    // special case as described in JVM spec., p.243 & p.271.
    //
    //         normal case                           special case
    //
    // input : rax: dividend                         min_long
    //         reg: divisor                          -1
    //
    // output: rax: quotient  (= rax idiv reg)       min_long
    //         rdx: remainder (= rax irem reg)       0
    //
    //  Code sequnce:
    //
    //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
    //    7:   00 00 80
    //    a:   48 39 d0                cmp    %rdx,%rax
    //    d:   75 08                   jne    17 <normal>
    //    f:   33 d2                   xor    %edx,%edx
    //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
    //   15:   74 05                   je     1c <done>
    // 0000000000000017 <normal>:
    //   17:   48 99                   cqto
    //   19:   48 f7 f9                idiv   $div
    // 000000000000001c <done>:

    // mov    $0x8000000000000000,%rdx
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0xBA);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x80);

    // cmp    %rdx,%rax
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x39);
    emit_d8(cbuf, 0xD0);

    // jne    17 <normal>
    emit_opcode(cbuf, 0x75);
    emit_d8(cbuf, 0x08);

    // xor    %edx,%edx
    emit_opcode(cbuf, 0x33);
    emit_d8(cbuf, 0xD2);

    // cmp    $0xffffffffffffffff,$div
    emit_opcode(cbuf, opnd_array(2)->reg(ra_,this,idx2)/* div */ < 8 ? Assembler::REX_W : Assembler::REX_WB);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x7, opnd_array(2)->reg(ra_,this,idx2)/* div */ & 7);
    emit_d8(cbuf, 0xFF);

    // je     1e <done>
    emit_opcode(cbuf, 0x74);
    emit_d8(cbuf, 0x05);

    // <normal>
    // cqto
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x99);

    // idivq (note: must be emitted by the user of this rule)
    // <done>
  
#line 31352 "ad_x86.cpp"
  }
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* div */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 31364 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 31372 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2)/* div */ & 7);
  
#line 31381 "ad_x86.cpp"
  }
}

void salI_rReg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 31399 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 31407 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 31416 "ad_x86.cpp"
  }
}

void salI_mem_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 31442 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 31450 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 31470 "ad_x86.cpp"
  }
}

void salI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2215 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 31494 "ad_x86.cpp"
  }
}

void salI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 31520 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xC1 /*primary()*/));
  
#line 31528 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 31548 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 31562 "ad_x86.cpp"
  }
}

void salI_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 31580 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 31588 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 31597 "ad_x86.cpp"
  }
}

void salI_mem_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 31623 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 31631 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 31651 "ad_x86.cpp"
  }
}

void sarI_rReg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 31669 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 31677 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 31686 "ad_x86.cpp"
  }
}

void sarI_mem_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 31712 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 31720 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x7 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 31740 "ad_x86.cpp"
  }
}

void sarI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2215 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 31764 "ad_x86.cpp"
  }
}

void sarI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 31790 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xC1 /*primary()*/));
  
#line 31798 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x7 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 31818 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 31832 "ad_x86.cpp"
  }
}

void sarI_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 31850 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 31858 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 31867 "ad_x86.cpp"
  }
}

void sarI_mem_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 31893 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 31901 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x7 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 31921 "ad_x86.cpp"
  }
}

void shrI_rReg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 31939 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 31947 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 31956 "ad_x86.cpp"
  }
}

void shrI_mem_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 31982 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 31990 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x5 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 32010 "ad_x86.cpp"
  }
}

void shrI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2215 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 32034 "ad_x86.cpp"
  }
}

void shrI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 32060 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xC1 /*primary()*/));
  
#line 32068 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x5 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 32088 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 32102 "ad_x86.cpp"
  }
}

void shrI_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 32120 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 32128 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 32137 "ad_x86.cpp"
  }
}

void shrI_mem_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 32163 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 32171 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x5 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 32191 "ad_x86.cpp"
  }
}

void salL_rReg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 32211 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 32219 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 32228 "ad_x86.cpp"
  }
}

void salL_mem_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 32256 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 32264 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 32284 "ad_x86.cpp"
  }
}

void salL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2228 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 32310 "ad_x86.cpp"
  }
}

void salL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 32338 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xC1 /*primary()*/));
  
#line 32346 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 32366 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 32380 "ad_x86.cpp"
  }
}

void salL_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 32400 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 32408 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 32417 "ad_x86.cpp"
  }
}

void salL_mem_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 32445 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 32453 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 32473 "ad_x86.cpp"
  }
}

void sarL_rReg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 32493 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 32501 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 32510 "ad_x86.cpp"
  }
}

void sarL_mem_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 32538 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 32546 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x7 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 32566 "ad_x86.cpp"
  }
}

void sarL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2228 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 32592 "ad_x86.cpp"
  }
}

void sarL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 32620 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xC1 /*primary()*/));
  
#line 32628 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x7 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 32648 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 32662 "ad_x86.cpp"
  }
}

void sarL_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 32682 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 32690 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 32699 "ad_x86.cpp"
  }
}

void sarL_mem_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 32727 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 32735 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x7 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 32755 "ad_x86.cpp"
  }
}

void shrL_rReg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 32775 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 32783 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 32792 "ad_x86.cpp"
  }
}

void shrL_mem_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 32820 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 32828 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x5 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 32848 "ad_x86.cpp"
  }
}

void shrL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2228 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 32874 "ad_x86.cpp"
  }
}

void shrL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 32902 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xC1 /*primary()*/));
  
#line 32910 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x5 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 32930 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 32944 "ad_x86.cpp"
  }
}

void shrL_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 32964 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 32972 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 32981 "ad_x86.cpp"
  }
}

void shrL_mem_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 33009 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 33017 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x5 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 33037 "ad_x86.cpp"
  }
}

void i2bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// twentyfour
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ >= 4) {
        emit_opcode(cbuf, opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 33063 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 33071 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xBE /*secondary()*/));
  
#line 33079 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* dst */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 33087 "ad_x86.cpp"
  }
}

void i2sNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// sixteen
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 33113 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 33121 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xBF /*secondary()*/));
  
#line 33129 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* dst */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 33137 "ad_x86.cpp"
  }
}

void rolI_rReg_imm1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 33154 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 33162 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x0 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 33171 "ad_x86.cpp"
  }
}

void rolI_rReg_imm8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// shift
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  {

#line 2215 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x0 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 33195 "ad_x86.cpp"
  }
}

void rolI_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// shift
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 33213 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 33221 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x0 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 33230 "ad_x86.cpp"
  }
}

void rorI_rReg_imm1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 33247 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 33255 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x1 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 33264 "ad_x86.cpp"
  }
}

void rorI_rReg_imm8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// shift
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  {

#line 2215 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x1 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 33288 "ad_x86.cpp"
  }
}

void rorI_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// shift
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 33306 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 33314 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x1 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 33323 "ad_x86.cpp"
  }
}

void rolL_rReg_imm1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 33342 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 33350 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x0 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 33359 "ad_x86.cpp"
  }
}

void rolL_rReg_imm8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// shift
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  {

#line 2228 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x0 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 33385 "ad_x86.cpp"
  }
}

void rolL_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// shift
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 33405 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 33413 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x0 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 33422 "ad_x86.cpp"
  }
}

void rorL_rReg_imm1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 33441 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 33449 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x1 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 33458 "ad_x86.cpp"
  }
}

void rorL_rReg_imm8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// shift
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  {

#line 2228 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x1 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 33484 "ad_x86.cpp"
  }
}

void rorL_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// shift
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 33504 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 33512 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x1 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 33521 "ad_x86.cpp"
  }
}

void andI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 33547 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x23 /*primary()*/));
  
#line 33555 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 33563 "ad_x86.cpp"
  }
}

void andI_rReg_imm255Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ >= 4) {
        emit_opcode(cbuf, opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 33589 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 33597 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6 /*secondary()*/));
  
#line 33605 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 33613 "ad_x86.cpp"
  }
}

void andI2L_rReg_imm255Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ >= 4) {
        emit_opcode(cbuf, opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 33639 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 33647 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6 /*secondary()*/));
  
#line 33655 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* dst */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 33663 "ad_x86.cpp"
  }
}

void andI_rReg_imm65535Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 33689 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 33697 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB7 /*secondary()*/));
  
#line 33705 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 33713 "ad_x86.cpp"
  }
}

void andI2L_rReg_imm65535Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 33739 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 33747 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB7 /*secondary()*/));
  
#line 33755 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* dst */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 33763 "ad_x86.cpp"
  }
}

void andI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2029 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x04 /*secondary()*/), dstenc);
  
#line 33794 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 33808 "ad_x86.cpp"
  }
}

void andI_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 33850 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x23 /*primary()*/));
  
#line 33858 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 33874 "ad_x86.cpp"
  }
}

void andI_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 33916 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x23 /*primary()*/));
  
#line 33924 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 33940 "ad_x86.cpp"
  }
}

void andI_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 33982 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x21 /*primary()*/));
  
#line 33990 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 34006 "ad_x86.cpp"
  }
}

void andI_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 34048 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x21 /*primary()*/));
  
#line 34056 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 34072 "ad_x86.cpp"
  }
}

void andI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 34098 "ad_x86.cpp"
  }
  {

#line 2017 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 34113 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 34133 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 34147 "ad_x86.cpp"
  }
}

void andnI_rReg_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 9229 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ andnl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(3)->base(ra_,this,idx3), opnd_array(3)->index(ra_,this,idx3), opnd_array(3)->scale(), opnd_array(3)->disp(ra_,this,idx3), opnd_array(3)->disp_reloc()));
  
#line 34165 "ad_x86.cpp"
  }
}

void andnI_rReg_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9229 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ andnl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(2)->as_Register(ra_,this,idx2)/* src1 */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 34183 "ad_x86.cpp"
  }
}

void andnI_rReg_rReg_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 9242 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ andnl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* src2 */);
  
#line 34201 "ad_x86.cpp"
  }
}

void andnI_rReg_rReg_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9242 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ andnl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(2)->as_Register(ra_,this,idx2)/* src1 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src2 */);
  
#line 34219 "ad_x86.cpp"
  }
}

void blsiI_rReg_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// imm_zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9255 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsil(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(2)->as_Register(ra_,this,idx2)/* src */);
  
#line 34236 "ad_x86.cpp"
  }
}

void blsiI_rReg_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm_zero
  {
    MacroAssembler _masm(&cbuf);

#line 9255 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsil(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 34253 "ad_x86.cpp"
  }
}

void blsiI_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// imm_zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9269 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsil(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 34270 "ad_x86.cpp"
  }
}

void blsiI_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm_zero
  {
    MacroAssembler _masm(&cbuf);

#line 9269 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsil(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 34287 "ad_x86.cpp"
  }
}

void blsmskI_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9284 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsmskl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 34304 "ad_x86.cpp"
  }
}

void blsmskI_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9284 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsmskl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 34321 "ad_x86.cpp"
  }
}

void blsmskI_rReg_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9298 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsmskl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 34338 "ad_x86.cpp"
  }
}

void blsmskI_rReg_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9298 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsmskl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 34355 "ad_x86.cpp"
  }
}

void blsrI_rReg_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9313 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsrl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 34372 "ad_x86.cpp"
  }
}

void blsrI_rReg_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9313 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsrl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 34389 "ad_x86.cpp"
  }
}

void blsrI_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9329 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsrl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 34406 "ad_x86.cpp"
  }
}

void blsrI_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9329 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsrl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 34423 "ad_x86.cpp"
  }
}

void orI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 34449 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 34457 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 34465 "ad_x86.cpp"
  }
}

void orI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2029 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x01 /*secondary()*/), dstenc);
  
#line 34496 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 34510 "ad_x86.cpp"
  }
}

void orI_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 34552 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 34560 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 34576 "ad_x86.cpp"
  }
}

void orI_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 34618 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 34626 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 34642 "ad_x86.cpp"
  }
}

void orI_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 34684 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x09 /*primary()*/));
  
#line 34692 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 34708 "ad_x86.cpp"
  }
}

void orI_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 34750 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x09 /*primary()*/));
  
#line 34758 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 34774 "ad_x86.cpp"
  }
}

void orI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 34800 "ad_x86.cpp"
  }
  {

#line 2017 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 34815 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x1 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 34835 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 34849 "ad_x86.cpp"
  }
}

void xorI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 34875 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 34883 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 34891 "ad_x86.cpp"
  }
}

void xorI_rReg_im1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm
  {
    MacroAssembler _masm(&cbuf);

#line 9419 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

     __ notl(opnd_array(1)->as_Register(ra_,this,idx1)/* dst */);
  
#line 34908 "ad_x86.cpp"
  }
}

void xorI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2029 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x06 /*secondary()*/), dstenc);
  
#line 34939 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 34953 "ad_x86.cpp"
  }
}

void xorI_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 34995 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 35003 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 35019 "ad_x86.cpp"
  }
}

void xorI_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 35061 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 35069 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 35085 "ad_x86.cpp"
  }
}

void xorI_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 35127 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x31 /*primary()*/));
  
#line 35135 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 35151 "ad_x86.cpp"
  }
}

void xorI_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 35193 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x31 /*primary()*/));
  
#line 35201 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 35217 "ad_x86.cpp"
  }
}

void xorI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 35243 "ad_x86.cpp"
  }
  {

#line 2017 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 35258 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x6 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 35278 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 35292 "ad_x86.cpp"
  }
}

void andL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 35320 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x23 /*primary()*/));
  
#line 35328 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 35336 "ad_x86.cpp"
  }
}

void andL_rReg_imm255Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 35364 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 35372 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6 /*secondary()*/));
  
#line 35380 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 35388 "ad_x86.cpp"
  }
}

void andL_rReg_imm65535Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 35416 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 35424 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB7 /*secondary()*/));
  
#line 35432 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7);
  
#line 35440 "ad_x86.cpp"
  }
}

void andL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2049 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x04 /*secondary()*/), dstenc);
  
#line 35473 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 35487 "ad_x86.cpp"
  }
}

void andL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 35531 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x23 /*primary()*/));
  
#line 35539 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 35555 "ad_x86.cpp"
  }
}

void andL_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 35599 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x23 /*primary()*/));
  
#line 35607 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 35623 "ad_x86.cpp"
  }
}

void andL_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 35667 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x21 /*primary()*/));
  
#line 35675 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 35691 "ad_x86.cpp"
  }
}

void andL_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 35735 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x21 /*primary()*/));
  
#line 35743 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 35759 "ad_x86.cpp"
  }
}

void andL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 35787 "ad_x86.cpp"
  }
  {

#line 2017 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 35802 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 35822 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 35836 "ad_x86.cpp"
  }
}

void andnL_rReg_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 9576 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ andnq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(3)->base(ra_,this,idx3), opnd_array(3)->index(ra_,this,idx3), opnd_array(3)->scale(), opnd_array(3)->disp(ra_,this,idx3), opnd_array(3)->disp_reloc()));
  
#line 35854 "ad_x86.cpp"
  }
}

void andnL_rReg_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9576 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ andnq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(2)->as_Register(ra_,this,idx2)/* src1 */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 35872 "ad_x86.cpp"
  }
}

void andnL_rReg_rReg_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 9589 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

  __ andnq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* src2 */);
  
#line 35890 "ad_x86.cpp"
  }
}

void andnL_rReg_rReg_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9589 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

  __ andnq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(2)->as_Register(ra_,this,idx2)/* src1 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src2 */);
  
#line 35908 "ad_x86.cpp"
  }
}

void blsiL_rReg_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// imm_zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9602 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsiq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(2)->as_Register(ra_,this,idx2)/* src */);
  
#line 35925 "ad_x86.cpp"
  }
}

void blsiL_rReg_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm_zero
  {
    MacroAssembler _masm(&cbuf);

#line 9602 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsiq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 35942 "ad_x86.cpp"
  }
}

void blsiL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// imm_zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9616 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsiq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 35959 "ad_x86.cpp"
  }
}

void blsiL_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm_zero
  {
    MacroAssembler _masm(&cbuf);

#line 9616 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsiq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 35976 "ad_x86.cpp"
  }
}

void blsmskL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9631 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsmskq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 35993 "ad_x86.cpp"
  }
}

void blsmskL_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9631 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsmskq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 36010 "ad_x86.cpp"
  }
}

void blsmskL_rReg_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9645 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsmskq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 36027 "ad_x86.cpp"
  }
}

void blsmskL_rReg_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9645 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsmskq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 36044 "ad_x86.cpp"
  }
}

void blsrL_rReg_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9660 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsrq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 36061 "ad_x86.cpp"
  }
}

void blsrL_rReg_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9660 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsrq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 36078 "ad_x86.cpp"
  }
}

void blsrL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9676 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsrq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 36095 "ad_x86.cpp"
  }
}

void blsrL_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// minus_1
  {
    MacroAssembler _masm(&cbuf);

#line 9676 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ blsrq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 36112 "ad_x86.cpp"
  }
}

void orL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 36140 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 36148 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 36156 "ad_x86.cpp"
  }
}

void orL_rReg_castP2XNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 36184 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 36192 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 36200 "ad_x86.cpp"
  }
}

void orL_rReg_castP2X_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* dst */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 36228 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 36236 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(2)->reg(ra_,this,idx2)/* dst */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 36244 "ad_x86.cpp"
  }
}

void orL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2049 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x01 /*secondary()*/), dstenc);
  
#line 36277 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 36291 "ad_x86.cpp"
  }
}

void orL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 36335 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 36343 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 36359 "ad_x86.cpp"
  }
}

void orL_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 36403 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 36411 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 36427 "ad_x86.cpp"
  }
}

void orL_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 36471 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x09 /*primary()*/));
  
#line 36479 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 36495 "ad_x86.cpp"
  }
}

void orL_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 36539 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x09 /*primary()*/));
  
#line 36547 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 36563 "ad_x86.cpp"
  }
}

void orL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 36591 "ad_x86.cpp"
  }
  {

#line 2017 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 36606 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x1 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 36626 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 36640 "ad_x86.cpp"
  }
}

void xorL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 36668 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 36676 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 36684 "ad_x86.cpp"
  }
}

void xorL_rReg_im1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm
  {
    MacroAssembler _masm(&cbuf);

#line 9778 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

     __ notq(opnd_array(1)->as_Register(ra_,this,idx1)/* dst */);
  
#line 36701 "ad_x86.cpp"
  }
}

void xorL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2049 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x06 /*secondary()*/), dstenc);
  
#line 36734 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 36748 "ad_x86.cpp"
  }
}

void xorL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 36792 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 36800 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* dst */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 36816 "ad_x86.cpp"
  }
}

void xorL_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* dst */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 36860 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 36868 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* dst */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 36884 "ad_x86.cpp"
  }
}

void xorL_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 36928 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x31 /*primary()*/));
  
#line 36936 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 36952 "ad_x86.cpp"
  }
}

void xorL_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 36996 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x31 /*primary()*/));
  
#line 37004 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 37020 "ad_x86.cpp"
  }
}

void xorL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 37048 "ad_x86.cpp"
  }
  {

#line 2017 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 37063 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x6 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 37083 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 37097 "ad_x86.cpp"
  }
}

void convI2BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 37122 "ad_x86.cpp"
  }
  {

#line 1875 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x85));
    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 37131 "ad_x86.cpp"
  }
  {

#line 2647 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    } else if (dstenc >= 4) {
      emit_opcode(cbuf, Assembler::REX);
    }
    // SETNZ $dst
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x95);
    emit_rm(cbuf, 0x3, 0x0, dstenc);
  
#line 37149 "ad_x86.cpp"
  }
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* dst */ >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* dst */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 37167 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 37175 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 37183 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* dst */ & 7, opnd_array(0)->reg(ra_,this)/* dst */ & 7);
  
#line 37191 "ad_x86.cpp"
  }
}

void convP2BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 37218 "ad_x86.cpp"
  }
  {

#line 1875 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x85));
    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 37227 "ad_x86.cpp"
  }
  {

#line 2647 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    } else if (dstenc >= 4) {
      emit_opcode(cbuf, Assembler::REX);
    }
    // SETNZ $dst
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x95);
    emit_rm(cbuf, 0x3, 0x0, dstenc);
  
#line 37245 "ad_x86.cpp"
  }
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* dst */ >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* dst */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 37263 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 37271 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 37279 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* dst */ & 7, opnd_array(0)->reg(ra_,this)/* dst */ & 7);
  
#line 37287 "ad_x86.cpp"
  }
}

void cmpLTMaskNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// p
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// q
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* p */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* q */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* q */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 37313 "ad_x86.cpp"
  }
  {

#line 1875 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x3B));
    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* p */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* q */ & 7);
  
#line 37322 "ad_x86.cpp"
  }
  {

#line 2632 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    } else if (dstenc >= 4) {
      emit_opcode(cbuf, Assembler::REX);
    }
    // SETLT $dst
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x9C);
    emit_rm(cbuf, 0x3, 0x0, dstenc);
  
#line 37340 "ad_x86.cpp"
  }
  {

#line 2403 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
      if (opnd_array(0)->reg(ra_,this)/* dst */ >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this)/* dst */ < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this)/* dst */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 37358 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 37366 "ad_x86.cpp"
  }
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 37374 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this)/* dst */ & 7, opnd_array(0)->reg(ra_,this)/* dst */ & 7);
  
#line 37382 "ad_x86.cpp"
  }
  {

#line 2606 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this)/* dst */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // NEG $dst
    emit_opcode(cbuf, 0xF7);
    emit_rm(cbuf, 0x3, 0x03, dstenc);
  
#line 37397 "ad_x86.cpp"
  }
}

void cmpLTMask0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 9893 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

  __ sarl(opnd_array(1)->as_Register(ra_,this,idx1)/* dst */, 31);
  
#line 37414 "ad_x86.cpp"
  }
}

void cadd_cmpLTMaskNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// p
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// q
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// y
  {
    MacroAssembler _masm(&cbuf);

#line 9909 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register Rp = opnd_array(1)->as_Register(ra_,this,idx1)/* p */;
    Register Rq = opnd_array(2)->as_Register(ra_,this,idx2)/* q */;
    Register Ry = opnd_array(3)->as_Register(ra_,this,idx3)/* y */;
    Label done;
    __ subl(Rp, Rq);
    __ jccb(Assembler::greaterEqual, done);
    __ addl(Rp, Ry);
    __ bind(done);
  
#line 37439 "ad_x86.cpp"
  }
}

void cadd_cmpLTMask_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// p
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// q
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// y
  {
    MacroAssembler _masm(&cbuf);

#line 9909 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register Rp = opnd_array(1)->as_Register(ra_,this,idx1)/* p */;
    Register Rq = opnd_array(2)->as_Register(ra_,this,idx2)/* q */;
    Register Ry = opnd_array(3)->as_Register(ra_,this,idx3)/* y */;
    Label done;
    __ subl(Rp, Rq);
    __ jccb(Assembler::greaterEqual, done);
    __ addl(Rp, Ry);
    __ bind(done);
  
#line 37464 "ad_x86.cpp"
  }
}

void cadd_cmpLTMask_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// y
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// p
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// q
  {
    MacroAssembler _masm(&cbuf);

#line 9909 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register Rp = opnd_array(2)->as_Register(ra_,this,idx2)/* p */;
    Register Rq = opnd_array(3)->as_Register(ra_,this,idx3)/* q */;
    Register Ry = opnd_array(1)->as_Register(ra_,this,idx1)/* y */;
    Label done;
    __ subl(Rp, Rq);
    __ jccb(Assembler::greaterEqual, done);
    __ addl(Rp, Ry);
    __ bind(done);
  
#line 37489 "ad_x86.cpp"
  }
}

void cadd_cmpLTMask_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// p
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// q
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// y
  {
    MacroAssembler _masm(&cbuf);

#line 9909 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register Rp = opnd_array(1)->as_Register(ra_,this,idx1)/* p */;
    Register Rq = opnd_array(2)->as_Register(ra_,this,idx2)/* q */;
    Register Ry = opnd_array(3)->as_Register(ra_,this,idx3)/* y */;
    Label done;
    __ subl(Rp, Rq);
    __ jccb(Assembler::greaterEqual, done);
    __ addl(Rp, Ry);
    __ bind(done);
  
#line 37514 "ad_x86.cpp"
  }
}

void and_cmpLTMaskNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// p
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// q
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// y
  {
    MacroAssembler _masm(&cbuf);

#line 9934 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register Rp = opnd_array(1)->as_Register(ra_,this,idx1)/* p */;
    Register Rq = opnd_array(2)->as_Register(ra_,this,idx2)/* q */;
    Register Ry = opnd_array(3)->as_Register(ra_,this,idx3)/* y */;
    Label done;
    __ cmpl(Rp, Rq);
    __ jccb(Assembler::less, done);
    __ xorl(Ry, Ry);
    __ bind(done);
  
#line 37539 "ad_x86.cpp"
  }
}

void and_cmpLTMask_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// y
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// p
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// q
  {
    MacroAssembler _masm(&cbuf);

#line 9934 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register Rp = opnd_array(2)->as_Register(ra_,this,idx2)/* p */;
    Register Rq = opnd_array(3)->as_Register(ra_,this,idx3)/* q */;
    Register Ry = opnd_array(1)->as_Register(ra_,this,idx1)/* y */;
    Label done;
    __ cmpl(Rp, Rq);
    __ jccb(Assembler::less, done);
    __ xorl(Ry, Ry);
    __ bind(done);
  
#line 37564 "ad_x86.cpp"
  }
}

void cmpF_cc_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 9961 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomiss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    emit_cmpfp_fixup(_masm);
  
#line 37582 "ad_x86.cpp"
  }
}

void cmpF_cc_reg_CFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 9973 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomiss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
  
#line 37599 "ad_x86.cpp"
  }
}

void cmpF_cc_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 9990 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomiss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
    emit_cmpfp_fixup(_masm);
  
#line 37617 "ad_x86.cpp"
  }
}

void cmpF_cc_memCFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10002 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomiss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 37634 "ad_x86.cpp"
  }
}

void cmpF_cc_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 10018 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomiss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    emit_cmpfp_fixup(_masm);
  
#line 37652 "ad_x86.cpp"
  }
}

void cmpF_cc_immNode::eval_constant(Compile* C) {
  {

#line 10019 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 37661 "ad_x86.cpp"
  }
}
void cmpF_cc_immCFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 10029 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomiss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 37677 "ad_x86.cpp"
  }
}

void cmpF_cc_immCFNode::eval_constant(Compile* C) {
  {

#line 10030 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 37686 "ad_x86.cpp"
  }
}
void cmpD_cc_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10046 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomisd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    emit_cmpfp_fixup(_masm);
  
#line 37703 "ad_x86.cpp"
  }
}

void cmpD_cc_reg_CFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10058 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomisd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
  
#line 37720 "ad_x86.cpp"
  }
}

void cmpD_cc_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10075 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomisd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
    emit_cmpfp_fixup(_masm);
  
#line 37738 "ad_x86.cpp"
  }
}

void cmpD_cc_memCFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10087 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomisd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 37755 "ad_x86.cpp"
  }
}

void cmpD_cc_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 10103 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomisd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    emit_cmpfp_fixup(_masm);
  
#line 37773 "ad_x86.cpp"
  }
}

void cmpD_cc_immNode::eval_constant(Compile* C) {
  {

#line 10104 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 37782 "ad_x86.cpp"
  }
}
void cmpD_cc_immCFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 10114 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomisd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 37798 "ad_x86.cpp"
  }
}

void cmpD_cc_immCFNode::eval_constant(Compile* C) {
  {

#line 10115 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 37807 "ad_x86.cpp"
  }
}
void cmpF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10134 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomiss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    emit_cmpfp3(_masm, opnd_array(0)->as_Register(ra_,this)/* dst */);
  
#line 37824 "ad_x86.cpp"
  }
}

void cmpF_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10155 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomiss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
    emit_cmpfp3(_masm, opnd_array(0)->as_Register(ra_,this)/* dst */);
  
#line 37842 "ad_x86.cpp"
  }
}

void cmpF_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 10175 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomiss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    emit_cmpfp3(_masm, opnd_array(0)->as_Register(ra_,this)/* dst */);
  
#line 37860 "ad_x86.cpp"
  }
}

void cmpF_immNode::eval_constant(Compile* C) {
  {

#line 10176 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 37869 "ad_x86.cpp"
  }
}
void cmpD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10196 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomisd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    emit_cmpfp3(_masm, opnd_array(0)->as_Register(ra_,this)/* dst */);
  
#line 37886 "ad_x86.cpp"
  }
}

void cmpD_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10217 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomisd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
    emit_cmpfp3(_masm, opnd_array(0)->as_Register(ra_,this)/* dst */);
  
#line 37904 "ad_x86.cpp"
  }
}

void cmpD_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 10237 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ ucomisd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    emit_cmpfp3(_masm, opnd_array(0)->as_Register(ra_,this)/* dst */);
  
#line 37922 "ad_x86.cpp"
  }
}

void cmpD_immNode::eval_constant(Compile* C) {
  {

#line 10238 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 37931 "ad_x86.cpp"
  }
}
void roundFloat_nopNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  // User did not define which encode class to use.
}

void roundDouble_nopNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  // User did not define which encode class to use.
}

void convF2D_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10269 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cvtss2sd (opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
  
#line 37962 "ad_x86.cpp"
  }
}

void convF2D_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10280 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cvtss2sd (opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 37978 "ad_x86.cpp"
  }
}

void convD2F_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10291 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cvtsd2ss (opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
  
#line 37994 "ad_x86.cpp"
  }
}

void convD2F_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10302 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cvtsd2ss (opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 38010 "ad_x86.cpp"
  }
}

void convF2I_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10322 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label done;
    __ cvttss2sil(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
    __ cmpl(opnd_array(0)->as_Register(ra_,this)/* dst */, 0x80000000);
    __ jccb(Assembler::notEqual, done);
    __ subptr(rsp, 8);
    __ movflt(Address(rsp, 0), opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
    __ pop(opnd_array(0)->as_Register(ra_,this)/* dst */);
    __ bind(done);
  
#line 38034 "ad_x86.cpp"
  }
}

void convF2L_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10349 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label done;
    __ cvttss2siq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
    __ cmp64(opnd_array(0)->as_Register(ra_,this)/* dst */,
             ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
    __ jccb(Assembler::notEqual, done);
    __ subptr(rsp, 8);
    __ movflt(Address(rsp, 0), opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
    __ pop(opnd_array(0)->as_Register(ra_,this)/* dst */);
    __ bind(done);
  
#line 38059 "ad_x86.cpp"
  }
}

void convD2I_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label done;
    __ cvttsd2sil(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
    __ cmpl(opnd_array(0)->as_Register(ra_,this)/* dst */, 0x80000000);
    __ jccb(Assembler::notEqual, done);
    __ subptr(rsp, 8);
    __ movdbl(Address(rsp, 0), opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
    __ pop(opnd_array(0)->as_Register(ra_,this)/* dst */);
    __ bind(done);
  
#line 38083 "ad_x86.cpp"
  }
}

void convD2L_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10404 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label done;
    __ cvttsd2siq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
    __ cmp64(opnd_array(0)->as_Register(ra_,this)/* dst */,
             ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
    __ jccb(Assembler::notEqual, done);
    __ subptr(rsp, 8);
    __ movdbl(Address(rsp, 0), opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
    __ pop(opnd_array(0)->as_Register(ra_,this)/* dst */);
    __ bind(done);
  
#line 38108 "ad_x86.cpp"
  }
}

void convI2F_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10425 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cvtsi2ssl (opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 38124 "ad_x86.cpp"
  }
}

void convI2F_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10436 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cvtsi2ssl (opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 38140 "ad_x86.cpp"
  }
}

void convI2D_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10448 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cvtsi2sdl (opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 38156 "ad_x86.cpp"
  }
}

void convI2D_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cvtsi2sdl (opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 38172 "ad_x86.cpp"
  }
}

void convXI2F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10472 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ cvtdq2ps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 38189 "ad_x86.cpp"
  }
}

void convXI2D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10486 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ cvtdq2pd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 38206 "ad_x86.cpp"
  }
}

void convL2F_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10498 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cvtsi2ssq (opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 38222 "ad_x86.cpp"
  }
}

void convL2F_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10509 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cvtsi2ssq (opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 38238 "ad_x86.cpp"
  }
}

void convL2D_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10520 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cvtsi2sdq (opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 38254 "ad_x86.cpp"
  }
}

void convL2D_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cvtsi2sdq (opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 38270 "ad_x86.cpp"
  }
}

void convI2L_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10543 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movslq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 38286 "ad_x86.cpp"
  }
}

void convI2L_reg_reg_zexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {
    MacroAssembler _masm(&cbuf);

#line 10572 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this)/* dst */!= opnd_array(1)->reg(ra_,this,idx1)/* src */) {
      __ movl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    }
  
#line 38305 "ad_x86.cpp"
  }
}

void convI2L_reg_mem_zexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {
    MacroAssembler _masm(&cbuf);

#line 10586 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 38322 "ad_x86.cpp"
  }
}

void zerox_long_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mask
  {
    MacroAssembler _masm(&cbuf);

#line 10597 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 38339 "ad_x86.cpp"
  }
}

void convL2I_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10608 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 38355 "ad_x86.cpp"
  }
}

void MoveF2I_stack_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10621 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movl(opnd_array(0)->as_Register(ra_,this)/* dst */, Address(rsp, opnd_array(1)->disp(ra_,this,idx1)));
  
#line 38371 "ad_x86.cpp"
  }
}

void MoveI2F_stack_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10633 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movflt(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address(rsp, opnd_array(1)->disp(ra_,this,idx1)));
  
#line 38387 "ad_x86.cpp"
  }
}

void MoveD2L_stack_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10645 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movq(opnd_array(0)->as_Register(ra_,this)/* dst */, Address(rsp, opnd_array(1)->disp(ra_,this,idx1)));
  
#line 38403 "ad_x86.cpp"
  }
}

void MoveL2D_stack_reg_partialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10658 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movdbl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address(rsp, opnd_array(1)->disp(ra_,this,idx1)));
  
#line 38419 "ad_x86.cpp"
  }
}

void MoveL2D_stack_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10671 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movdbl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address(rsp, opnd_array(1)->disp(ra_,this,idx1)));
  
#line 38435 "ad_x86.cpp"
  }
}

void MoveF2I_reg_stackNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10684 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movflt(Address(rsp, opnd_array(0)->disp(ra_,this,0)), opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
  
#line 38451 "ad_x86.cpp"
  }
}

void MoveI2F_reg_stackNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10696 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movl(Address(rsp, opnd_array(0)->disp(ra_,this,0)), opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 38467 "ad_x86.cpp"
  }
}

void MoveD2L_reg_stackNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10708 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movdbl(Address(rsp, opnd_array(0)->disp(ra_,this,0)), opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
  
#line 38483 "ad_x86.cpp"
  }
}

void MoveL2D_reg_stackNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10720 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movq(Address(rsp, opnd_array(0)->disp(ra_,this,0)), opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 38499 "ad_x86.cpp"
  }
}

void MoveF2I_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10731 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
  
#line 38515 "ad_x86.cpp"
  }
}

void MoveD2L_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10742 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movdq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
  
#line 38531 "ad_x86.cpp"
  }
}

void MoveI2F_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10753 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 38547 "ad_x86.cpp"
  }
}

void MoveL2D_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10764 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

     __ movdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 38563 "ad_x86.cpp"
  }
}

void rep_stosNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// cnt
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// base
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 10825 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ clear_mem(opnd_array(2)->as_Register(ra_,this,idx2)/* base */, opnd_array(1)->as_Register(ra_,this,idx1)/* cnt */, as_Register(RAX_enc),
                 opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, false);
  
#line 38582 "ad_x86.cpp"
  }
}

void rep_stos_largeNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// cnt
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// base
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 10875 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ clear_mem(opnd_array(2)->as_Register(ra_,this,idx2)/* base */, opnd_array(1)->as_Register(ra_,this,idx1)/* cnt */, as_Register(RAX_enc), 
                 opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, true);
  
#line 38601 "ad_x86.cpp"
  }
}

void string_compareLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  {
    MacroAssembler _masm(&cbuf);

#line 10890 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ string_compare(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */, opnd_array(0)->as_Register(ra_,this)/* result */,
                      opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp1 */, StrIntrinsicNode::LL);
  
#line 38623 "ad_x86.cpp"
  }
}

void string_compareUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  {
    MacroAssembler _masm(&cbuf);

#line 10906 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ string_compare(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */, opnd_array(0)->as_Register(ra_,this)/* result */,
                      opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp1 */, StrIntrinsicNode::UU);
  
#line 38645 "ad_x86.cpp"
  }
}

void string_compareLUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  {
    MacroAssembler _masm(&cbuf);

#line 10922 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ string_compare(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */, opnd_array(0)->as_Register(ra_,this)/* result */,
                      opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp1 */, StrIntrinsicNode::LU);
  
#line 38667 "ad_x86.cpp"
  }
}

void string_compareULNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp1
  {
    MacroAssembler _masm(&cbuf);

#line 10938 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ string_compare(opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */,
                      opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */, opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(0)->as_Register(ra_,this)/* result */,
                      opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp1 */, StrIntrinsicNode::UL);
  
#line 38689 "ad_x86.cpp"
  }
}

void string_indexof_conLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// int_cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vec
  {
    MacroAssembler _masm(&cbuf);

#line 10955 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int icnt2 = (int)opnd_array(4)->constant();
    if (icnt2 >= 16) {
      // IndexOf for constant substrings with size >= 16 elements
      // which don't need to be loaded through stack.
      __ string_indexofC8(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                          opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, as_Register(RAX_enc),
                          icnt2, opnd_array(0)->as_Register(ra_,this)/* result */,
                          opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* vec */, as_Register(RCX_enc), StrIntrinsicNode::LL);
    } else {
      // Small strings are loaded through stack if they cross page boundary.
      __ string_indexof(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                        opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, as_Register(RAX_enc),
                        icnt2, opnd_array(0)->as_Register(ra_,this)/* result */,
                        opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* vec */, as_Register(RCX_enc), StrIntrinsicNode::LL);
    }
  
#line 38723 "ad_x86.cpp"
  }
}

void string_indexof_conUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// int_cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vec
  {
    MacroAssembler _masm(&cbuf);

#line 10984 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int icnt2 = (int)opnd_array(4)->constant();
    if (icnt2 >= 8) {
      // IndexOf for constant substrings with size >= 8 elements
      // which don't need to be loaded through stack.
      __ string_indexofC8(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                          opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, as_Register(RAX_enc),
                          icnt2, opnd_array(0)->as_Register(ra_,this)/* result */,
                          opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* vec */, as_Register(RCX_enc), StrIntrinsicNode::UU);
    } else {
      // Small strings are loaded through stack if they cross page boundary.
      __ string_indexof(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                        opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, as_Register(RAX_enc),
                        icnt2, opnd_array(0)->as_Register(ra_,this)/* result */,
                        opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* vec */, as_Register(RCX_enc), StrIntrinsicNode::UU);
    }
  
#line 38757 "ad_x86.cpp"
  }
}

void string_indexof_conULNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// int_cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vec
  {
    MacroAssembler _masm(&cbuf);

#line 11013 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int icnt2 = (int)opnd_array(4)->constant();
    if (icnt2 >= 8) {
      // IndexOf for constant substrings with size >= 8 elements
      // which don't need to be loaded through stack.
      __ string_indexofC8(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                          opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, as_Register(RAX_enc),
                          icnt2, opnd_array(0)->as_Register(ra_,this)/* result */,
                          opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* vec */, as_Register(RCX_enc), StrIntrinsicNode::UL);
    } else {
      // Small strings are loaded through stack if they cross page boundary.
      __ string_indexof(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                        opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, as_Register(RAX_enc),
                        icnt2, opnd_array(0)->as_Register(ra_,this)/* result */,
                        opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* vec */, as_Register(RCX_enc), StrIntrinsicNode::UL);
    }
  
#line 38791 "ad_x86.cpp"
  }
}

void string_indexofLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vec
  {
    MacroAssembler _masm(&cbuf);

#line 11041 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ string_indexof(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */,
                      (-1), opnd_array(0)->as_Register(ra_,this)/* result */,
                      opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* vec */, as_Register(RCX_enc), StrIntrinsicNode::LL);
  
#line 38814 "ad_x86.cpp"
  }
}

void string_indexofUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vec
  {
    MacroAssembler _masm(&cbuf);

#line 11058 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ string_indexof(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */,
                      (-1), opnd_array(0)->as_Register(ra_,this)/* result */,
                      opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* vec */, as_Register(RCX_enc), StrIntrinsicNode::UU);
  
#line 38837 "ad_x86.cpp"
  }
}

void string_indexofULNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// str2
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// cnt2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vec
  {
    MacroAssembler _masm(&cbuf);

#line 11075 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ string_indexof(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* str2 */,
                      opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(4)->as_Register(ra_,this,idx4)/* cnt2 */,
                      (-1), opnd_array(0)->as_Register(ra_,this)/* result */,
                      opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* vec */, as_Register(RCX_enc), StrIntrinsicNode::UL);
  
#line 38860 "ad_x86.cpp"
  }
}

void string_indexofU_charNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cnt1
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// ch
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// vec1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// vec2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// vec3
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 11091 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ string_indexof_char(opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* cnt1 */, opnd_array(3)->as_Register(ra_,this,idx3)/* ch */, opnd_array(0)->as_Register(ra_,this)/* result */,
                           opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* vec1 */, opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* vec2 */, opnd_array(6)->as_XMMRegister(ra_,this,idx6)/* vec3 */, opnd_array(7)->as_Register(ra_,this,idx7)/* tmp */);
  
#line 38883 "ad_x86.cpp"
  }
}

void string_equalsNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// str1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// str2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// cnt
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 11106 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ arrays_equals(false, opnd_array(1)->as_Register(ra_,this,idx1)/* str1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* str2 */,
                     opnd_array(3)->as_Register(ra_,this,idx3)/* cnt */, opnd_array(0)->as_Register(ra_,this)/* result */, as_Register(RBX_enc),
                     opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp1 */, opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp2 */, false /* char */);
  
#line 38905 "ad_x86.cpp"
  }
}

void array_equalsBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// ary1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// ary2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 11123 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ arrays_equals(true, opnd_array(1)->as_Register(ra_,this,idx1)/* ary1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* ary2 */,
                     as_Register(RCX_enc), opnd_array(0)->as_Register(ra_,this)/* result */, as_Register(RBX_enc),
                     opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp1 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, false /* char */);
  
#line 38926 "ad_x86.cpp"
  }
}

void array_equalsCNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// ary1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// ary2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 11139 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ arrays_equals(true, opnd_array(1)->as_Register(ra_,this,idx1)/* ary1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* ary2 */,
                     as_Register(RCX_enc), opnd_array(0)->as_Register(ra_,this)/* result */, as_Register(RBX_enc),
                     opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp1 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, true /* char */);
  
#line 38947 "ad_x86.cpp"
  }
}

void has_negativesNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// ary1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// len
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 11154 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ has_negatives(opnd_array(1)->as_Register(ra_,this,idx1)/* ary1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* len */,
                     opnd_array(0)->as_Register(ra_,this)/* result */, as_Register(RBX_enc),
                     opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp1 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 38968 "ad_x86.cpp"
  }
}

void string_compressNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// len
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp3
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp4
  {
    MacroAssembler _masm(&cbuf);

#line 11169 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ char_array_compress(opnd_array(1)->as_Register(ra_,this,idx1)/* src */, opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, opnd_array(3)->as_Register(ra_,this,idx3)/* len */,
                           opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp1 */, opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp2 */, opnd_array(6)->as_XMMRegister(ra_,this,idx6)/* tmp3 */,
                           opnd_array(7)->as_XMMRegister(ra_,this,idx7)/* tmp4 */, as_Register(RCX_enc), opnd_array(0)->as_Register(ra_,this)/* result */);
  
#line 38992 "ad_x86.cpp"
  }
}

void string_inflateNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// len
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 11184 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ byte_array_inflate(opnd_array(1)->as_Register(ra_,this,idx1)/* src */, opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, opnd_array(3)->as_Register(ra_,this,idx3)/* len */,
                          opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp1 */, opnd_array(5)->as_Register(ra_,this,idx5)/* tmp2 */);
  
#line 39013 "ad_x86.cpp"
  }
}

void encode_iso_arrayNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// len
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp1
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp2
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// tmp3
  unsigned idx7 = idx6 + opnd_array(6)->num_edges(); 	// tmp4
  {
    MacroAssembler _masm(&cbuf);

#line 11199 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ encode_iso_array(opnd_array(1)->as_Register(ra_,this,idx1)/* src */, opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, opnd_array(3)->as_Register(ra_,this,idx3)/* len */,
                        opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp1 */, opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp2 */, opnd_array(6)->as_XMMRegister(ra_,this,idx6)/* tmp3 */,
                        opnd_array(7)->as_XMMRegister(ra_,this,idx7)/* tmp4 */, as_Register(RCX_enc), opnd_array(0)->as_Register(ra_,this)/* result */);
  
#line 39037 "ad_x86.cpp"
  }
}

void overflowAddI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    MacroAssembler _masm(&cbuf);

#line 11216 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ addl(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);
  
#line 39054 "ad_x86.cpp"
  }
}

void overflowAddI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    MacroAssembler _masm(&cbuf);

#line 11229 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ addl(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->constant());
  
#line 39071 "ad_x86.cpp"
  }
}

void overflowAddL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    MacroAssembler _masm(&cbuf);

#line 11241 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ addq(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);
  
#line 39088 "ad_x86.cpp"
  }
}

void overflowAddL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    MacroAssembler _masm(&cbuf);

#line 11253 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ addq(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->constantL());
  
#line 39105 "ad_x86.cpp"
  }
}

void overflowSubI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    MacroAssembler _masm(&cbuf);

#line 11264 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cmpl(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);
  
#line 39122 "ad_x86.cpp"
  }
}

void overflowSubI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    MacroAssembler _masm(&cbuf);

#line 11275 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cmpl(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->constant());
  
#line 39139 "ad_x86.cpp"
  }
}

void overflowSubL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    MacroAssembler _masm(&cbuf);

#line 11286 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cmpq(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);
  
#line 39156 "ad_x86.cpp"
  }
}

void overflowSubL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    MacroAssembler _masm(&cbuf);

#line 11297 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cmpq(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->constantL());
  
#line 39173 "ad_x86.cpp"
  }
}

void overflowNegI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    MacroAssembler _masm(&cbuf);

#line 11309 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ negl(opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);
  
#line 39190 "ad_x86.cpp"
  }
}

void overflowNegL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    MacroAssembler _masm(&cbuf);

#line 11321 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ negq(opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);
  
#line 39207 "ad_x86.cpp"
  }
}

void overflowMulI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    MacroAssembler _masm(&cbuf);

#line 11333 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ imull(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);
  
#line 39224 "ad_x86.cpp"
  }
}

void overflowMulI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 11345 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ imull(opnd_array(3)->as_Register(ra_,this,idx3)/* tmp */, opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->constant());
  
#line 39242 "ad_x86.cpp"
  }
}

void overflowMulL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    MacroAssembler _masm(&cbuf);

#line 11357 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ imulq(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */);
  
#line 39259 "ad_x86.cpp"
  }
}

void overflowMulL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 11369 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ imulq(opnd_array(3)->as_Register(ra_,this,idx3)/* tmp */, opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->constantL());
  
#line 39277 "ad_x86.cpp"
  }
}

void compI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* op1 */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* op2 */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* op2 */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 39303 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 39311 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* op1 */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* op2 */ & 7);
  
#line 39319 "ad_x86.cpp"
  }
}

void compI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 2029 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* op1 */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x07 /*secondary()*/), dstenc);
  
#line 39350 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 39364 "ad_x86.cpp"
  }
}

void compI_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* op1 */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 39406 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 39414 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* op1 */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 39430 "ad_x86.cpp"
  }
}

void testI_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 39456 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 39464 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 39472 "ad_x86.cpp"
  }
}

void testI_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 39491 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 39499 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x00 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 39508 "ad_x86.cpp"
  }
  {

#line 2323 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Output immediate
    emit_d32(cbuf, opnd_array(2)->constant());
  
#line 39517 "ad_x86.cpp"
  }
}

void testI_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 39560 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 39568 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* src */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 39584 "ad_x86.cpp"
  }
}

void testI_reg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 39627 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 39635 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 39651 "ad_x86.cpp"
  }
}

void compU_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* op1 */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* op2 */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* op2 */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 39677 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 39685 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* op1 */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* op2 */ & 7);
  
#line 39693 "ad_x86.cpp"
  }
}

void compU_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 2029 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* op1 */;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x07 /*secondary()*/), dstenc);
  
#line 39724 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 39738 "ad_x86.cpp"
  }
}

void compU_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 2500 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* op1 */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 39780 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 39788 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* op1 */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 39804 "ad_x86.cpp"
  }
}

void testU_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 39830 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 39838 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 39846 "ad_x86.cpp"
  }
}

void compP_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* op1 */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* op2 */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* op2 */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 39874 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 39882 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* op1 */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* op2 */ & 7);
  
#line 39890 "ad_x86.cpp"
  }
}

void compP_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* op1 */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 39934 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 39942 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* op1 */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 39958 "ad_x86.cpp"
  }
}

void compP_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* op1 */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 40002 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 40010 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* op1 */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 40026 "ad_x86.cpp"
  }
}

void testP_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 40054 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 40062 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 40070 "ad_x86.cpp"
  }
}

void testP_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// op
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 2377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 40098 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 40106 "ad_x86.cpp"
  }
  {

#line 2577 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();       // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_reloc);
  
#line 40126 "ad_x86.cpp"
  }
  {

#line 2344 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_d32(cbuf,(0xFFFFFFFF));
  
#line 40134 "ad_x86.cpp"
  }
}

void testP_mem_reg0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 11576 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cmpq(r12, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 40151 "ad_x86.cpp"
  }
}

void compN_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    MacroAssembler _masm(&cbuf);

#line 11587 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"
__ cmpl(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, opnd_array(2)->as_Register(ra_,this,idx2)/* op2 */); 
#line 40166 "ad_x86.cpp"
  }
}

void compN_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 11596 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cmpl(opnd_array(1)->as_Register(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 40183 "ad_x86.cpp"
  }
}

void compN_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    MacroAssembler _masm(&cbuf);

#line 11606 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cmp_narrow_oop(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, (jobject)opnd_array(2)->constant());
  
#line 40200 "ad_x86.cpp"
  }
}

void compN_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 11617 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cmp_narrow_oop(Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), (jobject)opnd_array(1)->constant());
  
#line 40217 "ad_x86.cpp"
  }
}

void compN_rReg_imm_klassNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {
    MacroAssembler _masm(&cbuf);

#line 11627 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cmp_narrow_klass(opnd_array(1)->as_Register(ra_,this,idx1)/* op1 */, (Klass*)opnd_array(2)->constant());
  
#line 40234 "ad_x86.cpp"
  }
}

void compN_mem_imm_klassNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 11638 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cmp_narrow_klass(Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), (Klass*)opnd_array(1)->constant());
  
#line 40251 "ad_x86.cpp"
  }
}

void testN_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 11648 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"
__ testl(opnd_array(1)->as_Register(ra_,this,idx1)/* src */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */); 
#line 40266 "ad_x86.cpp"
  }
}

void testN_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 11659 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cmpl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), (int)0xFFFFFFFF);
  
#line 40283 "ad_x86.cpp"
  }
}

void testN_mem_reg0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 11671 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ cmpl(r12, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 40300 "ad_x86.cpp"
  }
}

void compL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* op1 */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* op2 */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* op2 */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 40328 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 40336 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* op1 */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* op2 */ & 7);
  
#line 40344 "ad_x86.cpp"
  }
}

void compL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 2049 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* op1 */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x07 /*secondary()*/), dstenc);
  
#line 40377 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 40391 "ad_x86.cpp"
  }
}

void compL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* op1 */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 40435 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 40443 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* op1 */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 40459 "ad_x86.cpp"
  }
}

void testL_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 40487 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 40495 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 40503 "ad_x86.cpp"
  }
}

void testL_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  {

#line 2459 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 40524 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 40532 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x00 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 40541 "ad_x86.cpp"
  }
  {

#line 2323 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Output immediate
    emit_d32(cbuf, opnd_array(2)->constantL());
  
#line 40550 "ad_x86.cpp"
  }
}

void testL_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 40595 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 40603 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* src */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 40619 "ad_x86.cpp"
  }
}

void testL_reg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 40664 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 40672 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 40688 "ad_x86.cpp"
  }
}

void testL_reg_mem2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 40733 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 40741 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* src */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 40757 "ad_x86.cpp"
  }
}

void testL_reg_mem2_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 40802 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 40810 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2)/* src */;
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    relocInfo::relocType disp_reloc = opnd_array(1)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 40826 "ad_x86.cpp"
  }
}

void cmpL3_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {

#line 2664 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    int src1enc = opnd_array(1)->reg(ra_,this,idx1)/* src1 */;
    int src2enc = opnd_array(2)->reg(ra_,this,idx2)/* src2 */;
    int dstenc = opnd_array(0)->reg(ra_,this)/* dst */;

    // cmpq $src1, $src2
    if (src1enc < 8) {
      if (src2enc < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (src2enc < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
    emit_opcode(cbuf, 0x3B);
    emit_rm(cbuf, 0x3, src1enc & 7, src2enc & 7);

    // movl $dst, -1
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0xB8 | (dstenc & 7));
    emit_d32(cbuf, -1);

    // jl,s done
    emit_opcode(cbuf, 0x7C);
    emit_d8(cbuf, dstenc < 4 ? 0x06 : 0x08);

    // setne $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x95);
    emit_opcode(cbuf, 0xC0 | (dstenc & 7));

    // movzbl $dst, $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_RB);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0xB6);
    emit_rm(cbuf, 0x3, dstenc & 7, dstenc & 7);
  
#line 40888 "ad_x86.cpp"
  }
}

void compUL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* op1 */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* op2 */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* op2 */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 40916 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 40924 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* op1 */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* op2 */ & 7);
  
#line 40932 "ad_x86.cpp"
  }
}

void compUL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 2049 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1)/* op1 */;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x07 /*secondary()*/), dstenc);
  
#line 40965 "ad_x86.cpp"
  }
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 40979 "ad_x86.cpp"
  }
}

void compUL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// op1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// op2
  {

#line 2531 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* op1 */ < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 41023 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 41031 "ad_x86.cpp"
  }
  {

#line 2564 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1)/* op1 */;
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    relocInfo::relocType disp_reloc = opnd_array(2)->disp_reloc();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
  
#line 41047 "ad_x86.cpp"
  }
}

void testUL_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// zero
  {

#line 2483 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 41075 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 41083 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7, opnd_array(1)->reg(ra_,this,idx1)/* src */ & 7);
  
#line 41091 "ad_x86.cpp"
  }
}

void compB_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm
  {
    MacroAssembler _masm(&cbuf);

#line 11816 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"
__ cmpb(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->constant()); 
#line 41106 "ad_x86.cpp"
  }
}

void testB_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// imm
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 11826 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"
__ testb(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->constant()); 
#line 41122 "ad_x86.cpp"
  }
}

void cmovI_reg_gNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 41149 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 41157 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x4F /*secondary()*/));
  
#line 41165 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 41173 "ad_x86.cpp"
  }
}

void cmovI_reg_lNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cr
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {

#line 2468 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* dst */ < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2)/* src */ < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 41200 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 41208 "ad_x86.cpp"
  }
  {

#line 1842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x4C /*secondary()*/));
  
#line 41216 "ad_x86.cpp"
  }
  {

#line 1870 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1)/* dst */ & 7, opnd_array(2)->reg(ra_,this,idx2)/* src */ & 7);
  
#line 41224 "ad_x86.cpp"
  }
}

void jmpDirNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 11891 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(1)->label();
    __ jmp(*L, false); // Always long jump
  
#line 41241 "ad_x86.cpp"
  }
}

uint jmpDirNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 5, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 5);
}

void jmpConNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 11907 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(3)->label();
    __ jcc((Assembler::Condition)(opnd_array(1)->ccode()), *L, false); // Always long jump
  
#line 41265 "ad_x86.cpp"
  }
}

uint jmpConNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 6, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 6);
}

void jmpLoopEndNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 11924 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(3)->label();
    __ jcc((Assembler::Condition)(opnd_array(1)->ccode()), *L, false); // Always long jump
  
#line 41289 "ad_x86.cpp"
  }
}

uint jmpLoopEndNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 6, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 6);
}

void jmpLoopEndUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 11940 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(3)->label();
    __ jcc((Assembler::Condition)(opnd_array(1)->ccode()), *L, false); // Always long jump
  
#line 41313 "ad_x86.cpp"
  }
}

uint jmpLoopEndUNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 6, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 6);
}

void jmpLoopEndUCFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 11955 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(3)->label();
    __ jcc((Assembler::Condition)(opnd_array(1)->ccode()), *L, false); // Always long jump
  
#line 41337 "ad_x86.cpp"
  }
}

uint jmpLoopEndUCFNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 6, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 6);
}

void jmpLoopEnd_and_restoreMaskNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 11974 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(3)->label();
    __ jcc((Assembler::Condition)(opnd_array(1)->ccode()), *L, false); // Always long jump
    __ restorevectmask();
  
#line 41362 "ad_x86.cpp"
  }
}

uint jmpLoopEnd_and_restoreMaskNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 10, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 10);
}

void jmpLoopEndU_and_restoreMaskNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 11992 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(3)->label();
    __ jcc((Assembler::Condition)(opnd_array(1)->ccode()), *L, false); // Always long jump
    __ restorevectmask();
  
#line 41387 "ad_x86.cpp"
  }
}

uint jmpLoopEndU_and_restoreMaskNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 10, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 10);
}

void jmpLoopEndUCF_and_restoreMaskNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 12009 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(3)->label();
    __ jcc((Assembler::Condition)(opnd_array(1)->ccode()), *L, false); // Always long jump
    __ restorevectmask();
  
#line 41412 "ad_x86.cpp"
  }
}

uint jmpLoopEndUCF_and_restoreMaskNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 10, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 10);
}

void jmpConUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 12025 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(3)->label();
    __ jcc((Assembler::Condition)(opnd_array(1)->ccode()), *L, false); // Always long jump
  
#line 41436 "ad_x86.cpp"
  }
}

uint jmpConUNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 6, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 6);
}

void jmpConUCFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 12039 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(3)->label();
    __ jcc((Assembler::Condition)(opnd_array(1)->ccode()), *L, false); // Always long jump
  
#line 41460 "ad_x86.cpp"
  }
}

uint jmpConUCFNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 6, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 6);
}

void jmpConUCF2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 12061 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* l = opnd_array(3)->label();
    if (opnd_array(1)->ccode()== Assembler::notEqual) {
      __ jcc(Assembler::parity, *l, false);
      __ jcc(Assembler::notEqual, *l, false);
    } else if (opnd_array(1)->ccode()== Assembler::equal) {
      Label done;
      __ jccb(Assembler::parity, done);
      __ jcc(Assembler::equal, *l, false);
      __ bind(done);
    } else {
       ShouldNotReachHere();
    }
  
#line 41494 "ad_x86.cpp"
  }
}

void partialSubtypeCheckNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// sub
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// super
  {

#line 2107 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register Rrdi = as_Register(RDI_enc); // result register
    Register Rrax = as_Register(RAX_enc); // super class
    Register Rrcx = as_Register(RCX_enc); // killed
    Register Rrsi = as_Register(RSI_enc); // sub class
    Label miss;
    const bool set_cond_codes = true;

    MacroAssembler _masm(&cbuf);
    __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
                                     NULL, &miss,
                                     /*set_cond_codes:*/ true);
    if ((0x1 /*primary()*/)) {
      __ xorptr(Rrdi, Rrdi);
    }
    __ bind(miss);
  
#line 41524 "ad_x86.cpp"
  }
}

void partialSubtypeCheck_vs_ZeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// sub
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// super
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// zero
  {

#line 2107 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Register Rrdi = as_Register(RDI_enc); // result register
    Register Rrax = as_Register(RAX_enc); // super class
    Register Rrcx = as_Register(RCX_enc); // killed
    Register Rrsi = as_Register(RSI_enc); // sub class
    Label miss;
    const bool set_cond_codes = true;

    MacroAssembler _masm(&cbuf);
    __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
                                     NULL, &miss,
                                     /*set_cond_codes:*/ true);
    if ((0x0 /*primary()*/)) {
      __ xorptr(Rrdi, Rrdi);
    }
    __ bind(miss);
  
#line 41555 "ad_x86.cpp"
  }
}

void jmpDir_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 12149 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(1)->label();
    __ jmpb(*L);
  
#line 41572 "ad_x86.cpp"
  }
}

uint jmpDir_shortNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 2, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 2);
}

void jmpCon_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 12165 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(3)->label();
    __ jccb((Assembler::Condition)(opnd_array(1)->ccode()), *L);
  
#line 41596 "ad_x86.cpp"
  }
}

uint jmpCon_shortNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 2, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 2);
}

void jmpLoopEnd_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cr
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 12181 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(3)->label();
    __ jccb((Assembler::Condition)(opnd_array(1)->ccode()), *L);
  
#line 41620 "ad_x86.cpp"
  }
}

uint jmpLoopEnd_shortNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 2, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 2);
}

void jmpLoopEndU_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 12197 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(3)->label();
    __ jccb((Assembler::Condition)(opnd_array(1)->ccode()), *L);
  
#line 41644 "ad_x86.cpp"
  }
}

uint jmpLoopEndU_shortNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 2, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 2);
}

void jmpLoopEndUCF_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 12212 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(3)->label();
    __ jccb((Assembler::Condition)(opnd_array(1)->ccode()), *L);
  
#line 41668 "ad_x86.cpp"
  }
}

uint jmpLoopEndUCF_shortNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 2, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 2);
}

void jmpConU_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 12228 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(3)->label();
    __ jccb((Assembler::Condition)(opnd_array(1)->ccode()), *L);
  
#line 41692 "ad_x86.cpp"
  }
}

uint jmpConU_shortNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 2, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 2);
}

void jmpConUCF_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 12243 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* L = opnd_array(3)->label();
    __ jccb((Assembler::Condition)(opnd_array(1)->ccode()), *L);
  
#line 41716 "ad_x86.cpp"
  }
}

uint jmpConUCF_shortNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 2, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 2);
}

void jmpConUCF2_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cmp
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// labl
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 12267 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    Label* l = opnd_array(3)->label();
    if (opnd_array(1)->ccode()== Assembler::notEqual) {
      __ jccb(Assembler::parity, *l);
      __ jccb(Assembler::notEqual, *l);
    } else if (opnd_array(1)->ccode()== Assembler::equal) {
      Label done;
      __ jccb(Assembler::parity, done);
      __ jccb(Assembler::equal, *l);
      __ bind(done);
    } else {
       ShouldNotReachHere();
    }
  
#line 41750 "ad_x86.cpp"
  }
}

uint jmpConUCF2_shortNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 4, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 4);
}

void cmpFastLockRTMNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// object
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// box
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// scr
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// cx1
  unsigned idx6 = idx5 + opnd_array(5)->num_edges(); 	// cx2
  {
    MacroAssembler _masm(&cbuf);

#line 12294 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ fast_lock(opnd_array(1)->as_Register(ra_,this,idx1)/* object */, opnd_array(2)->as_Register(ra_,this,idx2)/* box */, opnd_array(3)->as_Register(ra_,this,idx3)/* tmp */,
                 opnd_array(4)->as_Register(ra_,this,idx4)/* scr */, opnd_array(5)->as_Register(ra_,this,idx5)/* cx1 */, opnd_array(6)->as_Register(ra_,this,idx6)/* cx2 */,
                 _counters, _rtm_counters, _stack_rtm_counters,
                 ((Method*)(ra_->C->method()->constant_encoding()))->method_data(),
                 true, ra_->C->profile_rtm());
  
#line 41780 "ad_x86.cpp"
  }
}

void cmpFastLockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// object
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// box
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// scr
  {
    MacroAssembler _masm(&cbuf);

#line 12310 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ fast_lock(opnd_array(1)->as_Register(ra_,this,idx1)/* object */, opnd_array(2)->as_Register(ra_,this,idx2)/* box */, opnd_array(3)->as_Register(ra_,this,idx3)/* tmp */,
                 opnd_array(4)->as_Register(ra_,this,idx4)/* scr */, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
  
#line 41800 "ad_x86.cpp"
  }
}

void cmpFastUnlockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// object
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// box
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 12322 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ fast_unlock(opnd_array(1)->as_Register(ra_,this,idx1)/* object */, opnd_array(2)->as_Register(ra_,this,idx2)/* box */, opnd_array(3)->as_Register(ra_,this,idx3)/* tmp */, ra_->C->use_rtm());
  
#line 41818 "ad_x86.cpp"
  }
}

void safePoint_pollNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 12340 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
    __ testl(rax, addr);
  
#line 41835 "ad_x86.cpp"
  }
}

void safePoint_poll_farNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// cr
  {
    MacroAssembler _masm(&cbuf);

#line 12356 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ relocate(relocInfo::poll_type);
    __ testl(rax, Address(opnd_array(1)->as_Register(ra_,this,idx1)/* poll */, 0));
  
#line 41852 "ad_x86.cpp"
  }
}

void safePoint_poll_tlsNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// cr
  {
    MacroAssembler _masm(&cbuf);

#line 12373 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    __ relocate(relocInfo::poll_type);
    address pre_pc = __ pc();
    __ testl(rax, Address(opnd_array(1)->as_Register(ra_,this,idx1)/* poll */, 0));
    address post_pc = __ pc();
    guarantee(pre_pc[0] == 0x41 && pre_pc[1] == 0x85, "must emit #rex test-ax [reg]");
  
#line 41872 "ad_x86.cpp"
  }
}

uint safePoint_poll_tlsNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 3, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 3);
}

void CallStaticJavaDirectNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {

#line 2125 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    debug_only(int off0 = cbuf.insts_size());
    if (generate_vzeroupper(Compile::current())) {
      // Clear upper bits of YMM registers to avoid AVX <-> SSE transition penalty
      // Clear upper bits of YMM registers when current compiled code uses
      // wide vectors to avoid AVX <-> SSE transition penalty during call.
      MacroAssembler _masm(&cbuf);
      __ vzeroupper();
    }
    debug_only(int off1 = cbuf.insts_size());
    assert(off1 - off0 == clear_avx_size(), "correct size prediction");
  
#line 41901 "ad_x86.cpp"
  }
  {

#line 2159 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // JAVA STATIC CALL
    // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
    // determine who we intended to call.
    cbuf.set_insts_mark();
    emit_d8(cbuf, (0xE8 /*primary()*/));

    if (!_method) {
      emit_d32_reloc(cbuf, (int) (opnd_array(1)->method() - ((intptr_t) cbuf.insts_end()) - 4),
                     runtime_call_Relocation::spec(),
                     RELOC_DISP32);
    } else {
      int method_index = resolved_method_index(cbuf);
      RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
                                                  : static_call_Relocation::spec(method_index);
      emit_d32_reloc(cbuf, (int) (opnd_array(1)->method() - ((intptr_t) cbuf.insts_end()) - 4),
                     rspec, RELOC_DISP32);
      // Emit stubs for static call.
      address mark = cbuf.insts_mark();
      address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);
      if (stub == NULL) {
        ciEnv::current()->record_failure("CodeCache is full");
        return;
      }
#if INCLUDE_AOT
      CompiledStaticCall::emit_to_aot_stub(cbuf, mark);
#endif
    }
  
#line 41935 "ad_x86.cpp"
  }
  {

#line 1888 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    if (VerifyStackAtCalls) {
      // Check that stack depth is unchanged: find majik cookie on stack
      int framesize = ra_->reg2offset_unchecked(OptoReg::add(ra_->_matcher._old_SP, -3*VMRegImpl::slots_per_word));
      MacroAssembler _masm(&cbuf);
      Label L;
      __ cmpptr(Address(rsp, framesize), (int32_t)0xbadb100d);
      __ jccb(Assembler::equal, L);
      // Die if stack mismatch
      __ int3();
      __ bind(L);
    }
  
#line 41953 "ad_x86.cpp"
  }
}

void CallDynamicJavaDirectNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {

#line 2125 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    debug_only(int off0 = cbuf.insts_size());
    if (generate_vzeroupper(Compile::current())) {
      // Clear upper bits of YMM registers to avoid AVX <-> SSE transition penalty
      // Clear upper bits of YMM registers when current compiled code uses
      // wide vectors to avoid AVX <-> SSE transition penalty during call.
      MacroAssembler _masm(&cbuf);
      __ vzeroupper();
    }
    debug_only(int off1 = cbuf.insts_size());
    assert(off1 - off0 == clear_avx_size(), "correct size prediction");
  
#line 41977 "ad_x86.cpp"
  }
  {

#line 2189 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    MacroAssembler _masm(&cbuf);
    __ ic_call((address)opnd_array(1)->method(), resolved_method_index(cbuf));
  
#line 41986 "ad_x86.cpp"
  }
  {

#line 1888 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    if (VerifyStackAtCalls) {
      // Check that stack depth is unchanged: find majik cookie on stack
      int framesize = ra_->reg2offset_unchecked(OptoReg::add(ra_->_matcher._old_SP, -3*VMRegImpl::slots_per_word));
      MacroAssembler _masm(&cbuf);
      Label L;
      __ cmpptr(Address(rsp, framesize), (int32_t)0xbadb100d);
      __ jccb(Assembler::equal, L);
      // Die if stack mismatch
      __ int3();
      __ bind(L);
    }
  
#line 42004 "ad_x86.cpp"
  }
}

void CallRuntimeDirectNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {

#line 2125 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    debug_only(int off0 = cbuf.insts_size());
    if (generate_vzeroupper(Compile::current())) {
      // Clear upper bits of YMM registers to avoid AVX <-> SSE transition penalty
      // Clear upper bits of YMM registers when current compiled code uses
      // wide vectors to avoid AVX <-> SSE transition penalty during call.
      MacroAssembler _masm(&cbuf);
      __ vzeroupper();
    }
    debug_only(int off1 = cbuf.insts_size());
    assert(off1 - off0 == clear_avx_size(), "correct size prediction");
  
#line 42028 "ad_x86.cpp"
  }
  {

#line 2138 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // No relocation needed
    MacroAssembler _masm(&cbuf);
    __ mov64(r10, (int64_t) opnd_array(1)->method());
    __ call(r10);
  
#line 42039 "ad_x86.cpp"
  }
}

void CallLeafDirectNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {

#line 2125 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    debug_only(int off0 = cbuf.insts_size());
    if (generate_vzeroupper(Compile::current())) {
      // Clear upper bits of YMM registers to avoid AVX <-> SSE transition penalty
      // Clear upper bits of YMM registers when current compiled code uses
      // wide vectors to avoid AVX <-> SSE transition penalty during call.
      MacroAssembler _masm(&cbuf);
      __ vzeroupper();
    }
    debug_only(int off1 = cbuf.insts_size());
    assert(off1 - off0 == clear_avx_size(), "correct size prediction");
  
#line 42063 "ad_x86.cpp"
  }
  {

#line 2138 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // No relocation needed
    MacroAssembler _masm(&cbuf);
    __ mov64(r10, (int64_t) opnd_array(1)->method());
    __ call(r10);
  
#line 42074 "ad_x86.cpp"
  }
}

void CallLeafNoFPDirectNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {

#line 2125 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    debug_only(int off0 = cbuf.insts_size());
    if (generate_vzeroupper(Compile::current())) {
      // Clear upper bits of YMM registers to avoid AVX <-> SSE transition penalty
      // Clear upper bits of YMM registers when current compiled code uses
      // wide vectors to avoid AVX <-> SSE transition penalty during call.
      MacroAssembler _masm(&cbuf);
      __ vzeroupper();
    }
    debug_only(int off1 = cbuf.insts_size());
    assert(off1 - off0 == clear_avx_size(), "correct size prediction");
  
#line 42098 "ad_x86.cpp"
  }
  {

#line 2138 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // No relocation needed
    MacroAssembler _masm(&cbuf);
    __ mov64(r10, (int64_t) opnd_array(1)->method());
    __ call(r10);
  
#line 42109 "ad_x86.cpp"
  }
}

void RetNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// 
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xC3 /*primary()*/));
  
#line 42124 "ad_x86.cpp"
  }
}

void TailCalljmpIndNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// method_oop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// 
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* jump_target */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 42142 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 42150 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* jump_target */ & 7);
  
#line 42159 "ad_x86.cpp"
  }
}

void tailjmpIndNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// ex_oop
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// 
  {

#line 1854 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0x5a));
  
#line 42175 "ad_x86.cpp"
  }
  {

#line 2452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1)/* jump_target */ >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 42185 "ad_x86.cpp"
  }
  {

#line 1836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 42193 "ad_x86.cpp"
  }
  {

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1)/* jump_target */ & 7);
  
#line 42202 "ad_x86.cpp"
  }
}

void CreateExceptionNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  // User did not define which encode class to use.
}

uint CreateExceptionNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void RethrowExceptionNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// 
  {

#line 2730 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    cbuf.set_insts_mark();
    emit_opcode(cbuf, 0xE9); // jmp entry
    emit_d32_reloc(cbuf,
                   (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
                   runtime_call_Relocation::spec(),
                   RELOC_DISP32);
  
#line 42235 "ad_x86.cpp"
  }
}

void loadBarrierSlowRegNoVecNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 12536 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

#if INCLUDE_ZGC
    Register d = opnd_array(0)->as_Register(ra_,this)/* dst */;
    ZBarrierSetAssembler* bs = (ZBarrierSetAssembler*)BarrierSet::barrier_set()->barrier_set_assembler();

    assert(d != r12, "Can't be R12!");
    assert(d != r15, "Can't be R15!");
    assert(d != rsp, "Can't be RSP!");

    __ lea(d, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ call(RuntimeAddress(bs->load_barrier_slow_stub(d)));
#else
    ShouldNotReachHere();
#endif
  
#line 42263 "ad_x86.cpp"
  }
}

void loadBarrierSlowRegXmmAndYmmNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 12571 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

#if INCLUDE_ZGC
    Register d = opnd_array(0)->as_Register(ra_,this)/* dst */;
    ZBarrierSetAssembler* bs = (ZBarrierSetAssembler*)BarrierSet::barrier_set()->barrier_set_assembler();

    assert(d != r12, "Can't be R12!");
    assert(d != r15, "Can't be R15!");
    assert(d != rsp, "Can't be RSP!");

    __ lea(d, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ call(RuntimeAddress(bs->load_barrier_slow_stub(d)));
#else
    ShouldNotReachHere();
#endif
  
#line 42291 "ad_x86.cpp"
  }
}

void loadBarrierSlowRegZmmNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 12614 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

#if INCLUDE_ZGC
    Register d = opnd_array(0)->as_Register(ra_,this)/* dst */;
    ZBarrierSetAssembler* bs = (ZBarrierSetAssembler*)BarrierSet::barrier_set()->barrier_set_assembler();

    assert(d != r12, "Can't be R12!");
    assert(d != r15, "Can't be R15!");
    assert(d != rsp, "Can't be RSP!");

    __ lea(d, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ call(RuntimeAddress(bs->load_barrier_slow_stub(d)));
#else
    ShouldNotReachHere();
#endif
  
#line 42319 "ad_x86.cpp"
  }
}

void loadBarrierWeakSlowRegNoVecNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 12645 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

#if INCLUDE_ZGC
    Register d = opnd_array(0)->as_Register(ra_,this)/* dst */;
    ZBarrierSetAssembler* bs = (ZBarrierSetAssembler*)BarrierSet::barrier_set()->barrier_set_assembler();

    assert(d != r12, "Can't be R12!");
    assert(d != r15, "Can't be R15!");
    assert(d != rsp, "Can't be RSP!");

    __ lea(d, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ call(RuntimeAddress(bs->load_barrier_weak_slow_stub(d)));
#else
    ShouldNotReachHere();
#endif
  
#line 42347 "ad_x86.cpp"
  }
}

void loadBarrierWeakSlowRegXmmAndYmmNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 12680 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

#if INCLUDE_ZGC
    Register d = opnd_array(0)->as_Register(ra_,this)/* dst */;
    ZBarrierSetAssembler* bs = (ZBarrierSetAssembler*)BarrierSet::barrier_set()->barrier_set_assembler();

    assert(d != r12, "Can't be R12!");
    assert(d != r15, "Can't be R15!");
    assert(d != rsp, "Can't be RSP!");

    __ lea(d,Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ call(RuntimeAddress(bs->load_barrier_weak_slow_stub(d)));
#else
    ShouldNotReachHere();
#endif
  
#line 42375 "ad_x86.cpp"
  }
}

void loadBarrierWeakSlowRegZmmNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 12723 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

#if INCLUDE_ZGC
    Register d = opnd_array(0)->as_Register(ra_,this)/* dst */;
    ZBarrierSetAssembler* bs = (ZBarrierSetAssembler*)BarrierSet::barrier_set()->barrier_set_assembler();

    assert(d != r12, "Can't be R12!");
    assert(d != r15, "Can't be R15!");
    assert(d != rsp, "Can't be RSP!");

    __ lea(d,Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ call(RuntimeAddress(bs->load_barrier_weak_slow_stub(d)));
#else
    ShouldNotReachHere();
#endif
  
#line 42403 "ad_x86.cpp"
  }
}

void tlsLoadPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  // User did not define which encode class to use.
}

uint tlsLoadPNode::size(PhaseRegAlloc *ra_) const {
  assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
  return (VerifyOops ? MachNode::size(ra_) : 0);
}

void ShouldNotReachHereNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 5;
  unsigned idx1 = 5; 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 1949 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ ud2();
  
#line 42432 "ad_x86.cpp"
  }
}

void setMaskNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {
    MacroAssembler _masm(&cbuf);

#line 1962 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ setvectmask(opnd_array(2)->as_Register(ra_,this,idx2)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
  
#line 42449 "ad_x86.cpp"
  }
}

void addF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 1976 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ addss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 42466 "ad_x86.cpp"
  }
}

void addF_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 1988 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ addss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 42483 "ad_x86.cpp"
  }
}

void addF_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {
    MacroAssembler _masm(&cbuf);

#line 1988 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ addss(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 42500 "ad_x86.cpp"
  }
}

void addF_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 1999 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ addss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 42517 "ad_x86.cpp"
  }
}

void addF_immNode::eval_constant(Compile* C) {
  {

#line 2000 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 42526 "ad_x86.cpp"
  }
}
void addF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2011 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vaddss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
  
#line 42542 "ad_x86.cpp"
  }
}

void addF_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2023 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vaddss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 42559 "ad_x86.cpp"
  }
}

void addF_reg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 2023 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vaddss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src1 */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 42576 "ad_x86.cpp"
  }
}

void addF_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2035 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vaddss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 42593 "ad_x86.cpp"
  }
}

void addF_reg_immNode::eval_constant(Compile* C) {
  {

#line 2036 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 42602 "ad_x86.cpp"
  }
}
void addD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2047 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ addsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 42618 "ad_x86.cpp"
  }
}

void addD_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2059 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ addsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 42635 "ad_x86.cpp"
  }
}

void addD_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {
    MacroAssembler _masm(&cbuf);

#line 2059 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ addsd(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 42652 "ad_x86.cpp"
  }
}

void addD_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2070 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ addsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 42669 "ad_x86.cpp"
  }
}

void addD_immNode::eval_constant(Compile* C) {
  {

#line 2071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 42678 "ad_x86.cpp"
  }
}
void addD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2082 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vaddsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
  
#line 42694 "ad_x86.cpp"
  }
}

void addD_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vaddsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 42711 "ad_x86.cpp"
  }
}

void addD_reg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 2094 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vaddsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src1 */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 42728 "ad_x86.cpp"
  }
}

void addD_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2106 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vaddsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 42745 "ad_x86.cpp"
  }
}

void addD_reg_immNode::eval_constant(Compile* C) {
  {

#line 2107 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 42754 "ad_x86.cpp"
  }
}
void subF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2118 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ subss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 42770 "ad_x86.cpp"
  }
}

void subF_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2130 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ subss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 42787 "ad_x86.cpp"
  }
}

void subF_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2141 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ subss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 42804 "ad_x86.cpp"
  }
}

void subF_immNode::eval_constant(Compile* C) {
  {

#line 2142 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 42813 "ad_x86.cpp"
  }
}
void subF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2153 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vsubss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
  
#line 42829 "ad_x86.cpp"
  }
}

void subF_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2165 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vsubss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 42846 "ad_x86.cpp"
  }
}

void subF_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2177 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vsubss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 42863 "ad_x86.cpp"
  }
}

void subF_reg_immNode::eval_constant(Compile* C) {
  {

#line 2178 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 42872 "ad_x86.cpp"
  }
}
void subD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2189 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ subsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 42888 "ad_x86.cpp"
  }
}

void subD_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2201 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ subsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 42905 "ad_x86.cpp"
  }
}

void subD_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2212 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ subsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 42922 "ad_x86.cpp"
  }
}

void subD_immNode::eval_constant(Compile* C) {
  {

#line 2213 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 42931 "ad_x86.cpp"
  }
}
void subD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2224 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vsubsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
  
#line 42947 "ad_x86.cpp"
  }
}

void subD_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2236 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vsubsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 42964 "ad_x86.cpp"
  }
}

void subD_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2248 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vsubsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 42981 "ad_x86.cpp"
  }
}

void subD_reg_immNode::eval_constant(Compile* C) {
  {

#line 2249 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 42990 "ad_x86.cpp"
  }
}
void mulF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2260 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ mulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 43006 "ad_x86.cpp"
  }
}

void mulF_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2272 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ mulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 43023 "ad_x86.cpp"
  }
}

void mulF_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {
    MacroAssembler _masm(&cbuf);

#line 2272 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ mulss(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 43040 "ad_x86.cpp"
  }
}

void mulF_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2283 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ mulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 43057 "ad_x86.cpp"
  }
}

void mulF_immNode::eval_constant(Compile* C) {
  {

#line 2284 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 43066 "ad_x86.cpp"
  }
}
void mulF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2295 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmulss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
  
#line 43082 "ad_x86.cpp"
  }
}

void mulF_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2307 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmulss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 43099 "ad_x86.cpp"
  }
}

void mulF_reg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 2307 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmulss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src1 */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 43116 "ad_x86.cpp"
  }
}

void mulF_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2319 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmulss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 43133 "ad_x86.cpp"
  }
}

void mulF_reg_immNode::eval_constant(Compile* C) {
  {

#line 2320 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 43142 "ad_x86.cpp"
  }
}
void mulD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2331 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ mulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 43158 "ad_x86.cpp"
  }
}

void mulD_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2343 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ mulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 43175 "ad_x86.cpp"
  }
}

void mulD_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  {
    MacroAssembler _masm(&cbuf);

#line 2343 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ mulsd(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 43192 "ad_x86.cpp"
  }
}

void mulD_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2354 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ mulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 43209 "ad_x86.cpp"
  }
}

void mulD_immNode::eval_constant(Compile* C) {
  {

#line 2355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 43218 "ad_x86.cpp"
  }
}
void mulD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2366 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmulsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
  
#line 43234 "ad_x86.cpp"
  }
}

void mulD_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2378 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmulsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 43251 "ad_x86.cpp"
  }
}

void mulD_reg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src2
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 2378 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmulsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src1 */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 43268 "ad_x86.cpp"
  }
}

void mulD_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2390 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmulsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 43285 "ad_x86.cpp"
  }
}

void mulD_reg_immNode::eval_constant(Compile* C) {
  {

#line 2391 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 43294 "ad_x86.cpp"
  }
}
void divF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2402 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ divss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 43310 "ad_x86.cpp"
  }
}

void divF_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2414 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ divss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 43327 "ad_x86.cpp"
  }
}

void divF_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2425 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ divss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 43344 "ad_x86.cpp"
  }
}

void divF_immNode::eval_constant(Compile* C) {
  {

#line 2426 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 43353 "ad_x86.cpp"
  }
}
void divF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2437 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vdivss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
  
#line 43369 "ad_x86.cpp"
  }
}

void divF_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2449 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vdivss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 43386 "ad_x86.cpp"
  }
}

void divF_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2461 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vdivss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 43403 "ad_x86.cpp"
  }
}

void divF_reg_immNode::eval_constant(Compile* C) {
  {

#line 2462 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 43412 "ad_x86.cpp"
  }
}
void divD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2473 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ divsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 43428 "ad_x86.cpp"
  }
}

void divD_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2485 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ divsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 43445 "ad_x86.cpp"
  }
}

void divD_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2496 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ divsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 43462 "ad_x86.cpp"
  }
}

void divD_immNode::eval_constant(Compile* C) {
  {

#line 2497 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 43471 "ad_x86.cpp"
  }
}
void divD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2508 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vdivsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
  
#line 43487 "ad_x86.cpp"
  }
}

void divD_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2520 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vdivsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()));
  
#line 43504 "ad_x86.cpp"
  }
}

void divD_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2532 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vdivsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 43521 "ad_x86.cpp"
  }
}

void divD_reg_immNode::eval_constant(Compile* C) {
  {

#line 2533 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(2));
#line 43530 "ad_x86.cpp"
  }
}
void absF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  {
    MacroAssembler _masm(&cbuf);

#line 2543 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ andps(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, ExternalAddress(float_signmask()));
  
#line 43545 "ad_x86.cpp"
  }
}

void absF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2554 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vandps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */,
              ExternalAddress(float_signmask()), vector_len);
  
#line 43563 "ad_x86.cpp"
  }
}

void absF_reg_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2568 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vandps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */,
              ExternalAddress(float_signmask()), vector_len);
  
#line 43581 "ad_x86.cpp"
  }
}

void absF_reg_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2582 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vabsss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */,
              ExternalAddress(float_signmask()), vector_len);
  
#line 43600 "ad_x86.cpp"
  }
}

void absD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  {
    MacroAssembler _masm(&cbuf);

#line 2610 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ andpd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, ExternalAddress(double_signmask()));
  
#line 43616 "ad_x86.cpp"
  }
}

void absD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2622 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vandpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */,
              ExternalAddress(double_signmask()), vector_len);
  
#line 43634 "ad_x86.cpp"
  }
}

void absD_reg_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2637 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vandpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */,
              ExternalAddress(double_signmask()), vector_len);
  
#line 43652 "ad_x86.cpp"
  }
}

void absD_reg_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 2651 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vabssd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */,
              ExternalAddress(double_signmask()), vector_len);
  
#line 43671 "ad_x86.cpp"
  }
}

void negF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  {
    MacroAssembler _masm(&cbuf);

#line 2679 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ xorps(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, ExternalAddress(float_signflip()));
  
#line 43687 "ad_x86.cpp"
  }
}

void negF_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2690 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vnegatess(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */,
                 ExternalAddress(float_signflip()));
  
#line 43704 "ad_x86.cpp"
  }
}

void negD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  {
    MacroAssembler _masm(&cbuf);

#line 2703 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ xorpd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, ExternalAddress(double_signflip()));
  
#line 43720 "ad_x86.cpp"
  }
}

void negD_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2715 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vnegatesd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */,
                 ExternalAddress(double_signflip()));
  
#line 43737 "ad_x86.cpp"
  }
}

void sqrtF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2728 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ sqrtss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
  
#line 43753 "ad_x86.cpp"
  }
}

void sqrtF_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2740 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ sqrtss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 43769 "ad_x86.cpp"
  }
}

void sqrtF_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2752 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ sqrtss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 43785 "ad_x86.cpp"
  }
}

void sqrtF_immNode::eval_constant(Compile* C) {
  {

#line 2753 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(1));
#line 43794 "ad_x86.cpp"
  }
}
void sqrtD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2764 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ sqrtsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */);
  
#line 43809 "ad_x86.cpp"
  }
}

void sqrtD_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2776 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ sqrtsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 43825 "ad_x86.cpp"
  }
}

void sqrtD_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 2787 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ sqrtsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 43841 "ad_x86.cpp"
  }
}

void sqrtD_immNode::eval_constant(Compile* C) {
  {

#line 2788 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(1));
#line 43850 "ad_x86.cpp"
  }
}
void onspinwaitNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// 
  {
    MacroAssembler _masm(&cbuf);

#line 2805 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pause();
  
#line 43865 "ad_x86.cpp"
  }
}

void fmaD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// c
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// a
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// b
  {
    MacroAssembler _masm(&cbuf);

#line 2817 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ fmad(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* a */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* b */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */);
  
#line 43883 "ad_x86.cpp"
  }
}

void fmaF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// c
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// a
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// b
  {
    MacroAssembler _masm(&cbuf);

#line 2829 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ fmaf(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* a */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* b */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */);
  
#line 43901 "ad_x86.cpp"
  }
}

void loadV4Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 2843 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 43917 "ad_x86.cpp"
  }
}

void loadV8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 2855 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 43933 "ad_x86.cpp"
  }
}

void loadV16Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 2867 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdqu(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 43949 "ad_x86.cpp"
  }
}

void loadV32Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 2879 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmovdqu(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
  
#line 43965 "ad_x86.cpp"
  }
}

void loadV64_dwordNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 2891 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ evmovdqul(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 43982 "ad_x86.cpp"
  }
}

void loadV64_qwordNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 2904 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ evmovdquq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 43999 "ad_x86.cpp"
  }
}

void storeV4Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2917 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 44016 "ad_x86.cpp"
  }
}

void storeV8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2928 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movq(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 44033 "ad_x86.cpp"
  }
}

void storeV16Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2939 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdqu(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 44050 "ad_x86.cpp"
  }
}

void storeV32Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2950 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmovdqu(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 44067 "ad_x86.cpp"
  }
}

void storeV64_dwordNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2961 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ evmovdqul(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, vector_len);
  
#line 44085 "ad_x86.cpp"
  }
}

void storeV64_qwordNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 2973 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ evmovdquq(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, vector_len);
  
#line 44103 "ad_x86.cpp"
  }
}

void Repl4B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 2987 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ punpcklbw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ pshuflw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
  
#line 44120 "ad_x86.cpp"
  }
}

void Repl8B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 2999 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ punpcklbw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ pshuflw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
  
#line 44137 "ad_x86.cpp"
  }
}

void Repl16BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3013 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ punpcklbw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
    __ pshuflw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44156 "ad_x86.cpp"
  }
}

void Repl16B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3028 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ punpcklbw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ pshuflw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44174 "ad_x86.cpp"
  }
}

void Repl32BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3044 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ punpcklbw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
    __ pshuflw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
    __ vinserti128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44194 "ad_x86.cpp"
  }
}

void Repl32B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3061 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ punpcklbw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ pshuflw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
    __ vinserti128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44213 "ad_x86.cpp"
  }
}

void Repl16B_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3075 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44230 "ad_x86.cpp"
  }
}

void Repl16B_immNode::eval_constant(Compile* C) {
  {

#line 3076 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 1));
#line 44239 "ad_x86.cpp"
  }
}
void Repl32B_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3088 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
    __ vinserti128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44256 "ad_x86.cpp"
  }
}

void Repl32B_immNode::eval_constant(Compile* C) {
  {

#line 3089 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 1));
#line 44265 "ad_x86.cpp"
  }
}
void Repl4SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3101 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ pshuflw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
  
#line 44281 "ad_x86.cpp"
  }
}

void Repl4S_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3112 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshuflw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), 0x00);
  
#line 44297 "ad_x86.cpp"
  }
}

void Repl8SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3124 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ pshuflw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44315 "ad_x86.cpp"
  }
}

void Repl8S_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3137 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshuflw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), 0x00);
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44332 "ad_x86.cpp"
  }
}

void Repl8S_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3149 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44349 "ad_x86.cpp"
  }
}

void Repl8S_immNode::eval_constant(Compile* C) {
  {

#line 3150 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 2));
#line 44358 "ad_x86.cpp"
  }
}
void Repl16SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3163 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ pshuflw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
    __ vinserti128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44376 "ad_x86.cpp"
  }
}

void Repl16S_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3178 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshuflw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), 0x00);
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
    __ vinserti128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44394 "ad_x86.cpp"
  }
}

void Repl16S_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3192 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
    __ vinserti128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44412 "ad_x86.cpp"
  }
}

void Repl16S_immNode::eval_constant(Compile* C) {
  {

#line 3193 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 2));
#line 44421 "ad_x86.cpp"
  }
}
void Repl4INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3205 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
  
#line 44437 "ad_x86.cpp"
  }
}

void Repl4I_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3216 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), 0x00);
  
#line 44453 "ad_x86.cpp"
  }
}

void Repl8INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3228 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
    __ vinserti128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44471 "ad_x86.cpp"
  }
}

void Repl8I_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3241 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), 0x00);
    __ vinserti128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44488 "ad_x86.cpp"
  }
}

void Repl4I_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3253 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44505 "ad_x86.cpp"
  }
}

void Repl4I_immNode::eval_constant(Compile* C) {
  {

#line 3254 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 4));
#line 44514 "ad_x86.cpp"
  }
}
void Repl8I_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3266 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
    __ vinserti128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44531 "ad_x86.cpp"
  }
}

void Repl8I_immNode::eval_constant(Compile* C) {
  {

#line 3267 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 4));
#line 44540 "ad_x86.cpp"
  }
}
void Repl2L_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3280 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44556 "ad_x86.cpp"
  }
}

void Repl4LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3295 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
    __ vinserti128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44574 "ad_x86.cpp"
  }
}

void Repl4L_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3329 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
    __ vinserti128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44592 "ad_x86.cpp"
  }
}

void Repl4L_immNode::eval_constant(Compile* C) {
  {

#line 3330 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(1));
#line 44601 "ad_x86.cpp"
  }
}
void Repl4L_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3343 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
    __ vinserti128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44618 "ad_x86.cpp"
  }
}

void Repl2F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), 0x00);
  
#line 44634 "ad_x86.cpp"
  }
}

void Repl4F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3365 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), 0x00);
  
#line 44650 "ad_x86.cpp"
  }
}

void Repl8FNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3376 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, 0x00);
    __ vinsertf128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44667 "ad_x86.cpp"
  }
}

void Repl8F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3388 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), 0x00);
    __ vinsertf128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44684 "ad_x86.cpp"
  }
}

void Repl2F_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3399 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ xorps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44700 "ad_x86.cpp"
  }
}

void Repl4F_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3409 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ xorps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44716 "ad_x86.cpp"
  }
}

void Repl8F_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3419 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vxorps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 44733 "ad_x86.cpp"
  }
}

void Repl2D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3430 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), 0x44);
  
#line 44749 "ad_x86.cpp"
  }
}

void Repl4DNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3441 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, 0x44);
    __ vinsertf128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44766 "ad_x86.cpp"
  }
}

void Repl4D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3453 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), 0x44);
    __ vinsertf128_high(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44783 "ad_x86.cpp"
  }
}

void Repl2D_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3465 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ xorpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44799 "ad_x86.cpp"
  }
}

void Repl4D_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3475 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vxorpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 44816 "ad_x86.cpp"
  }
}

void Repl4BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3491 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ punpcklbw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
    __ pshuflw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
  
#line 44834 "ad_x86.cpp"
  }
}

void Repl8BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3505 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ punpcklbw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
    __ pshuflw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
  
#line 44852 "ad_x86.cpp"
  }
}

void Repl4B_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3518 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 44868 "ad_x86.cpp"
  }
}

void Repl4B_immNode::eval_constant(Compile* C) {
  {

#line 3519 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate4_imm(opnd_array(1)->constant(), 1));
#line 44877 "ad_x86.cpp"
  }
}
void Repl8B_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3528 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 44892 "ad_x86.cpp"
  }
}

void Repl8B_immNode::eval_constant(Compile* C) {
  {

#line 3529 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 1));
#line 44901 "ad_x86.cpp"
  }
}
void Repl4B_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3539 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44916 "ad_x86.cpp"
  }
}

void Repl8B_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3549 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44932 "ad_x86.cpp"
  }
}

void Repl16B_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3559 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 44948 "ad_x86.cpp"
  }
}

void Repl32B_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3569 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    // Use vxorpd since AVX does not have vpxor for 256-bit (AVX2 will have it).
    int vector_len = 1;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 44966 "ad_x86.cpp"
  }
}

void Repl2SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3583 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ pshuflw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
  
#line 44983 "ad_x86.cpp"
  }
}

void Repl2S_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3595 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 44999 "ad_x86.cpp"
  }
}

void Repl2S_immNode::eval_constant(Compile* C) {
  {

#line 3596 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate4_imm(opnd_array(1)->constant(), 2));
#line 45008 "ad_x86.cpp"
  }
}
void Repl4S_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3605 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 45023 "ad_x86.cpp"
  }
}

void Repl4S_immNode::eval_constant(Compile* C) {
  {

#line 3606 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 2));
#line 45032 "ad_x86.cpp"
  }
}
void Repl2S_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3616 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 45047 "ad_x86.cpp"
  }
}

void Repl4S_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3626 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 45063 "ad_x86.cpp"
  }
}

void Repl8S_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3636 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 45079 "ad_x86.cpp"
  }
}

void Repl16S_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3646 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    // Use vxorpd since AVX does not have vpxor for 256-bit (AVX2 will have it).
    int vector_len = 1;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 45097 "ad_x86.cpp"
  }
}

void Repl2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3660 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
  
#line 45114 "ad_x86.cpp"
  }
}

void Repl2I_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3673 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()));
    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, 0x00);
  
#line 45131 "ad_x86.cpp"
  }
}

void Repl2I_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3685 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 45147 "ad_x86.cpp"
  }
}

void Repl2I_immNode::eval_constant(Compile* C) {
  {

#line 3686 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 4));
#line 45156 "ad_x86.cpp"
  }
}
void Repl2I_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3696 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 45171 "ad_x86.cpp"
  }
}

void Repl4I_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3706 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 45187 "ad_x86.cpp"
  }
}

void Repl8I_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3716 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    // Use vxorpd since AVX does not have vpxor for 256-bit (AVX2 will have it).
    int vector_len = 1;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 45205 "ad_x86.cpp"
  }
}

void Repl2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3731 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */);
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 45222 "ad_x86.cpp"
  }
}

void Repl2L_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3762 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ punpcklqdq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 45239 "ad_x86.cpp"
  }
}

void Repl2L_immNode::eval_constant(Compile* C) {
  {

#line 3763 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(1));
#line 45248 "ad_x86.cpp"
  }
}
void Repl2L_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3774 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */);
  
#line 45263 "ad_x86.cpp"
  }
}

void Repl4L_zeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3784 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    // Use vxorpd since AVX does not have vpxor for 256-bit (AVX2 will have it).
    int vector_len = 1;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 45281 "ad_x86.cpp"
  }
}

void Repl2FNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3797 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, 0x00);
  
#line 45297 "ad_x86.cpp"
  }
}

void Repl4FNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3807 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, 0x00);
  
#line 45313 "ad_x86.cpp"
  }
}

void Repl2DNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3818 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, 0x44);
  
#line 45329 "ad_x86.cpp"
  }
}

void Repl4B_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3830 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ evpbroadcastb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 45346 "ad_x86.cpp"
  }
}

void Repl8B_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3841 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ evpbroadcastb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 45363 "ad_x86.cpp"
  }
}

void Repl16B_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3852 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

   int vector_len = 0;
    __ evpbroadcastb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */, vector_len);
  
#line 45380 "ad_x86.cpp"
  }
}

void Repl16B_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3863 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ evpbroadcastb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 45397 "ad_x86.cpp"
  }
}

void Repl32B_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3874 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

   int vector_len = 1;
    __ evpbroadcastb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */, vector_len);
  
#line 45414 "ad_x86.cpp"
  }
}

void Repl32B_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3885 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ evpbroadcastb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 45431 "ad_x86.cpp"
  }
}

void Repl64B_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3896 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

   int vector_len = 2;
    __ evpbroadcastb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */, vector_len);
  
#line 45448 "ad_x86.cpp"
  }
}

void Repl64B_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3907 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ evpbroadcastb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 45465 "ad_x86.cpp"
  }
}

void Repl16B_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3919 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

   int vector_len = 0;
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ evpbroadcastb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 45483 "ad_x86.cpp"
  }
}

void Repl16B_imm_evexNode::eval_constant(Compile* C) {
  {

#line 3921 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 1));
#line 45492 "ad_x86.cpp"
  }
}
void Repl32B_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3932 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

   int vector_len = 1;
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ evpbroadcastb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 45509 "ad_x86.cpp"
  }
}

void Repl32B_imm_evexNode::eval_constant(Compile* C) {
  {

#line 3934 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 1));
#line 45518 "ad_x86.cpp"
  }
}
void Repl64B_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 3945 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

   int vector_len = 2;
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ evpbroadcastb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 45535 "ad_x86.cpp"
  }
}

void Repl64B_imm_evexNode::eval_constant(Compile* C) {
  {

#line 3947 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 1));
#line 45544 "ad_x86.cpp"
  }
}
void Repl64B_zero_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 3957 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    // Use vxorpd since AVX does not have vpxor for 512-bit (EVEX will have it).
    int vector_len = 2;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */,opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 45561 "ad_x86.cpp"
  }
}

void Repl4S_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3969 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

   int vector_len = 0;
    __ evpbroadcastw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */, vector_len);
  
#line 45578 "ad_x86.cpp"
  }
}

void Repl4S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 3980 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ evpbroadcastw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 45595 "ad_x86.cpp"
  }
}

void Repl8S_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 3991 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

   int vector_len = 0;
    __ evpbroadcastw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */, vector_len);
  
#line 45612 "ad_x86.cpp"
  }
}

void Repl8S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4002 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ evpbroadcastw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 45629 "ad_x86.cpp"
  }
}

void Repl16S_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 4013 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

   int vector_len = 1;
    __ evpbroadcastw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */, vector_len);
  
#line 45646 "ad_x86.cpp"
  }
}

void Repl16S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4024 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ evpbroadcastw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 45663 "ad_x86.cpp"
  }
}

void Repl32S_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 4035 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

   int vector_len = 2;
    __ evpbroadcastw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */, vector_len);
  
#line 45680 "ad_x86.cpp"
  }
}

void Repl32S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4046 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ evpbroadcastw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 45697 "ad_x86.cpp"
  }
}

void Repl8S_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 4058 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

   int vector_len = 0;
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ evpbroadcastw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 45715 "ad_x86.cpp"
  }
}

void Repl8S_imm_evexNode::eval_constant(Compile* C) {
  {

#line 4060 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 2));
#line 45724 "ad_x86.cpp"
  }
}
void Repl16S_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 4071 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

   int vector_len = 1;
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ evpbroadcastw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 45741 "ad_x86.cpp"
  }
}

void Repl16S_imm_evexNode::eval_constant(Compile* C) {
  {

#line 4073 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 2));
#line 45750 "ad_x86.cpp"
  }
}
void Repl32S_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 4084 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

   int vector_len = 2;
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ evpbroadcastw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 45767 "ad_x86.cpp"
  }
}

void Repl32S_imm_evexNode::eval_constant(Compile* C) {
  {

#line 4086 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 2));
#line 45776 "ad_x86.cpp"
  }
}
void Repl32S_zero_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 4096 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    // Use vxorpd since AVX does not have vpxor for 512-bit (EVEX will have it).
    int vector_len = 2;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 45793 "ad_x86.cpp"
  }
}

void Repl4I_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 4108 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ evpbroadcastd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */, vector_len);
  
#line 45810 "ad_x86.cpp"
  }
}

void Repl4I_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4119 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ evpbroadcastd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 45827 "ad_x86.cpp"
  }
}

void Repl8I_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 4130 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ evpbroadcastd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */, vector_len);
  
#line 45844 "ad_x86.cpp"
  }
}

void Repl8I_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4141 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ evpbroadcastd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 45861 "ad_x86.cpp"
  }
}

void Repl16I_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 4152 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ evpbroadcastd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */, vector_len);
  
#line 45878 "ad_x86.cpp"
  }
}

void Repl16I_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4163 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ evpbroadcastd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 45895 "ad_x86.cpp"
  }
}

void Repl4I_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 4175 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ evpbroadcastd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 45913 "ad_x86.cpp"
  }
}

void Repl4I_imm_evexNode::eval_constant(Compile* C) {
  {

#line 4177 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 4));
#line 45922 "ad_x86.cpp"
  }
}
void Repl8I_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 4188 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ evpbroadcastd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 45939 "ad_x86.cpp"
  }
}

void Repl8I_imm_evexNode::eval_constant(Compile* C) {
  {

#line 4190 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 4));
#line 45948 "ad_x86.cpp"
  }
}
void Repl16I_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 4201 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ evpbroadcastd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 45965 "ad_x86.cpp"
  }
}

void Repl16I_imm_evexNode::eval_constant(Compile* C) {
  {

#line 4203 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, replicate8_imm(opnd_array(1)->constant(), 4));
#line 45974 "ad_x86.cpp"
  }
}
void Repl16I_zero_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 4213 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    // Use vxorpd since AVX does not have vpxor for 512-bit (AVX2 will have it).
    int vector_len = 2;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 45991 "ad_x86.cpp"
  }
}

void Repl4L_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 4227 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ evpbroadcastq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */, vector_len);
  
#line 46008 "ad_x86.cpp"
  }
}

void Repl8L_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 4238 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ evpbroadcastq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* src */, vector_len);
  
#line 46025 "ad_x86.cpp"
  }
}

void Repl4L_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 4287 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ evpbroadcastq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 46043 "ad_x86.cpp"
  }
}

void Repl4L_imm_evexNode::eval_constant(Compile* C) {
  {

#line 4289 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(1));
#line 46052 "ad_x86.cpp"
  }
}
void Repl8L_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// con
  {
    MacroAssembler _masm(&cbuf);

#line 4300 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ evpbroadcastq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 46069 "ad_x86.cpp"
  }
}

void Repl8L_imm_evexNode::eval_constant(Compile* C) {
  {

#line 4302 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"
    _constant = C->constant_table().add(this, opnd_array(1));
#line 46078 "ad_x86.cpp"
  }
}
void Repl2L_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4312 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ evpbroadcastq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 46094 "ad_x86.cpp"
  }
}

void Repl4L_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4323 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ evpbroadcastq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 46111 "ad_x86.cpp"
  }
}

void Repl8L_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4334 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ evpbroadcastq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 46128 "ad_x86.cpp"
  }
}

void Repl8L_zero_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 4345 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    // Use vxorpd since AVX does not have vpxor for 512-bit (EVEX will have it).
    int vector_len = 2;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */,opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 46146 "ad_x86.cpp"
  }
}

void Repl8F_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 4357 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ evpbroadcastss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, vector_len);
  
#line 46163 "ad_x86.cpp"
  }
}

void Repl8F_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4368 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ evpbroadcastss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 46180 "ad_x86.cpp"
  }
}

void Repl16F_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 4379 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ evpbroadcastss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, vector_len);
  
#line 46197 "ad_x86.cpp"
  }
}

void Repl16F_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4390 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ evpbroadcastss(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 46214 "ad_x86.cpp"
  }
}

void Repl2F_zero_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 4401 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    // Use vpxor in place of vxorps since EVEX has a constriant on dq for vxorps: this is a 512-bit operation
    int vector_len = 2;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */,opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 46232 "ad_x86.cpp"
  }
}

void Repl4F_zero_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 4413 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    // Use vpxor in place of vxorps since EVEX has a constriant on dq for vxorps: this is a 512-bit operation
    int vector_len = 2;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */,opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 46250 "ad_x86.cpp"
  }
}

void Repl8F_zero_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 4425 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    // Use vpxor in place of vxorps since EVEX has a constriant on dq for vxorps: this is a 512-bit operation
    int vector_len = 2;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */,opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 46268 "ad_x86.cpp"
  }
}

void Repl16F_zero_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 4437 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    // Use vpxor in place of vxorps since EVEX has a constriant on dq for vxorps: this is a 512-bit operation
    int vector_len = 2;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */,opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 46286 "ad_x86.cpp"
  }
}

void Repl4D_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 4449 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ evpbroadcastsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, vector_len);
  
#line 46303 "ad_x86.cpp"
  }
}

void Repl4D_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4460 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ evpbroadcastsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 46320 "ad_x86.cpp"
  }
}

void Repl8D_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 4471 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ evpbroadcastsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, vector_len);
  
#line 46337 "ad_x86.cpp"
  }
}

void Repl8D_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 4482 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ evpbroadcastsd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 46354 "ad_x86.cpp"
  }
}

void Repl2D_zero_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 4493 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    // Use vpxor in place of vxorpd since EVEX has a constriant on dq for vxorpd: this is a 512-bit operation
    int vector_len = 2;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */,opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 46372 "ad_x86.cpp"
  }
}

void Repl4D_zero_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 4505 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    // Use vpxor in place of vxorpd since EVEX has a constriant on dq for vxorpd: this is a 512-bit operation
    int vector_len = 2;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */,opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 46390 "ad_x86.cpp"
  }
}

void Repl8D_zero_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// zero
  {
    MacroAssembler _masm(&cbuf);

#line 4517 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    // Use vpxor in place of vxorpd since EVEX has a constriant on dq for vxorpd: this is a 512-bit operation
    int vector_len = 2;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */,opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, vector_len);
  
#line 46408 "ad_x86.cpp"
  }
}

void rsadd2I_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 4536 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdqu(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ phaddd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ movdl(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ paddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 46431 "ad_x86.cpp"
  }
}

void rvadd2I_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 4554 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vphaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
    __ movdl(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpaddd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, vector_len);
    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 46454 "ad_x86.cpp"
  }
}

void rvadd2I_reduction_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 4573 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x1);
    __ vpaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ movdl(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpaddd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 46478 "ad_x86.cpp"
  }
}

void rsadd4I_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 4594 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdqu(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ phaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ phaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ movdl(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ paddd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 46502 "ad_x86.cpp"
  }
}

void rvadd4I_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 4614 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vphaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
    __ vphaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, vector_len);
    __ movdl(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpaddd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, vector_len);
    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 46526 "ad_x86.cpp"
  }
}

void rvadd4I_reduction_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 4636 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0xE);
    __ vpaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0x1);
    __ vpaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ movdl(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpaddd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 46552 "ad_x86.cpp"
  }
}

void rvadd8I_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 4660 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vphaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
    __ vphaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ vextracti128_high(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vpaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0);
    __ movdl(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpaddd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0);
    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 46578 "ad_x86.cpp"
  }
}

void rvadd8I_reduction_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 4686 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vextracti128_high(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ vpaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0xE);
    __ vpaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0x1);
    __ vpaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ movdl(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpaddd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 46606 "ad_x86.cpp"
  }
}

void rvadd16I_reduction_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp3
  {
    MacroAssembler _masm(&cbuf);

#line 4716 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vextracti64x4_high(opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp3 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ vpaddd(opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp3 */, opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp3 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 1);
    __ vextracti128_high(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp3 */);
    __ vpaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp3 */, 0);
    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0xE);
    __ vpaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0);
    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0x1);
    __ vpaddd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0);
    __ movdl(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpaddd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0);
    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 46636 "ad_x86.cpp"
  }
}

void rvadd2L_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 4742 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0xE);
    __ vpaddq(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0);
    __ movdq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpaddq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0);
    __ movdq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 46659 "ad_x86.cpp"
  }
}

void rvadd4L_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 4763 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vextracti128_high(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ vpaddq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0xE);
    __ vpaddq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0);
    __ movdq(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpaddq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0);
    __ movdq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 46684 "ad_x86.cpp"
  }
}

void rvadd8L_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 4788 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vextracti64x4_high(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ vpaddq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 1);
    __ vextracti128_high(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ vpaddq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0xE);
    __ vpaddq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0);
    __ movdq(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpaddq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0);
    __ movdq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 46711 "ad_x86.cpp"
  }
}

void rsadd2F_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 4810 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ addss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x01);
    __ addss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 46731 "ad_x86.cpp"
  }
}

void rvadd2F_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 4825 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x01);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 46751 "ad_x86.cpp"
  }
}

void rsadd4F_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 4844 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ addss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x01);
    __ addss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x02);
    __ addss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x03);
    __ addss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 46775 "ad_x86.cpp"
  }
}

void rvadd4F_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 4867 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x01);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x02);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x03);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 46799 "ad_x86.cpp"
  }
}

void radd8F_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 4898 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x01);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x02);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x03);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf128_high(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x01);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x02);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x03);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 46832 "ad_x86.cpp"
  }
}

void radd16F_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 4953 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x01);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x02);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x03);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf32x4(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x1);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x01);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x02);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x03);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf32x4(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x2);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x01);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x02);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x03);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf32x4(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x3);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x01);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x02);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x03);
    __ vaddss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 46881 "ad_x86.cpp"
  }
}

void rsadd2D_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 4996 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ addsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0xE);
    __ addsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 46901 "ad_x86.cpp"
  }
}

void rvadd2D_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 5011 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vaddsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0xE);
    __ vaddsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 46921 "ad_x86.cpp"
  }
}

void rvadd4D_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 5030 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vaddsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0xE);
    __ vaddsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf32x4(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x1);
    __ vaddsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0xE);
    __ vaddsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 46946 "ad_x86.cpp"
  }
}

void rvadd8D_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 5061 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vaddsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0xE);
    __ vaddsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf32x4(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x1);
    __ vaddsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0xE);
    __ vaddsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf32x4(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x2);
    __ vaddsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0xE);
    __ vaddsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf32x4(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x3);
    __ vaddsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0xE);
    __ vaddsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 46979 "ad_x86.cpp"
  }
}

void rsmul2I_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 5090 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x1);
    __ pmulld(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ movdl(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ pmulld(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 47002 "ad_x86.cpp"
  }
}

void rvmul2I_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 5109 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x1);
    __ vpmulld(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ movdl(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpmulld(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 47026 "ad_x86.cpp"
  }
}

void rsmul4I_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 5131 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0xE);
    __ pmulld(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x1);
    __ pmulld(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ movdl(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ pmulld(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 47051 "ad_x86.cpp"
  }
}

void rvmul4I_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 5154 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0xE);
    __ vpmulld(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0x1);
    __ vpmulld(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ movdl(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpmulld(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 47077 "ad_x86.cpp"
  }
}

void rvmul8I_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 5180 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vextracti128_high(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ vpmulld(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0xE);
    __ vpmulld(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0x1);
    __ vpmulld(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ movdl(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpmulld(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, vector_len);
    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 47105 "ad_x86.cpp"
  }
}

void rvmul16I_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// tmp3
  {
    MacroAssembler _masm(&cbuf);

#line 5210 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vextracti64x4_high(opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp3 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ vpmulld(opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp3 */, opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp3 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 1);
    __ vextracti128_high(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp3 */);
    __ vpmulld(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* tmp3 */, 0);
    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0xE);
    __ vpmulld(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0);
    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0x1);
    __ vpmulld(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0);
    __ movdl(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpmulld(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0);
    __ movdl(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 47135 "ad_x86.cpp"
  }
}

void rvmul2L_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 5236 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pshufd(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0xE);
    __ vpmullq(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0);
    __ movdq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpmullq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0);
    __ movdq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 47158 "ad_x86.cpp"
  }
}

void rvmul4L_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 5257 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vextracti128_high(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ vpmullq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0xE);
    __ vpmullq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0);
    __ movdq(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpmullq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0);
    __ movdq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 47183 "ad_x86.cpp"
  }
}

void rvmul8L_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 5282 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vextracti64x4_high(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ vpmullq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 1);
    __ vextracti128_high(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ vpmullq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0xE);
    __ vpmullq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0);
    __ movdq(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(1)->as_Register(ra_,this,idx1)/* src1 */);
    __ vpmullq(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, 0);
    __ movdq(opnd_array(0)->as_Register(ra_,this)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
  
#line 47210 "ad_x86.cpp"
  }
}

void rsmul2F_reductionNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 5304 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ mulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x01);
    __ mulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 47230 "ad_x86.cpp"
  }
}

void rvmul2F_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 5319 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x01);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 47250 "ad_x86.cpp"
  }
}

void rsmul4F_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 5338 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ mulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x01);
    __ mulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x02);
    __ mulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x03);
    __ mulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 47274 "ad_x86.cpp"
  }
}

void rvmul4F_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 5361 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x01);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x02);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x03);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 47298 "ad_x86.cpp"
  }
}

void rvmul8F_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 5392 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x01);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x02);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x03);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf128_high(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x01);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x02);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x03);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 47331 "ad_x86.cpp"
  }
}

void rvmul16F_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 5447 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x01);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x02);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x03);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf32x4(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x1);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x01);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x02);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x03);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf32x4(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x2);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x01);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x02);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x03);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf32x4(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x3);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x01);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x02);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0x03);
    __ vmulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 47380 "ad_x86.cpp"
  }
}

void rsmul2D_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 5490 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ mulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0xE);
    __ mulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 47400 "ad_x86.cpp"
  }
}

void rvmul2D_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  {
    MacroAssembler _masm(&cbuf);

#line 5505 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0xE);
    __ vmulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 47420 "ad_x86.cpp"
  }
}

void rvmul4D_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 5524 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0xE);
    __ vmulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf128_high(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ vmulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0xE);
    __ vmulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 47445 "ad_x86.cpp"
  }
}

void rvmul8D_reduction_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// tmp
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// tmp2
  {
    MacroAssembler _masm(&cbuf);

#line 5555 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ vmulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0xE);
    __ vmulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf32x4(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x1);
    __ vmulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0xE);
    __ vmulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf32x4(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x2);
    __ vmulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0xE);
    __ vmulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
    __ vextractf32x4(opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, 0x3);
    __ vmulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */);
    __ pshufd(opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* tmp2 */, 0xE);
    __ vmulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* tmp */);
  
#line 47478 "ad_x86.cpp"
  }
}

void vadd4BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5584 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ paddb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 47495 "ad_x86.cpp"
  }
}

void vadd4B_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 5594 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 47513 "ad_x86.cpp"
  }
}

void vadd4B_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 5605 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 47531 "ad_x86.cpp"
  }
}

void vadd4B_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 5617 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 47550 "ad_x86.cpp"
  }
}

void vadd4B_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5628 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 47568 "ad_x86.cpp"
  }
}

void vadd4B_mem_avx_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5628 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 47586 "ad_x86.cpp"
  }
}

void vadd4B_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5639 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 47604 "ad_x86.cpp"
  }
}

void vadd4B_mem_evex_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5639 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 47622 "ad_x86.cpp"
  }
}

void vadd4B_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5651 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 47641 "ad_x86.cpp"
  }
}

void vadd4B_mem_evex_special_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5651 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 47660 "ad_x86.cpp"
  }
}

void vadd8BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5662 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ paddb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 47677 "ad_x86.cpp"
  }
}

void vadd8B_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 5672 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 47695 "ad_x86.cpp"
  }
}

void vadd8B_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 5683 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 47713 "ad_x86.cpp"
  }
}

void vadd8B_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 5695 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 47732 "ad_x86.cpp"
  }
}

void vadd8B_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5706 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 47750 "ad_x86.cpp"
  }
}

void vadd8B_mem_avx_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5706 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 47768 "ad_x86.cpp"
  }
}

void vadd8B_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5717 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 47786 "ad_x86.cpp"
  }
}

void vadd8B_mem_evex_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5717 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 47804 "ad_x86.cpp"
  }
}

void vadd8B_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5729 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 47823 "ad_x86.cpp"
  }
}

void vadd8B_mem_evex_special_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5729 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 47842 "ad_x86.cpp"
  }
}

void vadd16BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5740 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ paddb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 47859 "ad_x86.cpp"
  }
}

void vadd16B_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 5750 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 47877 "ad_x86.cpp"
  }
}

void vadd16B_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 5761 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 47895 "ad_x86.cpp"
  }
}

void vadd16B_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 5773 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 47914 "ad_x86.cpp"
  }
}

void vadd16B_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5784 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 47932 "ad_x86.cpp"
  }
}

void vadd16B_mem_avx_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5784 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 47950 "ad_x86.cpp"
  }
}

void vadd16B_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5795 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 47968 "ad_x86.cpp"
  }
}

void vadd16B_mem_evex_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5795 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 47986 "ad_x86.cpp"
  }
}

void vadd16B_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5807 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48005 "ad_x86.cpp"
  }
}

void vadd16B_mem_evex_special_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5807 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddb(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48024 "ad_x86.cpp"
  }
}

void vadd32B_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 5818 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48042 "ad_x86.cpp"
  }
}

void vadd32B_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 5829 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48060 "ad_x86.cpp"
  }
}

void vadd32B_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 5841 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48079 "ad_x86.cpp"
  }
}

void vadd32B_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5852 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48097 "ad_x86.cpp"
  }
}

void vadd32B_mem_avx_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5852 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48115 "ad_x86.cpp"
  }
}

void vadd32B_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5863 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48133 "ad_x86.cpp"
  }
}

void vadd32B_mem_evex_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5863 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48151 "ad_x86.cpp"
  }
}

void vadd32B_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5875 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48170 "ad_x86.cpp"
  }
}

void vadd32B_mem_evex_special_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5875 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddb(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48189 "ad_x86.cpp"
  }
}

void vadd64B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 5886 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48207 "ad_x86.cpp"
  }
}

void vadd64B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5897 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48225 "ad_x86.cpp"
  }
}

void vadd64B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5897 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpaddb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48243 "ad_x86.cpp"
  }
}

void vadd2SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5909 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ paddw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 48260 "ad_x86.cpp"
  }
}

void vadd2S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 5919 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48278 "ad_x86.cpp"
  }
}

void vadd2S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 5930 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48296 "ad_x86.cpp"
  }
}

void vadd2S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 5942 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48315 "ad_x86.cpp"
  }
}

void vadd2S_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5953 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48333 "ad_x86.cpp"
  }
}

void vadd2S_mem_avx_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5953 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48351 "ad_x86.cpp"
  }
}

void vadd2S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 5964 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48369 "ad_x86.cpp"
  }
}

void vadd2S_mem_evex_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5964 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48387 "ad_x86.cpp"
  }
}

void vadd2S_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5976 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48406 "ad_x86.cpp"
  }
}

void vadd2S_mem_evex_special_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5976 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48425 "ad_x86.cpp"
  }
}

void vadd4SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 5987 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ paddw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 48442 "ad_x86.cpp"
  }
}

void vadd4S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 5997 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48460 "ad_x86.cpp"
  }
}

void vadd4S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6008 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48478 "ad_x86.cpp"
  }
}

void vadd4S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 6020 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48497 "ad_x86.cpp"
  }
}

void vadd4S_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6031 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48515 "ad_x86.cpp"
  }
}

void vadd4S_mem_avx_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6031 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48533 "ad_x86.cpp"
  }
}

void vadd4S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6042 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48551 "ad_x86.cpp"
  }
}

void vadd4S_mem_evex_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6042 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48569 "ad_x86.cpp"
  }
}

void vadd4S_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6054 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48588 "ad_x86.cpp"
  }
}

void vadd4S_mem_evex_special_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6054 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48607 "ad_x86.cpp"
  }
}

void vadd8SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6065 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ paddw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 48624 "ad_x86.cpp"
  }
}

void vadd8S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6075 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48642 "ad_x86.cpp"
  }
}

void vadd8S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6086 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48660 "ad_x86.cpp"
  }
}

void vadd8S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 6098 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48679 "ad_x86.cpp"
  }
}

void vadd8S_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6109 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48697 "ad_x86.cpp"
  }
}

void vadd8S_mem_avx_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6109 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48715 "ad_x86.cpp"
  }
}

void vadd8S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6120 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48733 "ad_x86.cpp"
  }
}

void vadd8S_mem_evex_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6120 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48751 "ad_x86.cpp"
  }
}

void vadd8S_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6132 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48770 "ad_x86.cpp"
  }
}

void vadd8S_mem_evex_special_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6132 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddw(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48789 "ad_x86.cpp"
  }
}

void vadd16S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6143 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48807 "ad_x86.cpp"
  }
}

void vadd16S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6154 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48825 "ad_x86.cpp"
  }
}

void vadd16S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 6166 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48844 "ad_x86.cpp"
  }
}

void vadd16S_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6177 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48862 "ad_x86.cpp"
  }
}

void vadd16S_mem_avx_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6177 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48880 "ad_x86.cpp"
  }
}

void vadd16S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6188 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48898 "ad_x86.cpp"
  }
}

void vadd16S_mem_evex_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6188 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48916 "ad_x86.cpp"
  }
}

void vadd16S_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6200 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48935 "ad_x86.cpp"
  }
}

void vadd16S_mem_evex_special_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6200 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddw(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 48954 "ad_x86.cpp"
  }
}

void vadd32S_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6211 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 48972 "ad_x86.cpp"
  }
}

void vadd32S_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6222 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 48990 "ad_x86.cpp"
  }
}

void vadd32S_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6222 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpaddw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 49008 "ad_x86.cpp"
  }
}

void vadd2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6234 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ paddd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 49025 "ad_x86.cpp"
  }
}

void vadd2I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6244 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49043 "ad_x86.cpp"
  }
}

void vadd2I_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6255 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49061 "ad_x86.cpp"
  }
}

void vadd2I_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6255 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 49079 "ad_x86.cpp"
  }
}

void vadd4INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6266 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ paddd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 49096 "ad_x86.cpp"
  }
}

void vadd4I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6276 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49114 "ad_x86.cpp"
  }
}

void vadd4I_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6287 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49132 "ad_x86.cpp"
  }
}

void vadd4I_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6287 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 49150 "ad_x86.cpp"
  }
}

void vadd8I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6298 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49168 "ad_x86.cpp"
  }
}

void vadd8I_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6309 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49186 "ad_x86.cpp"
  }
}

void vadd8I_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6309 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 49204 "ad_x86.cpp"
  }
}

void vadd16I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6320 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpaddd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49222 "ad_x86.cpp"
  }
}

void vadd16I_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6331 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpaddd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49240 "ad_x86.cpp"
  }
}

void vadd16I_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6331 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpaddd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 49258 "ad_x86.cpp"
  }
}

void vadd2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6343 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ paddq(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 49275 "ad_x86.cpp"
  }
}

void vadd2L_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6353 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49293 "ad_x86.cpp"
  }
}

void vadd2L_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6364 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49311 "ad_x86.cpp"
  }
}

void vadd2L_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6364 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpaddq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 49329 "ad_x86.cpp"
  }
}

void vadd4L_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6375 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49347 "ad_x86.cpp"
  }
}

void vadd4L_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6386 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49365 "ad_x86.cpp"
  }
}

void vadd4L_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6386 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpaddq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 49383 "ad_x86.cpp"
  }
}

void vadd8L_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6397 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpaddq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49401 "ad_x86.cpp"
  }
}

void vadd8L_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6408 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpaddq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49419 "ad_x86.cpp"
  }
}

void vadd8L_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6408 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpaddq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 49437 "ad_x86.cpp"
  }
}

void vadd2FNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6420 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ addps(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 49454 "ad_x86.cpp"
  }
}

void vadd2F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6430 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vaddps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49472 "ad_x86.cpp"
  }
}

void vadd2F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6441 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vaddps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49490 "ad_x86.cpp"
  }
}

void vadd2F_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6441 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vaddps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 49508 "ad_x86.cpp"
  }
}

void vadd4FNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6452 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ addps(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 49525 "ad_x86.cpp"
  }
}

void vadd4F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6462 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vaddps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49543 "ad_x86.cpp"
  }
}

void vadd4F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6473 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vaddps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49561 "ad_x86.cpp"
  }
}

void vadd4F_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6473 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vaddps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 49579 "ad_x86.cpp"
  }
}

void vadd8F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6484 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vaddps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49597 "ad_x86.cpp"
  }
}

void vadd8F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6495 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vaddps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49615 "ad_x86.cpp"
  }
}

void vadd8F_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6495 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vaddps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 49633 "ad_x86.cpp"
  }
}

void vadd16F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6506 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vaddps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49651 "ad_x86.cpp"
  }
}

void vadd16F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6517 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vaddps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49669 "ad_x86.cpp"
  }
}

void vadd16F_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6517 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vaddps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 49687 "ad_x86.cpp"
  }
}

void vadd2DNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6529 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ addpd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 49704 "ad_x86.cpp"
  }
}

void vadd2D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6539 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vaddpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49722 "ad_x86.cpp"
  }
}

void vadd2D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6550 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vaddpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49740 "ad_x86.cpp"
  }
}

void vadd2D_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6550 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vaddpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 49758 "ad_x86.cpp"
  }
}

void vadd4D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6561 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vaddpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49776 "ad_x86.cpp"
  }
}

void vadd4D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6572 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vaddpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49794 "ad_x86.cpp"
  }
}

void vadd4D_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6572 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vaddpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 49812 "ad_x86.cpp"
  }
}

void vadd8D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6583 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vaddpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49830 "ad_x86.cpp"
  }
}

void vadd8D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6594 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vaddpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49848 "ad_x86.cpp"
  }
}

void vadd8D_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6594 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vaddpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 49866 "ad_x86.cpp"
  }
}

void vsub4BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6608 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psubb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 49883 "ad_x86.cpp"
  }
}

void vsub4B_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6618 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49901 "ad_x86.cpp"
  }
}

void vsub4B_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6629 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49919 "ad_x86.cpp"
  }
}

void vsub4B_reg_exex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 6641 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 49938 "ad_x86.cpp"
  }
}

void vsub4B_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6652 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49956 "ad_x86.cpp"
  }
}

void vsub4B_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6663 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49974 "ad_x86.cpp"
  }
}

void vsub4B_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6675 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 49993 "ad_x86.cpp"
  }
}

void vsub8BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6686 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psubb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 50010 "ad_x86.cpp"
  }
}

void vsub8B_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6696 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50028 "ad_x86.cpp"
  }
}

void vsub8B_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6707 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50046 "ad_x86.cpp"
  }
}

void vsub8B_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 6719 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50065 "ad_x86.cpp"
  }
}

void vsub8B_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6730 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50083 "ad_x86.cpp"
  }
}

void vsub8B_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6741 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50101 "ad_x86.cpp"
  }
}

void vsub8B_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6753 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50120 "ad_x86.cpp"
  }
}

void vsub16BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6764 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psubb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 50137 "ad_x86.cpp"
  }
}

void vsub16B_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6774 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50155 "ad_x86.cpp"
  }
}

void vsub16B_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6785 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50173 "ad_x86.cpp"
  }
}

void vsub16B_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 6797 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50192 "ad_x86.cpp"
  }
}

void vsub16B_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6808 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50210 "ad_x86.cpp"
  }
}

void vsub16B_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6819 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50228 "ad_x86.cpp"
  }
}

void vsub16B_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6831 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50247 "ad_x86.cpp"
  }
}

void vsub32B_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50265 "ad_x86.cpp"
  }
}

void vsub32B_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6853 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50283 "ad_x86.cpp"
  }
}

void vsub32B_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 6865 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50302 "ad_x86.cpp"
  }
}

void vsub32B_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6876 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50320 "ad_x86.cpp"
  }
}

void vsub32B_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6887 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50338 "ad_x86.cpp"
  }
}

void vsub32B_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6899 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubb(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50357 "ad_x86.cpp"
  }
}

void vsub64B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6910 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50375 "ad_x86.cpp"
  }
}

void vsub64B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6921 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsubb(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50393 "ad_x86.cpp"
  }
}

void vsub2SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 6933 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psubw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 50410 "ad_x86.cpp"
  }
}

void vsub2S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6943 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50428 "ad_x86.cpp"
  }
}

void vsub2S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 6954 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50446 "ad_x86.cpp"
  }
}

void vsub2S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 6966 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50465 "ad_x86.cpp"
  }
}

void vsub2S_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6977 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50483 "ad_x86.cpp"
  }
}

void vsub2S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 6988 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50501 "ad_x86.cpp"
  }
}

void vsub2S_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7000 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50520 "ad_x86.cpp"
  }
}

void vsub4SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7011 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psubw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 50537 "ad_x86.cpp"
  }
}

void vsub4S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7021 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50555 "ad_x86.cpp"
  }
}

void vsub4S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7032 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50573 "ad_x86.cpp"
  }
}

void vsub4S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 7044 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50592 "ad_x86.cpp"
  }
}

void vsub4S_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7055 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50610 "ad_x86.cpp"
  }
}

void vsub4S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7066 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50628 "ad_x86.cpp"
  }
}

void vsub4S_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7078 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50647 "ad_x86.cpp"
  }
}

void vsub8SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7089 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psubw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 50664 "ad_x86.cpp"
  }
}

void vsub8S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7099 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50682 "ad_x86.cpp"
  }
}

void vsub8S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7110 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50700 "ad_x86.cpp"
  }
}

void vsub8S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 7122 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50719 "ad_x86.cpp"
  }
}

void vsub8S_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7133 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50737 "ad_x86.cpp"
  }
}

void vsub8S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7144 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50755 "ad_x86.cpp"
  }
}

void vsub8S_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7156 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50774 "ad_x86.cpp"
  }
}

void vsub16S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7167 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50792 "ad_x86.cpp"
  }
}

void vsub16S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7178 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50810 "ad_x86.cpp"
  }
}

void vsub16S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 7190 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50829 "ad_x86.cpp"
  }
}

void vsub16S_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7201 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50847 "ad_x86.cpp"
  }
}

void vsub16S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7212 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50865 "ad_x86.cpp"
  }
}

void vsub16S_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7224 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50884 "ad_x86.cpp"
  }
}

void vsub32S_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7235 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50902 "ad_x86.cpp"
  }
}

void vsub32S_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7246 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsubw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50920 "ad_x86.cpp"
  }
}

void vsub2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7258 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psubd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 50937 "ad_x86.cpp"
  }
}

void vsub2I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7268 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 50955 "ad_x86.cpp"
  }
}

void vsub2I_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7279 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 50973 "ad_x86.cpp"
  }
}

void vsub4INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7290 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psubd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 50990 "ad_x86.cpp"
  }
}

void vsub4I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7300 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51008 "ad_x86.cpp"
  }
}

void vsub4I_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7311 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51026 "ad_x86.cpp"
  }
}

void vsub8I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7322 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51044 "ad_x86.cpp"
  }
}

void vsub8I_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7333 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51062 "ad_x86.cpp"
  }
}

void vsub16I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7344 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsubd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51080 "ad_x86.cpp"
  }
}

void vsub16I_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7355 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsubd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51098 "ad_x86.cpp"
  }
}

void vsub2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7367 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psubq(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 51115 "ad_x86.cpp"
  }
}

void vsub2L_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7377 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51133 "ad_x86.cpp"
  }
}

void vsub2L_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7388 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsubq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51151 "ad_x86.cpp"
  }
}

void vsub4L_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7399 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51169 "ad_x86.cpp"
  }
}

void vsub4L_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7410 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsubq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51187 "ad_x86.cpp"
  }
}

void vsub8L_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7421 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsubq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51205 "ad_x86.cpp"
  }
}

void vsub8L_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7432 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsubq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51223 "ad_x86.cpp"
  }
}

void vsub2FNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7444 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ subps(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 51240 "ad_x86.cpp"
  }
}

void vsub2F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7454 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vsubps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51258 "ad_x86.cpp"
  }
}

void vsub2F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7465 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vsubps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51276 "ad_x86.cpp"
  }
}

void vsub4FNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7476 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ subps(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 51293 "ad_x86.cpp"
  }
}

void vsub4F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7486 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vsubps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51311 "ad_x86.cpp"
  }
}

void vsub4F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7497 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vsubps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51329 "ad_x86.cpp"
  }
}

void vsub8F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7508 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vsubps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51347 "ad_x86.cpp"
  }
}

void vsub8F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7519 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vsubps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51365 "ad_x86.cpp"
  }
}

void vsub16F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7530 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vsubps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51383 "ad_x86.cpp"
  }
}

void vsub16F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7541 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vsubps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51401 "ad_x86.cpp"
  }
}

void vsub2DNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7553 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ subpd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 51418 "ad_x86.cpp"
  }
}

void vsub2D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7563 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vsubpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51436 "ad_x86.cpp"
  }
}

void vsub2D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7574 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vsubpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51454 "ad_x86.cpp"
  }
}

void vsub4D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7585 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vsubpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51472 "ad_x86.cpp"
  }
}

void vsub4D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7596 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vsubpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51490 "ad_x86.cpp"
  }
}

void vsub8D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7607 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vsubpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51508 "ad_x86.cpp"
  }
}

void vsub8D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7618 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vsubpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51526 "ad_x86.cpp"
  }
}

void vmul2SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7632 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pmullw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 51543 "ad_x86.cpp"
  }
}

void vmul2S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7642 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51561 "ad_x86.cpp"
  }
}

void vmul2S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7653 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51579 "ad_x86.cpp"
  }
}

void vmul2S_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 7665 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51598 "ad_x86.cpp"
  }
}

void vmul2S_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7676 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51616 "ad_x86.cpp"
  }
}

void vmul2S_mem_avx_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7676 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 51634 "ad_x86.cpp"
  }
}

void vmul2S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7687 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51652 "ad_x86.cpp"
  }
}

void vmul2S_mem_evex_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7687 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 51670 "ad_x86.cpp"
  }
}

void vmul2S_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7699 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51689 "ad_x86.cpp"
  }
}

void vmul2S_mem_evex_special_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7699 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 51708 "ad_x86.cpp"
  }
}

void vmul4SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7710 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pmullw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 51725 "ad_x86.cpp"
  }
}

void vmul4S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7720 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51743 "ad_x86.cpp"
  }
}

void vmul4S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7731 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51761 "ad_x86.cpp"
  }
}

void vmul4S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 7743 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51780 "ad_x86.cpp"
  }
}

void vmul4S_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7754 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51798 "ad_x86.cpp"
  }
}

void vmul4S_mem_avx_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7754 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 51816 "ad_x86.cpp"
  }
}

void vmul4S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7765 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51834 "ad_x86.cpp"
  }
}

void vmul4S_mem_evex_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7765 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 51852 "ad_x86.cpp"
  }
}

void vmul4S_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7777 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51871 "ad_x86.cpp"
  }
}

void vmul4S_mem_evex_special_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7777 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 51890 "ad_x86.cpp"
  }
}

void vmul8SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7788 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pmullw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 51907 "ad_x86.cpp"
  }
}

void vmul8S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7798 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51925 "ad_x86.cpp"
  }
}

void vmul8S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7809 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51943 "ad_x86.cpp"
  }
}

void vmul8S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 7821 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 51962 "ad_x86.cpp"
  }
}

void vmul8S_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7832 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 51980 "ad_x86.cpp"
  }
}

void vmul8S_mem_avx_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7832 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 51998 "ad_x86.cpp"
  }
}

void vmul8S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7843 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52016 "ad_x86.cpp"
  }
}

void vmul8S_mem_evex_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7843 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52034 "ad_x86.cpp"
  }
}

void vmul8S_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7855 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52053 "ad_x86.cpp"
  }
}

void vmul8S_mem_evex_special_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7855 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullw(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52072 "ad_x86.cpp"
  }
}

void vmul16S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7866 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52090 "ad_x86.cpp"
  }
}

void vmul16S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7877 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52108 "ad_x86.cpp"
  }
}

void vmul16S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  {
    MacroAssembler _masm(&cbuf);

#line 7889 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpmullw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52127 "ad_x86.cpp"
  }
}

void vmul16S_mem_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7900 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52145 "ad_x86.cpp"
  }
}

void vmul16S_mem_avx_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7900 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52163 "ad_x86.cpp"
  }
}

void vmul16S_mem_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7911 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52181 "ad_x86.cpp"
  }
}

void vmul16S_mem_evex_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7911 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52199 "ad_x86.cpp"
  }
}

void vmul16S_mem_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7923 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpmullw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52218 "ad_x86.cpp"
  }
}

void vmul16S_mem_evex_special_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// dst
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7923 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpmullw(opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52237 "ad_x86.cpp"
  }
}

void vmul32S_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7934 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52255 "ad_x86.cpp"
  }
}

void vmul32S_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7945 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52273 "ad_x86.cpp"
  }
}

void vmul32S_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7945 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpmullw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52291 "ad_x86.cpp"
  }
}

void vmul2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7957 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pmulld(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 52308 "ad_x86.cpp"
  }
}

void vmul2I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7967 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmulld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52326 "ad_x86.cpp"
  }
}

void vmul2I_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 7978 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmulld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52344 "ad_x86.cpp"
  }
}

void vmul2I_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7978 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmulld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52362 "ad_x86.cpp"
  }
}

void vmul4INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 7989 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pmulld(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 52379 "ad_x86.cpp"
  }
}

void vmul4I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 7999 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmulld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52397 "ad_x86.cpp"
  }
}

void vmul4I_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8010 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmulld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52415 "ad_x86.cpp"
  }
}

void vmul4I_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8010 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmulld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52433 "ad_x86.cpp"
  }
}

void vmul2L_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8021 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52451 "ad_x86.cpp"
  }
}

void vmul2L_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8032 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52469 "ad_x86.cpp"
  }
}

void vmul2L_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8032 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpmullq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52487 "ad_x86.cpp"
  }
}

void vmul4L_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8043 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpmullq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52505 "ad_x86.cpp"
  }
}

void vmul4L_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8054 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpmullq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52523 "ad_x86.cpp"
  }
}

void vmul4L_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8054 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpmullq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52541 "ad_x86.cpp"
  }
}

void vmul8L_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8065 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpmullq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52559 "ad_x86.cpp"
  }
}

void vmul8L_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8076 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpmullq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52577 "ad_x86.cpp"
  }
}

void vmul8L_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8076 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpmullq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52595 "ad_x86.cpp"
  }
}

void vmul8I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8087 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpmulld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52613 "ad_x86.cpp"
  }
}

void vmul8I_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8098 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpmulld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52631 "ad_x86.cpp"
  }
}

void vmul8I_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8098 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpmulld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52649 "ad_x86.cpp"
  }
}

void vmul16I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8109 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpmulld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52667 "ad_x86.cpp"
  }
}

void vmul16I_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8120 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpmulld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52685 "ad_x86.cpp"
  }
}

void vmul16I_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8120 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpmulld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52703 "ad_x86.cpp"
  }
}

void vmul2FNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8132 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ mulps(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 52720 "ad_x86.cpp"
  }
}

void vmul2F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8142 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vmulps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52738 "ad_x86.cpp"
  }
}

void vmul2F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8153 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vmulps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52756 "ad_x86.cpp"
  }
}

void vmul2F_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8153 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vmulps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52774 "ad_x86.cpp"
  }
}

void vmul4FNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8164 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ mulps(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 52791 "ad_x86.cpp"
  }
}

void vmul4F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8174 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vmulps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52809 "ad_x86.cpp"
  }
}

void vmul4F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8185 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vmulps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52827 "ad_x86.cpp"
  }
}

void vmul4F_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8185 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vmulps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52845 "ad_x86.cpp"
  }
}

void vmul8F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8196 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vmulps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52863 "ad_x86.cpp"
  }
}

void vmul8F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8207 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vmulps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52881 "ad_x86.cpp"
  }
}

void vmul8F_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8207 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vmulps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52899 "ad_x86.cpp"
  }
}

void vmul16F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8218 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vmulps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52917 "ad_x86.cpp"
  }
}

void vmul16F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8229 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vmulps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 52935 "ad_x86.cpp"
  }
}

void vmul16F_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8229 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vmulps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 52953 "ad_x86.cpp"
  }
}

void vmul2DNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8241 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ mulpd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 52970 "ad_x86.cpp"
  }
}

void vmul2D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8251 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vmulpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 52988 "ad_x86.cpp"
  }
}

void vmul2D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8262 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vmulpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 53006 "ad_x86.cpp"
  }
}

void vmul2D_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8262 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vmulpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 53024 "ad_x86.cpp"
  }
}

void vmul4D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8273 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vmulpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 53042 "ad_x86.cpp"
  }
}

void vmul4D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8284 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vmulpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 53060 "ad_x86.cpp"
  }
}

void vmul4D_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8284 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vmulpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 53078 "ad_x86.cpp"
  }
}

void vmul8D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8295 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vmulpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 53096 "ad_x86.cpp"
  }
}

void vmul8D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8306 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vmulpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 53114 "ad_x86.cpp"
  }
}

void vmul8D_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8306 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vmulpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 53132 "ad_x86.cpp"
  }
}

void vcmov8F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// copnd
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cop
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// dst
  {
    MacroAssembler _masm(&cbuf);

#line 8320 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    int cond = (Assembler::Condition)(opnd_array(1)->ccode());
    __ cmpps(opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* src2 */, cond, vector_len);
    __ blendvps(opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* src2 */, opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* dst */, vector_len);
  
#line 53155 "ad_x86.cpp"
  }
}

void vcmov4D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// copnd
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// cop
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src1
  unsigned idx4 = idx3 + opnd_array(3)->num_edges(); 	// src2
  unsigned idx5 = idx4 + opnd_array(4)->num_edges(); 	// dst
  {
    MacroAssembler _masm(&cbuf);

#line 8336 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    int cond = (Assembler::Condition)(opnd_array(1)->ccode());
    __ cmppd(opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* src2 */, cond, vector_len);
    __ blendvpd(opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src1 */, opnd_array(4)->as_XMMRegister(ra_,this,idx4)/* src2 */, opnd_array(5)->as_XMMRegister(ra_,this,idx5)/* dst */, vector_len);
  
#line 53178 "ad_x86.cpp"
  }
}

void vdiv2FNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8352 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ divps(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 53195 "ad_x86.cpp"
  }
}

void vdiv2F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8362 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vdivps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 53213 "ad_x86.cpp"
  }
}

void vdiv2F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8373 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vdivps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 53231 "ad_x86.cpp"
  }
}

void vdiv4FNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8384 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ divps(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 53248 "ad_x86.cpp"
  }
}

void vdiv4F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8394 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vdivps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 53266 "ad_x86.cpp"
  }
}

void vdiv4F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8405 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vdivps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 53284 "ad_x86.cpp"
  }
}

void vdiv8F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8416 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vdivps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 53302 "ad_x86.cpp"
  }
}

void vdiv8F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8427 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vdivps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 53320 "ad_x86.cpp"
  }
}

void vdiv16F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8438 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vdivps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 53338 "ad_x86.cpp"
  }
}

void vdiv16F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8449 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vdivps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 53356 "ad_x86.cpp"
  }
}

void vdiv2DNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8461 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ divpd(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 53373 "ad_x86.cpp"
  }
}

void vdiv2D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8471 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vdivpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 53391 "ad_x86.cpp"
  }
}

void vdiv2D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8482 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vdivpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 53409 "ad_x86.cpp"
  }
}

void vdiv4D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8493 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vdivpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 53427 "ad_x86.cpp"
  }
}

void vdiv4D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8504 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vdivpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 53445 "ad_x86.cpp"
  }
}

void vdiv8D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 8515 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vdivpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 53463 "ad_x86.cpp"
  }
}

void vdiv8D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8526 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vdivpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 53481 "ad_x86.cpp"
  }
}

void vshiftcntNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  {
    MacroAssembler _masm(&cbuf);

#line 8541 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* cnt */);
  
#line 53497 "ad_x86.cpp"
  }
}

void vshiftcnt_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// cnt
  {
    MacroAssembler _masm(&cbuf);

#line 8541 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_Register(ra_,this,idx1)/* cnt */);
  
#line 53513 "ad_x86.cpp"
  }
}

void vsqrt2D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8554 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vsqrtpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, vector_len);
  
#line 53530 "ad_x86.cpp"
  }
}

void vsqrt2D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8565 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vsqrtpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 53547 "ad_x86.cpp"
  }
}

void vsqrt4D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8576 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vsqrtpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, vector_len);
  
#line 53564 "ad_x86.cpp"
  }
}

void vsqrt4D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8587 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vsqrtpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 53581 "ad_x86.cpp"
  }
}

void vsqrt8D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8598 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vsqrtpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, vector_len);
  
#line 53598 "ad_x86.cpp"
  }
}

void vsqrt8D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8609 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vsqrtpd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 53615 "ad_x86.cpp"
  }
}

void vsqrt2F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8620 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vsqrtps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, vector_len);
  
#line 53632 "ad_x86.cpp"
  }
}

void vsqrt2F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8631 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vsqrtps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 53649 "ad_x86.cpp"
  }
}

void vsqrt4F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8642 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vsqrtps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, vector_len);
  
#line 53666 "ad_x86.cpp"
  }
}

void vsqrt4F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8653 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vsqrtps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 53683 "ad_x86.cpp"
  }
}

void vsqrt8F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8664 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vsqrtps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, vector_len);
  
#line 53700 "ad_x86.cpp"
  }
}

void vsqrt8F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8675 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vsqrtps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 53717 "ad_x86.cpp"
  }
}

void vsqrt16F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8686 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vsqrtps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, vector_len);
  
#line 53734 "ad_x86.cpp"
  }
}

void vsqrt16F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 8697 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vsqrtps(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 53751 "ad_x86.cpp"
  }
}

void vsll2SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8711 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psllw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 53768 "ad_x86.cpp"
  }
}

void vsll2S_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8721 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psllw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 53785 "ad_x86.cpp"
  }
}

void vsll2S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8731 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 53803 "ad_x86.cpp"
  }
}

void vsll2S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8742 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 53821 "ad_x86.cpp"
  }
}

void vsll2S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8754 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 53840 "ad_x86.cpp"
  }
}

void vsll2S_reg_imm_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8765 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 53858 "ad_x86.cpp"
  }
}

void vsll2S_reg_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8776 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 53876 "ad_x86.cpp"
  }
}

void vsll2S_reg_imm_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8788 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 53895 "ad_x86.cpp"
  }
}

void vsll4SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8799 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psllw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 53912 "ad_x86.cpp"
  }
}

void vsll4S_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8809 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psllw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 53929 "ad_x86.cpp"
  }
}

void vsll4S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8819 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 53947 "ad_x86.cpp"
  }
}

void vsll4S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8830 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 53965 "ad_x86.cpp"
  }
}

void vsll4S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8842 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 53984 "ad_x86.cpp"
  }
}

void vsll4S_reg_imm_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8853 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54002 "ad_x86.cpp"
  }
}

void vsll4S_reg_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8864 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54020 "ad_x86.cpp"
  }
}

void vsll4S_reg_imm_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8876 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54039 "ad_x86.cpp"
  }
}

void vsll8SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8887 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psllw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 54056 "ad_x86.cpp"
  }
}

void vsll8S_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8897 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psllw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 54073 "ad_x86.cpp"
  }
}

void vsll8S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8907 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54091 "ad_x86.cpp"
  }
}

void vsll8S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8918 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54109 "ad_x86.cpp"
  }
}

void vsll8S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8930 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54128 "ad_x86.cpp"
  }
}

void vsll8S_reg_imm_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8941 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54146 "ad_x86.cpp"
  }
}

void vsll8S_reg_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8952 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54164 "ad_x86.cpp"
  }
}

void vsll8S_reg_imm_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8964 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54183 "ad_x86.cpp"
  }
}

void vsll16S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8975 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54201 "ad_x86.cpp"
  }
}

void vsll16S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 8986 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54219 "ad_x86.cpp"
  }
}

void vsll16S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 8998 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsllw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54238 "ad_x86.cpp"
  }
}

void vsll16S_reg_imm_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9009 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54256 "ad_x86.cpp"
  }
}

void vsll16S_reg_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9020 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54274 "ad_x86.cpp"
  }
}

void vsll16S_reg_imm_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9032 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsllw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54293 "ad_x86.cpp"
  }
}

void vsll32S_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9043 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54311 "ad_x86.cpp"
  }
}

void vsll32S_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9054 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsllw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54329 "ad_x86.cpp"
  }
}

void vsll2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9066 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pslld(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 54346 "ad_x86.cpp"
  }
}

void vsll2I_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9076 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pslld(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 54363 "ad_x86.cpp"
  }
}

void vsll2I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9086 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpslld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54381 "ad_x86.cpp"
  }
}

void vsll2I_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9097 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpslld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54399 "ad_x86.cpp"
  }
}

void vsll4INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9108 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pslld(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 54416 "ad_x86.cpp"
  }
}

void vsll4I_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9118 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pslld(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 54433 "ad_x86.cpp"
  }
}

void vsll4I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9128 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpslld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54451 "ad_x86.cpp"
  }
}

void vsll4I_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9139 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpslld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54469 "ad_x86.cpp"
  }
}

void vsll8I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9150 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpslld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54487 "ad_x86.cpp"
  }
}

void vsll8I_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9161 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpslld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54505 "ad_x86.cpp"
  }
}

void vsll16I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9172 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpslld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54523 "ad_x86.cpp"
  }
}

void vsll16I_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9183 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpslld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54541 "ad_x86.cpp"
  }
}

void vsll2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9195 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psllq(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 54558 "ad_x86.cpp"
  }
}

void vsll2L_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9205 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psllq(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 54575 "ad_x86.cpp"
  }
}

void vsll2L_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9215 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54593 "ad_x86.cpp"
  }
}

void vsll2L_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9226 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsllq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54611 "ad_x86.cpp"
  }
}

void vsll4L_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9237 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsllq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54629 "ad_x86.cpp"
  }
}

void vsll4L_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9248 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsllq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54647 "ad_x86.cpp"
  }
}

void vsll8L_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9259 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsllq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54665 "ad_x86.cpp"
  }
}

void vsll8L_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9270 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsllq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54683 "ad_x86.cpp"
  }
}

void vsrl2SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9288 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrlw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 54700 "ad_x86.cpp"
  }
}

void vsrl2S_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9298 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrlw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 54717 "ad_x86.cpp"
  }
}

void vsrl2S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9308 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54735 "ad_x86.cpp"
  }
}

void vsrl2S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9319 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54753 "ad_x86.cpp"
  }
}

void vsrl2S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9331 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54772 "ad_x86.cpp"
  }
}

void vsrl2S_reg_imm_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9342 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54790 "ad_x86.cpp"
  }
}

void vsrl2S_reg_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9353 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54808 "ad_x86.cpp"
  }
}

void vsrl2S_reg_imm_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9365 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54827 "ad_x86.cpp"
  }
}

void vsrl4SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9376 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrlw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 54844 "ad_x86.cpp"
  }
}

void vsrl4S_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9386 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrlw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 54861 "ad_x86.cpp"
  }
}

void vsrl4S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9396 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54879 "ad_x86.cpp"
  }
}

void vsrl4S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9407 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54897 "ad_x86.cpp"
  }
}

void vsrl4S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9419 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 54916 "ad_x86.cpp"
  }
}

void vsrl4S_reg_imm_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9430 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54934 "ad_x86.cpp"
  }
}

void vsrl4S_reg_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9441 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54952 "ad_x86.cpp"
  }
}

void vsrl4S_reg_imm_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9453 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 54971 "ad_x86.cpp"
  }
}

void vsrl8SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9464 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrlw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 54988 "ad_x86.cpp"
  }
}

void vsrl8S_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9474 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrlw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 55005 "ad_x86.cpp"
  }
}

void vsrl8S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9484 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55023 "ad_x86.cpp"
  }
}

void vsrl8S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9495 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55041 "ad_x86.cpp"
  }
}

void vsrl8S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9507 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55060 "ad_x86.cpp"
  }
}

void vsrl8S_reg_imm_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9518 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55078 "ad_x86.cpp"
  }
}

void vsrl8S_reg_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9529 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55096 "ad_x86.cpp"
  }
}

void vsrl8S_reg_imm_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9541 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55115 "ad_x86.cpp"
  }
}

void vsrl16S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9552 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55133 "ad_x86.cpp"
  }
}

void vsrl16S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9563 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55151 "ad_x86.cpp"
  }
}

void vsrl16S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9575 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsrlw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55170 "ad_x86.cpp"
  }
}

void vsrl16S_reg_imm_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9586 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55188 "ad_x86.cpp"
  }
}

void vsrl16S_reg_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9597 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55206 "ad_x86.cpp"
  }
}

void vsrl16S_reg_imm_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9609 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsrlw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55225 "ad_x86.cpp"
  }
}

void vsrl32S_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9620 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55243 "ad_x86.cpp"
  }
}

void vsrl32S_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9631 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsrlw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55261 "ad_x86.cpp"
  }
}

void vsrl2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9643 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrld(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 55278 "ad_x86.cpp"
  }
}

void vsrl2I_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9653 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrld(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 55295 "ad_x86.cpp"
  }
}

void vsrl2I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9663 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55313 "ad_x86.cpp"
  }
}

void vsrl2I_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9674 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55331 "ad_x86.cpp"
  }
}

void vsrl4INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9685 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrld(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 55348 "ad_x86.cpp"
  }
}

void vsrl4I_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9695 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrld(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 55365 "ad_x86.cpp"
  }
}

void vsrl4I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9705 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55383 "ad_x86.cpp"
  }
}

void vsrl4I_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9716 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55401 "ad_x86.cpp"
  }
}

void vsrl8I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9727 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsrld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55419 "ad_x86.cpp"
  }
}

void vsrl8I_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9738 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsrld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55437 "ad_x86.cpp"
  }
}

void vsrl16I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9749 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsrld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55455 "ad_x86.cpp"
  }
}

void vsrl16I_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9760 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsrld(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55473 "ad_x86.cpp"
  }
}

void vsrl2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9772 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrlq(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 55490 "ad_x86.cpp"
  }
}

void vsrl2L_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9782 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrlq(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 55507 "ad_x86.cpp"
  }
}

void vsrl2L_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9792 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55525 "ad_x86.cpp"
  }
}

void vsrl2L_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9803 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrlq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55543 "ad_x86.cpp"
  }
}

void vsrl4L_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9814 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsrlq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55561 "ad_x86.cpp"
  }
}

void vsrl4L_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9825 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsrlq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55579 "ad_x86.cpp"
  }
}

void vsrl8L_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9836 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsrlq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55597 "ad_x86.cpp"
  }
}

void vsrl8L_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9847 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsrlq(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55615 "ad_x86.cpp"
  }
}

void vsra2SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9861 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psraw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 55632 "ad_x86.cpp"
  }
}

void vsra2S_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9871 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psraw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 55649 "ad_x86.cpp"
  }
}

void vsra2S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9881 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55667 "ad_x86.cpp"
  }
}

void vsra2S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9892 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55685 "ad_x86.cpp"
  }
}

void vsra2S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9904 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55704 "ad_x86.cpp"
  }
}

void vsra2S_reg_imm_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9915 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55722 "ad_x86.cpp"
  }
}

void vsra2S_reg_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9926 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55740 "ad_x86.cpp"
  }
}

void vsra2S_reg_imm_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9938 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55759 "ad_x86.cpp"
  }
}

void vsra4SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9949 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psraw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 55776 "ad_x86.cpp"
  }
}

void vsra4S_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9959 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psraw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 55793 "ad_x86.cpp"
  }
}

void vsra4S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9969 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55811 "ad_x86.cpp"
  }
}

void vsra4S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 9980 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55829 "ad_x86.cpp"
  }
}

void vsra4S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 9992 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55848 "ad_x86.cpp"
  }
}

void vsra4S_reg_imm_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10003 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55866 "ad_x86.cpp"
  }
}

void vsra4S_reg_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10014 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55884 "ad_x86.cpp"
  }
}

void vsra4S_reg_imm_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10026 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 55903 "ad_x86.cpp"
  }
}

void vsra8SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10037 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psraw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 55920 "ad_x86.cpp"
  }
}

void vsra8S_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10047 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psraw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 55937 "ad_x86.cpp"
  }
}

void vsra8S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10057 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55955 "ad_x86.cpp"
  }
}

void vsra8S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10068 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55973 "ad_x86.cpp"
  }
}

void vsra8S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10080 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 55992 "ad_x86.cpp"
  }
}

void vsra8S_reg_imm_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10091 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 56010 "ad_x86.cpp"
  }
}

void vsra8S_reg_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10102 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 56028 "ad_x86.cpp"
  }
}

void vsra8S_reg_imm_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10114 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsraw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 56047 "ad_x86.cpp"
  }
}

void vsra16S_reg_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10125 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 56065 "ad_x86.cpp"
  }
}

void vsra16S_reg_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10136 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 56083 "ad_x86.cpp"
  }
}

void vsra16S_reg_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10148 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsraw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 56102 "ad_x86.cpp"
  }
}

void vsra16S_reg_imm_avxNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10159 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 56120 "ad_x86.cpp"
  }
}

void vsra16S_reg_imm_evexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10170 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 56138 "ad_x86.cpp"
  }
}

void vsra16S_reg_imm_evex_specialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10182 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsraw(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 56157 "ad_x86.cpp"
  }
}

void vsra32S_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10193 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 56175 "ad_x86.cpp"
  }
}

void vsra32S_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10204 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsraw(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 56193 "ad_x86.cpp"
  }
}

void vsra2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10216 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrad(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 56210 "ad_x86.cpp"
  }
}

void vsra2I_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10226 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrad(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 56227 "ad_x86.cpp"
  }
}

void vsra2I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10236 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrad(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 56245 "ad_x86.cpp"
  }
}

void vsra2I_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10247 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrad(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 56263 "ad_x86.cpp"
  }
}

void vsra4INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10258 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrad(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */);
  
#line 56280 "ad_x86.cpp"
  }
}

void vsra4I_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10268 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ psrad(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, (int)opnd_array(2)->constant());
  
#line 56297 "ad_x86.cpp"
  }
}

void vsra4I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10278 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrad(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 56315 "ad_x86.cpp"
  }
}

void vsra4I_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10289 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpsrad(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 56333 "ad_x86.cpp"
  }
}

void vsra8I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10300 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsrad(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 56351 "ad_x86.cpp"
  }
}

void vsra8I_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10311 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpsrad(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 56369 "ad_x86.cpp"
  }
}

void vsra16I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10322 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsrad(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* shift */, vector_len);
  
#line 56387 "ad_x86.cpp"
  }
}

void vsra16I_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// shift
  {
    MacroAssembler _masm(&cbuf);

#line 10333 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpsrad(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, (int)opnd_array(2)->constant(), vector_len);
  
#line 56405 "ad_x86.cpp"
  }
}

void vand4BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10349 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pand(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 56422 "ad_x86.cpp"
  }
}

void vand4B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10359 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpand(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 56440 "ad_x86.cpp"
  }
}

void vand4B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 10370 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpand(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 56458 "ad_x86.cpp"
  }
}

void vand4B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10370 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpand(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 56476 "ad_x86.cpp"
  }
}

void vand8BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10381 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pand(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 56493 "ad_x86.cpp"
  }
}

void vand8B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10391 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpand(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 56511 "ad_x86.cpp"
  }
}

void vand8B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 10402 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpand(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 56529 "ad_x86.cpp"
  }
}

void vand8B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10402 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpand(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 56547 "ad_x86.cpp"
  }
}

void vand16BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10413 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pand(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 56564 "ad_x86.cpp"
  }
}

void vand16B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10423 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpand(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 56582 "ad_x86.cpp"
  }
}

void vand16B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 10434 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpand(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 56600 "ad_x86.cpp"
  }
}

void vand16B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10434 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpand(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 56618 "ad_x86.cpp"
  }
}

void vand32B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10445 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpand(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 56636 "ad_x86.cpp"
  }
}

void vand32B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 10456 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpand(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 56654 "ad_x86.cpp"
  }
}

void vand32B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10456 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpand(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 56672 "ad_x86.cpp"
  }
}

void vand64B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10467 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpand(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 56690 "ad_x86.cpp"
  }
}

void vand64B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 10478 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpand(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 56708 "ad_x86.cpp"
  }
}

void vand64B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10478 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpand(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 56726 "ad_x86.cpp"
  }
}

void vor4BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10491 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ por(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 56743 "ad_x86.cpp"
  }
}

void vor4B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10501 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 56761 "ad_x86.cpp"
  }
}

void vor4B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 10512 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 56779 "ad_x86.cpp"
  }
}

void vor4B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10512 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 56797 "ad_x86.cpp"
  }
}

void vor8BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10523 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ por(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 56814 "ad_x86.cpp"
  }
}

void vor8B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10533 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 56832 "ad_x86.cpp"
  }
}

void vor8B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 10544 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 56850 "ad_x86.cpp"
  }
}

void vor8B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10544 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 56868 "ad_x86.cpp"
  }
}

void vor16BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10555 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ por(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 56885 "ad_x86.cpp"
  }
}

void vor16B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10565 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 56903 "ad_x86.cpp"
  }
}

void vor16B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 10576 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 56921 "ad_x86.cpp"
  }
}

void vor16B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10576 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 56939 "ad_x86.cpp"
  }
}

void vor32B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10587 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 56957 "ad_x86.cpp"
  }
}

void vor32B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 10598 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 56975 "ad_x86.cpp"
  }
}

void vor32B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10598 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 56993 "ad_x86.cpp"
  }
}

void vor64B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10609 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 57011 "ad_x86.cpp"
  }
}

void vor64B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 10620 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 57029 "ad_x86.cpp"
  }
}

void vor64B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10620 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 57047 "ad_x86.cpp"
  }
}

void vxor4BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10633 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pxor(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 57064 "ad_x86.cpp"
  }
}

void vxor4B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10643 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 57082 "ad_x86.cpp"
  }
}

void vxor4B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 10654 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 57100 "ad_x86.cpp"
  }
}

void vxor4B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10654 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 57118 "ad_x86.cpp"
  }
}

void vxor8BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10665 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pxor(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 57135 "ad_x86.cpp"
  }
}

void vxor8B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10675 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 57153 "ad_x86.cpp"
  }
}

void vxor8B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 10686 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 57171 "ad_x86.cpp"
  }
}

void vxor8B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10686 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 57189 "ad_x86.cpp"
  }
}

void vxor16BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// dst
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10697 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    __ pxor(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */);
  
#line 57206 "ad_x86.cpp"
  }
}

void vxor16B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10707 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 57224 "ad_x86.cpp"
  }
}

void vxor16B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 10718 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 57242 "ad_x86.cpp"
  }
}

void vxor16B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10718 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 57260 "ad_x86.cpp"
  }
}

void vxor32B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10729 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 57278 "ad_x86.cpp"
  }
}

void vxor32B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 10740 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 57296 "ad_x86.cpp"
  }
}

void vxor32B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10740 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 57314 "ad_x86.cpp"
  }
}

void vxor64B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src1
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src2
  {
    MacroAssembler _masm(&cbuf);

#line 10751 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src1 */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src2 */, vector_len);
  
#line 57332 "ad_x86.cpp"
  }
}

void vxor64B_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// src
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// mem
  {
    MacroAssembler _masm(&cbuf);

#line 10762 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_reloc()), vector_len);
  
#line 57350 "ad_x86.cpp"
  }
}

void vxor64B_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// mem
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10762 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpxor(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* src */, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_reloc()), vector_len);
  
#line 57368 "ad_x86.cpp"
  }
}

void vfma2D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// c
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// a
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// b
  {
    MacroAssembler _masm(&cbuf);

#line 10777 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vfmad(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* a */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* b */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, vector_len);
  
#line 57387 "ad_x86.cpp"
  }
}

void vfma2D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// c
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// a
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// b
  {
    MacroAssembler _masm(&cbuf);

#line 10790 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vfmad(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* a */, Address::make_raw(opnd_array(3)->base(ra_,this,idx3), opnd_array(3)->index(ra_,this,idx3), opnd_array(3)->scale(), opnd_array(3)->disp(ra_,this,idx3), opnd_array(3)->disp_reloc()), opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, vector_len);
  
#line 57406 "ad_x86.cpp"
  }
}

void vfma4D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// c
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// a
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// b
  {
    MacroAssembler _masm(&cbuf);

#line 10804 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vfmad(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* a */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* b */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, vector_len);
  
#line 57425 "ad_x86.cpp"
  }
}

void vfma4D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// c
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// a
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// b
  {
    MacroAssembler _masm(&cbuf);

#line 10817 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vfmad(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* a */, Address::make_raw(opnd_array(3)->base(ra_,this,idx3), opnd_array(3)->index(ra_,this,idx3), opnd_array(3)->scale(), opnd_array(3)->disp(ra_,this,idx3), opnd_array(3)->disp_reloc()), opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, vector_len);
  
#line 57444 "ad_x86.cpp"
  }
}

void vfma8D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// c
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// a
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// b
  {
    MacroAssembler _masm(&cbuf);

#line 10830 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vfmad(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* a */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* b */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, vector_len);
  
#line 57463 "ad_x86.cpp"
  }
}

void vfma8D_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// c
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// a
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// b
  {
    MacroAssembler _masm(&cbuf);

#line 10843 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vfmad(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* a */, Address::make_raw(opnd_array(3)->base(ra_,this,idx3), opnd_array(3)->index(ra_,this,idx3), opnd_array(3)->scale(), opnd_array(3)->disp(ra_,this,idx3), opnd_array(3)->disp_reloc()), opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, vector_len);
  
#line 57482 "ad_x86.cpp"
  }
}

void vfma4F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// c
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// a
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// b
  {
    MacroAssembler _masm(&cbuf);

#line 10856 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vfmaf(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* a */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* b */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, vector_len);
  
#line 57501 "ad_x86.cpp"
  }
}

void vfma4F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// c
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// a
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// b
  {
    MacroAssembler _masm(&cbuf);

#line 10869 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vfmaf(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* a */, Address::make_raw(opnd_array(3)->base(ra_,this,idx3), opnd_array(3)->index(ra_,this,idx3), opnd_array(3)->scale(), opnd_array(3)->disp(ra_,this,idx3), opnd_array(3)->disp_reloc()), opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, vector_len);
  
#line 57520 "ad_x86.cpp"
  }
}

void vfma8F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// c
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// a
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// b
  {
    MacroAssembler _masm(&cbuf);

#line 10882 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vfmaf(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* a */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* b */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, vector_len);
  
#line 57539 "ad_x86.cpp"
  }
}

void vfma8F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// c
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// a
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// b
  {
    MacroAssembler _masm(&cbuf);

#line 10895 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vfmaf(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* a */, Address::make_raw(opnd_array(3)->base(ra_,this,idx3), opnd_array(3)->index(ra_,this,idx3), opnd_array(3)->scale(), opnd_array(3)->disp(ra_,this,idx3), opnd_array(3)->disp_reloc()), opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, vector_len);
  
#line 57558 "ad_x86.cpp"
  }
}

void vfma16F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// c
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// a
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// b
  {
    MacroAssembler _masm(&cbuf);

#line 10908 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vfmaf(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* a */, opnd_array(3)->as_XMMRegister(ra_,this,idx3)/* b */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, vector_len);
  
#line 57577 "ad_x86.cpp"
  }
}

void vfma16F_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 2;
  unsigned idx1 = 2; 	// c
  unsigned idx2 = idx1 + opnd_array(1)->num_edges(); 	// a
  unsigned idx3 = idx2 + opnd_array(2)->num_edges(); 	// b
  {
    MacroAssembler _masm(&cbuf);

#line 10921 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vfmaf(opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, opnd_array(2)->as_XMMRegister(ra_,this,idx2)/* a */, Address::make_raw(opnd_array(3)->base(ra_,this,idx3), opnd_array(3)->index(ra_,this,idx3), opnd_array(3)->scale(), opnd_array(3)->disp(ra_,this,idx3), opnd_array(3)->disp_reloc()), opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* c */, vector_len);
  
#line 57596 "ad_x86.cpp"
  }
}

void vpopcount2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10934 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpopcntd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, vector_len);
  
#line 57613 "ad_x86.cpp"
  }
}

void vpopcount4INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10945 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 0;
    __ vpopcntd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, vector_len);
  
#line 57630 "ad_x86.cpp"
  }
}

void vpopcount8INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10956 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 1;
    __ vpopcntd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, vector_len);
  
#line 57647 "ad_x86.cpp"
  }
}

void vpopcount16INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  // Start at oper_input_base() and count operands
  unsigned idx0 = 1;
  unsigned idx1 = 1; 	// src
  {
    MacroAssembler _masm(&cbuf);

#line 10967 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86.ad"

    int vector_len = 2;
    __ vpopcntd(opnd_array(0)->as_XMMRegister(ra_,this)/* dst */, opnd_array(1)->as_XMMRegister(ra_,this,idx1)/* src */, vector_len);
  
#line 57664 "ad_x86.cpp"
  }
}

const MachOper* loadBNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadB2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUBNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUB2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUB2L_immINode::memory_operand() const { return _opnds[1]; }
const MachOper* loadSNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadS2BNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadS2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUSNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUS2BNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUS2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUS2L_immI_255Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadUS2L_immINode::memory_operand() const { return _opnds[1]; }
const MachOper* loadINode::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2BNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2UBNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2SNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2USNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2L_immI_255Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2L_immI_65535Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2L_immU31Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadUI2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadLNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadRangeNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadPNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadNNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadKlassNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadNKlassNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadFNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadD_partialNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadDNode::memory_operand() const { return _opnds[1]; }
const MachOper* prefetchAllocNode::memory_operand() const { return _opnds[1]; }
const MachOper* prefetchAllocNTANode::memory_operand() const { return _opnds[1]; }
const MachOper* prefetchAllocT0Node::memory_operand() const { return _opnds[1]; }
const MachOper* prefetchAllocT2Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeBNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeCNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeINode::memory_operand() const { return _opnds[1]; }
const MachOper* storeLNode::memory_operand() const { return _opnds[1]; }
const MachOper* storePNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmP0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmPNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeNNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeNKlassNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmN0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmNNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmNKlassNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmI0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmINode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmL0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmLNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmC0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmI16Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmB0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmBNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmCM0_regNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmCM0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeFNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeF0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeF_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeDNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeD0_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeD0Node::memory_operand() const { return _opnds[1]; }
const MachOper* popCountI_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* popCountL_memNode::memory_operand() const { return _opnds[1]; }
const TypePtr *membar_acquireNode::adr_type() const { return TypePtr::BOTTOM; }
const MachOper* membar_acquireNode::memory_operand() const { return (MachOper*)-1; }
const TypePtr *membar_acquire_0Node::adr_type() const { return TypePtr::BOTTOM; }
const MachOper* membar_acquire_0Node::memory_operand() const { return (MachOper*)-1; }
const TypePtr *membar_acquire_lockNode::adr_type() const { return TypePtr::BOTTOM; }
const MachOper* membar_acquire_lockNode::memory_operand() const { return (MachOper*)-1; }
const TypePtr *membar_releaseNode::adr_type() const { return TypePtr::BOTTOM; }
const MachOper* membar_releaseNode::memory_operand() const { return (MachOper*)-1; }
const TypePtr *membar_release_0Node::adr_type() const { return TypePtr::BOTTOM; }
const MachOper* membar_release_0Node::memory_operand() const { return (MachOper*)-1; }
const TypePtr *membar_release_lockNode::adr_type() const { return TypePtr::BOTTOM; }
const MachOper* membar_release_lockNode::memory_operand() const { return (MachOper*)-1; }
const TypePtr *membar_volatileNode::adr_type() const { return TypePtr::BOTTOM; }
const MachOper* membar_volatileNode::memory_operand() const { return (MachOper*)-1; }
const TypePtr *unnecessary_membar_volatileNode::adr_type() const { return TypePtr::BOTTOM; }
const MachOper* unnecessary_membar_volatileNode::memory_operand() const { return (MachOper*)-1; }
const TypePtr *membar_storestoreNode::adr_type() const { return TypePtr::BOTTOM; }
const MachOper* membar_storestoreNode::memory_operand() const { return (MachOper*)-1; }
const MachOper* cmovI_memNode::memory_operand() const { return _opnds[4]; }
const MachOper* cmovI_memUNode::memory_operand() const { return _opnds[4]; }
const MachOper* cmovI_memUCFNode::memory_operand() const { return _opnds[4]; }
const MachOper* cmovL_memNode::memory_operand() const { return _opnds[4]; }
const MachOper* cmovL_memUNode::memory_operand() const { return _opnds[4]; }
const MachOper* cmovL_memUCFNode::memory_operand() const { return _opnds[4]; }
const MachOper* addI_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* addI_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* addI_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* addI_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* addI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* incI_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* decI_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* addL_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* addL_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* addL_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* addL_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* addL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* incL_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* decL_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadPLockedNode::memory_operand() const { return _opnds[1]; }
const MachOper* storePConditionalNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeIConditionalNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeLConditionalNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapPNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapP_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapLNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapL_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapINode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapI_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapBNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapB_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapSNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapS_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapNNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapN_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeBNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeSNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeINode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeLNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangeNNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndExchangePNode::memory_operand() const { return _opnds[1]; }
const MachOper* xaddB_no_resNode::memory_operand() const { return _opnds[1]; }
const MachOper* xaddBNode::memory_operand() const { return _opnds[1]; }
const MachOper* xaddS_no_resNode::memory_operand() const { return _opnds[1]; }
const MachOper* xaddSNode::memory_operand() const { return _opnds[1]; }
const MachOper* xaddI_no_resNode::memory_operand() const { return _opnds[1]; }
const MachOper* xaddINode::memory_operand() const { return _opnds[1]; }
const MachOper* xaddL_no_resNode::memory_operand() const { return _opnds[1]; }
const MachOper* xaddLNode::memory_operand() const { return _opnds[1]; }
const MachOper* xchgBNode::memory_operand() const { return _opnds[1]; }
const MachOper* xchgSNode::memory_operand() const { return _opnds[1]; }
const MachOper* xchgINode::memory_operand() const { return _opnds[1]; }
const MachOper* xchgLNode::memory_operand() const { return _opnds[1]; }
const MachOper* xchgPNode::memory_operand() const { return _opnds[1]; }
const MachOper* xchgNNode::memory_operand() const { return _opnds[1]; }
const MachOper* subI_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* subI_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* subI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* subL_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* subL_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* subL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* negI_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* negL_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* mulI_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* mulI_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* mulI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* mulL_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* mulL_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* mulL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* salI_mem_1Node::memory_operand() const { return _opnds[1]; }
const MachOper* salI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* salI_mem_CLNode::memory_operand() const { return _opnds[1]; }
const MachOper* sarI_mem_1Node::memory_operand() const { return _opnds[1]; }
const MachOper* sarI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* sarI_mem_CLNode::memory_operand() const { return _opnds[1]; }
const MachOper* shrI_mem_1Node::memory_operand() const { return _opnds[1]; }
const MachOper* shrI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* shrI_mem_CLNode::memory_operand() const { return _opnds[1]; }
const MachOper* salL_mem_1Node::memory_operand() const { return _opnds[1]; }
const MachOper* salL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* salL_mem_CLNode::memory_operand() const { return _opnds[1]; }
const MachOper* sarL_mem_1Node::memory_operand() const { return _opnds[1]; }
const MachOper* sarL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* sarL_mem_CLNode::memory_operand() const { return _opnds[1]; }
const MachOper* shrL_mem_1Node::memory_operand() const { return _opnds[1]; }
const MachOper* shrL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* shrL_mem_CLNode::memory_operand() const { return _opnds[1]; }
const MachOper* andI_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* andI_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* andI_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* andI_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* andI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* andnI_rReg_rReg_memNode::memory_operand() const { return _opnds[3]; }
const MachOper* andnI_rReg_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* blsiI_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* blsiI_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* blsmskI_rReg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* blsmskI_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* blsrI_rReg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* blsrI_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* orI_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* orI_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* orI_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* orI_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* orI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* xorI_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* xorI_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* xorI_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* xorI_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* xorI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* andL_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* andL_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* andL_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* andL_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* andL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* andnL_rReg_rReg_memNode::memory_operand() const { return _opnds[3]; }
const MachOper* andnL_rReg_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* blsiL_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* blsiL_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* blsmskL_rReg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* blsmskL_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* blsrL_rReg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* blsrL_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* orL_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* orL_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* orL_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* orL_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* orL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* xorL_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* xorL_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* xorL_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* xorL_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* xorL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* cmpF_cc_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* cmpF_cc_memCFNode::memory_operand() const { return _opnds[2]; }
const MachOper* cmpD_cc_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* cmpD_cc_memCFNode::memory_operand() const { return _opnds[2]; }
const MachOper* cmpF_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* cmpD_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* convF2D_reg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* convD2F_reg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* convI2F_reg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* convI2D_reg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* convL2F_reg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* convL2D_reg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* convI2L_reg_mem_zexNode::memory_operand() const { return _opnds[1]; }
const MachOper* compI_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* testI_reg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* testI_reg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* compU_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* compP_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* compP_mem_rRegNode::memory_operand() const { return _opnds[2]; }
const MachOper* testP_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* testP_mem_reg0Node::memory_operand() const { return _opnds[1]; }
const MachOper* compN_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* compN_mem_immNode::memory_operand() const { return _opnds[2]; }
const MachOper* compN_mem_imm_klassNode::memory_operand() const { return _opnds[2]; }
const MachOper* testN_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* testN_mem_reg0Node::memory_operand() const { return _opnds[1]; }
const MachOper* compL_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* testL_reg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* testL_reg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* testL_reg_mem2Node::memory_operand() const { return _opnds[2]; }
const MachOper* testL_reg_mem2_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* compUL_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* compB_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* testB_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadBarrierSlowRegNoVecNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadBarrierSlowRegXmmAndYmmNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadBarrierSlowRegZmmNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadBarrierWeakSlowRegNoVecNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadBarrierWeakSlowRegXmmAndYmmNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadBarrierWeakSlowRegZmmNode::memory_operand() const { return _opnds[1]; }
const MachOper* addF_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* addF_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* addF_reg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* addF_reg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* addD_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* addD_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* addD_reg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* addD_reg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* subF_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* subF_reg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* subD_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* subD_reg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* mulF_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* mulF_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* mulF_reg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* mulF_reg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* mulD_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* mulD_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* mulD_reg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* mulD_reg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* divF_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* divF_reg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* divD_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* divD_reg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* sqrtF_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* sqrtD_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadV4Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadV8Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadV16Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadV32Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadV64_dwordNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadV64_qwordNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeV4Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeV8Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeV16Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeV32Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeV64_dwordNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeV64_qwordNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl4B_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl8B_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl16B_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl32B_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl4S_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl8S_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl16S_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl4I_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl8I_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl2L_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl4L_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl2F_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl4F_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl8F_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl2D_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl4D_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl2I_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl4B_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl8B_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl16B_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl32B_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl64B_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl4S_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl8S_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl16S_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl32S_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl4I_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl8I_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl16I_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl2L_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl4L_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl8L_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl8F_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl16F_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl4D_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* Repl8D_mem_evexNode::memory_operand() const { return _opnds[1]; }
const MachOper* vadd4B_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd4B_mem_avx_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd4B_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd4B_mem_evex_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd4B_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd4B_mem_evex_special_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd8B_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd8B_mem_avx_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd8B_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd8B_mem_evex_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd8B_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd8B_mem_evex_special_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd16B_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd16B_mem_avx_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd16B_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd16B_mem_evex_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd16B_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd16B_mem_evex_special_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd32B_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd32B_mem_avx_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd32B_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd32B_mem_evex_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd32B_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd32B_mem_evex_special_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd64B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd64B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd2S_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd2S_mem_avx_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd2S_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd2S_mem_evex_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd2S_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd2S_mem_evex_special_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd4S_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd4S_mem_avx_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd4S_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd4S_mem_evex_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd4S_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd4S_mem_evex_special_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd8S_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd8S_mem_avx_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd8S_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd8S_mem_evex_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd8S_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd8S_mem_evex_special_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd16S_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd16S_mem_avx_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd16S_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd16S_mem_evex_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd16S_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd16S_mem_evex_special_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd32S_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd32S_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd2I_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd2I_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd4I_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd4I_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd8I_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd8I_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd16I_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd16I_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd2L_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd2L_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd4L_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd4L_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd8L_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd8L_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd2F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd2F_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd4F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd4F_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd8F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd8F_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd16F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd16F_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd2D_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd2D_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd4D_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd4D_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vadd8D_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vadd8D_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vsub4B_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub4B_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub4B_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub8B_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub8B_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub8B_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub16B_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub16B_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub16B_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub32B_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub32B_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub32B_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub64B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub2S_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub2S_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub2S_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub4S_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub4S_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub4S_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub8S_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub8S_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub8S_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub16S_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub16S_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub16S_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub32S_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub2I_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub4I_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub8I_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub16I_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub2L_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub4L_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub8L_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub2F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub4F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub8F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub16F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub2D_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub4D_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsub8D_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul2S_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul2S_mem_avx_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul2S_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul2S_mem_evex_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul2S_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul2S_mem_evex_special_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul4S_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul4S_mem_avx_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul4S_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul4S_mem_evex_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul4S_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul4S_mem_evex_special_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul8S_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul8S_mem_avx_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul8S_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul8S_mem_evex_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul8S_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul8S_mem_evex_special_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul16S_mem_avxNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul16S_mem_avx_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul16S_mem_evexNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul16S_mem_evex_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul16S_mem_evex_specialNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul16S_mem_evex_special_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul32S_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul32S_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul2I_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul2I_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul4I_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul4I_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul2L_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul2L_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul4L_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul4L_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul8L_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul8L_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul8I_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul8I_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul16I_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul16I_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul2F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul2F_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul4F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul4F_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul8F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul8F_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul16F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul16F_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul2D_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul2D_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul4D_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul4D_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vmul8D_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vmul8D_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vdiv2F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vdiv4F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vdiv8F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vdiv16F_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vdiv2D_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vdiv4D_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vdiv8D_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vsqrt2D_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* vsqrt4D_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* vsqrt8D_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* vsqrt2F_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* vsqrt4F_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* vsqrt8F_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* vsqrt16F_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* vand4B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vand4B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vand8B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vand8B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vand16B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vand16B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vand32B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vand32B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vand64B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vand64B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vor4B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vor4B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vor8B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vor8B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vor16B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vor16B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vor32B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vor32B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vor64B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vor64B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vxor4B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vxor4B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vxor8B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vxor8B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vxor16B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vxor16B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vxor32B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vxor32B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vxor64B_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* vxor64B_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* vfma2D_memNode::memory_operand() const { return _opnds[3]; }
const MachOper* vfma4D_memNode::memory_operand() const { return _opnds[3]; }
const MachOper* vfma8D_memNode::memory_operand() const { return _opnds[3]; }
const MachOper* vfma4F_memNode::memory_operand() const { return _opnds[3]; }
const MachOper* vfma8F_memNode::memory_operand() const { return _opnds[3]; }
const MachOper* vfma16F_memNode::memory_operand() const { return _opnds[3]; }


const bool Matcher::has_match_rule(int opcode) {
  assert(_last_machine_leaf < opcode && opcode < _last_opcode, "opcode in range");
  return _hasMatchRule[opcode];
}

const bool Matcher::_hasMatchRule[_last_opcode] = {
    false,  // Node
    false,  // Set
    false,  // RegN
    false,  // RegI
    false,  // RegP
    false,  // RegF
    false,  // RegD
    false,  // RegL
    false,  // RegFlags
    false,  // VecS
    false,  // VecD
    false,  // VecX
    false,  // VecY
    false,  // VecZ
    false,  // _last_machine_leaf
    true ,  // AbsD
    true ,  // AbsF
    false,  // AbsI
    true ,  // AddD
    true ,  // AddF
    true ,  // AddI
    true ,  // AddL
    true ,  // AddP
    false,  // Allocate
    false,  // AllocateArray
    true ,  // AndI
    true ,  // AndL
    false,  // ArrayCopy
    true ,  // AryEq
    false,  // AtanD
    true ,  // Binary
    true ,  // Bool
    false,  // BoxLock
    true ,  // ReverseBytesI
    true ,  // ReverseBytesL
    true ,  // ReverseBytesUS
    true ,  // ReverseBytesS
    false,  // CProj
    true ,  // CallDynamicJava
    false,  // CallJava
    true ,  // CallLeaf
    true ,  // CallLeafNoFP
    true ,  // CallRuntime
    true ,  // CallStaticJava
    true ,  // CastII
    true ,  // CastX2P
    true ,  // CastP2X
    true ,  // CastPP
    false,  // Catch
    false,  // CatchProj
    true ,  // CheckCastPP
    true ,  // ClearArray
    false,  // ConstraintCast
    true ,  // CMoveD
    true ,  // CMoveVD
    true ,  // CMoveF
    true ,  // CMoveVF
    true ,  // CMoveI
    true ,  // CMoveL
    true ,  // CMoveP
    true ,  // CMoveN
    true ,  // CmpN
    true ,  // CmpD
    true ,  // CmpD3
    true ,  // CmpF
    true ,  // CmpF3
    true ,  // CmpI
    true ,  // CmpL
    true ,  // CmpL3
    true ,  // CmpLTMask
    true ,  // CmpP
    true ,  // CmpU
    true ,  // CmpUL
    true ,  // CompareAndSwapB
    true ,  // CompareAndSwapS
    true ,  // CompareAndSwapI
    true ,  // CompareAndSwapL
    true ,  // CompareAndSwapP
    true ,  // CompareAndSwapN
    true ,  // WeakCompareAndSwapB
    true ,  // WeakCompareAndSwapS
    true ,  // WeakCompareAndSwapI
    true ,  // WeakCompareAndSwapL
    true ,  // WeakCompareAndSwapP
    true ,  // WeakCompareAndSwapN
    true ,  // CompareAndExchangeB
    true ,  // CompareAndExchangeS
    true ,  // CompareAndExchangeI
    true ,  // CompareAndExchangeL
    true ,  // CompareAndExchangeP
    true ,  // CompareAndExchangeN
    true ,  // GetAndAddB
    true ,  // GetAndAddS
    true ,  // GetAndAddI
    true ,  // GetAndAddL
    true ,  // GetAndSetB
    true ,  // GetAndSetS
    true ,  // GetAndSetI
    true ,  // GetAndSetL
    true ,  // GetAndSetP
    true ,  // GetAndSetN
    false,  // Con
    true ,  // ConN
    true ,  // ConNKlass
    true ,  // ConD
    true ,  // ConF
    true ,  // ConI
    true ,  // ConL
    true ,  // ConP
    true ,  // Conv2B
    true ,  // ConvD2F
    true ,  // ConvD2I
    true ,  // ConvD2L
    true ,  // ConvF2D
    true ,  // ConvF2I
    true ,  // ConvF2L
    true ,  // ConvI2D
    true ,  // ConvI2F
    true ,  // ConvI2L
    true ,  // ConvL2D
    true ,  // ConvL2F
    true ,  // ConvL2I
    false,  // CountedLoop
    true ,  // CountedLoopEnd
    false,  // OuterStripMinedLoop
    false,  // OuterStripMinedLoopEnd
    true ,  // CountLeadingZerosI
    true ,  // CountLeadingZerosL
    true ,  // CountTrailingZerosI
    true ,  // CountTrailingZerosL
    true ,  // CreateEx
    true ,  // DecodeN
    true ,  // DecodeNKlass
    true ,  // DivD
    true ,  // DivF
    true ,  // DivI
    true ,  // DivL
    false,  // DivMod
    true ,  // DivModI
    true ,  // DivModL
    true ,  // EncodeISOArray
    true ,  // EncodeP
    true ,  // EncodePKlass
    true ,  // FastLock
    true ,  // FastUnlock
    true ,  // FmaD
    true ,  // FmaF
    true ,  // Goto
    true ,  // Halt
    true ,  // HasNegatives
    true ,  // If
    false,  // RangeCheck
    false,  // IfFalse
    false,  // IfTrue
    false,  // Initialize
    false,  // JProj
    true ,  // Jump
    false,  // JumpProj
    true ,  // LShiftI
    true ,  // LShiftL
    true ,  // LoadB
    true ,  // LoadUB
    true ,  // LoadUS
    true ,  // LoadD
    false,  // LoadD_unaligned
    true ,  // LoadF
    true ,  // LoadI
    true ,  // LoadKlass
    true ,  // LoadNKlass
    true ,  // LoadL
    false,  // LoadL_unaligned
    true ,  // LoadPLocked
    true ,  // LoadP
    true ,  // LoadN
    true ,  // LoadRange
    true ,  // LoadS
    false,  // LoadBarrier
    true ,  // LoadBarrierSlowReg
    true ,  // LoadBarrierWeakSlowReg
    false,  // Lock
    false,  // Loop
    false,  // LoopLimit
    false,  // Mach
    false,  // MachProj
    true ,  // MaxI
    true ,  // MemBarAcquire
    true ,  // LoadFence
    true ,  // SetVectMaskI
    true ,  // MemBarAcquireLock
    false,  // MemBarCPUOrder
    true ,  // MemBarRelease
    true ,  // StoreFence
    true ,  // MemBarReleaseLock
    true ,  // MemBarVolatile
    true ,  // MemBarStoreStore
    false,  // MergeMem
    true ,  // MinI
    false,  // ModD
    false,  // ModF
    true ,  // ModI
    true ,  // ModL
    true ,  // MoveI2F
    true ,  // MoveF2I
    true ,  // MoveL2D
    true ,  // MoveD2L
    true ,  // MulD
    true ,  // MulF
    true ,  // MulHiL
    true ,  // MulI
    true ,  // MulL
    false,  // Multi
    true ,  // NegD
    true ,  // NegF
    false,  // NeverBranch
    true ,  // OnSpinWait
    false,  // Opaque1
    false,  // Opaque2
    false,  // Opaque3
    false,  // Opaque4
    false,  // ProfileBoolean
    true ,  // OrI
    true ,  // OrL
    true ,  // OverflowAddI
    true ,  // OverflowSubI
    true ,  // OverflowMulI
    true ,  // OverflowAddL
    true ,  // OverflowSubL
    true ,  // OverflowMulL
    false,  // PCTable
    false,  // Parm
    true ,  // PartialSubtypeCheck
    false,  // Phi
    true ,  // PopCountI
    true ,  // PopCountL
    true ,  // PopCountVI
    true ,  // PrefetchAllocation
    false,  // Proj
    true ,  // RShiftI
    true ,  // RShiftL
    false,  // Region
    true ,  // Rethrow
    true ,  // Return
    false,  // Root
    true ,  // RoundDouble
    true ,  // RoundFloat
    true ,  // SafePoint
    false,  // SafePointScalarObject
    false,  // SCMemProj
    true ,  // SqrtD
    true ,  // SqrtF
    false,  // Start
    false,  // StartOSR
    true ,  // StoreB
    true ,  // StoreC
    true ,  // StoreCM
    true ,  // StorePConditional
    true ,  // StoreIConditional
    true ,  // StoreLConditional
    true ,  // StoreD
    true ,  // StoreF
    true ,  // StoreI
    true ,  // StoreL
    true ,  // StoreP
    true ,  // StoreN
    true ,  // StoreNKlass
    true ,  // StrComp
    true ,  // StrCompressedCopy
    true ,  // StrEquals
    true ,  // StrIndexOf
    true ,  // StrIndexOfChar
    true ,  // StrInflatedCopy
    true ,  // SubD
    true ,  // SubF
    true ,  // SubI
    true ,  // SubL
    true ,  // TailCall
    true ,  // TailJump
    true ,  // ThreadLocal
    false,  // Unlock
    true ,  // URShiftI
    true ,  // URShiftL
    true ,  // XorI
    true ,  // XorL
    false,  // Vector
    true ,  // AddVB
    true ,  // AddVS
    true ,  // AddVI
    true ,  // AddReductionVI
    true ,  // AddVL
    true ,  // AddReductionVL
    true ,  // AddVF
    true ,  // AddReductionVF
    true ,  // AddVD
    true ,  // AddReductionVD
    true ,  // SubVB
    true ,  // SubVS
    true ,  // SubVI
    true ,  // SubVL
    true ,  // SubVF
    true ,  // SubVD
    true ,  // MulVS
    true ,  // MulVI
    true ,  // MulReductionVI
    true ,  // MulVL
    true ,  // MulReductionVL
    true ,  // MulVF
    true ,  // MulReductionVF
    true ,  // MulVD
    true ,  // MulReductionVD
    true ,  // FmaVD
    true ,  // FmaVF
    true ,  // DivVF
    true ,  // DivVD
    false,  // AbsVF
    false,  // AbsVD
    false,  // NegVF
    false,  // NegVD
    true ,  // SqrtVD
    true ,  // SqrtVF
    true ,  // LShiftCntV
    true ,  // RShiftCntV
    false,  // LShiftVB
    true ,  // LShiftVS
    true ,  // LShiftVI
    true ,  // LShiftVL
    false,  // RShiftVB
    true ,  // RShiftVS
    true ,  // RShiftVI
    false,  // RShiftVL
    false,  // URShiftVB
    true ,  // URShiftVS
    true ,  // URShiftVI
    true ,  // URShiftVL
    true ,  // AndV
    true ,  // OrV
    true ,  // XorV
    true ,  // LoadVector
    true ,  // StoreVector
    false,  // Pack
    false,  // PackB
    false,  // PackS
    false,  // PackI
    false,  // PackL
    false,  // PackF
    false,  // PackD
    false,  // Pack2L
    false,  // Pack2D
    true ,  // ReplicateB
    true ,  // ReplicateS
    true ,  // ReplicateI
    true ,  // ReplicateL
    true ,  // ReplicateF
    true ,  // ReplicateD
    false,  // Extract
    false,  // ExtractB
    false,  // ExtractUB
    false,  // ExtractC
    false,  // ExtractS
    false,  // ExtractI
    false,  // ExtractL
    false,  // ExtractF
    false   // ExtractD
};


bool Matcher::stack_direction() const { return false; }

int Compile::sync_stack_slots() const { return 2; }

uint Matcher::stack_alignment_in_bytes() { return StackAlignmentInBytes; }

OptoReg::Name Matcher::return_addr() const { return OptoReg::stack2reg(- 2 +
              align_up((Compile::current()->in_preserve_stack_slots() +
                        Compile::current()->fixed_slots()),
                       stack_alignment_in_slots())); }

uint Compile::in_preserve_stack_slots() { return 4 + 2 * VerifyStackAtCalls; }

uint Compile::out_preserve_stack_slots() { return SharedRuntime::out_preserve_stack_slots(); }

uint Compile::varargs_C_out_slots_killed() const { return frame::arg_reg_save_area_bytes/BytesPerInt; }

void Matcher::calling_convention(BasicType *sig_bt, VMRegPair *regs, uint length, bool is_outgoing) {

#line 2858 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // No difference between ingoing/outgoing just pass false
    SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
  
#line 58621 "ad_x86.cpp"

}

void Matcher::c_calling_convention(BasicType *sig_bt, VMRegPair *regs, uint length) {

#line 2864 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    // This is obviously always outgoing
    (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
  
#line 58632 "ad_x86.cpp"

}

OptoRegPair Matcher::return_value(uint ideal_reg, bool is_outgoing) {

#line 2871 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    assert(ideal_reg >= Op_RegI && ideal_reg <= Op_RegL,
           "only return normal values");

    static const int lo[Op_RegL + 1] = {
      0,
      0,
      RAX_num,  // Op_RegN
      RAX_num,  // Op_RegI
      RAX_num,  // Op_RegP
      XMM0_num, // Op_RegF
      XMM0_num, // Op_RegD
      RAX_num   // Op_RegL
    };
    static const int hi[Op_RegL + 1] = {
      0,
      0,
      OptoReg::Bad, // Op_RegN
      OptoReg::Bad, // Op_RegI
      RAX_H_num,    // Op_RegP
      OptoReg::Bad, // Op_RegF
      XMM0b_num,    // Op_RegD
      RAX_H_num     // Op_RegL
    };
    // Excluded flags and vector registers.
    assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, "missing type");
    return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
  
#line 58667 "ad_x86.cpp"

}

OptoRegPair Matcher::c_return_value(uint ideal_reg, bool is_outgoing) {

#line 2871 "/priv/d038402/hg/jdk/src/hotspot/cpu/x86/x86_64.ad"

    assert(ideal_reg >= Op_RegI && ideal_reg <= Op_RegL,
           "only return normal values");

    static const int lo[Op_RegL + 1] = {
      0,
      0,
      RAX_num,  // Op_RegN
      RAX_num,  // Op_RegI
      RAX_num,  // Op_RegP
      XMM0_num, // Op_RegF
      XMM0_num, // Op_RegD
      RAX_num   // Op_RegL
    };
    static const int hi[Op_RegL + 1] = {
      0,
      0,
      OptoReg::Bad, // Op_RegN
      OptoReg::Bad, // Op_RegI
      RAX_H_num,    // Op_RegP
      OptoReg::Bad, // Op_RegF
      XMM0b_num,    // Op_RegD
      RAX_H_num     // Op_RegL
    };
    // Excluded flags and vector registers.
    assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, "missing type");
    return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
  
#line 58702 "ad_x86.cpp"

}

OptoReg::Name Matcher::inline_cache_reg() { return OptoReg::Name(RAX_num); }

int Matcher::inline_cache_reg_encode() { return _regEncode[inline_cache_reg()]; }

OptoReg::Name Matcher::interpreter_method_oop_reg() { return OptoReg::Name(RBX_num); }

int Matcher::interpreter_method_oop_reg_encode() { return _regEncode[interpreter_method_oop_reg()]; }

OptoReg::Name Matcher::interpreter_frame_pointer_reg() { return OptoReg::Name(RBP_num); }

OptoReg::Name Matcher::c_frame_pointer() const { return OptoReg::Name(RSP_num); }

// Number of callee-save + always-save registers
int  Matcher::number_of_saved_registers() {
  return 0;
};

bool Compile::needs_clone_jvms() { return false; }

// Check consistency of C++ compilation with ADLC options:
// Check adlc -DLINUX=1
#ifndef LINUX
#  error "LINUX must be defined"
#endif // LINUX
// Check adlc -D_GNU_SOURCE=1
#ifndef _GNU_SOURCE
#  error "_GNU_SOURCE must be defined"
#endif // _GNU_SOURCE
// Check adlc -DAMD64=1
#ifndef AMD64
#  error "AMD64 must be defined"
#endif // AMD64
// Check adlc -D_LP64=1
#ifndef _LP64
#  error "_LP64 must be defined"
#endif // _LP64
